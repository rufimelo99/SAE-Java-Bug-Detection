{"project": "Collections", "bug_id": 1, "classes_modified": [{"class_name": "org.apache.commons.collections.map.Flat3Map", "buggy_version": "/*\n *  Copyright 2003-2004 The Apache Software Foundation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.apache.commons.collections.map;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.AbstractCollection;\nimport java.util.AbstractSet;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Set;\n\nimport org.apache.commons.collections.IterableMap;\nimport org.apache.commons.collections.MapIterator;\nimport org.apache.commons.collections.ResettableIterator;\nimport org.apache.commons.collections.iterators.EmptyIterator;\nimport org.apache.commons.collections.iterators.EmptyMapIterator;\n\n/**\n * A <code>Map</code> implementation that stores data in simple fields until\n * the size is greater than 3.\n * <p>\n * This map is designed for performance and can outstrip HashMap.\n * It also has good garbage collection characteristics.\n * <ul>\n * <li>Optimised for operation at size 3 or less.\n * <li>Still works well once size 3 exceeded.\n * <li>Gets at size 3 or less are about 0-10% faster than HashMap,\n * <li>Puts at size 3 or less are over 4 times faster than HashMap.\n * <li>Performance 5% slower than HashMap once size 3 exceeded once.\n * </ul>\n * The design uses two distinct modes of operation - flat and delegate.\n * While the map is size 3 or less, operations map straight onto fields using\n * switch statements. Once size 4 is reached, the map switches to delegate mode\n * and only switches back when cleared. In delegate mode, all operations are\n * forwarded straight to a HashMap resulting in the 5% performance loss.\n * <p>\n * The performance gains on puts are due to not needing to create a Map Entry\n * object. This is a large saving not only in performance but in garbage collection.\n * <p>\n * Whilst in flat mode this map is also easy for the garbage collector to dispatch.\n * This is because it contains no complex objects or arrays which slow the progress.\n * <p>\n * Do not use <code>Flat3Map</code> if the size is likely to grow beyond 3.\n * <p>\n * <strong>Note that Flat3Map is not synchronized and is not thread-safe.</strong>\n * If you wish to use this map from multiple threads concurrently, you must use\n * appropriate synchronization. The simplest approach is to wrap this map\n * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw \n * exceptions when accessed by concurrent threads without synchronization.\n *\n * @since Commons Collections 3.0\n * @version $Revision$ $Date$\n *\n * @author Stephen Colebourne\n */\npublic class Flat3Map implements IterableMap, Serializable, Cloneable {\n\n    /** Serialization version */\n    private static final long serialVersionUID = -6701087419741928296L;\n\n    /** The size of the map, used while in flat mode */\n    private transient int size;\n    /** Hash, used while in flat mode */\n    private transient int hash1;\n    /** Hash, used while in flat mode */\n    private transient int hash2;\n    /** Hash, used while in flat mode */\n    private transient int hash3;\n    /** Key, used while in flat mode */\n    private transient Object key1;\n    /** Key, used while in flat mode */\n    private transient Object key2;\n    /** Key, used while in flat mode */\n    private transient Object key3;\n    /** Value, used while in flat mode */\n    private transient Object value1;\n    /** Value, used while in flat mode */\n    private transient Object value2;\n    /** Value, used while in flat mode */\n    private transient Object value3;\n    /** Map, used while in delegate mode */\n    private transient AbstractHashedMap delegateMap;\n\n    /**\n     * Constructor.\n     */\n    public Flat3Map() {\n        super();\n    }\n\n    /**\n     * Constructor copying elements from another map.\n     *\n     * @param map  the map to copy\n     * @throws NullPointerException if the map is null\n     */\n    public Flat3Map(Map map) {\n        super();\n        putAll(map);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the value mapped to the key specified.\n     * \n     * @param key  the key\n     * @return the mapped value, null if no match\n     */\n    public Object get(Object key) {\n        if (delegateMap != null) {\n            return delegateMap.get(key);\n        }\n        if (key == null) {\n            switch (size) {\n                // drop through\n                case 3:\n                    if (key3 == null) return value3;\n                case 2:\n                    if (key2 == null) return value2;\n                case 1:\n                    if (key1 == null) return value1;\n            }\n        } else {\n            if (size > 0) {\n                int hashCode = key.hashCode();\n                switch (size) {\n                    // drop through\n                    case 3:\n                        if (hash3 == hashCode && key.equals(key3)) return value3;\n                    case 2:\n                        if (hash2 == hashCode && key.equals(key2)) return value2;\n                    case 1:\n                        if (hash1 == hashCode && key.equals(key1)) return value1;\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Gets the size of the map.\n     * \n     * @return the size\n     */\n    public int size() {\n        if (delegateMap != null) {\n            return delegateMap.size();\n        }\n        return size;\n    }\n\n    /**\n     * Checks whether the map is currently empty.\n     * \n     * @return true if the map is currently size zero\n     */\n    public boolean isEmpty() {\n        return (size() == 0);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks whether the map contains the specified key.\n     * \n     * @param key  the key to search for\n     * @return true if the map contains the key\n     */\n    public boolean containsKey(Object key) {\n        if (delegateMap != null) {\n            return delegateMap.containsKey(key);\n        }\n        if (key == null) {\n            switch (size) {  // drop through\n                case 3:\n                    if (key3 == null) return true;\n                case 2:\n                    if (key2 == null) return true;\n                case 1:\n                    if (key1 == null) return true;\n            }\n        } else {\n            if (size > 0) {\n                int hashCode = key.hashCode();\n                switch (size) {  // drop through\n                    case 3:\n                        if (hash3 == hashCode && key.equals(key3)) return true;\n                    case 2:\n                        if (hash2 == hashCode && key.equals(key2)) return true;\n                    case 1:\n                        if (hash1 == hashCode && key.equals(key1)) return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Checks whether the map contains the specified value.\n     * \n     * @param value  the value to search for\n     * @return true if the map contains the key\n     */\n    public boolean containsValue(Object value) {\n        if (delegateMap != null) {\n            return delegateMap.containsValue(value);\n        }\n        if (value == null) {  // drop through\n            switch (size) {\n                case 3:\n                    if (value3 == null) return true;\n                case 2:\n                    if (value2 == null) return true;\n                case 1:\n                    if (value1 == null) return true;\n            }\n        } else {\n            switch (size) {  // drop through\n                case 3:\n                    if (value.equals(value3)) return true;\n                case 2:\n                    if (value.equals(value2)) return true;\n                case 1:\n                    if (value.equals(value1)) return true;\n            }\n        }\n        return false;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Puts a key-value mapping into this map.\n     * \n     * @param key  the key to add\n     * @param value  the value to add\n     * @return the value previously mapped to this key, null if none\n     */\n    public Object put(Object key, Object value) {\n        if (delegateMap != null) {\n            return delegateMap.put(key, value);\n        }\n        // change existing mapping\n        if (key == null) {\n            switch (size) {  // drop through\n                case 3:\n                    if (key3 == null) {\n                        Object old = value3;\n                        value3 = value;\n                        return old;\n                    }\n                case 2:\n                    if (key2 == null) {\n                        Object old = value2;\n                        value2 = value;\n                        return old;\n                    }\n                case 1:\n                    if (key1 == null) {\n                        Object old = value1;\n                        value1 = value;\n                        return old;\n                    }\n            }\n        } else {\n            if (size > 0) {\n                int hashCode = key.hashCode();\n                switch (size) {  // drop through\n                    case 3:\n                        if (hash3 == hashCode && key.equals(key3)) {\n                            Object old = value3;\n                            value3 = value;\n                            return old;\n                        }\n                    case 2:\n                        if (hash2 == hashCode && key.equals(key2)) {\n                            Object old = value2;\n                            value2 = value;\n                            return old;\n                        }\n                    case 1:\n                        if (hash1 == hashCode && key.equals(key1)) {\n                            Object old = value1;\n                            value1 = value;\n                            return old;\n                        }\n                }\n            }\n        }\n        \n        // add new mapping\n        switch (size) {\n            default:\n                convertToMap();\n                delegateMap.put(key, value);\n                return null;\n            case 2:\n                hash3 = (key == null ? 0 : key.hashCode());\n                key3 = key;\n                value3 = value;\n                break;\n            case 1:\n                hash2 = (key == null ? 0 : key.hashCode());\n                key2 = key;\n                value2 = value;\n                break;\n            case 0:\n                hash1 = (key == null ? 0 : key.hashCode());\n                key1 = key;\n                value1 = value;\n                break;\n        }\n        size++;\n        return null;\n    }\n\n    /**\n     * Puts all the values from the specified map into this map.\n     * \n     * @param map  the map to add\n     * @throws NullPointerException if the map is null\n     */\n    public void putAll(Map map) {\n        int size = map.size();\n        if (size == 0) {\n            return;\n        }\n        if (delegateMap != null) {\n            delegateMap.putAll(map);\n            return;\n        }\n        if (size < 4) {\n            for (Iterator it = map.entrySet().iterator(); it.hasNext();) {\n                Map.Entry entry = (Map.Entry) it.next();\n                put(entry.getKey(), entry.getValue());\n            }\n        } else {\n            convertToMap();\n            delegateMap.putAll(map);\n        }\n    }\n\n    /**\n     * Converts the flat map data to a map.\n     */\n    private void convertToMap() {\n        delegateMap = createDelegateMap();\n        switch (size) {  // drop through\n            case 3:\n                delegateMap.put(key3, value3);\n            case 2:\n                delegateMap.put(key2, value2);\n            case 1:\n                delegateMap.put(key1, value1);\n        }\n        \n        size = 0;\n        hash1 = hash2 = hash3 = 0;\n        key1 = key2 = key3 = null;\n        value1 = value2 = value3 = null;\n    }\n\n    /**\n     * Create an instance of the map used for storage when in delegation mode.\n     * <p>\n     * This can be overridden by subclasses to provide a different map implementation.\n     * Not every AbstractHashedMap is suitable, identity and reference based maps\n     * would be poor choices.\n     *\n     * @return a new AbstractHashedMap or subclass\n     * @since Commons Collections 3.1\n     */\n    protected AbstractHashedMap createDelegateMap() {\n        return new HashedMap();\n    }\n\n    /**\n     * Removes the specified mapping from this map.\n     * \n     * @param key  the mapping to remove\n     * @return the value mapped to the removed key, null if key not in map\n     */\n    public Object remove(Object key) {\n        if (delegateMap != null) {\n            return delegateMap.remove(key);\n        }\n        if (size == 0) {\n            return null;\n        }\n        if (key == null) {\n            switch (size) {  // drop through\n                case 3:\n                    if (key3 == null) {\n                        Object old = value3;\n                        hash3 = 0;\n                        key3 = null;\n                        value3 = null;\n                        size = 2;\n                        return old;\n                    }\n                    if (key2 == null) {\n                        Object old = value3;\n                        hash2 = hash3;\n                        key2 = key3;\n                        value2 = value3;\n                        hash3 = 0;\n                        key3 = null;\n                        value3 = null;\n                        size = 2;\n                        return old;\n                    }\n                    if (key1 == null) {\n                        Object old = value3;\n                        hash1 = hash3;\n                        key1 = key3;\n                        value1 = value3;\n                        hash3 = 0;\n                        key3 = null;\n                        value3 = null;\n                        size = 2;\n                        return old;\n                    }\n                    return null;\n                case 2:\n                    if (key2 == null) {\n                        Object old = value2;\n                        hash2 = 0;\n                        key2 = null;\n                        value2 = null;\n                        size = 1;\n                        return old;\n                    }\n                    if (key1 == null) {\n                        Object old = value2;\n                        hash1 = hash2;\n                        key1 = key2;\n                        value1 = value2;\n                        hash2 = 0;\n                        key2 = null;\n                        value2 = null;\n                        size = 1;\n                        return old;\n                    }\n                    return null;\n                case 1:\n                    if (key1 == null) {\n                        Object old = value1;\n                        hash1 = 0;\n                        key1 = null;\n                        value1 = null;\n                        size = 0;\n                        return old;\n                    }\n            }\n        } else {\n            if (size > 0) {\n                int hashCode = key.hashCode();\n                switch (size) {  // drop through\n                    case 3:\n                        if (hash3 == hashCode && key.equals(key3)) {\n                            Object old = value3;\n                            hash3 = 0;\n                            key3 = null;\n                            value3 = null;\n                            size = 2;\n                            return old;\n                        }\n                        if (hash2 == hashCode && key.equals(key2)) {\n                            Object old = value3;\n                            hash2 = hash3;\n                            key2 = key3;\n                            value2 = value3;\n                            hash3 = 0;\n                            key3 = null;\n                            value3 = null;\n                            size = 2;\n                            return old;\n                        }\n                        if (hash1 == hashCode && key.equals(key1)) {\n                            Object old = value3;\n                            hash1 = hash3;\n                            key1 = key3;\n                            value1 = value3;\n                            hash3 = 0;\n                            key3 = null;\n                            value3 = null;\n                            size = 2;\n                            return old;\n                        }\n                        return null;\n                    case 2:\n                        if (hash2 == hashCode && key.equals(key2)) {\n                            Object old = value2;\n                            hash2 = 0;\n                            key2 = null;\n                            value2 = null;\n                            size = 1;\n                            return old;\n                        }\n                        if (hash1 == hashCode && key.equals(key1)) {\n                            Object old = value2;\n                            hash1 = hash2;\n                            key1 = key2;\n                            value1 = value2;\n                            hash2 = 0;\n                            key2 = null;\n                            value2 = null;\n                            size = 1;\n                            return old;\n                        }\n                        return null;\n                    case 1:\n                        if (hash1 == hashCode && key.equals(key1)) {\n                            Object old = value1;\n                            hash1 = 0;\n                            key1 = null;\n                            value1 = null;\n                            size = 0;\n                            return old;\n                        }\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Clears the map, resetting the size to zero and nullifying references\n     * to avoid garbage collection issues.\n     */\n    public void clear() {\n        if (delegateMap != null) {\n            delegateMap.clear();  // should aid gc\n            delegateMap = null;  // switch back to flat mode\n        } else {\n            size = 0;\n            hash1 = hash2 = hash3 = 0;\n            key1 = key2 = key3 = null;\n            value1 = value2 = value3 = null;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets an iterator over the map.\n     * Changes made to the iterator affect this map.\n     * <p>\n     * A MapIterator returns the keys in the map. It also provides convenient\n     * methods to get the key and value, and set the value.\n     * It avoids the need to create an entrySet/keySet/values object.\n     * It also avoids creating the Map Entry object.\n     * \n     * @return the map iterator\n     */\n    public MapIterator mapIterator() {\n        if (delegateMap != null) {\n            return delegateMap.mapIterator();\n        }\n        if (size == 0) {\n            return EmptyMapIterator.INSTANCE;\n        }\n        return new FlatMapIterator(this);\n    }\n\n    /**\n     * FlatMapIterator\n     */\n    static class FlatMapIterator implements MapIterator, ResettableIterator {\n        private final Flat3Map parent;\n        private int nextIndex = 0;\n        private boolean canRemove = false;\n        \n        FlatMapIterator(Flat3Map parent) {\n            super();\n            this.parent = parent;\n        }\n\n        public boolean hasNext() {\n            return (nextIndex < parent.size);\n        }\n\n        public Object next() {\n            if (hasNext() == false) {\n                throw new NoSuchElementException(AbstractHashedMap.NO_NEXT_ENTRY);\n            }\n            canRemove = true;\n            nextIndex++;\n            return getKey();\n        }\n\n        public void remove() {\n            if (canRemove == false) {\n                throw new IllegalStateException(AbstractHashedMap.REMOVE_INVALID);\n            }\n            parent.remove(getKey());\n            nextIndex--;\n            canRemove = false;\n        }\n\n        public Object getKey() {\n            if (canRemove == false) {\n                throw new IllegalStateException(AbstractHashedMap.GETKEY_INVALID);\n            }\n            switch (nextIndex) {\n                case 3:\n                    return parent.key3;\n                case 2:\n                    return parent.key2;\n                case 1:\n                    return parent.key1;\n            }\n            throw new IllegalStateException(\"Invalid map index\");\n        }\n\n        public Object getValue() {\n            if (canRemove == false) {\n                throw new IllegalStateException(AbstractHashedMap.GETVALUE_INVALID);\n            }\n            switch (nextIndex) {\n                case 3:\n                    return parent.value3;\n                case 2:\n                    return parent.value2;\n                case 1:\n                    return parent.value1;\n            }\n            throw new IllegalStateException(\"Invalid map index\");\n        }\n\n        public Object setValue(Object value) {\n            if (canRemove == false) {\n                throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n            }\n            Object old = getValue();\n            switch (nextIndex) {\n                case 3: \n                    parent.value3 = value;\n                case 2:\n                    parent.value2 = value;\n                case 1:\n                    parent.value1 = value;\n            }\n            return old;\n        }\n        \n        public void reset() {\n            nextIndex = 0;\n            canRemove = false;\n        }\n        \n        public String toString() {\n            if (canRemove) {\n                return \"Iterator[\" + getKey() + \"=\" + getValue() + \"]\";\n            } else {\n                return \"Iterator[]\";\n            }\n        }\n    }\n    \n    /**\n     * Gets the entrySet view of the map.\n     * Changes made to the view affect this map.\n     * The Map Entry is not an independent object and changes as the \n     * iterator progresses.\n     * To simply iterate through the entries, use {@link #mapIterator()}.\n     * \n     * @return the entrySet view\n     */\n    public Set entrySet() {\n        if (delegateMap != null) {\n            return delegateMap.entrySet();\n        }\n        return new EntrySet(this);\n    }\n    \n    /**\n     * EntrySet\n     */\n    static class EntrySet extends AbstractSet {\n        private final Flat3Map parent;\n        \n        EntrySet(Flat3Map parent) {\n            super();\n            this.parent = parent;\n        }\n\n        public int size() {\n            return parent.size();\n        }\n        \n        public void clear() {\n            parent.clear();\n        }\n        \n        public boolean remove(Object obj) {\n            if (obj instanceof Map.Entry == false) {\n                return false;\n            }\n            Map.Entry entry = (Map.Entry) obj;\n            Object key = entry.getKey();\n            boolean result = parent.containsKey(key);\n            parent.remove(key);\n            return result;\n        }\n\n        public Iterator iterator() {\n            if (parent.delegateMap != null) {\n                return parent.delegateMap.entrySet().iterator();\n            }\n            if (parent.size() == 0) {\n                return EmptyIterator.INSTANCE;\n            }\n            return new EntrySetIterator(parent);\n        }\n    }\n\n    /**\n     * EntrySetIterator and MapEntry\n     */\n    static class EntrySetIterator implements Iterator, Map.Entry {\n        private final Flat3Map parent;\n        private int nextIndex = 0;\n        private boolean canRemove = false;\n        \n        EntrySetIterator(Flat3Map parent) {\n            super();\n            this.parent = parent;\n        }\n\n        public boolean hasNext() {\n            return (nextIndex < parent.size);\n        }\n\n        public Object next() {\n            if (hasNext() == false) {\n                throw new NoSuchElementException(AbstractHashedMap.NO_NEXT_ENTRY);\n            }\n            canRemove = true;\n            nextIndex++;\n            return this;\n        }\n\n        public void remove() {\n            if (canRemove == false) {\n                throw new IllegalStateException(AbstractHashedMap.REMOVE_INVALID);\n            }\n            parent.remove(getKey());\n            nextIndex--;\n            canRemove = false;\n        }\n\n        public Object getKey() {\n            if (canRemove == false) {\n                throw new IllegalStateException(AbstractHashedMap.GETKEY_INVALID);\n            }\n            switch (nextIndex) {\n                case 3:\n                    return parent.key3;\n                case 2:\n                    return parent.key2;\n                case 1:\n                    return parent.key1;\n            }\n            throw new IllegalStateException(\"Invalid map index\");\n        }\n\n        public Object getValue() {\n            if (canRemove == false) {\n                throw new IllegalStateException(AbstractHashedMap.GETVALUE_INVALID);\n            }\n            switch (nextIndex) {\n                case 3:\n                    return parent.value3;\n                case 2:\n                    return parent.value2;\n                case 1:\n                    return parent.value1;\n            }\n            throw new IllegalStateException(\"Invalid map index\");\n        }\n\n        public Object setValue(Object value) {\n            if (canRemove == false) {\n                throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n            }\n            Object old = getValue();\n            switch (nextIndex) {\n                case 3: \n                    parent.value3 = value;\n                case 2:\n                    parent.value2 = value;\n                case 1:\n                    parent.value1 = value;\n            }\n            return old;\n        }\n        \n        public boolean equals(Object obj) {\n            if (canRemove == false) {\n                return false;\n            }\n            if (obj instanceof Map.Entry == false) {\n                return false;\n            }\n            Map.Entry other = (Map.Entry) obj;\n            Object key = getKey();\n            Object value = getValue();\n            return (key == null ? other.getKey() == null : key.equals(other.getKey())) &&\n                   (value == null ? other.getValue() == null : value.equals(other.getValue()));\n        }\n        \n        public int hashCode() {\n            if (canRemove == false) {\n                return 0;\n            }\n            Object key = getKey();\n            Object value = getValue();\n            return (key == null ? 0 : key.hashCode()) ^\n                   (value == null ? 0 : value.hashCode());\n        }\n        \n        public String toString() {\n            if (canRemove) {\n                return getKey() + \"=\" + getValue();\n            } else {\n                return \"\";\n            }\n        }\n    }\n    \n    /**\n     * Gets the keySet view of the map.\n     * Changes made to the view affect this map.\n     * To simply iterate through the keys, use {@link #mapIterator()}.\n     * \n     * @return the keySet view\n     */\n    public Set keySet() {\n        if (delegateMap != null) {\n            return delegateMap.keySet();\n        }\n        return new KeySet(this);\n    }\n\n    /**\n     * KeySet\n     */\n    static class KeySet extends AbstractSet {\n        private final Flat3Map parent;\n        \n        KeySet(Flat3Map parent) {\n            super();\n            this.parent = parent;\n        }\n\n        public int size() {\n            return parent.size();\n        }\n        \n        public void clear() {\n            parent.clear();\n        }\n        \n        public boolean contains(Object key) {\n            return parent.containsKey(key);\n        }\n\n        public boolean remove(Object key) {\n            boolean result = parent.containsKey(key);\n            parent.remove(key);\n            return result;\n        }\n\n        public Iterator iterator() {\n            if (parent.delegateMap != null) {\n                return parent.delegateMap.keySet().iterator();\n            }\n            if (parent.size() == 0) {\n                return EmptyIterator.INSTANCE;\n            }\n            return new KeySetIterator(parent);\n        }\n    }\n\n    /**\n     * KeySetIterator\n     */\n    static class KeySetIterator extends EntrySetIterator {\n        \n        KeySetIterator(Flat3Map parent) {\n            super(parent);\n        }\n\n        public Object next() {\n            super.next();\n            return getKey();\n        }\n    }\n    \n    /**\n     * Gets the values view of the map.\n     * Changes made to the view affect this map.\n     * To simply iterate through the values, use {@link #mapIterator()}.\n     * \n     * @return the values view\n     */\n    public Collection values() {\n        if (delegateMap != null) {\n            return delegateMap.values();\n        }\n        return new Values(this);\n    }\n\n    /**\n     * Values\n     */\n    static class Values extends AbstractCollection {\n        private final Flat3Map parent;\n        \n        Values(Flat3Map parent) {\n            super();\n            this.parent = parent;\n        }\n\n        public int size() {\n            return parent.size();\n        }\n        \n        public void clear() {\n            parent.clear();\n        }\n        \n        public boolean contains(Object value) {\n            return parent.containsValue(value);\n        }\n\n        public Iterator iterator() {\n            if (parent.delegateMap != null) {\n                return parent.delegateMap.values().iterator();\n            }\n            if (parent.size() == 0) {\n                return EmptyIterator.INSTANCE;\n            }\n            return new ValuesIterator(parent);\n        }\n    }\n\n    /**\n     * ValuesIterator\n     */\n    static class ValuesIterator extends EntrySetIterator {\n        \n        ValuesIterator(Flat3Map parent) {\n            super(parent);\n        }\n\n        public Object next() {\n            super.next();\n            return getValue();\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Write the map out using a custom routine.\n     */\n    private void writeObject(ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        out.writeInt(size());\n        for (MapIterator it = mapIterator(); it.hasNext();) {\n            out.writeObject(it.next());  // key\n            out.writeObject(it.getValue());  // value\n        }\n    }\n\n    /**\n     * Read the map in using a custom routine.\n     */\n    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        int count = in.readInt();\n        if (count > 3) {\n            delegateMap = createDelegateMap();\n        }\n        for (int i = count; i > 0; i--) {\n            put(in.readObject(), in.readObject());\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Clones the map without cloning the keys or values.\n     *\n     * @return a shallow clone\n     * @since Commons Collections 3.1\n     */\n    public Object clone() {\n        try {\n            Flat3Map cloned = (Flat3Map) super.clone();\n            if (cloned.delegateMap != null) {\n                cloned.delegateMap = (HashedMap) cloned.delegateMap.clone();\n            }\n            return cloned;\n        } catch (CloneNotSupportedException ex) {\n            throw new InternalError();\n        }\n    }\n\n    /**\n     * Compares this map with another.\n     * \n     * @param obj  the object to compare to\n     * @return true if equal\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (delegateMap != null) {\n            return delegateMap.equals(obj);\n        }\n        if (obj instanceof Map == false) {\n            return false;\n        }\n        Map other = (Map) obj;\n        if (size != other.size()) {\n            return false;\n        }\n        if (size > 0) {\n            Object otherValue = null;\n            switch (size) {  // drop through\n                case 3:\n                    if (other.containsKey(key3) == false) {\n                        return false;\n                    }\n                    otherValue = other.get(key3);\n                    if (value3 == null ? otherValue != null : !value3.equals(otherValue)) {\n                        return false;\n                    }\n                case 2:\n                    if (other.containsKey(key2) == false) {\n                        return false;\n                    }\n                    otherValue = other.get(key2);\n                    if (value2 == null ? otherValue != null : !value2.equals(otherValue)) {\n                        return false;\n                    }\n                case 1:\n                    if (other.containsKey(key1) == false) {\n                        return false;\n                    }\n                    otherValue = other.get(key1);\n                    if (value1 == null ? otherValue != null : !value1.equals(otherValue)) {\n                        return false;\n                    }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Gets the standard Map hashCode.\n     * \n     * @return the hash code defined in the Map interface\n     */\n    public int hashCode() {\n        if (delegateMap != null) {\n            return delegateMap.hashCode();\n        }\n        int total = 0;\n        switch (size) {  // drop through\n            case 3:\n                total += (hash3 ^ (value3 == null ? 0 : value3.hashCode()));\n            case 2:\n                total += (hash2 ^ (value2 == null ? 0 : value2.hashCode()));\n            case 1:\n                total += (hash1 ^ (value1 == null ? 0 : value1.hashCode()));\n        }\n        return total;\n    }\n\n    /**\n     * Gets the map as a String.\n     * \n     * @return a string version of the map\n     */\n    public String toString() {\n        if (delegateMap != null) {\n            return delegateMap.toString();\n        }\n        if (size == 0) {\n            return \"{}\";\n        }\n        StringBuffer buf = new StringBuffer(128);\n        buf.append('{');\n        switch (size) {  // drop through\n            case 3:\n                buf.append((key3 == this ? \"(this Map)\" : key3));\n                buf.append('=');\n                buf.append((value3 == this ? \"(this Map)\" : value3));\n                buf.append(',');\n            case 2:\n                buf.append((key2 == this ? \"(this Map)\" : key2));\n                buf.append('=');\n                buf.append((value2 == this ? \"(this Map)\" : value2));\n                buf.append(',');\n            case 1:\n                buf.append((key1 == this ? \"(this Map)\" : key1));\n                buf.append('=');\n                buf.append((value1 == this ? \"(this Map)\" : value1));\n        }\n        buf.append('}');\n        return buf.toString();\n    }\n\n}\n", "fixed_version": "/*\n *  Copyright 2003-2004 The Apache Software Foundation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.apache.commons.collections.map;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.AbstractCollection;\nimport java.util.AbstractSet;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Set;\n\nimport org.apache.commons.collections.IterableMap;\nimport org.apache.commons.collections.MapIterator;\nimport org.apache.commons.collections.ResettableIterator;\nimport org.apache.commons.collections.iterators.EmptyIterator;\nimport org.apache.commons.collections.iterators.EmptyMapIterator;\n\n/**\n * A <code>Map</code> implementation that stores data in simple fields until\n * the size is greater than 3.\n * <p>\n * This map is designed for performance and can outstrip HashMap.\n * It also has good garbage collection characteristics.\n * <ul>\n * <li>Optimised for operation at size 3 or less.\n * <li>Still works well once size 3 exceeded.\n * <li>Gets at size 3 or less are about 0-10% faster than HashMap,\n * <li>Puts at size 3 or less are over 4 times faster than HashMap.\n * <li>Performance 5% slower than HashMap once size 3 exceeded once.\n * </ul>\n * The design uses two distinct modes of operation - flat and delegate.\n * While the map is size 3 or less, operations map straight onto fields using\n * switch statements. Once size 4 is reached, the map switches to delegate mode\n * and only switches back when cleared. In delegate mode, all operations are\n * forwarded straight to a HashMap resulting in the 5% performance loss.\n * <p>\n * The performance gains on puts are due to not needing to create a Map Entry\n * object. This is a large saving not only in performance but in garbage collection.\n * <p>\n * Whilst in flat mode this map is also easy for the garbage collector to dispatch.\n * This is because it contains no complex objects or arrays which slow the progress.\n * <p>\n * Do not use <code>Flat3Map</code> if the size is likely to grow beyond 3.\n * <p>\n * <strong>Note that Flat3Map is not synchronized and is not thread-safe.</strong>\n * If you wish to use this map from multiple threads concurrently, you must use\n * appropriate synchronization. The simplest approach is to wrap this map\n * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw \n * exceptions when accessed by concurrent threads without synchronization.\n *\n * @since Commons Collections 3.0\n * @version $Revision$ $Date$\n *\n * @author Stephen Colebourne\n */\npublic class Flat3Map implements IterableMap, Serializable, Cloneable {\n\n    /** Serialization version */\n    private static final long serialVersionUID = -6701087419741928296L;\n\n    /** The size of the map, used while in flat mode */\n    private transient int size;\n    /** Hash, used while in flat mode */\n    private transient int hash1;\n    /** Hash, used while in flat mode */\n    private transient int hash2;\n    /** Hash, used while in flat mode */\n    private transient int hash3;\n    /** Key, used while in flat mode */\n    private transient Object key1;\n    /** Key, used while in flat mode */\n    private transient Object key2;\n    /** Key, used while in flat mode */\n    private transient Object key3;\n    /** Value, used while in flat mode */\n    private transient Object value1;\n    /** Value, used while in flat mode */\n    private transient Object value2;\n    /** Value, used while in flat mode */\n    private transient Object value3;\n    /** Map, used while in delegate mode */\n    private transient AbstractHashedMap delegateMap;\n\n    /**\n     * Constructor.\n     */\n    public Flat3Map() {\n        super();\n    }\n\n    /**\n     * Constructor copying elements from another map.\n     *\n     * @param map  the map to copy\n     * @throws NullPointerException if the map is null\n     */\n    public Flat3Map(Map map) {\n        super();\n        putAll(map);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the value mapped to the key specified.\n     * \n     * @param key  the key\n     * @return the mapped value, null if no match\n     */\n    public Object get(Object key) {\n        if (delegateMap != null) {\n            return delegateMap.get(key);\n        }\n        if (key == null) {\n            switch (size) {\n                // drop through\n                case 3:\n                    if (key3 == null) return value3;\n                case 2:\n                    if (key2 == null) return value2;\n                case 1:\n                    if (key1 == null) return value1;\n            }\n        } else {\n            if (size > 0) {\n                int hashCode = key.hashCode();\n                switch (size) {\n                    // drop through\n                    case 3:\n                        if (hash3 == hashCode && key.equals(key3)) return value3;\n                    case 2:\n                        if (hash2 == hashCode && key.equals(key2)) return value2;\n                    case 1:\n                        if (hash1 == hashCode && key.equals(key1)) return value1;\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Gets the size of the map.\n     * \n     * @return the size\n     */\n    public int size() {\n        if (delegateMap != null) {\n            return delegateMap.size();\n        }\n        return size;\n    }\n\n    /**\n     * Checks whether the map is currently empty.\n     * \n     * @return true if the map is currently size zero\n     */\n    public boolean isEmpty() {\n        return (size() == 0);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks whether the map contains the specified key.\n     * \n     * @param key  the key to search for\n     * @return true if the map contains the key\n     */\n    public boolean containsKey(Object key) {\n        if (delegateMap != null) {\n            return delegateMap.containsKey(key);\n        }\n        if (key == null) {\n            switch (size) {  // drop through\n                case 3:\n                    if (key3 == null) return true;\n                case 2:\n                    if (key2 == null) return true;\n                case 1:\n                    if (key1 == null) return true;\n            }\n        } else {\n            if (size > 0) {\n                int hashCode = key.hashCode();\n                switch (size) {  // drop through\n                    case 3:\n                        if (hash3 == hashCode && key.equals(key3)) return true;\n                    case 2:\n                        if (hash2 == hashCode && key.equals(key2)) return true;\n                    case 1:\n                        if (hash1 == hashCode && key.equals(key1)) return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Checks whether the map contains the specified value.\n     * \n     * @param value  the value to search for\n     * @return true if the map contains the key\n     */\n    public boolean containsValue(Object value) {\n        if (delegateMap != null) {\n            return delegateMap.containsValue(value);\n        }\n        if (value == null) {  // drop through\n            switch (size) {\n                case 3:\n                    if (value3 == null) return true;\n                case 2:\n                    if (value2 == null) return true;\n                case 1:\n                    if (value1 == null) return true;\n            }\n        } else {\n            switch (size) {  // drop through\n                case 3:\n                    if (value.equals(value3)) return true;\n                case 2:\n                    if (value.equals(value2)) return true;\n                case 1:\n                    if (value.equals(value1)) return true;\n            }\n        }\n        return false;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Puts a key-value mapping into this map.\n     * \n     * @param key  the key to add\n     * @param value  the value to add\n     * @return the value previously mapped to this key, null if none\n     */\n    public Object put(Object key, Object value) {\n        if (delegateMap != null) {\n            return delegateMap.put(key, value);\n        }\n        // change existing mapping\n        if (key == null) {\n            switch (size) {  // drop through\n                case 3:\n                    if (key3 == null) {\n                        Object old = value3;\n                        value3 = value;\n                        return old;\n                    }\n                case 2:\n                    if (key2 == null) {\n                        Object old = value2;\n                        value2 = value;\n                        return old;\n                    }\n                case 1:\n                    if (key1 == null) {\n                        Object old = value1;\n                        value1 = value;\n                        return old;\n                    }\n            }\n        } else {\n            if (size > 0) {\n                int hashCode = key.hashCode();\n                switch (size) {  // drop through\n                    case 3:\n                        if (hash3 == hashCode && key.equals(key3)) {\n                            Object old = value3;\n                            value3 = value;\n                            return old;\n                        }\n                    case 2:\n                        if (hash2 == hashCode && key.equals(key2)) {\n                            Object old = value2;\n                            value2 = value;\n                            return old;\n                        }\n                    case 1:\n                        if (hash1 == hashCode && key.equals(key1)) {\n                            Object old = value1;\n                            value1 = value;\n                            return old;\n                        }\n                }\n            }\n        }\n        \n        // add new mapping\n        switch (size) {\n            default:\n                convertToMap();\n                delegateMap.put(key, value);\n                return null;\n            case 2:\n                hash3 = (key == null ? 0 : key.hashCode());\n                key3 = key;\n                value3 = value;\n                break;\n            case 1:\n                hash2 = (key == null ? 0 : key.hashCode());\n                key2 = key;\n                value2 = value;\n                break;\n            case 0:\n                hash1 = (key == null ? 0 : key.hashCode());\n                key1 = key;\n                value1 = value;\n                break;\n        }\n        size++;\n        return null;\n    }\n\n    /**\n     * Puts all the values from the specified map into this map.\n     * \n     * @param map  the map to add\n     * @throws NullPointerException if the map is null\n     */\n    public void putAll(Map map) {\n        int size = map.size();\n        if (size == 0) {\n            return;\n        }\n        if (delegateMap != null) {\n            delegateMap.putAll(map);\n            return;\n        }\n        if (size < 4) {\n            for (Iterator it = map.entrySet().iterator(); it.hasNext();) {\n                Map.Entry entry = (Map.Entry) it.next();\n                put(entry.getKey(), entry.getValue());\n            }\n        } else {\n            convertToMap();\n            delegateMap.putAll(map);\n        }\n    }\n\n    /**\n     * Converts the flat map data to a map.\n     */\n    private void convertToMap() {\n        delegateMap = createDelegateMap();\n        switch (size) {  // drop through\n            case 3:\n                delegateMap.put(key3, value3);\n            case 2:\n                delegateMap.put(key2, value2);\n            case 1:\n                delegateMap.put(key1, value1);\n        }\n        \n        size = 0;\n        hash1 = hash2 = hash3 = 0;\n        key1 = key2 = key3 = null;\n        value1 = value2 = value3 = null;\n    }\n\n    /**\n     * Create an instance of the map used for storage when in delegation mode.\n     * <p>\n     * This can be overridden by subclasses to provide a different map implementation.\n     * Not every AbstractHashedMap is suitable, identity and reference based maps\n     * would be poor choices.\n     *\n     * @return a new AbstractHashedMap or subclass\n     * @since Commons Collections 3.1\n     */\n    protected AbstractHashedMap createDelegateMap() {\n        return new HashedMap();\n    }\n\n    /**\n     * Removes the specified mapping from this map.\n     * \n     * @param key  the mapping to remove\n     * @return the value mapped to the removed key, null if key not in map\n     */\n    public Object remove(Object key) {\n        if (delegateMap != null) {\n            return delegateMap.remove(key);\n        }\n        if (size == 0) {\n            return null;\n        }\n        if (key == null) {\n            switch (size) {  // drop through\n                case 3:\n                    if (key3 == null) {\n                        Object old = value3;\n                        hash3 = 0;\n                        key3 = null;\n                        value3 = null;\n                        size = 2;\n                        return old;\n                    }\n                    if (key2 == null) {\n                        Object old = value3;\n                        hash2 = hash3;\n                        key2 = key3;\n                        value2 = value3;\n                        hash3 = 0;\n                        key3 = null;\n                        value3 = null;\n                        size = 2;\n                        return old;\n                    }\n                    if (key1 == null) {\n                        Object old = value3;\n                        hash1 = hash3;\n                        key1 = key3;\n                        value1 = value3;\n                        hash3 = 0;\n                        key3 = null;\n                        value3 = null;\n                        size = 2;\n                        return old;\n                    }\n                    return null;\n                case 2:\n                    if (key2 == null) {\n                        Object old = value2;\n                        hash2 = 0;\n                        key2 = null;\n                        value2 = null;\n                        size = 1;\n                        return old;\n                    }\n                    if (key1 == null) {\n                        Object old = value2;\n                        hash1 = hash2;\n                        key1 = key2;\n                        value1 = value2;\n                        hash2 = 0;\n                        key2 = null;\n                        value2 = null;\n                        size = 1;\n                        return old;\n                    }\n                    return null;\n                case 1:\n                    if (key1 == null) {\n                        Object old = value1;\n                        hash1 = 0;\n                        key1 = null;\n                        value1 = null;\n                        size = 0;\n                        return old;\n                    }\n            }\n        } else {\n            if (size > 0) {\n                int hashCode = key.hashCode();\n                switch (size) {  // drop through\n                    case 3:\n                        if (hash3 == hashCode && key.equals(key3)) {\n                            Object old = value3;\n                            hash3 = 0;\n                            key3 = null;\n                            value3 = null;\n                            size = 2;\n                            return old;\n                        }\n                        if (hash2 == hashCode && key.equals(key2)) {\n                            Object old = value3;\n                            hash2 = hash3;\n                            key2 = key3;\n                            value2 = value3;\n                            hash3 = 0;\n                            key3 = null;\n                            value3 = null;\n                            size = 2;\n                            return old;\n                        }\n                        if (hash1 == hashCode && key.equals(key1)) {\n                            Object old = value3;\n                            hash1 = hash3;\n                            key1 = key3;\n                            value1 = value3;\n                            hash3 = 0;\n                            key3 = null;\n                            value3 = null;\n                            size = 2;\n                            return old;\n                        }\n                        return null;\n                    case 2:\n                        if (hash2 == hashCode && key.equals(key2)) {\n                            Object old = value2;\n                            hash2 = 0;\n                            key2 = null;\n                            value2 = null;\n                            size = 1;\n                            return old;\n                        }\n                        if (hash1 == hashCode && key.equals(key1)) {\n                            Object old = value2;\n                            hash1 = hash2;\n                            key1 = key2;\n                            value1 = value2;\n                            hash2 = 0;\n                            key2 = null;\n                            value2 = null;\n                            size = 1;\n                            return old;\n                        }\n                        return null;\n                    case 1:\n                        if (hash1 == hashCode && key.equals(key1)) {\n                            Object old = value1;\n                            hash1 = 0;\n                            key1 = null;\n                            value1 = null;\n                            size = 0;\n                            return old;\n                        }\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Clears the map, resetting the size to zero and nullifying references\n     * to avoid garbage collection issues.\n     */\n    public void clear() {\n        if (delegateMap != null) {\n            delegateMap.clear();  // should aid gc\n            delegateMap = null;  // switch back to flat mode\n        } else {\n            size = 0;\n            hash1 = hash2 = hash3 = 0;\n            key1 = key2 = key3 = null;\n            value1 = value2 = value3 = null;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets an iterator over the map.\n     * Changes made to the iterator affect this map.\n     * <p>\n     * A MapIterator returns the keys in the map. It also provides convenient\n     * methods to get the key and value, and set the value.\n     * It avoids the need to create an entrySet/keySet/values object.\n     * It also avoids creating the Map Entry object.\n     * \n     * @return the map iterator\n     */\n    public MapIterator mapIterator() {\n        if (delegateMap != null) {\n            return delegateMap.mapIterator();\n        }\n        if (size == 0) {\n            return EmptyMapIterator.INSTANCE;\n        }\n        return new FlatMapIterator(this);\n    }\n\n    /**\n     * FlatMapIterator\n     */\n    static class FlatMapIterator implements MapIterator, ResettableIterator {\n        private final Flat3Map parent;\n        private int nextIndex = 0;\n        private boolean canRemove = false;\n        \n        FlatMapIterator(Flat3Map parent) {\n            super();\n            this.parent = parent;\n        }\n\n        public boolean hasNext() {\n            return (nextIndex < parent.size);\n        }\n\n        public Object next() {\n            if (hasNext() == false) {\n                throw new NoSuchElementException(AbstractHashedMap.NO_NEXT_ENTRY);\n            }\n            canRemove = true;\n            nextIndex++;\n            return getKey();\n        }\n\n        public void remove() {\n            if (canRemove == false) {\n                throw new IllegalStateException(AbstractHashedMap.REMOVE_INVALID);\n            }\n            parent.remove(getKey());\n            nextIndex--;\n            canRemove = false;\n        }\n\n        public Object getKey() {\n            if (canRemove == false) {\n                throw new IllegalStateException(AbstractHashedMap.GETKEY_INVALID);\n            }\n            switch (nextIndex) {\n                case 3:\n                    return parent.key3;\n                case 2:\n                    return parent.key2;\n                case 1:\n                    return parent.key1;\n            }\n            throw new IllegalStateException(\"Invalid map index\");\n        }\n\n        public Object getValue() {\n            if (canRemove == false) {\n                throw new IllegalStateException(AbstractHashedMap.GETVALUE_INVALID);\n            }\n            switch (nextIndex) {\n                case 3:\n                    return parent.value3;\n                case 2:\n                    return parent.value2;\n                case 1:\n                    return parent.value1;\n            }\n            throw new IllegalStateException(\"Invalid map index\");\n        }\n\n        public Object setValue(Object value) {\n            if (canRemove == false) {\n                throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n            }\n            Object old = getValue();\n            switch (nextIndex) {\n                case 3: \n                    parent.value3 = value;\n                    break;\n                case 2:\n                    parent.value2 = value;\n                    break;\n                case 1:\n                    parent.value1 = value;\n                    break;\n            }\n            return old;\n        }\n        \n        public void reset() {\n            nextIndex = 0;\n            canRemove = false;\n        }\n        \n        public String toString() {\n            if (canRemove) {\n                return \"Iterator[\" + getKey() + \"=\" + getValue() + \"]\";\n            } else {\n                return \"Iterator[]\";\n            }\n        }\n    }\n    \n    /**\n     * Gets the entrySet view of the map.\n     * Changes made to the view affect this map.\n     * The Map Entry is not an independent object and changes as the \n     * iterator progresses.\n     * To simply iterate through the entries, use {@link #mapIterator()}.\n     * \n     * @return the entrySet view\n     */\n    public Set entrySet() {\n        if (delegateMap != null) {\n            return delegateMap.entrySet();\n        }\n        return new EntrySet(this);\n    }\n    \n    /**\n     * EntrySet\n     */\n    static class EntrySet extends AbstractSet {\n        private final Flat3Map parent;\n        \n        EntrySet(Flat3Map parent) {\n            super();\n            this.parent = parent;\n        }\n\n        public int size() {\n            return parent.size();\n        }\n        \n        public void clear() {\n            parent.clear();\n        }\n        \n        public boolean remove(Object obj) {\n            if (obj instanceof Map.Entry == false) {\n                return false;\n            }\n            Map.Entry entry = (Map.Entry) obj;\n            Object key = entry.getKey();\n            boolean result = parent.containsKey(key);\n            parent.remove(key);\n            return result;\n        }\n\n        public Iterator iterator() {\n            if (parent.delegateMap != null) {\n                return parent.delegateMap.entrySet().iterator();\n            }\n            if (parent.size() == 0) {\n                return EmptyIterator.INSTANCE;\n            }\n            return new EntrySetIterator(parent);\n        }\n    }\n\n    /**\n     * EntrySetIterator and MapEntry\n     */\n    static class EntrySetIterator implements Iterator, Map.Entry {\n        private final Flat3Map parent;\n        private int nextIndex = 0;\n        private boolean canRemove = false;\n        \n        EntrySetIterator(Flat3Map parent) {\n            super();\n            this.parent = parent;\n        }\n\n        public boolean hasNext() {\n            return (nextIndex < parent.size);\n        }\n\n        public Object next() {\n            if (hasNext() == false) {\n                throw new NoSuchElementException(AbstractHashedMap.NO_NEXT_ENTRY);\n            }\n            canRemove = true;\n            nextIndex++;\n            return this;\n        }\n\n        public void remove() {\n            if (canRemove == false) {\n                throw new IllegalStateException(AbstractHashedMap.REMOVE_INVALID);\n            }\n            parent.remove(getKey());\n            nextIndex--;\n            canRemove = false;\n        }\n\n        public Object getKey() {\n            if (canRemove == false) {\n                throw new IllegalStateException(AbstractHashedMap.GETKEY_INVALID);\n            }\n            switch (nextIndex) {\n                case 3:\n                    return parent.key3;\n                case 2:\n                    return parent.key2;\n                case 1:\n                    return parent.key1;\n            }\n            throw new IllegalStateException(\"Invalid map index\");\n        }\n\n        public Object getValue() {\n            if (canRemove == false) {\n                throw new IllegalStateException(AbstractHashedMap.GETVALUE_INVALID);\n            }\n            switch (nextIndex) {\n                case 3:\n                    return parent.value3;\n                case 2:\n                    return parent.value2;\n                case 1:\n                    return parent.value1;\n            }\n            throw new IllegalStateException(\"Invalid map index\");\n        }\n\n        public Object setValue(Object value) {\n            if (canRemove == false) {\n                throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n            }\n            Object old = getValue();\n            switch (nextIndex) {\n                case 3: \n                    parent.value3 = value;\n                    break;\n                case 2:\n                    parent.value2 = value;\n                    break;\n                case 1:\n                    parent.value1 = value;\n                    break;\n            }\n            return old;\n        }\n        \n        public boolean equals(Object obj) {\n            if (canRemove == false) {\n                return false;\n            }\n            if (obj instanceof Map.Entry == false) {\n                return false;\n            }\n            Map.Entry other = (Map.Entry) obj;\n            Object key = getKey();\n            Object value = getValue();\n            return (key == null ? other.getKey() == null : key.equals(other.getKey())) &&\n                   (value == null ? other.getValue() == null : value.equals(other.getValue()));\n        }\n        \n        public int hashCode() {\n            if (canRemove == false) {\n                return 0;\n            }\n            Object key = getKey();\n            Object value = getValue();\n            return (key == null ? 0 : key.hashCode()) ^\n                   (value == null ? 0 : value.hashCode());\n        }\n        \n        public String toString() {\n            if (canRemove) {\n                return getKey() + \"=\" + getValue();\n            } else {\n                return \"\";\n            }\n        }\n    }\n    \n    /**\n     * Gets the keySet view of the map.\n     * Changes made to the view affect this map.\n     * To simply iterate through the keys, use {@link #mapIterator()}.\n     * \n     * @return the keySet view\n     */\n    public Set keySet() {\n        if (delegateMap != null) {\n            return delegateMap.keySet();\n        }\n        return new KeySet(this);\n    }\n\n    /**\n     * KeySet\n     */\n    static class KeySet extends AbstractSet {\n        private final Flat3Map parent;\n        \n        KeySet(Flat3Map parent) {\n            super();\n            this.parent = parent;\n        }\n\n        public int size() {\n            return parent.size();\n        }\n        \n        public void clear() {\n            parent.clear();\n        }\n        \n        public boolean contains(Object key) {\n            return parent.containsKey(key);\n        }\n\n        public boolean remove(Object key) {\n            boolean result = parent.containsKey(key);\n            parent.remove(key);\n            return result;\n        }\n\n        public Iterator iterator() {\n            if (parent.delegateMap != null) {\n                return parent.delegateMap.keySet().iterator();\n            }\n            if (parent.size() == 0) {\n                return EmptyIterator.INSTANCE;\n            }\n            return new KeySetIterator(parent);\n        }\n    }\n\n    /**\n     * KeySetIterator\n     */\n    static class KeySetIterator extends EntrySetIterator {\n        \n        KeySetIterator(Flat3Map parent) {\n            super(parent);\n        }\n\n        public Object next() {\n            super.next();\n            return getKey();\n        }\n    }\n    \n    /**\n     * Gets the values view of the map.\n     * Changes made to the view affect this map.\n     * To simply iterate through the values, use {@link #mapIterator()}.\n     * \n     * @return the values view\n     */\n    public Collection values() {\n        if (delegateMap != null) {\n            return delegateMap.values();\n        }\n        return new Values(this);\n    }\n\n    /**\n     * Values\n     */\n    static class Values extends AbstractCollection {\n        private final Flat3Map parent;\n        \n        Values(Flat3Map parent) {\n            super();\n            this.parent = parent;\n        }\n\n        public int size() {\n            return parent.size();\n        }\n        \n        public void clear() {\n            parent.clear();\n        }\n        \n        public boolean contains(Object value) {\n            return parent.containsValue(value);\n        }\n\n        public Iterator iterator() {\n            if (parent.delegateMap != null) {\n                return parent.delegateMap.values().iterator();\n            }\n            if (parent.size() == 0) {\n                return EmptyIterator.INSTANCE;\n            }\n            return new ValuesIterator(parent);\n        }\n    }\n\n    /**\n     * ValuesIterator\n     */\n    static class ValuesIterator extends EntrySetIterator {\n        \n        ValuesIterator(Flat3Map parent) {\n            super(parent);\n        }\n\n        public Object next() {\n            super.next();\n            return getValue();\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Write the map out using a custom routine.\n     */\n    private void writeObject(ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        out.writeInt(size());\n        for (MapIterator it = mapIterator(); it.hasNext();) {\n            out.writeObject(it.next());  // key\n            out.writeObject(it.getValue());  // value\n        }\n    }\n\n    /**\n     * Read the map in using a custom routine.\n     */\n    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        int count = in.readInt();\n        if (count > 3) {\n            delegateMap = createDelegateMap();\n        }\n        for (int i = count; i > 0; i--) {\n            put(in.readObject(), in.readObject());\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Clones the map without cloning the keys or values.\n     *\n     * @return a shallow clone\n     * @since Commons Collections 3.1\n     */\n    public Object clone() {\n        try {\n            Flat3Map cloned = (Flat3Map) super.clone();\n            if (cloned.delegateMap != null) {\n                cloned.delegateMap = (HashedMap) cloned.delegateMap.clone();\n            }\n            return cloned;\n        } catch (CloneNotSupportedException ex) {\n            throw new InternalError();\n        }\n    }\n\n    /**\n     * Compares this map with another.\n     * \n     * @param obj  the object to compare to\n     * @return true if equal\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (delegateMap != null) {\n            return delegateMap.equals(obj);\n        }\n        if (obj instanceof Map == false) {\n            return false;\n        }\n        Map other = (Map) obj;\n        if (size != other.size()) {\n            return false;\n        }\n        if (size > 0) {\n            Object otherValue = null;\n            switch (size) {  // drop through\n                case 3:\n                    if (other.containsKey(key3) == false) {\n                        return false;\n                    }\n                    otherValue = other.get(key3);\n                    if (value3 == null ? otherValue != null : !value3.equals(otherValue)) {\n                        return false;\n                    }\n                case 2:\n                    if (other.containsKey(key2) == false) {\n                        return false;\n                    }\n                    otherValue = other.get(key2);\n                    if (value2 == null ? otherValue != null : !value2.equals(otherValue)) {\n                        return false;\n                    }\n                case 1:\n                    if (other.containsKey(key1) == false) {\n                        return false;\n                    }\n                    otherValue = other.get(key1);\n                    if (value1 == null ? otherValue != null : !value1.equals(otherValue)) {\n                        return false;\n                    }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Gets the standard Map hashCode.\n     * \n     * @return the hash code defined in the Map interface\n     */\n    public int hashCode() {\n        if (delegateMap != null) {\n            return delegateMap.hashCode();\n        }\n        int total = 0;\n        switch (size) {  // drop through\n            case 3:\n                total += (hash3 ^ (value3 == null ? 0 : value3.hashCode()));\n            case 2:\n                total += (hash2 ^ (value2 == null ? 0 : value2.hashCode()));\n            case 1:\n                total += (hash1 ^ (value1 == null ? 0 : value1.hashCode()));\n        }\n        return total;\n    }\n\n    /**\n     * Gets the map as a String.\n     * \n     * @return a string version of the map\n     */\n    public String toString() {\n        if (delegateMap != null) {\n            return delegateMap.toString();\n        }\n        if (size == 0) {\n            return \"{}\";\n        }\n        StringBuffer buf = new StringBuffer(128);\n        buf.append('{');\n        switch (size) {  // drop through\n            case 3:\n                buf.append((key3 == this ? \"(this Map)\" : key3));\n                buf.append('=');\n                buf.append((value3 == this ? \"(this Map)\" : value3));\n                buf.append(',');\n            case 2:\n                buf.append((key2 == this ? \"(this Map)\" : key2));\n                buf.append('=');\n                buf.append((value2 == this ? \"(this Map)\" : value2));\n                buf.append(',');\n            case 1:\n                buf.append((key1 == this ? \"(this Map)\" : key1));\n                buf.append('=');\n                buf.append((value1 == this ? \"(this Map)\" : value1));\n        }\n        buf.append('}');\n        return buf.toString();\n    }\n\n}\n"}]}
{"project": "Collections", "bug_id": 2, "classes_modified": [{"class_name": "org.apache.commons.collections.ExtendedProperties", "buggy_version": "/*\n *  Copyright 2001-2006 The Apache Software Foundation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.apache.commons.collections;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.LineNumberReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.UnsupportedEncodingException;\nimport java.util.ArrayList;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.NoSuchElementException;\nimport java.util.Properties;\nimport java.util.StringTokenizer;\nimport java.util.Vector;\n\n/**\n * This class extends normal Java properties by adding the possibility\n * to use the same key many times concatenating the value strings\n * instead of overwriting them.\n * <p>\n * <b>Please consider using the <code>PropertiesConfiguration</code> class in\n * Commons-Configuration as soon as it is released.</b>\n * <p>\n * The Extended Properties syntax is explained here:\n *\n * <ul>\n *  <li>\n *   Each property has the syntax <code>key = value</code>\n *  </li>\n *  <li>\n *   The <i>key</i> may use any character but the equal sign '='.\n *  </li>\n *  <li>\n *   <i>value</i> may be separated on different lines if a backslash\n *   is placed at the end of the line that continues below.\n *  </li>\n *  <li>\n *   If <i>value</i> is a list of strings, each token is separated\n *   by a comma ','.\n *  </li>\n *  <li>\n *   Commas in each token are escaped placing a backslash right before\n *   the comma.\n *  </li>\n *  <li>\n *   Backslashes are escaped by using two consecutive backslashes i.e. \\\\\n *  </li>\n *  <li>\n *   If a <i>key</i> is used more than once, the values are appended\n *   as if they were on the same line separated with commas.\n *  </li>\n *  <li>\n *   Blank lines and lines starting with character '#' are skipped.\n *  </li>\n *  <li>\n *   If a property is named \"include\" (or whatever is defined by\n *   setInclude() and getInclude() and the value of that property is\n *   the full path to a file on disk, that file will be included into\n *   the ConfigurationsRepository. You can also pull in files relative\n *   to the parent configuration file. So if you have something\n *   like the following:\n *\n *   include = additional.properties\n *\n *   Then \"additional.properties\" is expected to be in the same\n *   directory as the parent configuration file.\n * \n *   Duplicate name values will be replaced, so be careful.\n *\n *  </li>\n * </ul>\n *\n * <p>Here is an example of a valid extended properties file:\n *\n * <p><pre>\n *      # lines starting with # are comments\n *\n *      # This is the simplest property\n *      key = value\n *\n *      # A long property may be separated on multiple lines\n *      longvalue = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa \\\n *                  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n *\n *      # This is a property with many tokens\n *      tokens_on_a_line = first token, second token\n *\n *      # This sequence generates exactly the same result\n *      tokens_on_multiple_lines = first token\n *      tokens_on_multiple_lines = second token\n *\n *      # commas may be escaped in tokens\n *      commas.escaped = Hi\\, what'up?\n * </pre>\n *\n * <p><b>NOTE</b>: this class has <b>not</b> been written for\n * performance nor low memory usage.  In fact, it's way slower than it\n * could be and generates too much memory garbage.  But since\n * performance is not an issue during intialization (and there is not\n * much time to improve it), I wrote it this way.  If you don't like\n * it, go ahead and tune it up!\n *\n * @since Commons Collections 1.0\n * @version $Revision$ $Date$\n * \n * @author <a href=\"mailto:stefano@apache.org\">Stefano Mazzocchi</a>\n * @author <a href=\"mailto:jon@latchkey.com\">Jon S. Stevens</a>\n * @author <a href=\"mailto:daveb@miceda-data\">Dave Bryson</a>\n * @author <a href=\"mailto:jvanzyl@periapt.com\">Jason van Zyl</a>\n * @author <a href=\"mailto:geirm@optonline.net\">Geir Magnusson Jr.</a>\n * @author <a href=\"mailto:leon@opticode.co.za\">Leon Messerschmidt</a>\n * @author <a href=\"mailto:kjohnson@transparent.com\">Kent Johnson</a>\n * @author <a href=\"mailto:dlr@finemaltcoding.com\">Daniel Rall</a>\n * @author <a href=\"mailto:ipriha@surfeu.fi\">Ilkka Priha</a>\n * @author Janek Bogucki\n * @author Mohan Kishore\n * @author Stephen Colebourne\n * @author Shinobu Kawai\n * @author <a href=\"mailto:hps@intermeta.de\">Henning P. Schmiedehausen</a>\n */\npublic class ExtendedProperties extends Hashtable {\n    \n    /**\n     * Default configurations repository.\n     */\n    private ExtendedProperties defaults;\n\n    /**\n     * The file connected to this repository (holding comments and\n     * such).\n     *\n     * @serial\n     */\n    protected String file;\n\n    /**\n     * Base path of the configuration file used to create\n     * this ExtendedProperties object.\n     */\n    protected String basePath;\n\n    /**\n     * File separator.\n     */\n    protected String fileSeparator = System.getProperty(\"file.separator\");\n\n    /**\n     * Has this configuration been intialized.\n     */\n    protected boolean isInitialized = false;\n\n    /**\n     * This is the name of the property that can point to other\n     * properties file for including other properties files.\n     */\n\n    /**\n     * This is the default name of the property that can point to other\n     * properties file for including other properties files.\n     * \n     * @deprecated Use getInclude() and setInclude() methods which operate\n     * on an instance variable from v3.3. Due to be removed in v4.0.\n     */\n    protected static String include = \"include\";\n\n    /**\n     * These are the keys in the order they listed\n     * in the configuration file. This is useful when\n     * you wish to perform operations with configuration\n     * information in a particular order.\n     */\n    protected ArrayList keysAsListed = new ArrayList();\n\n    protected final static String START_TOKEN=\"${\";\n    protected final static String END_TOKEN=\"}\";\n\n\n    /**\n     * Interpolate key names to handle ${key} stuff\n     *\n     * @param base string to interpolate\n     * @return returns the key name with the ${key} substituted\n     */\n    protected String interpolate(String base) {\n        // COPIED from [configuration] 2003-12-29\n        return (interpolateHelper(base, null));\n    }\n\n    /**\n     * Recursive handler for multiple levels of interpolation.\n     *\n     * When called the first time, priorVariables should be null.\n     *\n     * @param base string with the ${key} variables\n     * @param priorVariables serves two purposes: to allow checking for\n     * loops, and creating a meaningful exception message should a loop\n     * occur.  It's 0'th element will be set to the value of base from\n     * the first call.  All subsequent interpolated variables are added\n     * afterward.\n     *\n     * @return the string with the interpolation taken care of\n     */\n    protected String interpolateHelper(String base, List priorVariables) {\n        // COPIED from [configuration] 2003-12-29\n        if (base == null) {\n            return null;\n        }\n\n        // on the first call initialize priorVariables\n        // and add base as the first element\n        if (priorVariables == null) {\n            priorVariables = new ArrayList();\n            priorVariables.add(base);\n        }\n\n        int begin = -1;\n        int end = -1;\n        int prec = 0 - END_TOKEN.length();\n        String variable = null;\n        StringBuffer result = new StringBuffer();\n\n        // FIXME: we should probably allow the escaping of the start token\n        while (((begin = base.indexOf(START_TOKEN, prec + END_TOKEN.length())) > -1)\n            && ((end = base.indexOf(END_TOKEN, begin)) > -1)) {\n            result.append(base.substring(prec + END_TOKEN.length(), begin));\n            variable = base.substring(begin + START_TOKEN.length(), end);\n\n            // if we've got a loop, create a useful exception message and throw\n            if (priorVariables.contains(variable)) {\n                String initialBase = priorVariables.remove(0).toString();\n                priorVariables.add(variable);\n                StringBuffer priorVariableSb = new StringBuffer();\n\n                // create a nice trace of interpolated variables like so:\n                // var1->var2->var3\n                for (Iterator it = priorVariables.iterator(); it.hasNext();) {\n                    priorVariableSb.append(it.next());\n                    if (it.hasNext()) {\n                        priorVariableSb.append(\"->\");\n                    }\n                }\n\n                throw new IllegalStateException(\n                    \"infinite loop in property interpolation of \" + initialBase + \": \" + priorVariableSb.toString());\n            }\n            // otherwise, add this variable to the interpolation list.\n            else {\n                priorVariables.add(variable);\n            }\n\n            //QUESTION: getProperty or getPropertyDirect\n            Object value = getProperty(variable);\n            if (value != null) {\n                result.append(interpolateHelper(value.toString(), priorVariables));\n\n                // pop the interpolated variable off the stack\n                // this maintains priorVariables correctness for\n                // properties with multiple interpolations, e.g.\n                // prop.name=${some.other.prop1}/blahblah/${some.other.prop2}\n                priorVariables.remove(priorVariables.size() - 1);\n            } else if (defaults != null && defaults.getString(variable, null) != null) {\n                result.append(defaults.getString(variable));\n            } else {\n                //variable not defined - so put it back in the value\n                result.append(START_TOKEN).append(variable).append(END_TOKEN);\n            }\n            prec = end;\n        }\n        result.append(base.substring(prec + END_TOKEN.length(), base.length()));\n\n        return result.toString();\n    }\n    \n    /**\n     * Inserts a backslash before every comma and backslash. \n     */\n    private static String escape(String s) {\n        StringBuffer buf = new StringBuffer(s);\n        for (int i = 0; i < buf.length(); i++) {\n            char c = buf.charAt(i);\n            if (c == ',' || c == '\\\\') {\n                buf.insert(i, '\\\\');\n                i++;\n            }\n        }\n        return buf.toString();\n    }\n    \n    /**\n     * Removes a backslash from every pair of backslashes. \n     */\n    private static String unescape(String s) {\n        StringBuffer buf = new StringBuffer(s);\n        for (int i = 0; i < buf.length() - 1; i++) {\n            char c1 = buf.charAt(i);\n            char c2 = buf.charAt(i + 1);\n            if (c1 == '\\\\' && c2 == '\\\\') {\n                buf.deleteCharAt(i);\n            }\n        }\n        return buf.toString();\n    }\n\n    /**\n     * Counts the number of successive times 'ch' appears in the\n     * 'line' before the position indicated by the 'index'.\n     */\n    private static int countPreceding(String line, int index, char ch) {\n        int i;\n        for (i = index - 1; i >= 0; i--) {\n            if (line.charAt(i) != ch) {\n                break;\n            }\n        }\n        return index - 1 - i;\n    }\n\n    /**\n     * Checks if the line ends with odd number of backslashes \n     */\n    private static boolean endsWithSlash(String line) {\n        if (!line.endsWith(\"\\\\\")) {\n            return false;\n        }\n        return (countPreceding(line, line.length() - 1, '\\\\') % 2 == 0);\n    }\n\n    /**\n     * This class is used to read properties lines.  These lines do\n     * not terminate with new-line chars but rather when there is no\n     * backslash sign a the end of the line.  This is used to\n     * concatenate multiple lines for readability.\n     */\n    static class PropertiesReader extends LineNumberReader {\n        /**\n         * Constructor.\n         *\n         * @param reader A Reader.\n         */\n        public PropertiesReader(Reader reader) {\n            super(reader);\n        }\n\n        /**\n         * Read a property.\n         *\n         * @return a String property\n         * @throws IOException if there is difficulty reading the source.\n         */\n        public String readProperty() throws IOException {\n            StringBuffer buffer = new StringBuffer();\n            String line = readLine();\n            while (line != null) {\n                line = line.trim();\n                if ((line.length() != 0) && (line.charAt(0) != '#')) {\n                    if (endsWithSlash(line)) {\n                        line = line.substring(0, line.length() - 1);\n                        buffer.append(line);\n                    } else {\n                        buffer.append(line);\n                        return buffer.toString();  // normal method end\n                    }\n                }\n                line = readLine();\n            }\n            return null;  // EOF reached\n        }\n    }\n\n    /**\n     * This class divides into tokens a property value.  Token\n     * separator is \",\" but commas into the property value are escaped\n     * using the backslash in front.\n     */\n    static class PropertiesTokenizer extends StringTokenizer {\n        /**\n         * The property delimiter used while parsing (a comma).\n         */\n        static final String DELIMITER = \",\";\n\n        /**\n         * Constructor.\n         *\n         * @param string A String.\n         */\n        public PropertiesTokenizer(String string) {\n            super(string, DELIMITER);\n        }\n\n        /**\n         * Check whether the object has more tokens.\n         *\n         * @return True if the object has more tokens.\n         */\n        public boolean hasMoreTokens() {\n            return super.hasMoreTokens();\n        }\n\n        /**\n         * Get next token.\n         *\n         * @return A String.\n         */\n        public String nextToken() {\n            StringBuffer buffer = new StringBuffer();\n\n            while (hasMoreTokens()) {\n                String token = super.nextToken();\n                if (endsWithSlash(token)) {\n                    buffer.append(token.substring(0, token.length() - 1));\n                    buffer.append(DELIMITER);\n                } else {\n                    buffer.append(token);\n                    break;\n                }\n            }\n\n            return buffer.toString().trim();\n        }\n    }\n\n    /**\n     * Creates an empty extended properties object.\n     */\n    public ExtendedProperties() {\n        super();\n    }\n\n    /**\n     * Creates and loads the extended properties from the specified file.\n     *\n     * @param file  the filename to load\n     * @throws IOException if a file error occurs\n     */\n    public ExtendedProperties(String file) throws IOException {\n        this(file, null);\n    }\n\n    /**\n     * Creates and loads the extended properties from the specified file.\n     *\n     * @param file  the filename to load\n     * @param defaultFile  a second filename to load default values from\n     * @throws IOException if a file error occurs\n     */\n    public ExtendedProperties(String file, String defaultFile) throws IOException {\n        this.file = file;\n\n        basePath = new File(file).getAbsolutePath();\n        basePath = basePath.substring(0, basePath.lastIndexOf(fileSeparator) + 1);\n\n        FileInputStream in = null;\n        try {\n            in = new FileInputStream(file);\n            this.load(in);\n        } finally {\n            try {\n                if (in != null) {\n                    in.close();\n                }\n            } catch (IOException ex) {}\n        }\n\n        if (defaultFile != null) {\n            defaults = new ExtendedProperties(defaultFile);\n        }\n    }\n\n    /**\n     * Indicate to client code whether property\n     * resources have been initialized or not.\n     */\n    public boolean isInitialized() {\n        return isInitialized;\n    }\n\n    /**\n     * Gets the property value for including other properties files.\n     * By default it is \"include\".\n     * <p>\n     * NOTE: Prior to v3.3 this method accessed a static variable.\n     * It now accesses an instance variable. For compatability, if the\n     * instance variable has not been set then the previous static\n     * variable is then accessed. However, the protected static variable\n     * can now only be set by subclasses.\n     * In v4.0, the static variable will be removed.\n     *\n     * @return the property name which includes another property\n     */\n    public String getInclude() {\n            return include;  // backwards compatability\n    }\n\n    /**\n     * Sets the property value for including other properties files.\n     * By default it is \"include\".\n     * <p>\n     * NOTE: Prior to v3.3 this method set a static variable and affected all\n     * users of the class. It now sets an instance variable.\n     * An empty string is also now converted to null internally.\n     * In v4.0, the static variable will be removed.\n     *\n     * @param inc  the property name which includes another property, empty converted to null\n     */\n    public void setInclude(String inc) {\n        include = inc;\n    }\n\n    /**\n     * Load the properties from the given input stream.\n     *\n     * @param input  the InputStream to load from\n     * @throws IOException if an IO error occurs\n     */\n    public void load(InputStream input) throws IOException {\n        load(input, null);\n    }\n\n    /**\n     * Load the properties from the given input stream\n     * and using the specified encoding.\n     *\n     * @param input  the InputStream to load from\n     * @param enc  the encoding to use\n     * @throws IOException if an IO error occurs\n     */\n    public synchronized void load(InputStream input, String enc) throws IOException {\n        PropertiesReader reader = null;\n        if (enc != null) {\n            try {\n                reader = new PropertiesReader(new InputStreamReader(input, enc));\n                \n            } catch (UnsupportedEncodingException ex) {\n                // Another try coming up....\n            }\n        }\n        \n        if (reader == null) {\n            try {\n                reader = new PropertiesReader(new InputStreamReader(input, \"8859_1\"));\n                \n            } catch (UnsupportedEncodingException ex) {\n                // ISO8859-1 support is required on java platforms but....\n                // If it's not supported, use the system default encoding\n                reader = new PropertiesReader(new InputStreamReader(input));\n            }\n        }\n\n        try {\n            while (true) {\n                String line = reader.readProperty();\n                if (line == null) {\n                    return;  // EOF\n                }\n                int equalSign = line.indexOf('=');\n\n                if (equalSign > 0) {\n                    String key = line.substring(0, equalSign).trim();\n                    String value = line.substring(equalSign + 1).trim();\n\n                    // Configure produces lines like this ... just ignore them\n                    if (\"\".equals(value)) {\n                        continue;\n                    }\n\n                    if (getInclude() != null && key.equalsIgnoreCase(getInclude())) {\n                        // Recursively load properties files.\n                        File file = null;\n\n                        if (value.startsWith(fileSeparator)) {\n                            // We have an absolute path so we'll use this\n                            file = new File(value);\n                            \n                        } else {\n                            // We have a relative path, and we have two \n                            // possible forms here. If we have the \"./\" form\n                            // then just strip that off first before continuing.\n                            if (value.startsWith(\".\" + fileSeparator)) {\n                                value = value.substring(2);\n                            }\n\n                            file = new File(basePath + value);\n                        }\n\n                        if (file != null && file.exists() && file.canRead()) {\n                            load(new FileInputStream(file));\n                        }\n                    } else {\n                        addProperty(key, value);\n                    }\n                }\n            }\n        } finally {\n            // Loading is initializing\n            isInitialized = true;\n        }\n    }\n\n    /**\n     * Gets a property from the configuration.\n     *\n     * @param key property to retrieve\n     * @return value as object. Will return user value if exists,\n     *        if not then default value if exists, otherwise null\n     */\n    public Object getProperty(String key) {\n        // first, try to get from the 'user value' store\n        Object obj = this.get(key);\n\n        if (obj == null) {\n            // if there isn't a value there, get it from the\n            // defaults if we have them\n            if (defaults != null) {\n                obj = defaults.get(key);\n            }\n        }\n\n        return obj;\n    }\n    \n    /**\n     * Add a property to the configuration. If it already\n     * exists then the value stated here will be added\n     * to the configuration entry. For example, if\n     *\n     * <code>resource.loader = file</code>\n     *\n     * is already present in the configuration and you\n     *\n     * <code>addProperty(\"resource.loader\", \"classpath\")</code>\n     *\n     * Then you will end up with a Vector like the\n     * following:\n     *\n     * <code>[\"file\", \"classpath\"]</code>\n     *\n     * @param key  the key to add\n     * @param value  the value to add\n     */\n    public void addProperty(String key, Object value) {\n        if (value instanceof String) {\n            String str = (String) value;\n            if (str.indexOf(PropertiesTokenizer.DELIMITER) > 0) {\n                // token contains commas, so must be split apart then added\n                PropertiesTokenizer tokenizer = new PropertiesTokenizer(str);\n                while (tokenizer.hasMoreTokens()) {\n                    String token = tokenizer.nextToken();\n                    addPropertyInternal(key, unescape(token));\n                }\n            } else {\n                // token contains no commas, so can be simply added\n                addPropertyInternal(key, unescape(str));\n            }\n        } else {\n            addPropertyInternal(key, value);\n        }\n\n        // Adding a property connotes initialization\n        isInitialized = true;\n    }\n\n    /**\n     * Adds a key/value pair to the map.  This routine does\n     * no magic morphing.  It ensures the keylist is maintained\n     *\n     * @param key  the key to store at\n     * @param value  the decoded object to store\n     */\n    private void addPropertyDirect(String key, Object value) {\n        // safety check\n        if (!containsKey(key)) {\n            keysAsListed.add(key);\n        }\n        put(key, value);\n    }\n\n    /**\n     * Adds a decoded property to the map w/o checking for commas - used\n     * internally when a property has been broken up into\n     * strings that could contain escaped commas to prevent\n     * the inadvertent vectorization.\n     * <p>\n     * Thanks to Leon Messerschmidt for this one.\n     *\n     * @param key  the key to store at\n     * @param value  the decoded object to store\n     */\n    private void addPropertyInternal(String key, Object value) {\n        Object current = this.get(key);\n\n        if (current instanceof String) {\n            // one object already in map - convert it to a vector\n            List values = new Vector(2);\n            values.add(current);\n            values.add(value);\n            put(key, values);\n            \n        } else if (current instanceof List) {\n            // already a list - just add the new token\n            ((List) current).add(value);\n            \n        } else {\n            // brand new key - store in keysAsListed to retain order\n            if (!containsKey(key)) {\n                keysAsListed.add(key);\n            }\n            put(key, value);\n        }\n    }\n\n    /**\n     * Set a property, this will replace any previously\n     * set values. Set values is implicitly a call\n     * to clearProperty(key), addProperty(key,value).\n     *\n     * @param key  the key to set\n     * @param value  the value to set\n     */\n    public void setProperty(String key, Object value) {\n        clearProperty(key);\n        addProperty(key, value);\n    }\n    \n    /**\n     * Save the properties to the given output stream.\n     * <p>\n     * The stream is not closed, but it is flushed.\n     *\n     * @param output  an OutputStream, may be null\n     * @param header  a textual comment to act as a file header\n     * @throws IOException if an IO error occurs\n     */\n    public synchronized void save(OutputStream output, String header) throws IOException {\n        if (output == null) {\n            return;\n        }\n        PrintWriter theWrtr = new PrintWriter(output);\n        if (header != null) {\n            theWrtr.println(header);\n        }\n        \n        Enumeration theKeys = keys();\n        while (theKeys.hasMoreElements()) {\n            String key = (String) theKeys.nextElement();\n            Object value = get(key);\n            if (value != null) {\n                if (value instanceof String) {\n                    StringBuffer currentOutput = new StringBuffer();\n                    currentOutput.append(key);\n                    currentOutput.append(\"=\");\n                    currentOutput.append(escape((String) value));\n                    theWrtr.println(currentOutput.toString());\n                    \n                } else if (value instanceof List) {\n                    List values = (List) value;\n                    for (Iterator it = values.iterator(); it.hasNext(); ) {\n                        String currentElement = (String) it.next();\n                        StringBuffer currentOutput = new StringBuffer();\n                        currentOutput.append(key);\n                        currentOutput.append(\"=\");\n                        currentOutput.append(escape(currentElement));\n                        theWrtr.println(currentOutput.toString());\n                    }\n                }\n            }\n            theWrtr.println();\n            theWrtr.flush();\n        }\n    }\n\n    /**\n     * Combines an existing Hashtable with this Hashtable.\n     * <p>\n     * Warning: It will overwrite previous entries without warning.\n     *\n     * @param props  the properties to combine\n     */\n    public void combine(ExtendedProperties props) {\n        for (Iterator it = props.getKeys(); it.hasNext();) {\n            String key = (String) it.next();\n            setProperty(key, props.get(key));\n        }\n    }\n    \n    /**\n     * Clear a property in the configuration.\n     *\n     * @param key  the property key to remove along with corresponding value\n     */\n    public void clearProperty(String key) {\n        if (containsKey(key)) {\n            // we also need to rebuild the keysAsListed or else\n            // things get *very* confusing\n            for (int i = 0; i < keysAsListed.size(); i++) {\n                if (( keysAsListed.get(i)).equals(key)) {\n                    keysAsListed.remove(i);\n                    break;\n                }\n            }\n            remove(key);\n        }\n    }\n\n    /**\n     * Get the list of the keys contained in the configuration\n     * repository.\n     *\n     * @return an Iterator over the keys\n     */\n    public Iterator getKeys() {\n        return keysAsListed.iterator();\n    }\n\n    /**\n     * Get the list of the keys contained in the configuration\n     * repository that match the specified prefix.\n     *\n     * @param prefix  the prefix to match\n     * @return an Iterator of keys that match the prefix\n     */\n    public Iterator getKeys(String prefix) {\n        Iterator keys = getKeys();\n        ArrayList matchingKeys = new ArrayList();\n\n        while (keys.hasNext()) {\n            Object key = keys.next();\n\n            if (key instanceof String && ((String) key).startsWith(prefix)) {\n                matchingKeys.add(key);\n            }\n        }\n        return matchingKeys.iterator();\n    }\n\n    /**\n     * Create an ExtendedProperties object that is a subset\n     * of this one. Take into account duplicate keys\n     * by using the setProperty() in ExtendedProperties.\n     *\n     * @param prefix  the prefix to get a subset for\n     * @return a new independent ExtendedProperties\n     */\n    public ExtendedProperties subset(String prefix) {\n        ExtendedProperties c = new ExtendedProperties();\n        Iterator keys = getKeys();\n        boolean validSubset = false;\n\n        while (keys.hasNext()) {\n            Object key = keys.next();\n\n            if (key instanceof String && ((String) key).startsWith(prefix)) {\n                if (!validSubset) {\n                    validSubset = true;\n                }\n\n                /*\n                 * Check to make sure that c.subset(prefix) doesn't\n                 * blow up when there is only a single property\n                 * with the key prefix. This is not a useful\n                 * subset but it is a valid subset.\n                 */\n                String newKey = null;\n                if (((String) key).length() == prefix.length()) {\n                    newKey = prefix;\n                } else {\n                    newKey = ((String) key).substring(prefix.length() + 1);\n                }\n\n                /*\n                 *  use addPropertyDirect() - this will plug the data as \n                 *  is into the Map, but will also do the right thing\n                 *  re key accounting\n                 */\n                c.addPropertyDirect(newKey, get(key));\n            }\n        }\n\n        if (validSubset) {\n            return c;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Display the configuration for debugging purposes to System.out.\n     */\n    public void display() {\n        Iterator i = getKeys();\n\n        while (i.hasNext()) {\n            String key = (String) i.next();\n            Object value = get(key);\n            System.out.println(key + \" => \" + value);\n        }\n    }\n\n    /**\n     * Get a string associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated string.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a String.\n     */\n    public String getString(String key) {\n        return getString(key, null);\n    }\n\n    /**\n     * Get a string associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated string if key is found,\n     * default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a String.\n     */\n    public String getString(String key, String defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof String) {\n            return interpolate((String) value);\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return interpolate(defaults.getString(key, defaultValue));\n            } else {\n                return interpolate(defaultValue);\n            }\n        } else if (value instanceof List) {\n            return interpolate((String) ((List) value).get(0));\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a String object\");\n        }\n    }\n\n    /**\n     * Get a list of properties associated with the given\n     * configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated properties if key is found.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a String/List.\n     * @throws IllegalArgumentException if one of the tokens is\n     * malformed (does not contain an equals sign).\n     */\n    public Properties getProperties(String key) {\n        return getProperties(key, new Properties());\n    }\n\n    /**\n     * Get a list of properties associated with the given\n     * configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated properties if key is found.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a String/List.\n     * @throws IllegalArgumentException if one of the tokens is\n     * malformed (does not contain an equals sign).\n     */\n    public Properties getProperties(String key, Properties defaults) {\n        /*\n         * Grab an array of the tokens for this key.\n         */\n        String[] tokens = getStringArray(key);\n\n        // Each token is of the form 'key=value'.\n        Properties props = new Properties(defaults);\n        for (int i = 0; i < tokens.length; i++) {\n            String token = tokens[i];\n            int equalSign = token.indexOf('=');\n            if (equalSign > 0) {\n                String pkey = token.substring(0, equalSign).trim();\n                String pvalue = token.substring(equalSign + 1).trim();\n                props.put(pkey, pvalue);\n            } else {\n                throw new IllegalArgumentException('\\'' + token + \"' does not contain \" + \"an equals sign\");\n            }\n        }\n        return props;\n    }\n\n    /**\n     * Get an array of strings associated with the given configuration\n     * key.\n     *\n     * @param key The configuration key.\n     * @return The associated string array if key is found.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a String/List.\n     */\n    public String[] getStringArray(String key) {\n        Object value = get(key);\n\n        List values;\n        if (value instanceof String) {\n            values = new Vector(1);\n            values.add(value);\n            \n        } else if (value instanceof List) {\n            values = (List) value;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getStringArray(key);\n            } else {\n                return new String[0];\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a String/List object\");\n        }\n\n        String[] tokens = new String[values.size()];\n        for (int i = 0; i < tokens.length; i++) {\n            tokens[i] = (String) values.get(i);\n        }\n\n        return tokens;\n    }\n\n    /**\n     * Get a Vector of strings associated with the given configuration\n     * key.\n     *\n     * @param key The configuration key.\n     * @return The associated Vector.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Vector.\n     */\n    public Vector getVector(String key) {\n        return getVector(key, null);\n    }\n\n    /**\n     * Get a Vector of strings associated with the given configuration key.\n     * <p>\n     * The list is a copy of the internal data of this object, and as\n     * such you may alter it freely.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated Vector.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Vector.\n     */\n    public Vector getVector(String key, Vector defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof List) {\n            return new Vector((List) value);\n            \n        } else if (value instanceof String) {\n            Vector values = new Vector(1);\n            values.add(value);\n            put(key, values);\n            return values;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getVector(key, defaultValue);\n            } else {\n                return ((defaultValue == null) ? new Vector() : defaultValue);\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Vector object\");\n        }\n    }\n\n    /**\n     * Get a List of strings associated with the given configuration key.\n     * <p>\n     * The list is a copy of the internal data of this object, and as\n     * such you may alter it freely.\n     *\n     * @param key The configuration key.\n     * @return The associated List object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a List.\n     * @since Commons Collections 3.2\n     */\n    public List getList(String key) {\n        return getList(key, null);\n    }\n\n    /**\n     * Get a List of strings associated with the given configuration key.\n     * <p>\n     * The list is a copy of the internal data of this object, and as\n     * such you may alter it freely.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated List.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a List.\n     * @since Commons Collections 3.2\n     */\n    public List getList(String key, List defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof List) {\n            return new ArrayList((List) value);\n            \n        } else if (value instanceof String) {\n            List values = new ArrayList(1);\n            values.add(value);\n            put(key, values);\n            return values;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getList(key, defaultValue);\n            } else {\n                return ((defaultValue == null) ? new ArrayList() : defaultValue);\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a List object\");\n        }\n    }\n\n    /**\n     * Get a boolean associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated boolean.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Boolean.\n     */\n    public boolean getBoolean(String key) {\n        Boolean b = getBoolean(key, null);\n        if (b != null) {\n            return b.booleanValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a boolean associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated boolean.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Boolean.\n     */\n    public boolean getBoolean(String key, boolean defaultValue) {\n        return getBoolean(key, new Boolean(defaultValue)).booleanValue();\n    }\n\n    /**\n     * Get a boolean associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated boolean if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Boolean.\n     */\n    public Boolean getBoolean(String key, Boolean defaultValue) {\n\n        Object value = get(key);\n\n        if (value instanceof Boolean) {\n            return (Boolean) value;\n            \n        } else if (value instanceof String) {\n            String s = testBoolean((String) value);\n            Boolean b = new Boolean(s);\n            put(key, b);\n            return b;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getBoolean(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Boolean object\");\n        }\n    }\n\n    /**\n     * Test whether the string represent by value maps to a boolean\n     * value or not. We will allow <code>true</code>, <code>on</code>,\n     * and <code>yes</code> for a <code>true</code> boolean value, and\n     * <code>false</code>, <code>off</code>, and <code>no</code> for\n     * <code>false</code> boolean values.  Case of value to test for\n     * boolean status is ignored.\n     *\n     * @param value  the value to test for boolean state\n     * @return <code>true</code> or <code>false</code> if the supplied\n     * text maps to a boolean value, or <code>null</code> otherwise.\n     */\n    public String testBoolean(String value) {\n        String s = value.toLowerCase();\n\n        if (s.equals(\"true\") || s.equals(\"on\") || s.equals(\"yes\")) {\n            return \"true\";\n        } else if (s.equals(\"false\") || s.equals(\"off\") || s.equals(\"no\")) {\n            return \"false\";\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Get a byte associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated byte.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Byte.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public byte getByte(String key) {\n        Byte b = getByte(key, null);\n        if (b != null) {\n            return b.byteValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \" doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a byte associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated byte.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Byte.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public byte getByte(String key, byte defaultValue) {\n        return getByte(key, new Byte(defaultValue)).byteValue();\n    }\n\n    /**\n     * Get a byte associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated byte if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Byte.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public Byte getByte(String key, Byte defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Byte) {\n            return (Byte) value;\n            \n        } else if (value instanceof String) {\n            Byte b = new Byte((String) value);\n            put(key, b);\n            return b;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getByte(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Byte object\");\n        }\n    }\n\n    /**\n     * Get a short associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated short.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Short.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public short getShort(String key) {\n        Short s = getShort(key, null);\n        if (s != null) {\n            return s.shortValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a short associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated short.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Short.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public short getShort(String key, short defaultValue) {\n        return getShort(key, new Short(defaultValue)).shortValue();\n    }\n\n    /**\n     * Get a short associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated short if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Short.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public Short getShort(String key, Short defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Short) {\n            return (Short) value;\n            \n        } else if (value instanceof String) {\n            Short s = new Short((String) value);\n            put(key, s);\n            return s;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getShort(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Short object\");\n        }\n    }\n\n    /**\n     * The purpose of this method is to get the configuration resource\n     * with the given name as an integer.\n     *\n     * @param name The resource name.\n     * @return The value of the resource as an integer.\n     */\n    public int getInt(String name) {\n        return getInteger(name);\n    }\n\n    /**\n     * The purpose of this method is to get the configuration resource\n     * with the given name as an integer, or a default value.\n     *\n     * @param name The resource name\n     * @param def The default value of the resource.\n     * @return The value of the resource as an integer.\n     */\n    public int getInt(String name, int def) {\n        return getInteger(name, def);\n    }\n\n    /**\n     * Get a int associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated int.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Integer.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public int getInteger(String key) {\n        Integer i = getInteger(key, null);\n        if (i != null) {\n            return i.intValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a int associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated int.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Integer.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public int getInteger(String key, int defaultValue) {\n        Integer i = getInteger(key, null);\n\n        if (i == null) {\n            return defaultValue;\n        }\n        return i.intValue();\n    }\n\n    /**\n     * Get a int associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated int if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Integer.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public Integer getInteger(String key, Integer defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Integer) {\n            return (Integer) value;\n            \n        } else if (value instanceof String) {\n            Integer i = new Integer((String) value);\n            put(key, i);\n            return i;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getInteger(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Integer object\");\n        }\n    }\n\n    /**\n     * Get a long associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated long.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Long.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public long getLong(String key) {\n        Long l = getLong(key, null);\n        if (l != null) {\n            return l.longValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a long associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated long.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Long.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public long getLong(String key, long defaultValue) {\n        return getLong(key, new Long(defaultValue)).longValue();\n    }\n\n    /**\n     * Get a long associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated long if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Long.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public Long getLong(String key, Long defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Long) {\n            return (Long) value;\n            \n        } else if (value instanceof String) {\n            Long l = new Long((String) value);\n            put(key, l);\n            return l;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getLong(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Long object\");\n        }\n    }\n\n    /**\n     * Get a float associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated float.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Float.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public float getFloat(String key) {\n        Float f = getFloat(key, null);\n        if (f != null) {\n            return f.floatValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a float associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated float.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Float.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public float getFloat(String key, float defaultValue) {\n        return getFloat(key, new Float(defaultValue)).floatValue();\n    }\n\n    /**\n     * Get a float associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated float if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Float.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public Float getFloat(String key, Float defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Float) {\n            return (Float) value;\n            \n        } else if (value instanceof String) {\n            Float f = new Float((String) value);\n            put(key, f);\n            return f;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getFloat(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Float object\");\n        }\n    }\n\n    /**\n     * Get a double associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated double.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Double.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public double getDouble(String key) {\n        Double d = getDouble(key, null);\n        if (d != null) {\n            return d.doubleValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a double associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated double.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Double.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public double getDouble(String key, double defaultValue) {\n        return getDouble(key, new Double(defaultValue)).doubleValue();\n    }\n\n    /**\n     * Get a double associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated double if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Double.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public Double getDouble(String key, Double defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Double) {\n            return (Double) value;\n            \n        } else if (value instanceof String) {\n            Double d = new Double((String) value);\n            put(key, d);\n            return d;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getDouble(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Double object\");\n        }\n    }\n\n    /**\n     * Convert a standard properties class into a configuration class.\n     * <p>\n     * NOTE: From Commons Collections 3.2 this method will pick up\n     * any default parent Properties of the specified input object.\n     *\n     * @param props  the properties object to convert\n     * @return new ExtendedProperties created from props\n     */\n    public static ExtendedProperties convertProperties(Properties props) {\n        ExtendedProperties c = new ExtendedProperties();\n\n        for (Enumeration e = props.propertyNames(); e.hasMoreElements();) {\n            String s = (String) e.nextElement();\n            c.setProperty(s, props.getProperty(s));\n        }\n\n        return c;\n    }\n\n}\n", "fixed_version": "/*\n *  Copyright 2001-2006 The Apache Software Foundation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.apache.commons.collections;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.LineNumberReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.UnsupportedEncodingException;\nimport java.util.ArrayList;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.NoSuchElementException;\nimport java.util.Properties;\nimport java.util.StringTokenizer;\nimport java.util.Vector;\n\n/**\n * This class extends normal Java properties by adding the possibility\n * to use the same key many times concatenating the value strings\n * instead of overwriting them.\n * <p>\n * <b>Please consider using the <code>PropertiesConfiguration</code> class in\n * Commons-Configuration as soon as it is released.</b>\n * <p>\n * The Extended Properties syntax is explained here:\n *\n * <ul>\n *  <li>\n *   Each property has the syntax <code>key = value</code>\n *  </li>\n *  <li>\n *   The <i>key</i> may use any character but the equal sign '='.\n *  </li>\n *  <li>\n *   <i>value</i> may be separated on different lines if a backslash\n *   is placed at the end of the line that continues below.\n *  </li>\n *  <li>\n *   If <i>value</i> is a list of strings, each token is separated\n *   by a comma ','.\n *  </li>\n *  <li>\n *   Commas in each token are escaped placing a backslash right before\n *   the comma.\n *  </li>\n *  <li>\n *   Backslashes are escaped by using two consecutive backslashes i.e. \\\\\n *  </li>\n *  <li>\n *   If a <i>key</i> is used more than once, the values are appended\n *   as if they were on the same line separated with commas.\n *  </li>\n *  <li>\n *   Blank lines and lines starting with character '#' are skipped.\n *  </li>\n *  <li>\n *   If a property is named \"include\" (or whatever is defined by\n *   setInclude() and getInclude() and the value of that property is\n *   the full path to a file on disk, that file will be included into\n *   the ConfigurationsRepository. You can also pull in files relative\n *   to the parent configuration file. So if you have something\n *   like the following:\n *\n *   include = additional.properties\n *\n *   Then \"additional.properties\" is expected to be in the same\n *   directory as the parent configuration file.\n * \n *   Duplicate name values will be replaced, so be careful.\n *\n *  </li>\n * </ul>\n *\n * <p>Here is an example of a valid extended properties file:\n *\n * <p><pre>\n *      # lines starting with # are comments\n *\n *      # This is the simplest property\n *      key = value\n *\n *      # A long property may be separated on multiple lines\n *      longvalue = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa \\\n *                  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n *\n *      # This is a property with many tokens\n *      tokens_on_a_line = first token, second token\n *\n *      # This sequence generates exactly the same result\n *      tokens_on_multiple_lines = first token\n *      tokens_on_multiple_lines = second token\n *\n *      # commas may be escaped in tokens\n *      commas.escaped = Hi\\, what'up?\n * </pre>\n *\n * <p><b>NOTE</b>: this class has <b>not</b> been written for\n * performance nor low memory usage.  In fact, it's way slower than it\n * could be and generates too much memory garbage.  But since\n * performance is not an issue during intialization (and there is not\n * much time to improve it), I wrote it this way.  If you don't like\n * it, go ahead and tune it up!\n *\n * @since Commons Collections 1.0\n * @version $Revision$ $Date$\n * \n * @author <a href=\"mailto:stefano@apache.org\">Stefano Mazzocchi</a>\n * @author <a href=\"mailto:jon@latchkey.com\">Jon S. Stevens</a>\n * @author <a href=\"mailto:daveb@miceda-data\">Dave Bryson</a>\n * @author <a href=\"mailto:jvanzyl@periapt.com\">Jason van Zyl</a>\n * @author <a href=\"mailto:geirm@optonline.net\">Geir Magnusson Jr.</a>\n * @author <a href=\"mailto:leon@opticode.co.za\">Leon Messerschmidt</a>\n * @author <a href=\"mailto:kjohnson@transparent.com\">Kent Johnson</a>\n * @author <a href=\"mailto:dlr@finemaltcoding.com\">Daniel Rall</a>\n * @author <a href=\"mailto:ipriha@surfeu.fi\">Ilkka Priha</a>\n * @author Janek Bogucki\n * @author Mohan Kishore\n * @author Stephen Colebourne\n * @author Shinobu Kawai\n * @author <a href=\"mailto:hps@intermeta.de\">Henning P. Schmiedehausen</a>\n */\npublic class ExtendedProperties extends Hashtable {\n    \n    /**\n     * Default configurations repository.\n     */\n    private ExtendedProperties defaults;\n\n    /**\n     * The file connected to this repository (holding comments and\n     * such).\n     *\n     * @serial\n     */\n    protected String file;\n\n    /**\n     * Base path of the configuration file used to create\n     * this ExtendedProperties object.\n     */\n    protected String basePath;\n\n    /**\n     * File separator.\n     */\n    protected String fileSeparator = System.getProperty(\"file.separator\");\n\n    /**\n     * Has this configuration been intialized.\n     */\n    protected boolean isInitialized = false;\n\n    /**\n     * This is the name of the property that can point to other\n     * properties file for including other properties files.\n     */\n    private String includePropertyName = null;\n\n    /**\n     * This is the default name of the property that can point to other\n     * properties file for including other properties files.\n     * \n     * @deprecated Use getInclude() and setInclude() methods which operate\n     * on an instance variable from v3.3. Due to be removed in v4.0.\n     */\n    protected static String include = \"include\";\n\n    /**\n     * These are the keys in the order they listed\n     * in the configuration file. This is useful when\n     * you wish to perform operations with configuration\n     * information in a particular order.\n     */\n    protected ArrayList keysAsListed = new ArrayList();\n\n    protected final static String START_TOKEN=\"${\";\n    protected final static String END_TOKEN=\"}\";\n\n\n    /**\n     * Interpolate key names to handle ${key} stuff\n     *\n     * @param base string to interpolate\n     * @return returns the key name with the ${key} substituted\n     */\n    protected String interpolate(String base) {\n        // COPIED from [configuration] 2003-12-29\n        return (interpolateHelper(base, null));\n    }\n\n    /**\n     * Recursive handler for multiple levels of interpolation.\n     *\n     * When called the first time, priorVariables should be null.\n     *\n     * @param base string with the ${key} variables\n     * @param priorVariables serves two purposes: to allow checking for\n     * loops, and creating a meaningful exception message should a loop\n     * occur.  It's 0'th element will be set to the value of base from\n     * the first call.  All subsequent interpolated variables are added\n     * afterward.\n     *\n     * @return the string with the interpolation taken care of\n     */\n    protected String interpolateHelper(String base, List priorVariables) {\n        // COPIED from [configuration] 2003-12-29\n        if (base == null) {\n            return null;\n        }\n\n        // on the first call initialize priorVariables\n        // and add base as the first element\n        if (priorVariables == null) {\n            priorVariables = new ArrayList();\n            priorVariables.add(base);\n        }\n\n        int begin = -1;\n        int end = -1;\n        int prec = 0 - END_TOKEN.length();\n        String variable = null;\n        StringBuffer result = new StringBuffer();\n\n        // FIXME: we should probably allow the escaping of the start token\n        while (((begin = base.indexOf(START_TOKEN, prec + END_TOKEN.length())) > -1)\n            && ((end = base.indexOf(END_TOKEN, begin)) > -1)) {\n            result.append(base.substring(prec + END_TOKEN.length(), begin));\n            variable = base.substring(begin + START_TOKEN.length(), end);\n\n            // if we've got a loop, create a useful exception message and throw\n            if (priorVariables.contains(variable)) {\n                String initialBase = priorVariables.remove(0).toString();\n                priorVariables.add(variable);\n                StringBuffer priorVariableSb = new StringBuffer();\n\n                // create a nice trace of interpolated variables like so:\n                // var1->var2->var3\n                for (Iterator it = priorVariables.iterator(); it.hasNext();) {\n                    priorVariableSb.append(it.next());\n                    if (it.hasNext()) {\n                        priorVariableSb.append(\"->\");\n                    }\n                }\n\n                throw new IllegalStateException(\n                    \"infinite loop in property interpolation of \" + initialBase + \": \" + priorVariableSb.toString());\n            }\n            // otherwise, add this variable to the interpolation list.\n            else {\n                priorVariables.add(variable);\n            }\n\n            //QUESTION: getProperty or getPropertyDirect\n            Object value = getProperty(variable);\n            if (value != null) {\n                result.append(interpolateHelper(value.toString(), priorVariables));\n\n                // pop the interpolated variable off the stack\n                // this maintains priorVariables correctness for\n                // properties with multiple interpolations, e.g.\n                // prop.name=${some.other.prop1}/blahblah/${some.other.prop2}\n                priorVariables.remove(priorVariables.size() - 1);\n            } else if (defaults != null && defaults.getString(variable, null) != null) {\n                result.append(defaults.getString(variable));\n            } else {\n                //variable not defined - so put it back in the value\n                result.append(START_TOKEN).append(variable).append(END_TOKEN);\n            }\n            prec = end;\n        }\n        result.append(base.substring(prec + END_TOKEN.length(), base.length()));\n\n        return result.toString();\n    }\n    \n    /**\n     * Inserts a backslash before every comma and backslash. \n     */\n    private static String escape(String s) {\n        StringBuffer buf = new StringBuffer(s);\n        for (int i = 0; i < buf.length(); i++) {\n            char c = buf.charAt(i);\n            if (c == ',' || c == '\\\\') {\n                buf.insert(i, '\\\\');\n                i++;\n            }\n        }\n        return buf.toString();\n    }\n    \n    /**\n     * Removes a backslash from every pair of backslashes. \n     */\n    private static String unescape(String s) {\n        StringBuffer buf = new StringBuffer(s);\n        for (int i = 0; i < buf.length() - 1; i++) {\n            char c1 = buf.charAt(i);\n            char c2 = buf.charAt(i + 1);\n            if (c1 == '\\\\' && c2 == '\\\\') {\n                buf.deleteCharAt(i);\n            }\n        }\n        return buf.toString();\n    }\n\n    /**\n     * Counts the number of successive times 'ch' appears in the\n     * 'line' before the position indicated by the 'index'.\n     */\n    private static int countPreceding(String line, int index, char ch) {\n        int i;\n        for (i = index - 1; i >= 0; i--) {\n            if (line.charAt(i) != ch) {\n                break;\n            }\n        }\n        return index - 1 - i;\n    }\n\n    /**\n     * Checks if the line ends with odd number of backslashes \n     */\n    private static boolean endsWithSlash(String line) {\n        if (!line.endsWith(\"\\\\\")) {\n            return false;\n        }\n        return (countPreceding(line, line.length() - 1, '\\\\') % 2 == 0);\n    }\n\n    /**\n     * This class is used to read properties lines.  These lines do\n     * not terminate with new-line chars but rather when there is no\n     * backslash sign a the end of the line.  This is used to\n     * concatenate multiple lines for readability.\n     */\n    static class PropertiesReader extends LineNumberReader {\n        /**\n         * Constructor.\n         *\n         * @param reader A Reader.\n         */\n        public PropertiesReader(Reader reader) {\n            super(reader);\n        }\n\n        /**\n         * Read a property.\n         *\n         * @return a String property\n         * @throws IOException if there is difficulty reading the source.\n         */\n        public String readProperty() throws IOException {\n            StringBuffer buffer = new StringBuffer();\n            String line = readLine();\n            while (line != null) {\n                line = line.trim();\n                if ((line.length() != 0) && (line.charAt(0) != '#')) {\n                    if (endsWithSlash(line)) {\n                        line = line.substring(0, line.length() - 1);\n                        buffer.append(line);\n                    } else {\n                        buffer.append(line);\n                        return buffer.toString();  // normal method end\n                    }\n                }\n                line = readLine();\n            }\n            return null;  // EOF reached\n        }\n    }\n\n    /**\n     * This class divides into tokens a property value.  Token\n     * separator is \",\" but commas into the property value are escaped\n     * using the backslash in front.\n     */\n    static class PropertiesTokenizer extends StringTokenizer {\n        /**\n         * The property delimiter used while parsing (a comma).\n         */\n        static final String DELIMITER = \",\";\n\n        /**\n         * Constructor.\n         *\n         * @param string A String.\n         */\n        public PropertiesTokenizer(String string) {\n            super(string, DELIMITER);\n        }\n\n        /**\n         * Check whether the object has more tokens.\n         *\n         * @return True if the object has more tokens.\n         */\n        public boolean hasMoreTokens() {\n            return super.hasMoreTokens();\n        }\n\n        /**\n         * Get next token.\n         *\n         * @return A String.\n         */\n        public String nextToken() {\n            StringBuffer buffer = new StringBuffer();\n\n            while (hasMoreTokens()) {\n                String token = super.nextToken();\n                if (endsWithSlash(token)) {\n                    buffer.append(token.substring(0, token.length() - 1));\n                    buffer.append(DELIMITER);\n                } else {\n                    buffer.append(token);\n                    break;\n                }\n            }\n\n            return buffer.toString().trim();\n        }\n    }\n\n    /**\n     * Creates an empty extended properties object.\n     */\n    public ExtendedProperties() {\n        super();\n    }\n\n    /**\n     * Creates and loads the extended properties from the specified file.\n     *\n     * @param file  the filename to load\n     * @throws IOException if a file error occurs\n     */\n    public ExtendedProperties(String file) throws IOException {\n        this(file, null);\n    }\n\n    /**\n     * Creates and loads the extended properties from the specified file.\n     *\n     * @param file  the filename to load\n     * @param defaultFile  a second filename to load default values from\n     * @throws IOException if a file error occurs\n     */\n    public ExtendedProperties(String file, String defaultFile) throws IOException {\n        this.file = file;\n\n        basePath = new File(file).getAbsolutePath();\n        basePath = basePath.substring(0, basePath.lastIndexOf(fileSeparator) + 1);\n\n        FileInputStream in = null;\n        try {\n            in = new FileInputStream(file);\n            this.load(in);\n        } finally {\n            try {\n                if (in != null) {\n                    in.close();\n                }\n            } catch (IOException ex) {}\n        }\n\n        if (defaultFile != null) {\n            defaults = new ExtendedProperties(defaultFile);\n        }\n    }\n\n    /**\n     * Indicate to client code whether property\n     * resources have been initialized or not.\n     */\n    public boolean isInitialized() {\n        return isInitialized;\n    }\n\n    /**\n     * Gets the property value for including other properties files.\n     * By default it is \"include\".\n     * <p>\n     * NOTE: Prior to v3.3 this method accessed a static variable.\n     * It now accesses an instance variable. For compatability, if the\n     * instance variable has not been set then the previous static\n     * variable is then accessed. However, the protected static variable\n     * can now only be set by subclasses.\n     * In v4.0, the static variable will be removed.\n     *\n     * @return the property name which includes another property\n     */\n    public String getInclude() {\n        if (includePropertyName == null) {\n            return include;  // backwards compatability\n        }\n        if (\"\".equals(includePropertyName)) {\n            return null;  // hack to allow backwards compatability\n        }\n        return includePropertyName;\n    }\n\n    /**\n     * Sets the property value for including other properties files.\n     * By default it is \"include\".\n     * <p>\n     * NOTE: Prior to v3.3 this method set a static variable and affected all\n     * users of the class. It now sets an instance variable.\n     * An empty string is also now converted to null internally.\n     * In v4.0, the static variable will be removed.\n     *\n     * @param inc  the property name which includes another property, empty converted to null\n     */\n    public void setInclude(String inc) {\n        if (inc == null) {\n            inc = \"\";  // hack to allow backwards compatability\n        }\n        includePropertyName = inc;\n    }\n\n    /**\n     * Load the properties from the given input stream.\n     *\n     * @param input  the InputStream to load from\n     * @throws IOException if an IO error occurs\n     */\n    public void load(InputStream input) throws IOException {\n        load(input, null);\n    }\n\n    /**\n     * Load the properties from the given input stream\n     * and using the specified encoding.\n     *\n     * @param input  the InputStream to load from\n     * @param enc  the encoding to use\n     * @throws IOException if an IO error occurs\n     */\n    public synchronized void load(InputStream input, String enc) throws IOException {\n        PropertiesReader reader = null;\n        if (enc != null) {\n            try {\n                reader = new PropertiesReader(new InputStreamReader(input, enc));\n                \n            } catch (UnsupportedEncodingException ex) {\n                // Another try coming up....\n            }\n        }\n        \n        if (reader == null) {\n            try {\n                reader = new PropertiesReader(new InputStreamReader(input, \"8859_1\"));\n                \n            } catch (UnsupportedEncodingException ex) {\n                // ISO8859-1 support is required on java platforms but....\n                // If it's not supported, use the system default encoding\n                reader = new PropertiesReader(new InputStreamReader(input));\n            }\n        }\n\n        try {\n            String includeProperty = getInclude();\n            while (true) {\n                String line = reader.readProperty();\n                if (line == null) {\n                    return;  // EOF\n                }\n                int equalSign = line.indexOf('=');\n\n                if (equalSign > 0) {\n                    String key = line.substring(0, equalSign).trim();\n                    String value = line.substring(equalSign + 1).trim();\n\n                    // Configure produces lines like this ... just ignore them\n                    if (\"\".equals(value)) {\n                        continue;\n                    }\n\n                    if (includeProperty != null && key.equalsIgnoreCase(includeProperty)) {\n                        // Recursively load properties files.\n                        File file = null;\n\n                        if (value.startsWith(fileSeparator)) {\n                            // We have an absolute path so we'll use this\n                            file = new File(value);\n                            \n                        } else {\n                            // We have a relative path, and we have two \n                            // possible forms here. If we have the \"./\" form\n                            // then just strip that off first before continuing.\n                            if (value.startsWith(\".\" + fileSeparator)) {\n                                value = value.substring(2);\n                            }\n\n                            file = new File(basePath + value);\n                        }\n\n                        if (file != null && file.exists() && file.canRead()) {\n                            load(new FileInputStream(file));\n                        }\n                    } else {\n                        addProperty(key, value);\n                    }\n                }\n            }\n        } finally {\n            // Loading is initializing\n            isInitialized = true;\n        }\n    }\n\n    /**\n     * Gets a property from the configuration.\n     *\n     * @param key property to retrieve\n     * @return value as object. Will return user value if exists,\n     *        if not then default value if exists, otherwise null\n     */\n    public Object getProperty(String key) {\n        // first, try to get from the 'user value' store\n        Object obj = this.get(key);\n\n        if (obj == null) {\n            // if there isn't a value there, get it from the\n            // defaults if we have them\n            if (defaults != null) {\n                obj = defaults.get(key);\n            }\n        }\n\n        return obj;\n    }\n    \n    /**\n     * Add a property to the configuration. If it already\n     * exists then the value stated here will be added\n     * to the configuration entry. For example, if\n     *\n     * <code>resource.loader = file</code>\n     *\n     * is already present in the configuration and you\n     *\n     * <code>addProperty(\"resource.loader\", \"classpath\")</code>\n     *\n     * Then you will end up with a Vector like the\n     * following:\n     *\n     * <code>[\"file\", \"classpath\"]</code>\n     *\n     * @param key  the key to add\n     * @param value  the value to add\n     */\n    public void addProperty(String key, Object value) {\n        if (value instanceof String) {\n            String str = (String) value;\n            if (str.indexOf(PropertiesTokenizer.DELIMITER) > 0) {\n                // token contains commas, so must be split apart then added\n                PropertiesTokenizer tokenizer = new PropertiesTokenizer(str);\n                while (tokenizer.hasMoreTokens()) {\n                    String token = tokenizer.nextToken();\n                    addPropertyInternal(key, unescape(token));\n                }\n            } else {\n                // token contains no commas, so can be simply added\n                addPropertyInternal(key, unescape(str));\n            }\n        } else {\n            addPropertyInternal(key, value);\n        }\n\n        // Adding a property connotes initialization\n        isInitialized = true;\n    }\n\n    /**\n     * Adds a key/value pair to the map.  This routine does\n     * no magic morphing.  It ensures the keylist is maintained\n     *\n     * @param key  the key to store at\n     * @param value  the decoded object to store\n     */\n    private void addPropertyDirect(String key, Object value) {\n        // safety check\n        if (!containsKey(key)) {\n            keysAsListed.add(key);\n        }\n        put(key, value);\n    }\n\n    /**\n     * Adds a decoded property to the map w/o checking for commas - used\n     * internally when a property has been broken up into\n     * strings that could contain escaped commas to prevent\n     * the inadvertent vectorization.\n     * <p>\n     * Thanks to Leon Messerschmidt for this one.\n     *\n     * @param key  the key to store at\n     * @param value  the decoded object to store\n     */\n    private void addPropertyInternal(String key, Object value) {\n        Object current = this.get(key);\n\n        if (current instanceof String) {\n            // one object already in map - convert it to a vector\n            List values = new Vector(2);\n            values.add(current);\n            values.add(value);\n            put(key, values);\n            \n        } else if (current instanceof List) {\n            // already a list - just add the new token\n            ((List) current).add(value);\n            \n        } else {\n            // brand new key - store in keysAsListed to retain order\n            if (!containsKey(key)) {\n                keysAsListed.add(key);\n            }\n            put(key, value);\n        }\n    }\n\n    /**\n     * Set a property, this will replace any previously\n     * set values. Set values is implicitly a call\n     * to clearProperty(key), addProperty(key,value).\n     *\n     * @param key  the key to set\n     * @param value  the value to set\n     */\n    public void setProperty(String key, Object value) {\n        clearProperty(key);\n        addProperty(key, value);\n    }\n    \n    /**\n     * Save the properties to the given output stream.\n     * <p>\n     * The stream is not closed, but it is flushed.\n     *\n     * @param output  an OutputStream, may be null\n     * @param header  a textual comment to act as a file header\n     * @throws IOException if an IO error occurs\n     */\n    public synchronized void save(OutputStream output, String header) throws IOException {\n        if (output == null) {\n            return;\n        }\n        PrintWriter theWrtr = new PrintWriter(output);\n        if (header != null) {\n            theWrtr.println(header);\n        }\n        \n        Enumeration theKeys = keys();\n        while (theKeys.hasMoreElements()) {\n            String key = (String) theKeys.nextElement();\n            Object value = get(key);\n            if (value != null) {\n                if (value instanceof String) {\n                    StringBuffer currentOutput = new StringBuffer();\n                    currentOutput.append(key);\n                    currentOutput.append(\"=\");\n                    currentOutput.append(escape((String) value));\n                    theWrtr.println(currentOutput.toString());\n                    \n                } else if (value instanceof List) {\n                    List values = (List) value;\n                    for (Iterator it = values.iterator(); it.hasNext(); ) {\n                        String currentElement = (String) it.next();\n                        StringBuffer currentOutput = new StringBuffer();\n                        currentOutput.append(key);\n                        currentOutput.append(\"=\");\n                        currentOutput.append(escape(currentElement));\n                        theWrtr.println(currentOutput.toString());\n                    }\n                }\n            }\n            theWrtr.println();\n            theWrtr.flush();\n        }\n    }\n\n    /**\n     * Combines an existing Hashtable with this Hashtable.\n     * <p>\n     * Warning: It will overwrite previous entries without warning.\n     *\n     * @param props  the properties to combine\n     */\n    public void combine(ExtendedProperties props) {\n        for (Iterator it = props.getKeys(); it.hasNext();) {\n            String key = (String) it.next();\n            setProperty(key, props.get(key));\n        }\n    }\n    \n    /**\n     * Clear a property in the configuration.\n     *\n     * @param key  the property key to remove along with corresponding value\n     */\n    public void clearProperty(String key) {\n        if (containsKey(key)) {\n            // we also need to rebuild the keysAsListed or else\n            // things get *very* confusing\n            for (int i = 0; i < keysAsListed.size(); i++) {\n                if (( keysAsListed.get(i)).equals(key)) {\n                    keysAsListed.remove(i);\n                    break;\n                }\n            }\n            remove(key);\n        }\n    }\n\n    /**\n     * Get the list of the keys contained in the configuration\n     * repository.\n     *\n     * @return an Iterator over the keys\n     */\n    public Iterator getKeys() {\n        return keysAsListed.iterator();\n    }\n\n    /**\n     * Get the list of the keys contained in the configuration\n     * repository that match the specified prefix.\n     *\n     * @param prefix  the prefix to match\n     * @return an Iterator of keys that match the prefix\n     */\n    public Iterator getKeys(String prefix) {\n        Iterator keys = getKeys();\n        ArrayList matchingKeys = new ArrayList();\n\n        while (keys.hasNext()) {\n            Object key = keys.next();\n\n            if (key instanceof String && ((String) key).startsWith(prefix)) {\n                matchingKeys.add(key);\n            }\n        }\n        return matchingKeys.iterator();\n    }\n\n    /**\n     * Create an ExtendedProperties object that is a subset\n     * of this one. Take into account duplicate keys\n     * by using the setProperty() in ExtendedProperties.\n     *\n     * @param prefix  the prefix to get a subset for\n     * @return a new independent ExtendedProperties\n     */\n    public ExtendedProperties subset(String prefix) {\n        ExtendedProperties c = new ExtendedProperties();\n        Iterator keys = getKeys();\n        boolean validSubset = false;\n\n        while (keys.hasNext()) {\n            Object key = keys.next();\n\n            if (key instanceof String && ((String) key).startsWith(prefix)) {\n                if (!validSubset) {\n                    validSubset = true;\n                }\n\n                /*\n                 * Check to make sure that c.subset(prefix) doesn't\n                 * blow up when there is only a single property\n                 * with the key prefix. This is not a useful\n                 * subset but it is a valid subset.\n                 */\n                String newKey = null;\n                if (((String) key).length() == prefix.length()) {\n                    newKey = prefix;\n                } else {\n                    newKey = ((String) key).substring(prefix.length() + 1);\n                }\n\n                /*\n                 *  use addPropertyDirect() - this will plug the data as \n                 *  is into the Map, but will also do the right thing\n                 *  re key accounting\n                 */\n                c.addPropertyDirect(newKey, get(key));\n            }\n        }\n\n        if (validSubset) {\n            return c;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Display the configuration for debugging purposes to System.out.\n     */\n    public void display() {\n        Iterator i = getKeys();\n\n        while (i.hasNext()) {\n            String key = (String) i.next();\n            Object value = get(key);\n            System.out.println(key + \" => \" + value);\n        }\n    }\n\n    /**\n     * Get a string associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated string.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a String.\n     */\n    public String getString(String key) {\n        return getString(key, null);\n    }\n\n    /**\n     * Get a string associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated string if key is found,\n     * default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a String.\n     */\n    public String getString(String key, String defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof String) {\n            return interpolate((String) value);\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return interpolate(defaults.getString(key, defaultValue));\n            } else {\n                return interpolate(defaultValue);\n            }\n        } else if (value instanceof List) {\n            return interpolate((String) ((List) value).get(0));\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a String object\");\n        }\n    }\n\n    /**\n     * Get a list of properties associated with the given\n     * configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated properties if key is found.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a String/List.\n     * @throws IllegalArgumentException if one of the tokens is\n     * malformed (does not contain an equals sign).\n     */\n    public Properties getProperties(String key) {\n        return getProperties(key, new Properties());\n    }\n\n    /**\n     * Get a list of properties associated with the given\n     * configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated properties if key is found.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a String/List.\n     * @throws IllegalArgumentException if one of the tokens is\n     * malformed (does not contain an equals sign).\n     */\n    public Properties getProperties(String key, Properties defaults) {\n        /*\n         * Grab an array of the tokens for this key.\n         */\n        String[] tokens = getStringArray(key);\n\n        // Each token is of the form 'key=value'.\n        Properties props = new Properties(defaults);\n        for (int i = 0; i < tokens.length; i++) {\n            String token = tokens[i];\n            int equalSign = token.indexOf('=');\n            if (equalSign > 0) {\n                String pkey = token.substring(0, equalSign).trim();\n                String pvalue = token.substring(equalSign + 1).trim();\n                props.put(pkey, pvalue);\n            } else {\n                throw new IllegalArgumentException('\\'' + token + \"' does not contain \" + \"an equals sign\");\n            }\n        }\n        return props;\n    }\n\n    /**\n     * Get an array of strings associated with the given configuration\n     * key.\n     *\n     * @param key The configuration key.\n     * @return The associated string array if key is found.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a String/List.\n     */\n    public String[] getStringArray(String key) {\n        Object value = get(key);\n\n        List values;\n        if (value instanceof String) {\n            values = new Vector(1);\n            values.add(value);\n            \n        } else if (value instanceof List) {\n            values = (List) value;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getStringArray(key);\n            } else {\n                return new String[0];\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a String/List object\");\n        }\n\n        String[] tokens = new String[values.size()];\n        for (int i = 0; i < tokens.length; i++) {\n            tokens[i] = (String) values.get(i);\n        }\n\n        return tokens;\n    }\n\n    /**\n     * Get a Vector of strings associated with the given configuration\n     * key.\n     *\n     * @param key The configuration key.\n     * @return The associated Vector.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Vector.\n     */\n    public Vector getVector(String key) {\n        return getVector(key, null);\n    }\n\n    /**\n     * Get a Vector of strings associated with the given configuration key.\n     * <p>\n     * The list is a copy of the internal data of this object, and as\n     * such you may alter it freely.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated Vector.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Vector.\n     */\n    public Vector getVector(String key, Vector defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof List) {\n            return new Vector((List) value);\n            \n        } else if (value instanceof String) {\n            Vector values = new Vector(1);\n            values.add(value);\n            put(key, values);\n            return values;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getVector(key, defaultValue);\n            } else {\n                return ((defaultValue == null) ? new Vector() : defaultValue);\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Vector object\");\n        }\n    }\n\n    /**\n     * Get a List of strings associated with the given configuration key.\n     * <p>\n     * The list is a copy of the internal data of this object, and as\n     * such you may alter it freely.\n     *\n     * @param key The configuration key.\n     * @return The associated List object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a List.\n     * @since Commons Collections 3.2\n     */\n    public List getList(String key) {\n        return getList(key, null);\n    }\n\n    /**\n     * Get a List of strings associated with the given configuration key.\n     * <p>\n     * The list is a copy of the internal data of this object, and as\n     * such you may alter it freely.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated List.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a List.\n     * @since Commons Collections 3.2\n     */\n    public List getList(String key, List defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof List) {\n            return new ArrayList((List) value);\n            \n        } else if (value instanceof String) {\n            List values = new ArrayList(1);\n            values.add(value);\n            put(key, values);\n            return values;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getList(key, defaultValue);\n            } else {\n                return ((defaultValue == null) ? new ArrayList() : defaultValue);\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a List object\");\n        }\n    }\n\n    /**\n     * Get a boolean associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated boolean.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Boolean.\n     */\n    public boolean getBoolean(String key) {\n        Boolean b = getBoolean(key, null);\n        if (b != null) {\n            return b.booleanValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a boolean associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated boolean.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Boolean.\n     */\n    public boolean getBoolean(String key, boolean defaultValue) {\n        return getBoolean(key, new Boolean(defaultValue)).booleanValue();\n    }\n\n    /**\n     * Get a boolean associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated boolean if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Boolean.\n     */\n    public Boolean getBoolean(String key, Boolean defaultValue) {\n\n        Object value = get(key);\n\n        if (value instanceof Boolean) {\n            return (Boolean) value;\n            \n        } else if (value instanceof String) {\n            String s = testBoolean((String) value);\n            Boolean b = new Boolean(s);\n            put(key, b);\n            return b;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getBoolean(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Boolean object\");\n        }\n    }\n\n    /**\n     * Test whether the string represent by value maps to a boolean\n     * value or not. We will allow <code>true</code>, <code>on</code>,\n     * and <code>yes</code> for a <code>true</code> boolean value, and\n     * <code>false</code>, <code>off</code>, and <code>no</code> for\n     * <code>false</code> boolean values.  Case of value to test for\n     * boolean status is ignored.\n     *\n     * @param value  the value to test for boolean state\n     * @return <code>true</code> or <code>false</code> if the supplied\n     * text maps to a boolean value, or <code>null</code> otherwise.\n     */\n    public String testBoolean(String value) {\n        String s = value.toLowerCase();\n\n        if (s.equals(\"true\") || s.equals(\"on\") || s.equals(\"yes\")) {\n            return \"true\";\n        } else if (s.equals(\"false\") || s.equals(\"off\") || s.equals(\"no\")) {\n            return \"false\";\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Get a byte associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated byte.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Byte.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public byte getByte(String key) {\n        Byte b = getByte(key, null);\n        if (b != null) {\n            return b.byteValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \" doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a byte associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated byte.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Byte.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public byte getByte(String key, byte defaultValue) {\n        return getByte(key, new Byte(defaultValue)).byteValue();\n    }\n\n    /**\n     * Get a byte associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated byte if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Byte.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public Byte getByte(String key, Byte defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Byte) {\n            return (Byte) value;\n            \n        } else if (value instanceof String) {\n            Byte b = new Byte((String) value);\n            put(key, b);\n            return b;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getByte(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Byte object\");\n        }\n    }\n\n    /**\n     * Get a short associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated short.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Short.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public short getShort(String key) {\n        Short s = getShort(key, null);\n        if (s != null) {\n            return s.shortValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a short associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated short.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Short.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public short getShort(String key, short defaultValue) {\n        return getShort(key, new Short(defaultValue)).shortValue();\n    }\n\n    /**\n     * Get a short associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated short if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Short.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public Short getShort(String key, Short defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Short) {\n            return (Short) value;\n            \n        } else if (value instanceof String) {\n            Short s = new Short((String) value);\n            put(key, s);\n            return s;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getShort(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Short object\");\n        }\n    }\n\n    /**\n     * The purpose of this method is to get the configuration resource\n     * with the given name as an integer.\n     *\n     * @param name The resource name.\n     * @return The value of the resource as an integer.\n     */\n    public int getInt(String name) {\n        return getInteger(name);\n    }\n\n    /**\n     * The purpose of this method is to get the configuration resource\n     * with the given name as an integer, or a default value.\n     *\n     * @param name The resource name\n     * @param def The default value of the resource.\n     * @return The value of the resource as an integer.\n     */\n    public int getInt(String name, int def) {\n        return getInteger(name, def);\n    }\n\n    /**\n     * Get a int associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated int.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Integer.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public int getInteger(String key) {\n        Integer i = getInteger(key, null);\n        if (i != null) {\n            return i.intValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a int associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated int.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Integer.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public int getInteger(String key, int defaultValue) {\n        Integer i = getInteger(key, null);\n\n        if (i == null) {\n            return defaultValue;\n        }\n        return i.intValue();\n    }\n\n    /**\n     * Get a int associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated int if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Integer.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public Integer getInteger(String key, Integer defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Integer) {\n            return (Integer) value;\n            \n        } else if (value instanceof String) {\n            Integer i = new Integer((String) value);\n            put(key, i);\n            return i;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getInteger(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Integer object\");\n        }\n    }\n\n    /**\n     * Get a long associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated long.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Long.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public long getLong(String key) {\n        Long l = getLong(key, null);\n        if (l != null) {\n            return l.longValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a long associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated long.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Long.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public long getLong(String key, long defaultValue) {\n        return getLong(key, new Long(defaultValue)).longValue();\n    }\n\n    /**\n     * Get a long associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated long if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Long.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public Long getLong(String key, Long defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Long) {\n            return (Long) value;\n            \n        } else if (value instanceof String) {\n            Long l = new Long((String) value);\n            put(key, l);\n            return l;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getLong(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Long object\");\n        }\n    }\n\n    /**\n     * Get a float associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated float.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Float.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public float getFloat(String key) {\n        Float f = getFloat(key, null);\n        if (f != null) {\n            return f.floatValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a float associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated float.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Float.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public float getFloat(String key, float defaultValue) {\n        return getFloat(key, new Float(defaultValue)).floatValue();\n    }\n\n    /**\n     * Get a float associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated float if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Float.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public Float getFloat(String key, Float defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Float) {\n            return (Float) value;\n            \n        } else if (value instanceof String) {\n            Float f = new Float((String) value);\n            put(key, f);\n            return f;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getFloat(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Float object\");\n        }\n    }\n\n    /**\n     * Get a double associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated double.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Double.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public double getDouble(String key) {\n        Double d = getDouble(key, null);\n        if (d != null) {\n            return d.doubleValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a double associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated double.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Double.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public double getDouble(String key, double defaultValue) {\n        return getDouble(key, new Double(defaultValue)).doubleValue();\n    }\n\n    /**\n     * Get a double associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated double if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Double.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public Double getDouble(String key, Double defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Double) {\n            return (Double) value;\n            \n        } else if (value instanceof String) {\n            Double d = new Double((String) value);\n            put(key, d);\n            return d;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getDouble(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Double object\");\n        }\n    }\n\n    /**\n     * Convert a standard properties class into a configuration class.\n     * <p>\n     * NOTE: From Commons Collections 3.2 this method will pick up\n     * any default parent Properties of the specified input object.\n     *\n     * @param props  the properties object to convert\n     * @return new ExtendedProperties created from props\n     */\n    public static ExtendedProperties convertProperties(Properties props) {\n        ExtendedProperties c = new ExtendedProperties();\n\n        for (Enumeration e = props.propertyNames(); e.hasMoreElements();) {\n            String s = (String) e.nextElement();\n            c.setProperty(s, props.getProperty(s));\n        }\n\n        return c;\n    }\n\n}\n"}]}
{"project": "Collections", "bug_id": 3, "classes_modified": [{"class_name": "org.apache.commons.collections.CollectionUtils", "buggy_version": "/*\n *  Copyright 2001-2006 The Apache Software Foundation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.apache.commons.collections;\n\nimport java.lang.reflect.Array;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.apache.commons.collections.collection.PredicatedCollection;\nimport org.apache.commons.collections.collection.SynchronizedCollection;\nimport org.apache.commons.collections.collection.TransformedCollection;\nimport org.apache.commons.collections.collection.TypedCollection;\nimport org.apache.commons.collections.collection.UnmodifiableBoundedCollection;\nimport org.apache.commons.collections.collection.UnmodifiableCollection;\n\n/**\n * Provides utility methods and decorators for {@link Collection} instances.\n *\n * @since Commons Collections 1.0\n * @version $Revision$ $Date$\n * \n * @author Rodney Waldhoff\n * @author Paul Jack\n * @author Stephen Colebourne\n * @author Steve Downey\n * @author Herve Quiroz\n * @author Peter KoBek\n * @author Matthew Hawthorne\n * @author Janek Bogucki\n * @author Phil Steitz\n * @author Steven Melzer\n * @author Jon Schewe\n * @author Neil O'Toole\n * @author Stephen Smith\n */\npublic class CollectionUtils {\n\n    /** Constant to avoid repeated object creation */\n    private static Integer INTEGER_ONE = new Integer(1);\n\n    /**\n     * An empty unmodifiable collection.\n     * The JDK provides empty Set and List implementations which could be used for\n     * this purpose. However they could be cast to Set or List which might be\n     * undesirable. This implementation only implements Collection.\n     */\n    public static final Collection EMPTY_COLLECTION = UnmodifiableCollection.decorate(new ArrayList());\n\n    /**\n     * <code>CollectionUtils</code> should not normally be instantiated.\n     */\n    public CollectionUtils() {\n    }\n\n    /**\n     * Returns a {@link Collection} containing the union\n     * of the given {@link Collection}s.\n     * <p>\n     * The cardinality of each element in the returned {@link Collection}\n     * will be equal to the maximum of the cardinality of that element\n     * in the two given {@link Collection}s.\n     *\n     * @param a  the first collection, must not be null\n     * @param b  the second collection, must not be null\n     * @return  the union of the two collections\n     * @see Collection#addAll\n     */\n    public static Collection union(final Collection a, final Collection b) {\n        ArrayList list = new ArrayList();\n        Map mapa = getCardinalityMap(a);\n        Map mapb = getCardinalityMap(b);\n        Set elts = new HashSet(a);\n        elts.addAll(b);\n        Iterator it = elts.iterator();\n        while(it.hasNext()) {\n            Object obj = it.next();\n            for(int i=0,m=Math.max(getFreq(obj,mapa),getFreq(obj,mapb));i<m;i++) {\n                list.add(obj);\n            }\n        }\n        return list;\n    }\n\n    /**\n     * Returns a {@link Collection} containing the intersection\n     * of the given {@link Collection}s.\n     * <p>\n     * The cardinality of each element in the returned {@link Collection}\n     * will be equal to the minimum of the cardinality of that element\n     * in the two given {@link Collection}s.\n     *\n     * @param a  the first collection, must not be null\n     * @param b  the second collection, must not be null\n     * @return the intersection of the two collections\n     * @see Collection#retainAll\n     * @see #containsAny\n     */\n    public static Collection intersection(final Collection a, final Collection b) {\n        ArrayList list = new ArrayList();\n        Map mapa = getCardinalityMap(a);\n        Map mapb = getCardinalityMap(b);\n        Set elts = new HashSet(a);\n        elts.addAll(b);\n        Iterator it = elts.iterator();\n        while(it.hasNext()) {\n            Object obj = it.next();\n            for(int i=0,m=Math.min(getFreq(obj,mapa),getFreq(obj,mapb));i<m;i++) {\n                list.add(obj);\n            }\n        }\n        return list;\n    }\n\n    /**\n     * Returns a {@link Collection} containing the exclusive disjunction\n     * (symmetric difference) of the given {@link Collection}s.\n     * <p>\n     * The cardinality of each element <i>e</i> in the returned {@link Collection}\n     * will be equal to\n     * <tt>max(cardinality(<i>e</i>,<i>a</i>),cardinality(<i>e</i>,<i>b</i>)) - min(cardinality(<i>e</i>,<i>a</i>),cardinality(<i>e</i>,<i>b</i>))</tt>.\n     * <p>\n     * This is equivalent to\n     * <tt>{@link #subtract subtract}({@link #union union(a,b)},{@link #intersection intersection(a,b)})</tt>\n     * or\n     * <tt>{@link #union union}({@link #subtract subtract(a,b)},{@link #subtract subtract(b,a)})</tt>.\n     *\n     * @param a  the first collection, must not be null\n     * @param b  the second collection, must not be null\n     * @return the symmetric difference of the two collections\n     */\n    public static Collection disjunction(final Collection a, final Collection b) {\n        ArrayList list = new ArrayList();\n        Map mapa = getCardinalityMap(a);\n        Map mapb = getCardinalityMap(b);\n        Set elts = new HashSet(a);\n        elts.addAll(b);\n        Iterator it = elts.iterator();\n        while(it.hasNext()) {\n            Object obj = it.next();\n            for(int i=0,m=((Math.max(getFreq(obj,mapa),getFreq(obj,mapb)))-(Math.min(getFreq(obj,mapa),getFreq(obj,mapb))));i<m;i++) {\n                list.add(obj);\n            }\n        }\n        return list;\n    }\n\n    /**\n     * Returns a new {@link Collection} containing <tt><i>a</i> - <i>b</i></tt>.\n     * The cardinality of each element <i>e</i> in the returned {@link Collection}\n     * will be the cardinality of <i>e</i> in <i>a</i> minus the cardinality\n     * of <i>e</i> in <i>b</i>, or zero, whichever is greater.\n     *\n     * @param a  the collection to subtract from, must not be null\n     * @param b  the collection to subtract, must not be null\n     * @return a new collection with the results\n     * @see Collection#removeAll\n     */\n    public static Collection subtract(final Collection a, final Collection b) {\n        ArrayList list = new ArrayList( a );\n        for (Iterator it = b.iterator(); it.hasNext();) {\n            list.remove(it.next());\n        }\n        return list;\n    }\n\n    /**\n     * Returns <code>true</code> iff at least one element is in both collections.\n     * <p>\n     * In other words, this method returns <code>true</code> iff the\n     * {@link #intersection} of <i>coll1</i> and <i>coll2</i> is not empty.\n     * \n     * @param coll1  the first collection, must not be null\n     * @param coll2  the first collection, must not be null\n     * @return <code>true</code> iff the intersection of the collections is non-empty\n     * @since 2.1\n     * @see #intersection\n     */\n    public static boolean containsAny(final Collection coll1, final Collection coll2) {\n        if (coll1.size() < coll2.size()) {\n            for (Iterator it = coll1.iterator(); it.hasNext();) {\n                if (coll2.contains(it.next())) {\n                    return true;\n                }\n            }\n        } else {\n            for (Iterator it = coll2.iterator(); it.hasNext();) {\n                if (coll1.contains(it.next())) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Returns a {@link Map} mapping each unique element in the given\n     * {@link Collection} to an {@link Integer} representing the number\n     * of occurrences of that element in the {@link Collection}.\n     * <p>\n     * Only those elements present in the collection will appear as\n     * keys in the map.\n     * \n     * @param coll  the collection to get the cardinality map for, must not be null\n     * @return the populated cardinality map\n     */\n    public static Map getCardinalityMap(final Collection coll) {\n        Map count = new HashMap();\n        for (Iterator it = coll.iterator(); it.hasNext();) {\n            Object obj = it.next();\n            Integer c = (Integer) (count.get(obj));\n            if (c == null) {\n                count.put(obj,INTEGER_ONE);\n            } else {\n                count.put(obj,new Integer(c.intValue() + 1));\n            }\n        }\n        return count;\n    }\n\n    /**\n     * Returns <tt>true</tt> iff <i>a</i> is a sub-collection of <i>b</i>,\n     * that is, iff the cardinality of <i>e</i> in <i>a</i> is less\n     * than or equal to the cardinality of <i>e</i> in <i>b</i>,\n     * for each element <i>e</i> in <i>a</i>.\n     *\n     * @param a  the first (sub?) collection, must not be null\n     * @param b  the second (super?) collection, must not be null\n     * @return <code>true</code> iff <i>a</i> is a sub-collection of <i>b</i>\n     * @see #isProperSubCollection\n     * @see Collection#containsAll\n     */\n    public static boolean isSubCollection(final Collection a, final Collection b) {\n        Map mapa = getCardinalityMap(a);\n        Map mapb = getCardinalityMap(b);\n        Iterator it = a.iterator();\n        while (it.hasNext()) {\n            Object obj = it.next();\n            if (getFreq(obj, mapa) > getFreq(obj, mapb)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns <tt>true</tt> iff <i>a</i> is a <i>proper</i> sub-collection of <i>b</i>,\n     * that is, iff the cardinality of <i>e</i> in <i>a</i> is less\n     * than or equal to the cardinality of <i>e</i> in <i>b</i>,\n     * for each element <i>e</i> in <i>a</i>, and there is at least one\n     * element <i>f</i> such that the cardinality of <i>f</i> in <i>b</i>\n     * is strictly greater than the cardinality of <i>f</i> in <i>a</i>.\n     * <p>\n     * The implementation assumes\n     * <ul>\n     *    <li><code>a.size()</code> and <code>b.size()</code> represent the \n     *    total cardinality of <i>a</i> and <i>b</i>, resp. </li>\n     *    <li><code>a.size() < Integer.MAXVALUE</code></li>\n     * </ul>\n     *\n     * @param a  the first (sub?) collection, must not be null\n     * @param b  the second (super?) collection, must not be null\n     * @return <code>true</code> iff <i>a</i> is a <i>proper</i> sub-collection of <i>b</i>\n     * @see #isSubCollection\n     * @see Collection#containsAll\n     */\n    public static boolean isProperSubCollection(final Collection a, final Collection b) {\n        return (a.size() < b.size()) && CollectionUtils.isSubCollection(a,b);\n    }\n\n    /**\n     * Returns <tt>true</tt> iff the given {@link Collection}s contain\n     * exactly the same elements with exactly the same cardinalities.\n     * <p>\n     * That is, iff the cardinality of <i>e</i> in <i>a</i> is\n     * equal to the cardinality of <i>e</i> in <i>b</i>,\n     * for each element <i>e</i> in <i>a</i> or <i>b</i>.\n     *\n     * @param a  the first collection, must not be null\n     * @param b  the second collection, must not be null\n     * @return <code>true</code> iff the collections contain the same elements with the same cardinalities.\n     */\n    public static boolean isEqualCollection(final Collection a, final Collection b) {\n        if(a.size() != b.size()) {\n            return false;\n        } else {\n            Map mapa = getCardinalityMap(a);\n            Map mapb = getCardinalityMap(b);\n            if(mapa.size() != mapb.size()) {\n                return false;\n            } else {\n                Iterator it = mapa.keySet().iterator();\n                while(it.hasNext()) {\n                    Object obj = it.next();\n                    if(getFreq(obj,mapa) != getFreq(obj,mapb)) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n        }\n    }\n\n    /**\n     * Returns the number of occurrences of <i>obj</i> in <i>coll</i>.\n     *\n     * @param obj  the object to find the cardinality of\n     * @param coll  the collection to search\n     * @return the the number of occurrences of obj in coll\n     */\n    public static int cardinality(Object obj, final Collection coll) {\n        if (coll instanceof Set) {\n            return (coll.contains(obj) ? 1 : 0);\n        }\n        if (coll instanceof Bag) {\n            return ((Bag) coll).getCount(obj);\n        }\n        int count = 0;\n        if (obj == null) {\n            for (Iterator it = coll.iterator();it.hasNext();) {\n                if (it.next() == null) {\n                    count++;\n                }\n            }\n        } else {\n            for (Iterator it = coll.iterator();it.hasNext();) {\n                if (obj.equals(it.next())) {\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n\n    /** \n     * Finds the first element in the given collection which matches the given predicate.\n     * <p>\n     * If the input collection or predicate is null, or no element of the collection \n     * matches the predicate, null is returned.\n     *\n     * @param collection  the collection to search, may be null\n     * @param predicate  the predicate to use, may be null\n     * @return the first element of the collection which matches the predicate or null if none could be found\n     */\n    public static Object find(Collection collection, Predicate predicate) {\n        if (collection != null && predicate != null) {\n            for (Iterator iter = collection.iterator(); iter.hasNext();) {\n                Object item = iter.next();\n                if (predicate.evaluate(item)) {\n                    return item;\n                }\n            }\n        }\n        return null;\n    }\n    \n    /** \n     * Executes the given closure on each element in the collection.\n     * <p>\n     * If the input collection or closure is null, there is no change made.\n     * \n     * @param collection  the collection to get the input from, may be null\n     * @param closure  the closure to perform, may be null\n     */\n    public static void forAllDo(Collection collection, Closure closure) {\n        if (collection != null && closure != null) {\n            for (Iterator it = collection.iterator(); it.hasNext();) {\n                closure.execute(it.next());\n            }\n        }\n    }\n\n    /** \n     * Filter the collection by applying a Predicate to each element. If the\n     * predicate returns false, remove the element.\n     * <p>\n     * If the input collection or predicate is null, there is no change made.\n     * \n     * @param collection  the collection to get the input from, may be null\n     * @param predicate  the predicate to use as a filter, may be null\n     */\n    public static void filter(Collection collection, Predicate predicate) {\n        if (collection != null && predicate != null) {\n            for (Iterator it = collection.iterator(); it.hasNext();) {\n                if (predicate.evaluate(it.next()) == false) {\n                    it.remove();\n                }\n            }\n        }\n    }\n\n    /** \n     * Transform the collection by applying a Transformer to each element.\n     * <p>\n     * If the input collection or transformer is null, there is no change made.\n     * <p>\n     * This routine is best for Lists, for which set() is used to do the \n     * transformations \"in place.\"  For other Collections, clear() and addAll()\n     * are used to replace elements.  \n     * <p>\n     * If the input collection controls its input, such as a Set, and the\n     * Transformer creates duplicates (or are otherwise invalid), the \n     * collection may reduce in size due to calling this method.\n     * \n     * @param collection  the collection to get the input from, may be null\n     * @param transformer  the transformer to perform, may be null\n     */\n    public static void transform(Collection collection, Transformer transformer) {\n        if (collection != null && transformer != null) {\n            if (collection instanceof List) {\n                List list = (List) collection;\n                for (ListIterator it = list.listIterator(); it.hasNext();) {\n                    it.set(transformer.transform(it.next()));\n                }\n            } else {\n                Collection resultCollection = collect(collection, transformer);\n                collection.clear();\n                collection.addAll(resultCollection);\n            }\n        }\n    }\n\n    /** \n     * Counts the number of elements in the input collection that match the predicate.\n     * <p>\n     * A <code>null</code> collection or predicate matches no elements.\n     * \n     * @param inputCollection  the collection to get the input from, may be null\n     * @param predicate  the predicate to use, may be null\n     * @return the number of matches for the predicate in the collection\n     */\n    public static int countMatches(Collection inputCollection, Predicate predicate) {\n        int count = 0;\n        if (inputCollection != null && predicate != null) {\n            for (Iterator it = inputCollection.iterator(); it.hasNext();) {\n                if (predicate.evaluate(it.next())) {\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n\n    /** \n     * Answers true if a predicate is true for at least one element of a collection.\n     * <p>\n     * A <code>null</code> collection or predicate returns false.\n     * \n     * @param collection the collection to get the input from, may be null\n     * @param predicate the predicate to use, may be null\n     * @return true if at least one element of the collection matches the predicate\n     */\n    public static boolean exists(Collection collection, Predicate predicate) {\n        if (collection != null && predicate != null) {\n            for (Iterator it = collection.iterator(); it.hasNext();) {\n                if (predicate.evaluate(it.next())) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /** \n     * Selects all elements from input collection which match the given predicate\n     * into an output collection.\n     * <p>\n     * A <code>null</code> predicate matches no elements.\n     * \n     * @param inputCollection  the collection to get the input from, may not be null\n     * @param predicate  the predicate to use, may be null\n     * @return the elements matching the predicate (new list)\n     * @throws NullPointerException if the input collection is null\n     */\n    public static Collection select(Collection inputCollection, Predicate predicate) {\n        ArrayList answer = new ArrayList(inputCollection.size());\n        select(inputCollection, predicate, answer);\n        return answer;\n    }\n\n    /** \n     * Selects all elements from input collection which match the given predicate\n     * and adds them to outputCollection.\n     * <p>\n     * If the input collection or predicate is null, there is no change to the \n     * output collection.\n     * \n     * @param inputCollection  the collection to get the input from, may be null\n     * @param predicate  the predicate to use, may be null\n     * @param outputCollection  the collection to output into, may not be null\n     */\n    public static void select(Collection inputCollection, Predicate predicate, Collection outputCollection) {\n        if (inputCollection != null && predicate != null) {\n            for (Iterator iter = inputCollection.iterator(); iter.hasNext();) {\n                Object item = iter.next();\n                if (predicate.evaluate(item)) {\n                    outputCollection.add(item);\n                }\n            }\n        }\n    }\n    \n    /**\n     * Selects all elements from inputCollection which don't match the given predicate\n     * into an output collection.\n     * <p>\n     * If the input predicate is <code>null</code>, the result is an empty list.\n     * \n     * @param inputCollection  the collection to get the input from, may not be null\n     * @param predicate  the predicate to use, may be null\n     * @return the elements <b>not</b> matching the predicate (new list)\n     * @throws NullPointerException if the input collection is null\n     */\n    public static Collection selectRejected(Collection inputCollection, Predicate predicate) {\n        ArrayList answer = new ArrayList(inputCollection.size());\n        selectRejected(inputCollection, predicate, answer);\n        return answer;\n    }\n    \n    /** \n     * Selects all elements from inputCollection which don't match the given predicate\n     * and adds them to outputCollection.\n     * <p>\n     * If the input predicate is <code>null</code>, no elements are added to <code>outputCollection</code>.\n     * \n     * @param inputCollection  the collection to get the input from, may be null\n     * @param predicate  the predicate to use, may be null\n     * @param outputCollection  the collection to output into, may not be null\n     */\n    public static void selectRejected(Collection inputCollection, Predicate predicate, Collection outputCollection) {\n        if (inputCollection != null && predicate != null) {\n            for (Iterator iter = inputCollection.iterator(); iter.hasNext();) {\n                Object item = iter.next();\n                if (predicate.evaluate(item) == false) {\n                    outputCollection.add(item);\n                }\n            }\n        }\n    }\n    \n    /** \n     * Returns a new Collection consisting of the elements of inputCollection transformed\n     * by the given transformer.\n     * <p>\n     * If the input transformer is null, the result is an empty list.\n     * \n     * @param inputCollection  the collection to get the input from, may not be null\n     * @param transformer  the transformer to use, may be null\n     * @return the transformed result (new list)\n     * @throws NullPointerException if the input collection is null\n     */\n    public static Collection collect(Collection inputCollection, Transformer transformer) {\n        ArrayList answer = new ArrayList(inputCollection.size());\n        collect(inputCollection, transformer, answer);\n        return answer;\n    }\n    \n    /** \n     * Transforms all elements from the inputIterator with the given transformer \n     * and adds them to the outputCollection.\n     * <p>\n     * If the input iterator or transformer is null, the result is an empty list.\n     * \n     * @param inputIterator  the iterator to get the input from, may be null\n     * @param transformer  the transformer to use, may be null\n     * @return the transformed result (new list)\n     */\n    public static Collection collect(Iterator inputIterator, Transformer transformer) {\n        ArrayList answer = new ArrayList();\n        collect(inputIterator, transformer, answer);\n        return answer;\n    }\n    \n    /** \n     * Transforms all elements from inputCollection with the given transformer \n     * and adds them to the outputCollection.\n     * <p>\n     * If the input collection or transformer is null, there is no change to the \n     * output collection.\n     *\n     * @param inputCollection  the collection to get the input from, may be null\n     * @param transformer  the transformer to use, may be null\n     * @param outputCollection  the collection to output into, may not be null\n     * @return the outputCollection with the transformed input added\n     * @throws NullPointerException if the output collection is null\n     */\n    public static Collection collect(Collection inputCollection, final Transformer transformer, final Collection outputCollection) {\n        if (inputCollection != null) {\n            return collect(inputCollection.iterator(), transformer, outputCollection);\n        }\n        return outputCollection;\n    }\n\n    /** \n     * Transforms all elements from the inputIterator with the given transformer \n     * and adds them to the outputCollection.\n     * <p>\n     * If the input iterator or transformer is null, there is no change to the \n     * output collection.\n     *\n     * @param inputIterator  the iterator to get the input from, may be null\n     * @param transformer  the transformer to use, may be null\n     * @param outputCollection  the collection to output into, may not be null\n     * @return the outputCollection with the transformed input added\n     * @throws NullPointerException if the output collection is null\n     */\n    public static Collection collect(Iterator inputIterator, final Transformer transformer, final Collection outputCollection) {\n        if (inputIterator != null && transformer != null) {\n            while (inputIterator.hasNext()) {\n                Object item = inputIterator.next();\n                Object value = transformer.transform(item);\n                outputCollection.add(value);\n            }\n        }\n        return outputCollection;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Adds an element to the collection unless the element is null.\n     * \n     * @param collection  the collection to add to, must not be null\n     * @param object  the object to add, if null it will not be added\n     * @return true if the collection changed\n     * @throws NullPointerException if the collection is null\n     * @since Commons Collections 3.2\n     */\n    public static boolean addIgnoreNull(Collection collection, Object object) {\n        return (object == null ? false : collection.add(object));\n    }\n    \n    /**\n     * Adds all elements in the iteration to the given collection.\n     * \n     * @param collection  the collection to add to, must not be null\n     * @param iterator  the iterator of elements to add, must not be null\n     * @throws NullPointerException if the collection or iterator is null\n     */\n    public static void addAll(Collection collection, Iterator iterator) {\n        while (iterator.hasNext()) {\n            collection.add(iterator.next());\n        }\n    }\n    \n    /**\n     * Adds all elements in the enumeration to the given collection.\n     * \n     * @param collection  the collection to add to, must not be null\n     * @param enumeration  the enumeration of elements to add, must not be null\n     * @throws NullPointerException if the collection or enumeration is null\n     */\n    public static void addAll(Collection collection, Enumeration enumeration) {\n        while (enumeration.hasMoreElements()) {\n            collection.add(enumeration.nextElement());\n        }\n    }    \n    \n    /** \n     * Adds all elements in the array to the given collection.\n     * \n     * @param collection  the collection to add to, must not be null\n     * @param elements  the array of elements to add, must not be null\n     * @throws NullPointerException if the collection or array is null\n     */\n    public static void addAll(Collection collection, Object[] elements) {\n        for (int i = 0, size = elements.length; i < size; i++) {\n            collection.add(elements[i]);\n        }\n    }    \n    \n    /**\n     * Given an Object, and an index, returns the nth value in the\n     * object.\n     * <ul>\n     * <li>If obj is a Map, returns the nth value from the <b>keySet</b> iterator, unless \n     *     the Map contains an Integer key with integer value = idx, in which case the\n     *     corresponding map entry value is returned.  If idx exceeds the number of entries in\n     *     the map, an empty Iterator is returned.\n     * <li>If obj is a List or an array, returns the nth value, throwing IndexOutOfBoundsException,\n     *     ArrayIndexOutOfBoundsException, resp. if the nth value does not exist.\n     * <li>If obj is an iterator, enumeration or Collection, returns the nth value from the iterator,\n     *     returning an empty Iterator (resp. Enumeration) if the nth value does not exist.\n     * <li>Returns the original obj if it is null or not a Collection or Iterator.\n     * </ul>\n     * \n     * @param obj  the object to get an index of, may be null\n     * @param idx  the index to get\n     * @throws IndexOutOfBoundsException\n     * @throws ArrayIndexOutOfBoundsException\n     *\n     * @deprecated use {@link #get(Object, int)} instead. Will be removed in v4.0\n     */\n    public static Object index(Object obj, int idx) {\n        return index(obj, new Integer(idx));\n    }\n    \n    /**\n     * Given an Object, and a key (index), returns the value associated with\n     * that key in the Object. The following checks are made:\n     * <ul>\n     * <li>If obj is a Map, use the index as a key to get a value. If no match continue.\n     * <li>Check key is an Integer. If not, return the object passed in.\n     * <li>If obj is a Map, get the nth value from the <b>keySet</b> iterator.\n     *     If the Map has fewer than n entries, return an empty Iterator.\n     * <li>If obj is a List or an array, get the nth value, throwing IndexOutOfBoundsException,\n     *     ArrayIndexOutOfBoundsException, resp. if the nth value does not exist.\n     * <li>If obj is an iterator, enumeration or Collection, get the nth value from the iterator,\n     *     returning an empty Iterator (resp. Enumeration) if the nth value does not exist.\n     * <li>Return the original obj.\n     * </ul>\n     * \n     * @param obj  the object to get an index of\n     * @param index  the index to get\n     * @return the object at the specified index\n     * @throws IndexOutOfBoundsException\n     * @throws ArrayIndexOutOfBoundsException\n     *\n     * @deprecated use {@link #get(Object, int)} instead. Will be removed in v4.0\n     */\n    public static Object index(Object obj, Object index) {\n        if(obj instanceof Map) {\n            Map map = (Map)obj;\n            if(map.containsKey(index)) {\n                return map.get(index);\n            }\n        }\n        int idx = -1;\n        if(index instanceof Integer) {\n            idx = ((Integer)index).intValue();\n        }\n        if(idx < 0) {\n            return obj;\n        } \n        else if(obj instanceof Map) {\n            Map map = (Map)obj;\n            Iterator iterator = map.keySet().iterator();\n            return index(iterator, idx);\n        } \n        else if(obj instanceof List) {\n            return ((List)obj).get(idx);\n        } \n        else if(obj instanceof Object[]) {\n            return ((Object[])obj)[idx];\n        } \n        else if(obj instanceof Enumeration) {\n            Enumeration it = (Enumeration)obj;\n            while(it.hasMoreElements()) {\n                idx--;\n                if(idx == -1) {\n                    return it.nextElement();\n                } else {\n                    it.nextElement();\n                }\n            }\n        } \n        else if(obj instanceof Iterator) {\n            return index((Iterator)obj, idx);\n        }\n        else if(obj instanceof Collection) {\n            Iterator iterator = ((Collection)obj).iterator();\n            return index(iterator, idx);\n        }\n        return obj;\n    }\n\n    private static Object index(Iterator iterator, int idx) {\n        while(iterator.hasNext()) {\n            idx--;\n            if(idx == -1) {\n                return iterator.next();\n            } else {\n                iterator.next();\n            }\n        }\n        return iterator;\n    }\n    \n    /**\n     * Returns the <code>index</code>-th value in <code>object</code>, throwing\n     * <code>IndexOutOfBoundsException</code> if there is no such element or \n     * <code>IllegalArgumentException</code> if <code>object</code> is not an \n     * instance of one of the supported types.\n     * <p>\n     * The supported types, and associated semantics are:\n     * <ul>\n     * <li> Map -- the value returned is the <code>Map.Entry</code> in position \n     *      <code>index</code> in the map's <code>entrySet</code> iterator, \n     *      if there is such an entry.</li>\n     * <li> List -- this method is equivalent to the list's get method.</li>\n     * <li> Array -- the <code>index</code>-th array entry is returned, \n     *      if there is such an entry; otherwise an <code>IndexOutOfBoundsException</code>\n     *      is thrown.</li>\n     * <li> Collection -- the value returned is the <code>index</code>-th object \n     *      returned by the collection's default iterator, if there is such an element.</li>\n     * <li> Iterator or Enumeration -- the value returned is the\n     *      <code>index</code>-th object in the Iterator/Enumeration, if there\n     *      is such an element.  The Iterator/Enumeration is advanced to \n     *      <code>index</code> (or to the end, if <code>index</code> exceeds the \n     *      number of entries) as a side effect of this method.</li>\n     * </ul>\n     * \n     * @param object  the object to get a value from\n     * @param index  the index to get\n     * @return the object at the specified index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     * @throws IllegalArgumentException if the object type is invalid\n     */\n    public static Object get(Object object, int index) {\n        if (index < 0) {\n            throw new IndexOutOfBoundsException(\"Index cannot be negative: \" + index);\n        }\n        if (object instanceof Map) {\n            Map map = (Map) object;\n            Iterator iterator = map.entrySet().iterator();\n            return get(iterator, index);\n        } else if (object instanceof List) {\n            return ((List) object).get(index);\n        } else if (object instanceof Object[]) {\n            return ((Object[]) object)[index];\n        } else if (object instanceof Iterator) {\n            Iterator it = (Iterator) object;\n            while (it.hasNext()) {\n                index--;\n                if (index == -1) {\n                    return it.next();\n                } else {\n                    it.next();\n                }\n            }\n            throw new IndexOutOfBoundsException(\"Entry does not exist: \" + index);\n        } else if (object instanceof Collection) {\n            Iterator iterator = ((Collection) object).iterator();\n            return get(iterator, index);\n        } else if (object instanceof Enumeration) {\n            Enumeration it = (Enumeration) object;\n            while (it.hasMoreElements()) {\n                index--;\n                if (index == -1) {\n                    return it.nextElement();\n                } else {\n                    it.nextElement();\n                }\n            }\n            throw new IndexOutOfBoundsException(\"Entry does not exist: \" + index);\n        } else if (object == null) {\n            throw new IllegalArgumentException(\"Unsupported object type: null\");\n        } else {\n            try {\n                return Array.get(object, index);\n            } catch (IllegalArgumentException ex) {\n                throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n            }\n        }\n    }\n    \n    /** \n     * Gets the size of the collection/iterator specified.\n     * <p>\n     * This method can handles objects as follows\n     * <ul>\n     * <li>Collection - the collection size\n     * <li>Map - the map size\n     * <li>Array - the array size\n     * <li>Iterator - the number of elements remaining in the iterator\n     * <li>Enumeration - the number of elements remaining in the enumeration\n     * </ul>\n     * \n     * @param object  the object to get the size of\n     * @return the size of the specified collection\n     * @throws IllegalArgumentException thrown if object is not recognised or null\n     * @since Commons Collections 3.1\n     */\n    public static int size(Object object) {\n        int total = 0;\n        if (object instanceof Map) {\n            total = ((Map) object).size();\n        } else if (object instanceof Collection) {\n            total = ((Collection) object).size();\n        } else if (object instanceof Object[]) {\n            total = ((Object[]) object).length;\n        } else if (object instanceof Iterator) {\n            Iterator it = (Iterator) object;\n            while (it.hasNext()) {\n                total++;\n                it.next();\n            }\n        } else if (object instanceof Enumeration) {\n            Enumeration it = (Enumeration) object;\n            while (it.hasMoreElements()) {\n                total++;\n                it.nextElement();\n            }\n        } else if (object == null) {\n            throw new IllegalArgumentException(\"Unsupported object type: null\");\n        } else {\n            try {\n                total = Array.getLength(object);\n            } catch (IllegalArgumentException ex) {\n                throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n            }\n        }\n        return total;\n    }\n    \n    /**\n     * Checks if the specified collection/array/iterator is empty.\n     * <p>\n     * This method can handles objects as follows\n     * <ul>\n     * <li>Collection - via collection isEmpty\n     * <li>Map - via map isEmpty\n     * <li>Array - using array size\n     * <li>Iterator - via hasNext\n     * <li>Enumeration - via hasMoreElements\n     * </ul>\n     * <p>\n     * Note: This method is named to avoid clashing with\n     * {@link #isEmpty(Collection)}.\n     * \n     * @param object  the object to get the size of, not null\n     * @return true if empty\n     * @throws IllegalArgumentException thrown if object is not recognised or null\n     * @since Commons Collections 3.2\n     */\n    public static boolean sizeIsEmpty(Object object) {\n        if (object instanceof Collection) {\n            return ((Collection) object).isEmpty();\n        } else if (object instanceof Map) {\n            return ((Map) object).isEmpty();\n        } else if (object instanceof Object[]) {\n            return ((Object[]) object).length == 0;\n        } else if (object instanceof Iterator) {\n            return ((Iterator) object).hasNext() == false;\n        } else if (object instanceof Enumeration) {\n            return ((Enumeration) object).hasMoreElements() == false;\n        } else if (object == null) {\n            throw new IllegalArgumentException(\"Unsupported object type: null\");\n        } else {\n            try {\n                return Array.getLength(object) == 0;\n            } catch (IllegalArgumentException ex) {\n                throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n            }\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Null-safe check if the specified collection is empty.\n     * <p>\n     * Null returns true.\n     * \n     * @param coll  the collection to check, may be null\n     * @return true if empty or null\n     * @since Commons Collections 3.2\n     */\n    public static boolean isEmpty(Collection coll) {\n        return (coll == null || coll.isEmpty());\n    }\n\n    /**\n     * Null-safe check if the specified collection is not empty.\n     * <p>\n     * Null returns false.\n     * \n     * @param coll  the collection to check, may be null\n     * @return true if non-null and non-empty\n     * @since Commons Collections 3.2\n     */\n    public static boolean isNotEmpty(Collection coll) {\n        return !CollectionUtils.isEmpty(coll);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Reverses the order of the given array.\n     * \n     * @param array  the array to reverse\n     */\n    public static void reverseArray(Object[] array) {\n        int i = 0;\n        int j = array.length - 1;\n        Object tmp;\n\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    private static final int getFreq(final Object obj, final Map freqMap) {\n        Integer count = (Integer) freqMap.get(obj);\n        if (count != null) {\n            return count.intValue();\n        }\n        return 0;\n    }\n\n    /**\n     * Returns true if no more elements can be added to the Collection.\n     * <p>\n     * This method uses the {@link BoundedCollection} interface to determine the\n     * full status. If the collection does not implement this interface then\n     * false is returned.\n     * <p>\n     * The collection does not have to implement this interface directly.\n     * If the collection has been decorated using the decorators subpackage\n     * then these will be removed to access the BoundedCollection.\n     *\n     * @param coll  the collection to check\n     * @return true if the BoundedCollection is full\n     * @throws NullPointerException if the collection is null\n     */\n    public static boolean isFull(Collection coll) {\n        if (coll == null) {\n            throw new NullPointerException(\"The collection must not be null\");\n        }\n        if (coll instanceof BoundedCollection) {\n            return ((BoundedCollection) coll).isFull();\n        }\n        try {\n            BoundedCollection bcoll = UnmodifiableBoundedCollection.decorateUsing(coll);\n            return bcoll.isFull();\n            \n        } catch (IllegalArgumentException ex) {\n            return false;\n        }\n    }\n\n    /**\n     * Get the maximum number of elements that the Collection can contain.\n     * <p>\n     * This method uses the {@link BoundedCollection} interface to determine the\n     * maximum size. If the collection does not implement this interface then\n     * -1 is returned.\n     * <p>\n     * The collection does not have to implement this interface directly.\n     * If the collection has been decorated using the decorators subpackage\n     * then these will be removed to access the BoundedCollection.\n     *\n     * @param coll  the collection to check\n     * @return the maximum size of the BoundedCollection, -1 if no maximum size\n     * @throws NullPointerException if the collection is null\n     */\n    public static int maxSize(Collection coll) {\n        if (coll == null) {\n            throw new NullPointerException(\"The collection must not be null\");\n        }\n        if (coll instanceof BoundedCollection) {\n            return ((BoundedCollection) coll).maxSize();\n        }\n        try {\n            BoundedCollection bcoll = UnmodifiableBoundedCollection.decorateUsing(coll);\n            return bcoll.maxSize();\n            \n        } catch (IllegalArgumentException ex) {\n            return -1;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a collection containing all the elements in <code>collection</code>\n     * that are also in <code>retain</code>. The cardinality of an element <code>e</code>\n     * in the returned collection is the same as the cardinality of <code>e</code>\n     * in <code>collection</code> unless <code>retain</code> does not contain <code>e</code>, in which\n     * case the cardinality is zero. This method is useful if you do not wish to modify\n     * the collection <code>c</code> and thus cannot call <code>c.retainAll(retain);</code>.\n     * \n     * @param collection  the collection whose contents are the target of the #retailAll operation\n     * @param retain  the collection containing the elements to be retained in the returned collection\n     * @return a <code>Collection</code> containing all the elements of <code>collection</code>\n     * that occur at least once in <code>retain</code>.\n     * @throws NullPointerException if either parameter is null\n     * @since Commons Collections 3.2\n     */\n    public static Collection retainAll(Collection collection, Collection retain) {\n        return ListUtils.retainAll(collection, retain);\n    }\n\n    /**\n     * Removes the elements in <code>remove</code> from <code>collection</code>. That is, this\n     * method returns a collection containing all the elements in <code>c</code>\n     * that are not in <code>remove</code>. The cardinality of an element <code>e</code>\n     * in the returned collection is the same as the cardinality of <code>e</code>\n     * in <code>collection</code> unless <code>remove</code> contains <code>e</code>, in which\n     * case the cardinality is zero. This method is useful if you do not wish to modify\n     * the collection <code>c</code> and thus cannot call <code>collection.removeAll(remove);</code>.\n     * \n     * @param collection  the collection from which items are removed (in the returned collection)\n     * @param remove  the items to be removed from the returned <code>collection</code>\n     * @return a <code>Collection</code> containing all the elements of <code>collection</code> except\n     * any elements that also occur in <code>remove</code>.\n     * @throws NullPointerException if either parameter is null\n     * @since Commons Collections 3.3 (method existed in 3.2 but was completely broken)\n     */\n    public static Collection removeAll(Collection collection, Collection remove) {\n        return ListUtils.retainAll(collection, remove);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized collection backed by the given collection.\n     * <p>\n     * You must manually synchronize on the returned buffer's iterator to \n     * avoid non-deterministic behavior:\n     *  \n     * <pre>\n     * Collection c = CollectionUtils.synchronizedCollection(myCollection);\n     * synchronized (c) {\n     *     Iterator i = c.iterator();\n     *     while (i.hasNext()) {\n     *         process (i.next());\n     *     }\n     * }\n     * </pre>\n     * \n     * This method uses the implementation in the decorators subpackage.\n     * \n     * @param collection  the collection to synchronize, must not be null\n     * @return a synchronized collection backed by the given collection\n     * @throws IllegalArgumentException  if the collection is null\n     */\n    public static Collection synchronizedCollection(Collection collection) {\n        return SynchronizedCollection.decorate(collection);\n    }\n\n    /**\n     * Returns an unmodifiable collection backed by the given collection.\n     * <p>\n     * This method uses the implementation in the decorators subpackage.\n     *\n     * @param collection  the collection to make unmodifiable, must not be null\n     * @return an unmodifiable collection backed by the given collection\n     * @throws IllegalArgumentException  if the collection is null\n     */\n    public static Collection unmodifiableCollection(Collection collection) {\n        return UnmodifiableCollection.decorate(collection);\n    }\n\n    /**\n     * Returns a predicated (validating) collection backed by the given collection.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to the collection.\n     * Trying to add an invalid object results in an IllegalArgumentException.\n     * It is important not to use the original collection after invoking this method,\n     * as it is a backdoor for adding invalid objects.\n     *\n     * @param collection  the collection to predicate, must not be null\n     * @param predicate  the predicate for the collection, must not be null\n     * @return a predicated collection backed by the given collection\n     * @throws IllegalArgumentException  if the Collection is null\n     */\n    public static Collection predicatedCollection(Collection collection, Predicate predicate) {\n        return PredicatedCollection.decorate(collection, predicate);\n    }\n\n    /**\n     * Returns a typed collection backed by the given collection.\n     * <p>\n     * Only objects of the specified type can be added to the collection.\n     * \n     * @param collection  the collection to limit to a specific type, must not be null\n     * @param type  the type of objects which may be added to the collection\n     * @return a typed collection backed by the specified collection\n     */\n    public static Collection typedCollection(Collection collection, Class type) {\n        return TypedCollection.decorate(collection, type);\n    }\n    \n    /**\n     * Returns a transformed bag backed by the given collection.\n     * <p>\n     * Each object is passed through the transformer as it is added to the\n     * Collection. It is important not to use the original collection after invoking this \n     * method, as it is a backdoor for adding untransformed objects.\n     *\n     * @param collection  the collection to predicate, must not be null\n     * @param transformer  the transformer for the collection, must not be null\n     * @return a transformed collection backed by the given collection\n     * @throws IllegalArgumentException  if the Collection or Transformer is null\n     */\n    public static Collection transformedCollection(Collection collection, Transformer transformer) {\n        return TransformedCollection.decorate(collection, transformer);\n    }\n\n}\n", "fixed_version": "/*\n *  Copyright 2001-2006 The Apache Software Foundation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.apache.commons.collections;\n\nimport java.lang.reflect.Array;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.apache.commons.collections.collection.PredicatedCollection;\nimport org.apache.commons.collections.collection.SynchronizedCollection;\nimport org.apache.commons.collections.collection.TransformedCollection;\nimport org.apache.commons.collections.collection.TypedCollection;\nimport org.apache.commons.collections.collection.UnmodifiableBoundedCollection;\nimport org.apache.commons.collections.collection.UnmodifiableCollection;\n\n/**\n * Provides utility methods and decorators for {@link Collection} instances.\n *\n * @since Commons Collections 1.0\n * @version $Revision$ $Date$\n * \n * @author Rodney Waldhoff\n * @author Paul Jack\n * @author Stephen Colebourne\n * @author Steve Downey\n * @author Herve Quiroz\n * @author Peter KoBek\n * @author Matthew Hawthorne\n * @author Janek Bogucki\n * @author Phil Steitz\n * @author Steven Melzer\n * @author Jon Schewe\n * @author Neil O'Toole\n * @author Stephen Smith\n */\npublic class CollectionUtils {\n\n    /** Constant to avoid repeated object creation */\n    private static Integer INTEGER_ONE = new Integer(1);\n\n    /**\n     * An empty unmodifiable collection.\n     * The JDK provides empty Set and List implementations which could be used for\n     * this purpose. However they could be cast to Set or List which might be\n     * undesirable. This implementation only implements Collection.\n     */\n    public static final Collection EMPTY_COLLECTION = UnmodifiableCollection.decorate(new ArrayList());\n\n    /**\n     * <code>CollectionUtils</code> should not normally be instantiated.\n     */\n    public CollectionUtils() {\n    }\n\n    /**\n     * Returns a {@link Collection} containing the union\n     * of the given {@link Collection}s.\n     * <p>\n     * The cardinality of each element in the returned {@link Collection}\n     * will be equal to the maximum of the cardinality of that element\n     * in the two given {@link Collection}s.\n     *\n     * @param a  the first collection, must not be null\n     * @param b  the second collection, must not be null\n     * @return  the union of the two collections\n     * @see Collection#addAll\n     */\n    public static Collection union(final Collection a, final Collection b) {\n        ArrayList list = new ArrayList();\n        Map mapa = getCardinalityMap(a);\n        Map mapb = getCardinalityMap(b);\n        Set elts = new HashSet(a);\n        elts.addAll(b);\n        Iterator it = elts.iterator();\n        while(it.hasNext()) {\n            Object obj = it.next();\n            for(int i=0,m=Math.max(getFreq(obj,mapa),getFreq(obj,mapb));i<m;i++) {\n                list.add(obj);\n            }\n        }\n        return list;\n    }\n\n    /**\n     * Returns a {@link Collection} containing the intersection\n     * of the given {@link Collection}s.\n     * <p>\n     * The cardinality of each element in the returned {@link Collection}\n     * will be equal to the minimum of the cardinality of that element\n     * in the two given {@link Collection}s.\n     *\n     * @param a  the first collection, must not be null\n     * @param b  the second collection, must not be null\n     * @return the intersection of the two collections\n     * @see Collection#retainAll\n     * @see #containsAny\n     */\n    public static Collection intersection(final Collection a, final Collection b) {\n        ArrayList list = new ArrayList();\n        Map mapa = getCardinalityMap(a);\n        Map mapb = getCardinalityMap(b);\n        Set elts = new HashSet(a);\n        elts.addAll(b);\n        Iterator it = elts.iterator();\n        while(it.hasNext()) {\n            Object obj = it.next();\n            for(int i=0,m=Math.min(getFreq(obj,mapa),getFreq(obj,mapb));i<m;i++) {\n                list.add(obj);\n            }\n        }\n        return list;\n    }\n\n    /**\n     * Returns a {@link Collection} containing the exclusive disjunction\n     * (symmetric difference) of the given {@link Collection}s.\n     * <p>\n     * The cardinality of each element <i>e</i> in the returned {@link Collection}\n     * will be equal to\n     * <tt>max(cardinality(<i>e</i>,<i>a</i>),cardinality(<i>e</i>,<i>b</i>)) - min(cardinality(<i>e</i>,<i>a</i>),cardinality(<i>e</i>,<i>b</i>))</tt>.\n     * <p>\n     * This is equivalent to\n     * <tt>{@link #subtract subtract}({@link #union union(a,b)},{@link #intersection intersection(a,b)})</tt>\n     * or\n     * <tt>{@link #union union}({@link #subtract subtract(a,b)},{@link #subtract subtract(b,a)})</tt>.\n     *\n     * @param a  the first collection, must not be null\n     * @param b  the second collection, must not be null\n     * @return the symmetric difference of the two collections\n     */\n    public static Collection disjunction(final Collection a, final Collection b) {\n        ArrayList list = new ArrayList();\n        Map mapa = getCardinalityMap(a);\n        Map mapb = getCardinalityMap(b);\n        Set elts = new HashSet(a);\n        elts.addAll(b);\n        Iterator it = elts.iterator();\n        while(it.hasNext()) {\n            Object obj = it.next();\n            for(int i=0,m=((Math.max(getFreq(obj,mapa),getFreq(obj,mapb)))-(Math.min(getFreq(obj,mapa),getFreq(obj,mapb))));i<m;i++) {\n                list.add(obj);\n            }\n        }\n        return list;\n    }\n\n    /**\n     * Returns a new {@link Collection} containing <tt><i>a</i> - <i>b</i></tt>.\n     * The cardinality of each element <i>e</i> in the returned {@link Collection}\n     * will be the cardinality of <i>e</i> in <i>a</i> minus the cardinality\n     * of <i>e</i> in <i>b</i>, or zero, whichever is greater.\n     *\n     * @param a  the collection to subtract from, must not be null\n     * @param b  the collection to subtract, must not be null\n     * @return a new collection with the results\n     * @see Collection#removeAll\n     */\n    public static Collection subtract(final Collection a, final Collection b) {\n        ArrayList list = new ArrayList( a );\n        for (Iterator it = b.iterator(); it.hasNext();) {\n            list.remove(it.next());\n        }\n        return list;\n    }\n\n    /**\n     * Returns <code>true</code> iff at least one element is in both collections.\n     * <p>\n     * In other words, this method returns <code>true</code> iff the\n     * {@link #intersection} of <i>coll1</i> and <i>coll2</i> is not empty.\n     * \n     * @param coll1  the first collection, must not be null\n     * @param coll2  the first collection, must not be null\n     * @return <code>true</code> iff the intersection of the collections is non-empty\n     * @since 2.1\n     * @see #intersection\n     */\n    public static boolean containsAny(final Collection coll1, final Collection coll2) {\n        if (coll1.size() < coll2.size()) {\n            for (Iterator it = coll1.iterator(); it.hasNext();) {\n                if (coll2.contains(it.next())) {\n                    return true;\n                }\n            }\n        } else {\n            for (Iterator it = coll2.iterator(); it.hasNext();) {\n                if (coll1.contains(it.next())) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Returns a {@link Map} mapping each unique element in the given\n     * {@link Collection} to an {@link Integer} representing the number\n     * of occurrences of that element in the {@link Collection}.\n     * <p>\n     * Only those elements present in the collection will appear as\n     * keys in the map.\n     * \n     * @param coll  the collection to get the cardinality map for, must not be null\n     * @return the populated cardinality map\n     */\n    public static Map getCardinalityMap(final Collection coll) {\n        Map count = new HashMap();\n        for (Iterator it = coll.iterator(); it.hasNext();) {\n            Object obj = it.next();\n            Integer c = (Integer) (count.get(obj));\n            if (c == null) {\n                count.put(obj,INTEGER_ONE);\n            } else {\n                count.put(obj,new Integer(c.intValue() + 1));\n            }\n        }\n        return count;\n    }\n\n    /**\n     * Returns <tt>true</tt> iff <i>a</i> is a sub-collection of <i>b</i>,\n     * that is, iff the cardinality of <i>e</i> in <i>a</i> is less\n     * than or equal to the cardinality of <i>e</i> in <i>b</i>,\n     * for each element <i>e</i> in <i>a</i>.\n     *\n     * @param a  the first (sub?) collection, must not be null\n     * @param b  the second (super?) collection, must not be null\n     * @return <code>true</code> iff <i>a</i> is a sub-collection of <i>b</i>\n     * @see #isProperSubCollection\n     * @see Collection#containsAll\n     */\n    public static boolean isSubCollection(final Collection a, final Collection b) {\n        Map mapa = getCardinalityMap(a);\n        Map mapb = getCardinalityMap(b);\n        Iterator it = a.iterator();\n        while (it.hasNext()) {\n            Object obj = it.next();\n            if (getFreq(obj, mapa) > getFreq(obj, mapb)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns <tt>true</tt> iff <i>a</i> is a <i>proper</i> sub-collection of <i>b</i>,\n     * that is, iff the cardinality of <i>e</i> in <i>a</i> is less\n     * than or equal to the cardinality of <i>e</i> in <i>b</i>,\n     * for each element <i>e</i> in <i>a</i>, and there is at least one\n     * element <i>f</i> such that the cardinality of <i>f</i> in <i>b</i>\n     * is strictly greater than the cardinality of <i>f</i> in <i>a</i>.\n     * <p>\n     * The implementation assumes\n     * <ul>\n     *    <li><code>a.size()</code> and <code>b.size()</code> represent the \n     *    total cardinality of <i>a</i> and <i>b</i>, resp. </li>\n     *    <li><code>a.size() < Integer.MAXVALUE</code></li>\n     * </ul>\n     *\n     * @param a  the first (sub?) collection, must not be null\n     * @param b  the second (super?) collection, must not be null\n     * @return <code>true</code> iff <i>a</i> is a <i>proper</i> sub-collection of <i>b</i>\n     * @see #isSubCollection\n     * @see Collection#containsAll\n     */\n    public static boolean isProperSubCollection(final Collection a, final Collection b) {\n        return (a.size() < b.size()) && CollectionUtils.isSubCollection(a,b);\n    }\n\n    /**\n     * Returns <tt>true</tt> iff the given {@link Collection}s contain\n     * exactly the same elements with exactly the same cardinalities.\n     * <p>\n     * That is, iff the cardinality of <i>e</i> in <i>a</i> is\n     * equal to the cardinality of <i>e</i> in <i>b</i>,\n     * for each element <i>e</i> in <i>a</i> or <i>b</i>.\n     *\n     * @param a  the first collection, must not be null\n     * @param b  the second collection, must not be null\n     * @return <code>true</code> iff the collections contain the same elements with the same cardinalities.\n     */\n    public static boolean isEqualCollection(final Collection a, final Collection b) {\n        if(a.size() != b.size()) {\n            return false;\n        } else {\n            Map mapa = getCardinalityMap(a);\n            Map mapb = getCardinalityMap(b);\n            if(mapa.size() != mapb.size()) {\n                return false;\n            } else {\n                Iterator it = mapa.keySet().iterator();\n                while(it.hasNext()) {\n                    Object obj = it.next();\n                    if(getFreq(obj,mapa) != getFreq(obj,mapb)) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n        }\n    }\n\n    /**\n     * Returns the number of occurrences of <i>obj</i> in <i>coll</i>.\n     *\n     * @param obj  the object to find the cardinality of\n     * @param coll  the collection to search\n     * @return the the number of occurrences of obj in coll\n     */\n    public static int cardinality(Object obj, final Collection coll) {\n        if (coll instanceof Set) {\n            return (coll.contains(obj) ? 1 : 0);\n        }\n        if (coll instanceof Bag) {\n            return ((Bag) coll).getCount(obj);\n        }\n        int count = 0;\n        if (obj == null) {\n            for (Iterator it = coll.iterator();it.hasNext();) {\n                if (it.next() == null) {\n                    count++;\n                }\n            }\n        } else {\n            for (Iterator it = coll.iterator();it.hasNext();) {\n                if (obj.equals(it.next())) {\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n\n    /** \n     * Finds the first element in the given collection which matches the given predicate.\n     * <p>\n     * If the input collection or predicate is null, or no element of the collection \n     * matches the predicate, null is returned.\n     *\n     * @param collection  the collection to search, may be null\n     * @param predicate  the predicate to use, may be null\n     * @return the first element of the collection which matches the predicate or null if none could be found\n     */\n    public static Object find(Collection collection, Predicate predicate) {\n        if (collection != null && predicate != null) {\n            for (Iterator iter = collection.iterator(); iter.hasNext();) {\n                Object item = iter.next();\n                if (predicate.evaluate(item)) {\n                    return item;\n                }\n            }\n        }\n        return null;\n    }\n    \n    /** \n     * Executes the given closure on each element in the collection.\n     * <p>\n     * If the input collection or closure is null, there is no change made.\n     * \n     * @param collection  the collection to get the input from, may be null\n     * @param closure  the closure to perform, may be null\n     */\n    public static void forAllDo(Collection collection, Closure closure) {\n        if (collection != null && closure != null) {\n            for (Iterator it = collection.iterator(); it.hasNext();) {\n                closure.execute(it.next());\n            }\n        }\n    }\n\n    /** \n     * Filter the collection by applying a Predicate to each element. If the\n     * predicate returns false, remove the element.\n     * <p>\n     * If the input collection or predicate is null, there is no change made.\n     * \n     * @param collection  the collection to get the input from, may be null\n     * @param predicate  the predicate to use as a filter, may be null\n     */\n    public static void filter(Collection collection, Predicate predicate) {\n        if (collection != null && predicate != null) {\n            for (Iterator it = collection.iterator(); it.hasNext();) {\n                if (predicate.evaluate(it.next()) == false) {\n                    it.remove();\n                }\n            }\n        }\n    }\n\n    /** \n     * Transform the collection by applying a Transformer to each element.\n     * <p>\n     * If the input collection or transformer is null, there is no change made.\n     * <p>\n     * This routine is best for Lists, for which set() is used to do the \n     * transformations \"in place.\"  For other Collections, clear() and addAll()\n     * are used to replace elements.  \n     * <p>\n     * If the input collection controls its input, such as a Set, and the\n     * Transformer creates duplicates (or are otherwise invalid), the \n     * collection may reduce in size due to calling this method.\n     * \n     * @param collection  the collection to get the input from, may be null\n     * @param transformer  the transformer to perform, may be null\n     */\n    public static void transform(Collection collection, Transformer transformer) {\n        if (collection != null && transformer != null) {\n            if (collection instanceof List) {\n                List list = (List) collection;\n                for (ListIterator it = list.listIterator(); it.hasNext();) {\n                    it.set(transformer.transform(it.next()));\n                }\n            } else {\n                Collection resultCollection = collect(collection, transformer);\n                collection.clear();\n                collection.addAll(resultCollection);\n            }\n        }\n    }\n\n    /** \n     * Counts the number of elements in the input collection that match the predicate.\n     * <p>\n     * A <code>null</code> collection or predicate matches no elements.\n     * \n     * @param inputCollection  the collection to get the input from, may be null\n     * @param predicate  the predicate to use, may be null\n     * @return the number of matches for the predicate in the collection\n     */\n    public static int countMatches(Collection inputCollection, Predicate predicate) {\n        int count = 0;\n        if (inputCollection != null && predicate != null) {\n            for (Iterator it = inputCollection.iterator(); it.hasNext();) {\n                if (predicate.evaluate(it.next())) {\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n\n    /** \n     * Answers true if a predicate is true for at least one element of a collection.\n     * <p>\n     * A <code>null</code> collection or predicate returns false.\n     * \n     * @param collection the collection to get the input from, may be null\n     * @param predicate the predicate to use, may be null\n     * @return true if at least one element of the collection matches the predicate\n     */\n    public static boolean exists(Collection collection, Predicate predicate) {\n        if (collection != null && predicate != null) {\n            for (Iterator it = collection.iterator(); it.hasNext();) {\n                if (predicate.evaluate(it.next())) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /** \n     * Selects all elements from input collection which match the given predicate\n     * into an output collection.\n     * <p>\n     * A <code>null</code> predicate matches no elements.\n     * \n     * @param inputCollection  the collection to get the input from, may not be null\n     * @param predicate  the predicate to use, may be null\n     * @return the elements matching the predicate (new list)\n     * @throws NullPointerException if the input collection is null\n     */\n    public static Collection select(Collection inputCollection, Predicate predicate) {\n        ArrayList answer = new ArrayList(inputCollection.size());\n        select(inputCollection, predicate, answer);\n        return answer;\n    }\n\n    /** \n     * Selects all elements from input collection which match the given predicate\n     * and adds them to outputCollection.\n     * <p>\n     * If the input collection or predicate is null, there is no change to the \n     * output collection.\n     * \n     * @param inputCollection  the collection to get the input from, may be null\n     * @param predicate  the predicate to use, may be null\n     * @param outputCollection  the collection to output into, may not be null\n     */\n    public static void select(Collection inputCollection, Predicate predicate, Collection outputCollection) {\n        if (inputCollection != null && predicate != null) {\n            for (Iterator iter = inputCollection.iterator(); iter.hasNext();) {\n                Object item = iter.next();\n                if (predicate.evaluate(item)) {\n                    outputCollection.add(item);\n                }\n            }\n        }\n    }\n    \n    /**\n     * Selects all elements from inputCollection which don't match the given predicate\n     * into an output collection.\n     * <p>\n     * If the input predicate is <code>null</code>, the result is an empty list.\n     * \n     * @param inputCollection  the collection to get the input from, may not be null\n     * @param predicate  the predicate to use, may be null\n     * @return the elements <b>not</b> matching the predicate (new list)\n     * @throws NullPointerException if the input collection is null\n     */\n    public static Collection selectRejected(Collection inputCollection, Predicate predicate) {\n        ArrayList answer = new ArrayList(inputCollection.size());\n        selectRejected(inputCollection, predicate, answer);\n        return answer;\n    }\n    \n    /** \n     * Selects all elements from inputCollection which don't match the given predicate\n     * and adds them to outputCollection.\n     * <p>\n     * If the input predicate is <code>null</code>, no elements are added to <code>outputCollection</code>.\n     * \n     * @param inputCollection  the collection to get the input from, may be null\n     * @param predicate  the predicate to use, may be null\n     * @param outputCollection  the collection to output into, may not be null\n     */\n    public static void selectRejected(Collection inputCollection, Predicate predicate, Collection outputCollection) {\n        if (inputCollection != null && predicate != null) {\n            for (Iterator iter = inputCollection.iterator(); iter.hasNext();) {\n                Object item = iter.next();\n                if (predicate.evaluate(item) == false) {\n                    outputCollection.add(item);\n                }\n            }\n        }\n    }\n    \n    /** \n     * Returns a new Collection consisting of the elements of inputCollection transformed\n     * by the given transformer.\n     * <p>\n     * If the input transformer is null, the result is an empty list.\n     * \n     * @param inputCollection  the collection to get the input from, may not be null\n     * @param transformer  the transformer to use, may be null\n     * @return the transformed result (new list)\n     * @throws NullPointerException if the input collection is null\n     */\n    public static Collection collect(Collection inputCollection, Transformer transformer) {\n        ArrayList answer = new ArrayList(inputCollection.size());\n        collect(inputCollection, transformer, answer);\n        return answer;\n    }\n    \n    /** \n     * Transforms all elements from the inputIterator with the given transformer \n     * and adds them to the outputCollection.\n     * <p>\n     * If the input iterator or transformer is null, the result is an empty list.\n     * \n     * @param inputIterator  the iterator to get the input from, may be null\n     * @param transformer  the transformer to use, may be null\n     * @return the transformed result (new list)\n     */\n    public static Collection collect(Iterator inputIterator, Transformer transformer) {\n        ArrayList answer = new ArrayList();\n        collect(inputIterator, transformer, answer);\n        return answer;\n    }\n    \n    /** \n     * Transforms all elements from inputCollection with the given transformer \n     * and adds them to the outputCollection.\n     * <p>\n     * If the input collection or transformer is null, there is no change to the \n     * output collection.\n     *\n     * @param inputCollection  the collection to get the input from, may be null\n     * @param transformer  the transformer to use, may be null\n     * @param outputCollection  the collection to output into, may not be null\n     * @return the outputCollection with the transformed input added\n     * @throws NullPointerException if the output collection is null\n     */\n    public static Collection collect(Collection inputCollection, final Transformer transformer, final Collection outputCollection) {\n        if (inputCollection != null) {\n            return collect(inputCollection.iterator(), transformer, outputCollection);\n        }\n        return outputCollection;\n    }\n\n    /** \n     * Transforms all elements from the inputIterator with the given transformer \n     * and adds them to the outputCollection.\n     * <p>\n     * If the input iterator or transformer is null, there is no change to the \n     * output collection.\n     *\n     * @param inputIterator  the iterator to get the input from, may be null\n     * @param transformer  the transformer to use, may be null\n     * @param outputCollection  the collection to output into, may not be null\n     * @return the outputCollection with the transformed input added\n     * @throws NullPointerException if the output collection is null\n     */\n    public static Collection collect(Iterator inputIterator, final Transformer transformer, final Collection outputCollection) {\n        if (inputIterator != null && transformer != null) {\n            while (inputIterator.hasNext()) {\n                Object item = inputIterator.next();\n                Object value = transformer.transform(item);\n                outputCollection.add(value);\n            }\n        }\n        return outputCollection;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Adds an element to the collection unless the element is null.\n     * \n     * @param collection  the collection to add to, must not be null\n     * @param object  the object to add, if null it will not be added\n     * @return true if the collection changed\n     * @throws NullPointerException if the collection is null\n     * @since Commons Collections 3.2\n     */\n    public static boolean addIgnoreNull(Collection collection, Object object) {\n        return (object == null ? false : collection.add(object));\n    }\n    \n    /**\n     * Adds all elements in the iteration to the given collection.\n     * \n     * @param collection  the collection to add to, must not be null\n     * @param iterator  the iterator of elements to add, must not be null\n     * @throws NullPointerException if the collection or iterator is null\n     */\n    public static void addAll(Collection collection, Iterator iterator) {\n        while (iterator.hasNext()) {\n            collection.add(iterator.next());\n        }\n    }\n    \n    /**\n     * Adds all elements in the enumeration to the given collection.\n     * \n     * @param collection  the collection to add to, must not be null\n     * @param enumeration  the enumeration of elements to add, must not be null\n     * @throws NullPointerException if the collection or enumeration is null\n     */\n    public static void addAll(Collection collection, Enumeration enumeration) {\n        while (enumeration.hasMoreElements()) {\n            collection.add(enumeration.nextElement());\n        }\n    }    \n    \n    /** \n     * Adds all elements in the array to the given collection.\n     * \n     * @param collection  the collection to add to, must not be null\n     * @param elements  the array of elements to add, must not be null\n     * @throws NullPointerException if the collection or array is null\n     */\n    public static void addAll(Collection collection, Object[] elements) {\n        for (int i = 0, size = elements.length; i < size; i++) {\n            collection.add(elements[i]);\n        }\n    }    \n    \n    /**\n     * Given an Object, and an index, returns the nth value in the\n     * object.\n     * <ul>\n     * <li>If obj is a Map, returns the nth value from the <b>keySet</b> iterator, unless \n     *     the Map contains an Integer key with integer value = idx, in which case the\n     *     corresponding map entry value is returned.  If idx exceeds the number of entries in\n     *     the map, an empty Iterator is returned.\n     * <li>If obj is a List or an array, returns the nth value, throwing IndexOutOfBoundsException,\n     *     ArrayIndexOutOfBoundsException, resp. if the nth value does not exist.\n     * <li>If obj is an iterator, enumeration or Collection, returns the nth value from the iterator,\n     *     returning an empty Iterator (resp. Enumeration) if the nth value does not exist.\n     * <li>Returns the original obj if it is null or not a Collection or Iterator.\n     * </ul>\n     * \n     * @param obj  the object to get an index of, may be null\n     * @param idx  the index to get\n     * @throws IndexOutOfBoundsException\n     * @throws ArrayIndexOutOfBoundsException\n     *\n     * @deprecated use {@link #get(Object, int)} instead. Will be removed in v4.0\n     */\n    public static Object index(Object obj, int idx) {\n        return index(obj, new Integer(idx));\n    }\n    \n    /**\n     * Given an Object, and a key (index), returns the value associated with\n     * that key in the Object. The following checks are made:\n     * <ul>\n     * <li>If obj is a Map, use the index as a key to get a value. If no match continue.\n     * <li>Check key is an Integer. If not, return the object passed in.\n     * <li>If obj is a Map, get the nth value from the <b>keySet</b> iterator.\n     *     If the Map has fewer than n entries, return an empty Iterator.\n     * <li>If obj is a List or an array, get the nth value, throwing IndexOutOfBoundsException,\n     *     ArrayIndexOutOfBoundsException, resp. if the nth value does not exist.\n     * <li>If obj is an iterator, enumeration or Collection, get the nth value from the iterator,\n     *     returning an empty Iterator (resp. Enumeration) if the nth value does not exist.\n     * <li>Return the original obj.\n     * </ul>\n     * \n     * @param obj  the object to get an index of\n     * @param index  the index to get\n     * @return the object at the specified index\n     * @throws IndexOutOfBoundsException\n     * @throws ArrayIndexOutOfBoundsException\n     *\n     * @deprecated use {@link #get(Object, int)} instead. Will be removed in v4.0\n     */\n    public static Object index(Object obj, Object index) {\n        if(obj instanceof Map) {\n            Map map = (Map)obj;\n            if(map.containsKey(index)) {\n                return map.get(index);\n            }\n        }\n        int idx = -1;\n        if(index instanceof Integer) {\n            idx = ((Integer)index).intValue();\n        }\n        if(idx < 0) {\n            return obj;\n        } \n        else if(obj instanceof Map) {\n            Map map = (Map)obj;\n            Iterator iterator = map.keySet().iterator();\n            return index(iterator, idx);\n        } \n        else if(obj instanceof List) {\n            return ((List)obj).get(idx);\n        } \n        else if(obj instanceof Object[]) {\n            return ((Object[])obj)[idx];\n        } \n        else if(obj instanceof Enumeration) {\n            Enumeration it = (Enumeration)obj;\n            while(it.hasMoreElements()) {\n                idx--;\n                if(idx == -1) {\n                    return it.nextElement();\n                } else {\n                    it.nextElement();\n                }\n            }\n        } \n        else if(obj instanceof Iterator) {\n            return index((Iterator)obj, idx);\n        }\n        else if(obj instanceof Collection) {\n            Iterator iterator = ((Collection)obj).iterator();\n            return index(iterator, idx);\n        }\n        return obj;\n    }\n\n    private static Object index(Iterator iterator, int idx) {\n        while(iterator.hasNext()) {\n            idx--;\n            if(idx == -1) {\n                return iterator.next();\n            } else {\n                iterator.next();\n            }\n        }\n        return iterator;\n    }\n    \n    /**\n     * Returns the <code>index</code>-th value in <code>object</code>, throwing\n     * <code>IndexOutOfBoundsException</code> if there is no such element or \n     * <code>IllegalArgumentException</code> if <code>object</code> is not an \n     * instance of one of the supported types.\n     * <p>\n     * The supported types, and associated semantics are:\n     * <ul>\n     * <li> Map -- the value returned is the <code>Map.Entry</code> in position \n     *      <code>index</code> in the map's <code>entrySet</code> iterator, \n     *      if there is such an entry.</li>\n     * <li> List -- this method is equivalent to the list's get method.</li>\n     * <li> Array -- the <code>index</code>-th array entry is returned, \n     *      if there is such an entry; otherwise an <code>IndexOutOfBoundsException</code>\n     *      is thrown.</li>\n     * <li> Collection -- the value returned is the <code>index</code>-th object \n     *      returned by the collection's default iterator, if there is such an element.</li>\n     * <li> Iterator or Enumeration -- the value returned is the\n     *      <code>index</code>-th object in the Iterator/Enumeration, if there\n     *      is such an element.  The Iterator/Enumeration is advanced to \n     *      <code>index</code> (or to the end, if <code>index</code> exceeds the \n     *      number of entries) as a side effect of this method.</li>\n     * </ul>\n     * \n     * @param object  the object to get a value from\n     * @param index  the index to get\n     * @return the object at the specified index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     * @throws IllegalArgumentException if the object type is invalid\n     */\n    public static Object get(Object object, int index) {\n        if (index < 0) {\n            throw new IndexOutOfBoundsException(\"Index cannot be negative: \" + index);\n        }\n        if (object instanceof Map) {\n            Map map = (Map) object;\n            Iterator iterator = map.entrySet().iterator();\n            return get(iterator, index);\n        } else if (object instanceof List) {\n            return ((List) object).get(index);\n        } else if (object instanceof Object[]) {\n            return ((Object[]) object)[index];\n        } else if (object instanceof Iterator) {\n            Iterator it = (Iterator) object;\n            while (it.hasNext()) {\n                index--;\n                if (index == -1) {\n                    return it.next();\n                } else {\n                    it.next();\n                }\n            }\n            throw new IndexOutOfBoundsException(\"Entry does not exist: \" + index);\n        } else if (object instanceof Collection) {\n            Iterator iterator = ((Collection) object).iterator();\n            return get(iterator, index);\n        } else if (object instanceof Enumeration) {\n            Enumeration it = (Enumeration) object;\n            while (it.hasMoreElements()) {\n                index--;\n                if (index == -1) {\n                    return it.nextElement();\n                } else {\n                    it.nextElement();\n                }\n            }\n            throw new IndexOutOfBoundsException(\"Entry does not exist: \" + index);\n        } else if (object == null) {\n            throw new IllegalArgumentException(\"Unsupported object type: null\");\n        } else {\n            try {\n                return Array.get(object, index);\n            } catch (IllegalArgumentException ex) {\n                throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n            }\n        }\n    }\n    \n    /** \n     * Gets the size of the collection/iterator specified.\n     * <p>\n     * This method can handles objects as follows\n     * <ul>\n     * <li>Collection - the collection size\n     * <li>Map - the map size\n     * <li>Array - the array size\n     * <li>Iterator - the number of elements remaining in the iterator\n     * <li>Enumeration - the number of elements remaining in the enumeration\n     * </ul>\n     * \n     * @param object  the object to get the size of\n     * @return the size of the specified collection\n     * @throws IllegalArgumentException thrown if object is not recognised or null\n     * @since Commons Collections 3.1\n     */\n    public static int size(Object object) {\n        int total = 0;\n        if (object instanceof Map) {\n            total = ((Map) object).size();\n        } else if (object instanceof Collection) {\n            total = ((Collection) object).size();\n        } else if (object instanceof Object[]) {\n            total = ((Object[]) object).length;\n        } else if (object instanceof Iterator) {\n            Iterator it = (Iterator) object;\n            while (it.hasNext()) {\n                total++;\n                it.next();\n            }\n        } else if (object instanceof Enumeration) {\n            Enumeration it = (Enumeration) object;\n            while (it.hasMoreElements()) {\n                total++;\n                it.nextElement();\n            }\n        } else if (object == null) {\n            throw new IllegalArgumentException(\"Unsupported object type: null\");\n        } else {\n            try {\n                total = Array.getLength(object);\n            } catch (IllegalArgumentException ex) {\n                throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n            }\n        }\n        return total;\n    }\n    \n    /**\n     * Checks if the specified collection/array/iterator is empty.\n     * <p>\n     * This method can handles objects as follows\n     * <ul>\n     * <li>Collection - via collection isEmpty\n     * <li>Map - via map isEmpty\n     * <li>Array - using array size\n     * <li>Iterator - via hasNext\n     * <li>Enumeration - via hasMoreElements\n     * </ul>\n     * <p>\n     * Note: This method is named to avoid clashing with\n     * {@link #isEmpty(Collection)}.\n     * \n     * @param object  the object to get the size of, not null\n     * @return true if empty\n     * @throws IllegalArgumentException thrown if object is not recognised or null\n     * @since Commons Collections 3.2\n     */\n    public static boolean sizeIsEmpty(Object object) {\n        if (object instanceof Collection) {\n            return ((Collection) object).isEmpty();\n        } else if (object instanceof Map) {\n            return ((Map) object).isEmpty();\n        } else if (object instanceof Object[]) {\n            return ((Object[]) object).length == 0;\n        } else if (object instanceof Iterator) {\n            return ((Iterator) object).hasNext() == false;\n        } else if (object instanceof Enumeration) {\n            return ((Enumeration) object).hasMoreElements() == false;\n        } else if (object == null) {\n            throw new IllegalArgumentException(\"Unsupported object type: null\");\n        } else {\n            try {\n                return Array.getLength(object) == 0;\n            } catch (IllegalArgumentException ex) {\n                throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n            }\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Null-safe check if the specified collection is empty.\n     * <p>\n     * Null returns true.\n     * \n     * @param coll  the collection to check, may be null\n     * @return true if empty or null\n     * @since Commons Collections 3.2\n     */\n    public static boolean isEmpty(Collection coll) {\n        return (coll == null || coll.isEmpty());\n    }\n\n    /**\n     * Null-safe check if the specified collection is not empty.\n     * <p>\n     * Null returns false.\n     * \n     * @param coll  the collection to check, may be null\n     * @return true if non-null and non-empty\n     * @since Commons Collections 3.2\n     */\n    public static boolean isNotEmpty(Collection coll) {\n        return !CollectionUtils.isEmpty(coll);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Reverses the order of the given array.\n     * \n     * @param array  the array to reverse\n     */\n    public static void reverseArray(Object[] array) {\n        int i = 0;\n        int j = array.length - 1;\n        Object tmp;\n\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    private static final int getFreq(final Object obj, final Map freqMap) {\n        Integer count = (Integer) freqMap.get(obj);\n        if (count != null) {\n            return count.intValue();\n        }\n        return 0;\n    }\n\n    /**\n     * Returns true if no more elements can be added to the Collection.\n     * <p>\n     * This method uses the {@link BoundedCollection} interface to determine the\n     * full status. If the collection does not implement this interface then\n     * false is returned.\n     * <p>\n     * The collection does not have to implement this interface directly.\n     * If the collection has been decorated using the decorators subpackage\n     * then these will be removed to access the BoundedCollection.\n     *\n     * @param coll  the collection to check\n     * @return true if the BoundedCollection is full\n     * @throws NullPointerException if the collection is null\n     */\n    public static boolean isFull(Collection coll) {\n        if (coll == null) {\n            throw new NullPointerException(\"The collection must not be null\");\n        }\n        if (coll instanceof BoundedCollection) {\n            return ((BoundedCollection) coll).isFull();\n        }\n        try {\n            BoundedCollection bcoll = UnmodifiableBoundedCollection.decorateUsing(coll);\n            return bcoll.isFull();\n            \n        } catch (IllegalArgumentException ex) {\n            return false;\n        }\n    }\n\n    /**\n     * Get the maximum number of elements that the Collection can contain.\n     * <p>\n     * This method uses the {@link BoundedCollection} interface to determine the\n     * maximum size. If the collection does not implement this interface then\n     * -1 is returned.\n     * <p>\n     * The collection does not have to implement this interface directly.\n     * If the collection has been decorated using the decorators subpackage\n     * then these will be removed to access the BoundedCollection.\n     *\n     * @param coll  the collection to check\n     * @return the maximum size of the BoundedCollection, -1 if no maximum size\n     * @throws NullPointerException if the collection is null\n     */\n    public static int maxSize(Collection coll) {\n        if (coll == null) {\n            throw new NullPointerException(\"The collection must not be null\");\n        }\n        if (coll instanceof BoundedCollection) {\n            return ((BoundedCollection) coll).maxSize();\n        }\n        try {\n            BoundedCollection bcoll = UnmodifiableBoundedCollection.decorateUsing(coll);\n            return bcoll.maxSize();\n            \n        } catch (IllegalArgumentException ex) {\n            return -1;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a collection containing all the elements in <code>collection</code>\n     * that are also in <code>retain</code>. The cardinality of an element <code>e</code>\n     * in the returned collection is the same as the cardinality of <code>e</code>\n     * in <code>collection</code> unless <code>retain</code> does not contain <code>e</code>, in which\n     * case the cardinality is zero. This method is useful if you do not wish to modify\n     * the collection <code>c</code> and thus cannot call <code>c.retainAll(retain);</code>.\n     * \n     * @param collection  the collection whose contents are the target of the #retailAll operation\n     * @param retain  the collection containing the elements to be retained in the returned collection\n     * @return a <code>Collection</code> containing all the elements of <code>collection</code>\n     * that occur at least once in <code>retain</code>.\n     * @throws NullPointerException if either parameter is null\n     * @since Commons Collections 3.2\n     */\n    public static Collection retainAll(Collection collection, Collection retain) {\n        return ListUtils.retainAll(collection, retain);\n    }\n\n    /**\n     * Removes the elements in <code>remove</code> from <code>collection</code>. That is, this\n     * method returns a collection containing all the elements in <code>c</code>\n     * that are not in <code>remove</code>. The cardinality of an element <code>e</code>\n     * in the returned collection is the same as the cardinality of <code>e</code>\n     * in <code>collection</code> unless <code>remove</code> contains <code>e</code>, in which\n     * case the cardinality is zero. This method is useful if you do not wish to modify\n     * the collection <code>c</code> and thus cannot call <code>collection.removeAll(remove);</code>.\n     * \n     * @param collection  the collection from which items are removed (in the returned collection)\n     * @param remove  the items to be removed from the returned <code>collection</code>\n     * @return a <code>Collection</code> containing all the elements of <code>collection</code> except\n     * any elements that also occur in <code>remove</code>.\n     * @throws NullPointerException if either parameter is null\n     * @since Commons Collections 3.3 (method existed in 3.2 but was completely broken)\n     */\n    public static Collection removeAll(Collection collection, Collection remove) {\n        return ListUtils.removeAll(collection, remove);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a synchronized collection backed by the given collection.\n     * <p>\n     * You must manually synchronize on the returned buffer's iterator to \n     * avoid non-deterministic behavior:\n     *  \n     * <pre>\n     * Collection c = CollectionUtils.synchronizedCollection(myCollection);\n     * synchronized (c) {\n     *     Iterator i = c.iterator();\n     *     while (i.hasNext()) {\n     *         process (i.next());\n     *     }\n     * }\n     * </pre>\n     * \n     * This method uses the implementation in the decorators subpackage.\n     * \n     * @param collection  the collection to synchronize, must not be null\n     * @return a synchronized collection backed by the given collection\n     * @throws IllegalArgumentException  if the collection is null\n     */\n    public static Collection synchronizedCollection(Collection collection) {\n        return SynchronizedCollection.decorate(collection);\n    }\n\n    /**\n     * Returns an unmodifiable collection backed by the given collection.\n     * <p>\n     * This method uses the implementation in the decorators subpackage.\n     *\n     * @param collection  the collection to make unmodifiable, must not be null\n     * @return an unmodifiable collection backed by the given collection\n     * @throws IllegalArgumentException  if the collection is null\n     */\n    public static Collection unmodifiableCollection(Collection collection) {\n        return UnmodifiableCollection.decorate(collection);\n    }\n\n    /**\n     * Returns a predicated (validating) collection backed by the given collection.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to the collection.\n     * Trying to add an invalid object results in an IllegalArgumentException.\n     * It is important not to use the original collection after invoking this method,\n     * as it is a backdoor for adding invalid objects.\n     *\n     * @param collection  the collection to predicate, must not be null\n     * @param predicate  the predicate for the collection, must not be null\n     * @return a predicated collection backed by the given collection\n     * @throws IllegalArgumentException  if the Collection is null\n     */\n    public static Collection predicatedCollection(Collection collection, Predicate predicate) {\n        return PredicatedCollection.decorate(collection, predicate);\n    }\n\n    /**\n     * Returns a typed collection backed by the given collection.\n     * <p>\n     * Only objects of the specified type can be added to the collection.\n     * \n     * @param collection  the collection to limit to a specific type, must not be null\n     * @param type  the type of objects which may be added to the collection\n     * @return a typed collection backed by the specified collection\n     */\n    public static Collection typedCollection(Collection collection, Class type) {\n        return TypedCollection.decorate(collection, type);\n    }\n    \n    /**\n     * Returns a transformed bag backed by the given collection.\n     * <p>\n     * Each object is passed through the transformer as it is added to the\n     * Collection. It is important not to use the original collection after invoking this \n     * method, as it is a backdoor for adding untransformed objects.\n     *\n     * @param collection  the collection to predicate, must not be null\n     * @param transformer  the transformer for the collection, must not be null\n     * @return a transformed collection backed by the given collection\n     * @throws IllegalArgumentException  if the Collection or Transformer is null\n     */\n    public static Collection transformedCollection(Collection collection, Transformer transformer) {\n        return TransformedCollection.decorate(collection, transformer);\n    }\n\n}\n"}]}
{"project": "Collections", "bug_id": 4, "classes_modified": [{"class_name": "org.apache.commons.collections.map.MultiValueMap", "buggy_version": "/*\n *  Copyright 2001-2005 The Apache Software Foundation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.apache.commons.collections.map;\n\nimport java.util.AbstractCollection;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.apache.commons.collections.Factory;\nimport org.apache.commons.collections.FunctorException;\nimport org.apache.commons.collections.MultiMap;\nimport org.apache.commons.collections.iterators.EmptyIterator;\nimport org.apache.commons.collections.iterators.IteratorChain;\n\n/**\n * A MultiValueMap decorates another map, allowing it to have\n * more than one value for a key.\n * <p>\n * A <code>MultiMap</code> is a Map with slightly different semantics.\n * Putting a value into the map will add the value to a Collection at that key.\n * Getting a value will return a Collection, holding all the values put to that key.\n * <p>\n * This implementation is a decorator, allowing any Map implementation\n * to be used as the base.\n * <p>\n * In addition, this implementation allows the type of collection used\n * for the values to be controlled. By default, an <code>ArrayList</code>\n * is used, however a <code>Class</code> to instantiate may be specified,\n * or a factory that returns a <code>Collection</code> instance.\n * <p>\n * <strong>Note that MultiValueMap is not synchronized and is not thread-safe.</strong>\n * If you wish to use this map from multiple threads concurrently, you must use\n * appropriate synchronization. This class may throw exceptions when accessed\n * by concurrent threads without synchronization.\n *\n * @author James Carman\n * @author Christopher Berry\n * @author James Strachan\n * @author Steve Downey\n * @author Stephen Colebourne\n * @author Julien Buret\n * @author Serhiy Yevtushenko\n * @version $Revision$ $Date$\n * @since Commons Collections 3.2\n */\npublic class MultiValueMap extends AbstractMapDecorator implements MultiMap {\n\n    /** The factory for creating value collections. */\n    private final Factory collectionFactory;\n    /** The cached values. */\n    private transient Collection values;\n\n    /**\n     * Creates a map which wraps the given map and\n     * maps keys to ArrayLists.\n     *\n     * @param map  the map to wrap\n     */\n    public static MultiValueMap decorate(Map map) {\n        return new MultiValueMap(map, new ReflectionFactory(ArrayList.class));\n    }\n\n    /**\n     * Creates a map which decorates the given <code>map</code> and\n     * maps keys to collections of type <code>collectionClass</code>.\n     *\n     * @param map  the map to wrap\n     * @param collectionClass  the type of the collection class\n     */\n    public static MultiValueMap decorate(Map map, Class collectionClass) {\n        return new MultiValueMap(map, new ReflectionFactory(collectionClass));\n    }\n\n    /**\n     * Creates a map which decorates the given <code>map</code> and\n     * creates the value collections using the supplied <code>collectionFactory</code>.\n     *\n     * @param map  the map to decorate\n     * @param collectionFactory  the collection factory (must return a Collection object).\n     */\n    public static MultiValueMap decorate(Map map, Factory collectionFactory) {\n        return new MultiValueMap(map, collectionFactory);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Creates a MultiValueMap based on a <code>HashMap</code> and\n     * storing the multiple values in an <code>ArrayList</code>.\n     */\n    public MultiValueMap() {\n        this(new HashMap(), new ReflectionFactory(ArrayList.class));\n    }\n\n    /**\n     * Creates a MultiValueMap which decorates the given <code>map</code> and\n     * creates the value collections using the supplied <code>collectionFactory</code>.\n     *\n     * @param map  the map to decorate\n     * @param collectionFactory  the collection factory which must return a Collection instance\n     */\n    protected MultiValueMap(Map map, Factory collectionFactory) {\n        super(map);\n        if (collectionFactory == null) {\n            throw new IllegalArgumentException(\"The factory must not be null\");\n        }\n        this.collectionFactory = collectionFactory;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Clear the map.\n     */\n    public void clear() {\n        // If you believe that you have GC issues here, try uncommenting this code\n//        Set pairs = getMap().entrySet();\n//        Iterator pairsIterator = pairs.iterator();\n//        while (pairsIterator.hasNext()) {\n//            Map.Entry keyValuePair = (Map.Entry) pairsIterator.next();\n//            Collection coll = (Collection) keyValuePair.getValue();\n//            coll.clear();\n//        }\n        getMap().clear();\n    }\n\n    /**\n     * Removes a specific value from map.\n     * <p>\n     * The item is removed from the collection mapped to the specified key.\n     * Other values attached to that key are unaffected.\n     * <p>\n     * If the last value for a key is removed, <code>null</code> will be returned\n     * from a subsequant <code>get(key)</code>.\n     *\n     * @param key  the key to remove from\n     * @param value the value to remove\n     * @return the value removed (which was passed in), null if nothing removed\n     */\n    public Object removeMapping(Object key, Object value) {\n        Collection valuesForKey = getCollection(key);\n        if (valuesForKey == null) {\n            return null;\n        }\n        boolean removed = valuesForKey.remove(value);\n        if (removed == false) {\n            return null;\n        }\n        if (valuesForKey.isEmpty()) {\n            remove(key);\n        }\n        return value;\n    }\n\n    /**\n     * Checks whether the map contains the value specified.\n     * <p>\n     * This checks all collections against all keys for the value, and thus could be slow.\n     *\n     * @param value  the value to search for\n     * @return true if the map contains the value\n     */\n    public boolean containsValue(Object value) {\n        Set pairs = getMap().entrySet();\n        if (pairs == null) {\n            return false;\n        }\n        Iterator pairsIterator = pairs.iterator();\n        while (pairsIterator.hasNext()) {\n            Map.Entry keyValuePair = (Map.Entry) pairsIterator.next();\n            Collection coll = (Collection) keyValuePair.getValue();\n            if (coll.contains(value)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Adds the value to the collection associated with the specified key.\n     * <p>\n     * Unlike a normal <code>Map</code> the previous value is not replaced.\n     * Instead the new value is added to the collection stored against the key.\n     *\n     * @param key  the key to store against\n     * @param value  the value to add to the collection at the key\n     * @return the value added if the map changed and null if the map did not change\n     */\n    public Object put(Object key, Object value) {\n        boolean result = false;\n        Collection coll = getCollection(key);\n        if (coll == null) {\n            coll = createCollection(1);  // might produce a non-empty collection\n            result = coll.add(value);\n            if (coll.size() > 0) {\n                // only add if non-zero size to maintain class state\n                getMap().put(key, coll);\n                result = false;\n            }\n        } else {\n            result = coll.add(value);\n        }\n        return (result ? value : null);\n    }\n\n    /**\n     * Override superclass to ensure that MultiMap instances are\n     * correctly handled.\n     * <p>\n     * If you call this method with a normal map, each entry is\n     * added using <code>put(Object,Object)</code>.\n     * If you call this method with a multi map, each entry is\n     * added using <code>putAll(Object,Collection)</code>.\n     *\n     * @param map  the map to copy (either a normal or multi map)\n     */\n    public void putAll(Map map) {\n        if (map instanceof MultiMap) {\n            for (Iterator it = map.entrySet().iterator(); it.hasNext();) {\n                Map.Entry entry = (Map.Entry) it.next();\n                Collection coll = (Collection) entry.getValue();\n                putAll(entry.getKey(), coll);\n            }\n        } else {\n            for (Iterator it = map.entrySet().iterator(); it.hasNext();) {\n                Map.Entry entry = (Map.Entry) it.next();\n                put(entry.getKey(), entry.getValue());\n            }\n        }\n    }\n\n    /**\n     * Gets a collection containing all the values in the map.\n     * <p>\n     * This returns a collection containing the combination of values from all keys.\n     *\n     * @return a collection view of the values contained in this map\n     */\n    public Collection values() {\n        Collection vs = values;\n        return (vs != null ? vs : (values = new Values()));\n    }\n\n    /**\n     * Checks whether the collection at the specified key contains the value.\n     *\n     * @param value  the value to search for\n     * @return true if the map contains the value\n     */\n    public boolean containsValue(Object key, Object value) {\n        Collection coll = getCollection(key);\n        if (coll == null) {\n            return false;\n        }\n        return coll.contains(value);\n    }\n\n    /**\n     * Gets the collection mapped to the specified key.\n     * This method is a convenience method to typecast the result of <code>get(key)</code>.\n     *\n     * @param key  the key to retrieve\n     * @return the collection mapped to the key, null if no mapping\n     */\n    public Collection getCollection(Object key) {\n        return (Collection) getMap().get(key);\n    }\n\n    /**\n     * Gets the size of the collection mapped to the specified key.\n     *\n     * @param key  the key to get size for\n     * @return the size of the collection at the key, zero if key not in map\n     */\n    public int size(Object key) {\n        Collection coll = getCollection(key);\n        if (coll == null) {\n            return 0;\n        }\n        return coll.size();\n    }\n\n    /**\n     * Adds a collection of values to the collection associated with\n     * the specified key.\n     *\n     * @param key  the key to store against\n     * @param values  the values to add to the collection at the key, null ignored\n     * @return true if this map changed\n     */\n    public boolean putAll(Object key, Collection values) {\n        if (values == null || values.size() == 0) {\n            return false;\n        }\n        Collection coll = getCollection(key);\n        if (coll == null) {\n            coll = createCollection(values.size());  // might produce a non-empty collection\n            boolean result = coll.addAll(values);\n            if (coll.size() > 0) {\n                // only add if non-zero size to maintain class state\n                getMap().put(key, coll);\n                result = false;\n            }\n            return result;\n        } else {\n            return coll.addAll(values);\n        }\n    }\n\n    /**\n     * Gets an iterator for the collection mapped to the specified key.\n     *\n     * @param key  the key to get an iterator for\n     * @return the iterator of the collection at the key, empty iterator if key not in map\n     */\n    public Iterator iterator(Object key) {\n        if (!containsKey(key)) {\n            return EmptyIterator.INSTANCE;\n        } else {\n            return new ValuesIterator(key);\n        }\n    }\n\n    /**\n     * Gets the total size of the map by counting all the values.\n     *\n     * @return the total size of the map counting all values\n     */\n    public int totalSize() {\n        int total = 0;\n        Collection values = getMap().values();\n        for (Iterator it = values.iterator(); it.hasNext();) {\n            Collection coll = (Collection) it.next();\n            total += coll.size();\n        }\n        return total;\n    }\n\n    /**\n     * Creates a new instance of the map value Collection container\n     * using the factory.\n     * <p>\n     * This method can be overridden to perform your own processing\n     * instead of using the factory.\n     *\n     * @param size  the collection size that is about to be added\n     * @return the new collection\n     */\n    protected Collection createCollection(int size) {\n        return (Collection) collectionFactory.create();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Inner class that provides the values view.\n     */\n    private class Values extends AbstractCollection {\n        public Iterator iterator() {\n            final IteratorChain chain = new IteratorChain();\n            for (Iterator it = keySet().iterator(); it.hasNext();) {\n                chain.addIterator(new ValuesIterator(it.next()));\n            }\n            return chain;\n        }\n\n        public int size() {\n            return totalSize();\n        }\n\n        public void clear() {\n            MultiValueMap.this.clear();\n        }\n    }\n\n    /**\n     * Inner class that provides the values iterator.\n     */\n    private class ValuesIterator implements Iterator {\n        private final Object key;\n        private final Collection values;\n        private final Iterator iterator;\n\n        public ValuesIterator(Object key) {\n            this.key = key;\n            this.values = getCollection(key);\n            this.iterator = values.iterator();\n        }\n\n        public void remove() {\n            iterator.remove();\n            if (values.isEmpty()) {\n                MultiValueMap.this.remove(key);\n            }\n        }\n\n        public boolean hasNext() {\n            return iterator.hasNext();\n        }\n\n        public Object next() {\n            return iterator.next();\n        }\n    }\n\n    /**\n     * Inner class that provides a simple reflection factory.\n     */\n    private static class ReflectionFactory implements Factory {\n        private final Class clazz;\n\n        public ReflectionFactory(Class clazz) {\n            this.clazz = clazz;\n        }\n\n        public Object create() {\n            try {\n                return clazz.newInstance();\n            } catch (Exception ex) {\n                throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex);\n            }\n        }\n    }\n\n}\n", "fixed_version": "/*\n *  Copyright 2001-2005 The Apache Software Foundation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.apache.commons.collections.map;\n\nimport java.util.AbstractCollection;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.apache.commons.collections.Factory;\nimport org.apache.commons.collections.FunctorException;\nimport org.apache.commons.collections.MultiMap;\nimport org.apache.commons.collections.iterators.EmptyIterator;\nimport org.apache.commons.collections.iterators.IteratorChain;\n\n/**\n * A MultiValueMap decorates another map, allowing it to have\n * more than one value for a key.\n * <p>\n * A <code>MultiMap</code> is a Map with slightly different semantics.\n * Putting a value into the map will add the value to a Collection at that key.\n * Getting a value will return a Collection, holding all the values put to that key.\n * <p>\n * This implementation is a decorator, allowing any Map implementation\n * to be used as the base.\n * <p>\n * In addition, this implementation allows the type of collection used\n * for the values to be controlled. By default, an <code>ArrayList</code>\n * is used, however a <code>Class</code> to instantiate may be specified,\n * or a factory that returns a <code>Collection</code> instance.\n * <p>\n * <strong>Note that MultiValueMap is not synchronized and is not thread-safe.</strong>\n * If you wish to use this map from multiple threads concurrently, you must use\n * appropriate synchronization. This class may throw exceptions when accessed\n * by concurrent threads without synchronization.\n *\n * @author James Carman\n * @author Christopher Berry\n * @author James Strachan\n * @author Steve Downey\n * @author Stephen Colebourne\n * @author Julien Buret\n * @author Serhiy Yevtushenko\n * @version $Revision$ $Date$\n * @since Commons Collections 3.2\n */\npublic class MultiValueMap extends AbstractMapDecorator implements MultiMap {\n\n    /** The factory for creating value collections. */\n    private final Factory collectionFactory;\n    /** The cached values. */\n    private transient Collection values;\n\n    /**\n     * Creates a map which wraps the given map and\n     * maps keys to ArrayLists.\n     *\n     * @param map  the map to wrap\n     */\n    public static MultiValueMap decorate(Map map) {\n        return new MultiValueMap(map, new ReflectionFactory(ArrayList.class));\n    }\n\n    /**\n     * Creates a map which decorates the given <code>map</code> and\n     * maps keys to collections of type <code>collectionClass</code>.\n     *\n     * @param map  the map to wrap\n     * @param collectionClass  the type of the collection class\n     */\n    public static MultiValueMap decorate(Map map, Class collectionClass) {\n        return new MultiValueMap(map, new ReflectionFactory(collectionClass));\n    }\n\n    /**\n     * Creates a map which decorates the given <code>map</code> and\n     * creates the value collections using the supplied <code>collectionFactory</code>.\n     *\n     * @param map  the map to decorate\n     * @param collectionFactory  the collection factory (must return a Collection object).\n     */\n    public static MultiValueMap decorate(Map map, Factory collectionFactory) {\n        return new MultiValueMap(map, collectionFactory);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Creates a MultiValueMap based on a <code>HashMap</code> and\n     * storing the multiple values in an <code>ArrayList</code>.\n     */\n    public MultiValueMap() {\n        this(new HashMap(), new ReflectionFactory(ArrayList.class));\n    }\n\n    /**\n     * Creates a MultiValueMap which decorates the given <code>map</code> and\n     * creates the value collections using the supplied <code>collectionFactory</code>.\n     *\n     * @param map  the map to decorate\n     * @param collectionFactory  the collection factory which must return a Collection instance\n     */\n    protected MultiValueMap(Map map, Factory collectionFactory) {\n        super(map);\n        if (collectionFactory == null) {\n            throw new IllegalArgumentException(\"The factory must not be null\");\n        }\n        this.collectionFactory = collectionFactory;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Clear the map.\n     */\n    public void clear() {\n        // If you believe that you have GC issues here, try uncommenting this code\n//        Set pairs = getMap().entrySet();\n//        Iterator pairsIterator = pairs.iterator();\n//        while (pairsIterator.hasNext()) {\n//            Map.Entry keyValuePair = (Map.Entry) pairsIterator.next();\n//            Collection coll = (Collection) keyValuePair.getValue();\n//            coll.clear();\n//        }\n        getMap().clear();\n    }\n\n    /**\n     * Removes a specific value from map.\n     * <p>\n     * The item is removed from the collection mapped to the specified key.\n     * Other values attached to that key are unaffected.\n     * <p>\n     * If the last value for a key is removed, <code>null</code> will be returned\n     * from a subsequant <code>get(key)</code>.\n     *\n     * @param key  the key to remove from\n     * @param value the value to remove\n     * @return the value removed (which was passed in), null if nothing removed\n     */\n    public Object removeMapping(Object key, Object value) {\n        Collection valuesForKey = getCollection(key);\n        if (valuesForKey == null) {\n            return null;\n        }\n        boolean removed = valuesForKey.remove(value);\n        if (removed == false) {\n            return null;\n        }\n        if (valuesForKey.isEmpty()) {\n            remove(key);\n        }\n        return value;\n    }\n\n    /**\n     * Checks whether the map contains the value specified.\n     * <p>\n     * This checks all collections against all keys for the value, and thus could be slow.\n     *\n     * @param value  the value to search for\n     * @return true if the map contains the value\n     */\n    public boolean containsValue(Object value) {\n        Set pairs = getMap().entrySet();\n        if (pairs == null) {\n            return false;\n        }\n        Iterator pairsIterator = pairs.iterator();\n        while (pairsIterator.hasNext()) {\n            Map.Entry keyValuePair = (Map.Entry) pairsIterator.next();\n            Collection coll = (Collection) keyValuePair.getValue();\n            if (coll.contains(value)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Adds the value to the collection associated with the specified key.\n     * <p>\n     * Unlike a normal <code>Map</code> the previous value is not replaced.\n     * Instead the new value is added to the collection stored against the key.\n     *\n     * @param key  the key to store against\n     * @param value  the value to add to the collection at the key\n     * @return the value added if the map changed and null if the map did not change\n     */\n    public Object put(Object key, Object value) {\n        boolean result = false;\n        Collection coll = getCollection(key);\n        if (coll == null) {\n            coll = createCollection(1);  // might produce a non-empty collection\n            coll.add(value);\n            if (coll.size() > 0) {\n                // only add if non-zero size to maintain class state\n                getMap().put(key, coll);\n                result = true;  // map definitely changed\n            }\n        } else {\n            result = coll.add(value);\n        }\n        return (result ? value : null);\n    }\n\n    /**\n     * Override superclass to ensure that MultiMap instances are\n     * correctly handled.\n     * <p>\n     * If you call this method with a normal map, each entry is\n     * added using <code>put(Object,Object)</code>.\n     * If you call this method with a multi map, each entry is\n     * added using <code>putAll(Object,Collection)</code>.\n     *\n     * @param map  the map to copy (either a normal or multi map)\n     */\n    public void putAll(Map map) {\n        if (map instanceof MultiMap) {\n            for (Iterator it = map.entrySet().iterator(); it.hasNext();) {\n                Map.Entry entry = (Map.Entry) it.next();\n                Collection coll = (Collection) entry.getValue();\n                putAll(entry.getKey(), coll);\n            }\n        } else {\n            for (Iterator it = map.entrySet().iterator(); it.hasNext();) {\n                Map.Entry entry = (Map.Entry) it.next();\n                put(entry.getKey(), entry.getValue());\n            }\n        }\n    }\n\n    /**\n     * Gets a collection containing all the values in the map.\n     * <p>\n     * This returns a collection containing the combination of values from all keys.\n     *\n     * @return a collection view of the values contained in this map\n     */\n    public Collection values() {\n        Collection vs = values;\n        return (vs != null ? vs : (values = new Values()));\n    }\n\n    /**\n     * Checks whether the collection at the specified key contains the value.\n     *\n     * @param value  the value to search for\n     * @return true if the map contains the value\n     */\n    public boolean containsValue(Object key, Object value) {\n        Collection coll = getCollection(key);\n        if (coll == null) {\n            return false;\n        }\n        return coll.contains(value);\n    }\n\n    /**\n     * Gets the collection mapped to the specified key.\n     * This method is a convenience method to typecast the result of <code>get(key)</code>.\n     *\n     * @param key  the key to retrieve\n     * @return the collection mapped to the key, null if no mapping\n     */\n    public Collection getCollection(Object key) {\n        return (Collection) getMap().get(key);\n    }\n\n    /**\n     * Gets the size of the collection mapped to the specified key.\n     *\n     * @param key  the key to get size for\n     * @return the size of the collection at the key, zero if key not in map\n     */\n    public int size(Object key) {\n        Collection coll = getCollection(key);\n        if (coll == null) {\n            return 0;\n        }\n        return coll.size();\n    }\n\n    /**\n     * Adds a collection of values to the collection associated with\n     * the specified key.\n     *\n     * @param key  the key to store against\n     * @param values  the values to add to the collection at the key, null ignored\n     * @return true if this map changed\n     */\n    public boolean putAll(Object key, Collection values) {\n        if (values == null || values.size() == 0) {\n            return false;\n        }\n        boolean result = false;\n        Collection coll = getCollection(key);\n        if (coll == null) {\n            coll = createCollection(values.size());  // might produce a non-empty collection\n            coll.addAll(values);\n            if (coll.size() > 0) {\n                // only add if non-zero size to maintain class state\n                getMap().put(key, coll);\n                result = true;  // map definitely changed\n            }\n        } else {\n            result = coll.addAll(values);\n        }\n        return result;\n    }\n\n    /**\n     * Gets an iterator for the collection mapped to the specified key.\n     *\n     * @param key  the key to get an iterator for\n     * @return the iterator of the collection at the key, empty iterator if key not in map\n     */\n    public Iterator iterator(Object key) {\n        if (!containsKey(key)) {\n            return EmptyIterator.INSTANCE;\n        } else {\n            return new ValuesIterator(key);\n        }\n    }\n\n    /**\n     * Gets the total size of the map by counting all the values.\n     *\n     * @return the total size of the map counting all values\n     */\n    public int totalSize() {\n        int total = 0;\n        Collection values = getMap().values();\n        for (Iterator it = values.iterator(); it.hasNext();) {\n            Collection coll = (Collection) it.next();\n            total += coll.size();\n        }\n        return total;\n    }\n\n    /**\n     * Creates a new instance of the map value Collection container\n     * using the factory.\n     * <p>\n     * This method can be overridden to perform your own processing\n     * instead of using the factory.\n     *\n     * @param size  the collection size that is about to be added\n     * @return the new collection\n     */\n    protected Collection createCollection(int size) {\n        return (Collection) collectionFactory.create();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Inner class that provides the values view.\n     */\n    private class Values extends AbstractCollection {\n        public Iterator iterator() {\n            final IteratorChain chain = new IteratorChain();\n            for (Iterator it = keySet().iterator(); it.hasNext();) {\n                chain.addIterator(new ValuesIterator(it.next()));\n            }\n            return chain;\n        }\n\n        public int size() {\n            return totalSize();\n        }\n\n        public void clear() {\n            MultiValueMap.this.clear();\n        }\n    }\n\n    /**\n     * Inner class that provides the values iterator.\n     */\n    private class ValuesIterator implements Iterator {\n        private final Object key;\n        private final Collection values;\n        private final Iterator iterator;\n\n        public ValuesIterator(Object key) {\n            this.key = key;\n            this.values = getCollection(key);\n            this.iterator = values.iterator();\n        }\n\n        public void remove() {\n            iterator.remove();\n            if (values.isEmpty()) {\n                MultiValueMap.this.remove(key);\n            }\n        }\n\n        public boolean hasNext() {\n            return iterator.hasNext();\n        }\n\n        public Object next() {\n            return iterator.next();\n        }\n    }\n\n    /**\n     * Inner class that provides a simple reflection factory.\n     */\n    private static class ReflectionFactory implements Factory {\n        private final Class clazz;\n\n        public ReflectionFactory(Class clazz) {\n            this.clazz = clazz;\n        }\n\n        public Object create() {\n            try {\n                return clazz.newInstance();\n            } catch (Exception ex) {\n                throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex);\n            }\n        }\n    }\n\n}\n"}]}
{"project": "Collections", "bug_id": 5, "classes_modified": [{"class_name": "org.apache.commons.collections.list.SetUniqueList", "buggy_version": "/*\n *  Licensed to the Apache Software Foundation (ASF) under one or more\n *  contributor license agreements.  See the NOTICE file distributed with\n *  this work for additional information regarding copyright ownership.\n *  The ASF licenses this file to You under the Apache License, Version 2.0\n *  (the \"License\"); you may not use this file except in compliance with\n *  the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.apache.commons.collections.list;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Set;\n\nimport org.apache.commons.collections.iterators.AbstractIteratorDecorator;\nimport org.apache.commons.collections.iterators.AbstractListIteratorDecorator;\nimport org.apache.commons.collections.set.UnmodifiableSet;\n\n/**\n * Decorates a <code>List</code> to ensure that no duplicates are present\n * much like a <code>Set</code>.\n * <p>\n * The <code>List</code> interface makes certain assumptions/requirements.\n * This implementation breaks these in certain ways, but this is merely the\n * result of rejecting duplicates.\n * Each violation is explained in the method, but it should not affect you.\n * Bear in mind that Sets require immutable objects to function correctly.\n * <p>\n * The {@link org.apache.commons.collections.set.ListOrderedSet ListOrderedSet}\n * class provides an alternative approach, by wrapping an existing Set and\n * retaining insertion order in the iterator.\n * <p>\n * This class is Serializable from Commons Collections 3.1.\n *\n * @since Commons Collections 3.0\n * @version $Revision$ $Date$\n * \n * @author Matthew Hawthorne\n * @author Stephen Colebourne\n * @author Tom Dunham\n */\npublic class SetUniqueList extends AbstractSerializableListDecorator {\n\n    /** Serialization version */\n    private static final long serialVersionUID = 7196982186153478694L;\n\n    /**\n     * Internal Set to maintain uniqueness.\n     */\n    protected final Set set;\n\n    /**\n     * Factory method to create a SetList using the supplied list to retain order.\n     * <p>\n     * If the list contains duplicates, these are removed (first indexed one kept).\n     * A <code>HashSet</code> is used for the set behaviour.\n     * \n     * @param list  the list to decorate, must not be null\n     * @throws IllegalArgumentException if list is null\n     */\n    public static SetUniqueList decorate(List list) {\n        if (list == null) {\n            throw new IllegalArgumentException(\"List must not be null\");\n        }\n        if (list.isEmpty()) {\n            return new SetUniqueList(list, new HashSet());\n        } else {\n            List temp = new ArrayList(list);\n            list.clear();\n            SetUniqueList sl = new SetUniqueList(list, new HashSet());\n            sl.addAll(temp);\n            return sl;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructor that wraps (not copies) the List and specifies the set to use.\n     * <p>\n     * The set and list must both be correctly initialised to the same elements.\n     * \n     * @param set  the set to decorate, must not be null\n     * @param list  the list to decorate, must not be null\n     * @throws IllegalArgumentException if set or list is null\n     */\n    protected SetUniqueList(List list, Set set) {\n        super(list);\n        if (set == null) {\n            throw new IllegalArgumentException(\"Set must not be null\");\n        }\n        this.set = set;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets an unmodifiable view as a Set.\n     * \n     * @return an unmodifiable set view\n     */\n    public Set asSet() {\n        return UnmodifiableSet.decorate(set);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Adds an element to the list if it is not already present.\n     * <p>\n     * <i>(Violation)</i>\n     * The <code>List</code> interface requires that this method returns\n     * <code>true</code> always. However this class may return <code>false</code>\n     * because of the <code>Set</code> behaviour.\n     * \n     * @param object the object to add\n     * @return true if object was added\n     */\n    public boolean add(Object object) {\n        // gets initial size\n        final int sizeBefore = size();\n\n        // adds element if unique\n        add(size(), object);\n\n        // compares sizes to detect if collection changed\n        return (sizeBefore != size());\n    }\n\n    /**\n     * Adds an element to a specific index in the list if it is not already present.\n     * <p>\n     * <i>(Violation)</i>\n     * The <code>List</code> interface makes the assumption that the element is\n     * always inserted. This may not happen with this implementation.\n     * \n     * @param index  the index to insert at\n     * @param object  the object to add\n     */\n    public void add(int index, Object object) {\n        // adds element if it is not contained already\n        if (set.contains(object) == false) {\n            super.add(index, object);\n            set.add(object);\n        }\n    }\n\n    /**\n     * Adds a collection of objects to the end of the list avoiding duplicates.\n     * <p>\n     * Only elements that are not already in this list will be added, and\n     * duplicates from the specified collection will be ignored.\n     * <p>\n     * <i>(Violation)</i>\n     * The <code>List</code> interface makes the assumption that the elements\n     * are always inserted. This may not happen with this implementation.\n     * \n     * @param coll  the collection to add in iterator order\n     * @return true if this collection changed\n     */\n    public boolean addAll(Collection coll) {\n        return addAll(size(), coll);\n    }\n\n    /**\n     * Adds a collection of objects a specific index in the list avoiding \n     * duplicates.\n     * <p>\n     * Only elements that are not already in this list will be added, and\n     * duplicates from the specified collection will be ignored.\n     * <p>\n     * <i>(Violation)</i>\n     * The <code>List</code> interface makes the assumption that the elements\n     * are always inserted. This may not happen with this implementation.\n     * \n     * @param index  the index to insert at\n     * @param coll  the collection to add in iterator order\n     * @return true if this collection changed\n     */\n    public boolean addAll(int index, Collection coll) {\n        // gets initial size\n        final int sizeBefore = size();\n\n        // adds all elements\n        for (final Iterator it = coll.iterator(); it.hasNext();) {\n            add(it.next());\n            // if it was inserted, then increase the target index\n        }\n\n        // compares sizes to detect if collection changed\n        return sizeBefore != size();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Sets the value at the specified index avoiding duplicates.\n     * <p>\n     * The object is set into the specified index.\n     * Afterwards, any previous duplicate is removed\n     * If the object is not already in the list then a normal set occurs.\n     * If it is present, then the old version is removed.\n     * \n     * @param index  the index to insert at\n     * @param object  the object to set\n     * @return the previous object\n     */\n    public Object set(int index, Object object) {\n        int pos = indexOf(object);\n        Object removed = super.set(index, object);\n        if (pos == -1 || pos == index) {\n            return removed;\n        }\n        \n        // the object is already in the uniq list\n        // (and it hasn't been swapped with itself)\n        super.remove(pos);  // remove the duplicate by index\n        set.remove(removed);  // remove the item deleted by the set\n        return removed;  // return the item deleted by the set\n    }\n\n    public boolean remove(Object object) {\n        boolean result = super.remove(object);\n        set.remove(object);\n        return result;\n    }\n\n    public Object remove(int index) {\n        Object result = super.remove(index);\n        set.remove(result);\n        return result;\n    }\n\n    public boolean removeAll(Collection coll) {\n        boolean result = super.removeAll(coll);\n        set.removeAll(coll);\n        return result;\n    }\n\n    public boolean retainAll(Collection coll) {\n        boolean result = super.retainAll(coll);\n        set.retainAll(coll);\n        return result;\n    }\n\n    public void clear() {\n        super.clear();\n        set.clear();\n    }\n\n    public boolean contains(Object object) {\n        return set.contains(object);\n    }\n\n    public boolean containsAll(Collection coll) {\n        return set.containsAll(coll);\n    }\n\n    public Iterator iterator() {\n        return new SetListIterator(super.iterator(), set);\n    }\n\n    public ListIterator listIterator() {\n        return new SetListListIterator(super.listIterator(), set);\n    }\n\n    public ListIterator listIterator(int index) {\n        return new SetListListIterator(super.listIterator(index), set);\n    }\n\n    public List subList(int fromIndex, int toIndex) {\n        return new SetUniqueList(super.subList(fromIndex, toIndex), set);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Inner class iterator.\n     */\n    static class SetListIterator extends AbstractIteratorDecorator {\n        \n        protected final Set set;\n        protected Object last = null;\n        \n        protected SetListIterator(Iterator it, Set set) {\n            super(it);\n            this.set = set;\n        }\n        \n        public Object next() {\n            last = super.next();\n            return last;\n        }\n\n        public void remove() {\n            super.remove();\n            set.remove(last);\n            last = null;\n        }\n    }\n    \n    /**\n     * Inner class iterator.\n     */\n    static class SetListListIterator extends AbstractListIteratorDecorator {\n        \n        protected final Set set;\n        protected Object last = null;\n        \n        protected SetListListIterator(ListIterator it, Set set) {\n            super(it);\n            this.set = set;\n        }\n        \n        public Object next() {\n            last = super.next();\n            return last;\n        }\n\n        public Object previous() {\n            last = super.previous();\n            return last;\n        }\n\n        public void remove() {\n            super.remove();\n            set.remove(last);\n            last = null;\n        }\n\n        public void add(Object object) {\n            if (set.contains(object) == false) {\n                super.add(object);\n                set.add(object);\n            }\n        }\n        \n        public void set(Object object) {\n            throw new UnsupportedOperationException(\"ListIterator does not support set\");\n        }\n    }\n    \n}\n", "fixed_version": "/*\n *  Licensed to the Apache Software Foundation (ASF) under one or more\n *  contributor license agreements.  See the NOTICE file distributed with\n *  this work for additional information regarding copyright ownership.\n *  The ASF licenses this file to You under the Apache License, Version 2.0\n *  (the \"License\"); you may not use this file except in compliance with\n *  the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.apache.commons.collections.list;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Set;\n\nimport org.apache.commons.collections.iterators.AbstractIteratorDecorator;\nimport org.apache.commons.collections.iterators.AbstractListIteratorDecorator;\nimport org.apache.commons.collections.set.UnmodifiableSet;\n\n/**\n * Decorates a <code>List</code> to ensure that no duplicates are present\n * much like a <code>Set</code>.\n * <p>\n * The <code>List</code> interface makes certain assumptions/requirements.\n * This implementation breaks these in certain ways, but this is merely the\n * result of rejecting duplicates.\n * Each violation is explained in the method, but it should not affect you.\n * Bear in mind that Sets require immutable objects to function correctly.\n * <p>\n * The {@link org.apache.commons.collections.set.ListOrderedSet ListOrderedSet}\n * class provides an alternative approach, by wrapping an existing Set and\n * retaining insertion order in the iterator.\n * <p>\n * This class is Serializable from Commons Collections 3.1.\n *\n * @since Commons Collections 3.0\n * @version $Revision$ $Date$\n * \n * @author Matthew Hawthorne\n * @author Stephen Colebourne\n * @author Tom Dunham\n */\npublic class SetUniqueList extends AbstractSerializableListDecorator {\n\n    /** Serialization version */\n    private static final long serialVersionUID = 7196982186153478694L;\n\n    /**\n     * Internal Set to maintain uniqueness.\n     */\n    protected final Set set;\n\n    /**\n     * Factory method to create a SetList using the supplied list to retain order.\n     * <p>\n     * If the list contains duplicates, these are removed (first indexed one kept).\n     * A <code>HashSet</code> is used for the set behaviour.\n     * \n     * @param list  the list to decorate, must not be null\n     * @throws IllegalArgumentException if list is null\n     */\n    public static SetUniqueList decorate(List list) {\n        if (list == null) {\n            throw new IllegalArgumentException(\"List must not be null\");\n        }\n        if (list.isEmpty()) {\n            return new SetUniqueList(list, new HashSet());\n        } else {\n            List temp = new ArrayList(list);\n            list.clear();\n            SetUniqueList sl = new SetUniqueList(list, new HashSet());\n            sl.addAll(temp);\n            return sl;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructor that wraps (not copies) the List and specifies the set to use.\n     * <p>\n     * The set and list must both be correctly initialised to the same elements.\n     * \n     * @param set  the set to decorate, must not be null\n     * @param list  the list to decorate, must not be null\n     * @throws IllegalArgumentException if set or list is null\n     */\n    protected SetUniqueList(List list, Set set) {\n        super(list);\n        if (set == null) {\n            throw new IllegalArgumentException(\"Set must not be null\");\n        }\n        this.set = set;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets an unmodifiable view as a Set.\n     * \n     * @return an unmodifiable set view\n     */\n    public Set asSet() {\n        return UnmodifiableSet.decorate(set);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Adds an element to the list if it is not already present.\n     * <p>\n     * <i>(Violation)</i>\n     * The <code>List</code> interface requires that this method returns\n     * <code>true</code> always. However this class may return <code>false</code>\n     * because of the <code>Set</code> behaviour.\n     * \n     * @param object the object to add\n     * @return true if object was added\n     */\n    public boolean add(Object object) {\n        // gets initial size\n        final int sizeBefore = size();\n\n        // adds element if unique\n        add(size(), object);\n\n        // compares sizes to detect if collection changed\n        return (sizeBefore != size());\n    }\n\n    /**\n     * Adds an element to a specific index in the list if it is not already present.\n     * <p>\n     * <i>(Violation)</i>\n     * The <code>List</code> interface makes the assumption that the element is\n     * always inserted. This may not happen with this implementation.\n     * \n     * @param index  the index to insert at\n     * @param object  the object to add\n     */\n    public void add(int index, Object object) {\n        // adds element if it is not contained already\n        if (set.contains(object) == false) {\n            super.add(index, object);\n            set.add(object);\n        }\n    }\n\n    /**\n     * Adds a collection of objects to the end of the list avoiding duplicates.\n     * <p>\n     * Only elements that are not already in this list will be added, and\n     * duplicates from the specified collection will be ignored.\n     * <p>\n     * <i>(Violation)</i>\n     * The <code>List</code> interface makes the assumption that the elements\n     * are always inserted. This may not happen with this implementation.\n     * \n     * @param coll  the collection to add in iterator order\n     * @return true if this collection changed\n     */\n    public boolean addAll(Collection coll) {\n        return addAll(size(), coll);\n    }\n\n    /**\n     * Adds a collection of objects a specific index in the list avoiding \n     * duplicates.\n     * <p>\n     * Only elements that are not already in this list will be added, and\n     * duplicates from the specified collection will be ignored.\n     * <p>\n     * <i>(Violation)</i>\n     * The <code>List</code> interface makes the assumption that the elements\n     * are always inserted. This may not happen with this implementation.\n     * \n     * @param index  the index to insert at\n     * @param coll  the collection to add in iterator order\n     * @return true if this collection changed\n     */\n    public boolean addAll(int index, Collection coll) {\n        // gets initial size\n        final int sizeBefore = size();\n\n        // adds all elements\n        for (final Iterator it = coll.iterator(); it.hasNext();) {\n            int sizeBeforeAddNext = size();\n            add(index, it.next());\n            // if it was inserted, then increase the target index\n            if (sizeBeforeAddNext != size()) {\n              index++;\n            }\n        }\n\n        // compares sizes to detect if collection changed\n        return sizeBefore != size();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Sets the value at the specified index avoiding duplicates.\n     * <p>\n     * The object is set into the specified index.\n     * Afterwards, any previous duplicate is removed\n     * If the object is not already in the list then a normal set occurs.\n     * If it is present, then the old version is removed.\n     * \n     * @param index  the index to insert at\n     * @param object  the object to set\n     * @return the previous object\n     */\n    public Object set(int index, Object object) {\n        int pos = indexOf(object);\n        Object removed = super.set(index, object);\n        if (pos == -1 || pos == index) {\n            return removed;\n        }\n        \n        // the object is already in the uniq list\n        // (and it hasn't been swapped with itself)\n        super.remove(pos);  // remove the duplicate by index\n        set.remove(removed);  // remove the item deleted by the set\n        return removed;  // return the item deleted by the set\n    }\n\n    public boolean remove(Object object) {\n        boolean result = super.remove(object);\n        set.remove(object);\n        return result;\n    }\n\n    public Object remove(int index) {\n        Object result = super.remove(index);\n        set.remove(result);\n        return result;\n    }\n\n    public boolean removeAll(Collection coll) {\n        boolean result = super.removeAll(coll);\n        set.removeAll(coll);\n        return result;\n    }\n\n    public boolean retainAll(Collection coll) {\n        boolean result = super.retainAll(coll);\n        set.retainAll(coll);\n        return result;\n    }\n\n    public void clear() {\n        super.clear();\n        set.clear();\n    }\n\n    public boolean contains(Object object) {\n        return set.contains(object);\n    }\n\n    public boolean containsAll(Collection coll) {\n        return set.containsAll(coll);\n    }\n\n    public Iterator iterator() {\n        return new SetListIterator(super.iterator(), set);\n    }\n\n    public ListIterator listIterator() {\n        return new SetListListIterator(super.listIterator(), set);\n    }\n\n    public ListIterator listIterator(int index) {\n        return new SetListListIterator(super.listIterator(index), set);\n    }\n\n    public List subList(int fromIndex, int toIndex) {\n        return new SetUniqueList(super.subList(fromIndex, toIndex), set);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Inner class iterator.\n     */\n    static class SetListIterator extends AbstractIteratorDecorator {\n        \n        protected final Set set;\n        protected Object last = null;\n        \n        protected SetListIterator(Iterator it, Set set) {\n            super(it);\n            this.set = set;\n        }\n        \n        public Object next() {\n            last = super.next();\n            return last;\n        }\n\n        public void remove() {\n            super.remove();\n            set.remove(last);\n            last = null;\n        }\n    }\n    \n    /**\n     * Inner class iterator.\n     */\n    static class SetListListIterator extends AbstractListIteratorDecorator {\n        \n        protected final Set set;\n        protected Object last = null;\n        \n        protected SetListListIterator(ListIterator it, Set set) {\n            super(it);\n            this.set = set;\n        }\n        \n        public Object next() {\n            last = super.next();\n            return last;\n        }\n\n        public Object previous() {\n            last = super.previous();\n            return last;\n        }\n\n        public void remove() {\n            super.remove();\n            set.remove(last);\n            last = null;\n        }\n\n        public void add(Object object) {\n            if (set.contains(object) == false) {\n                super.add(object);\n                set.add(object);\n            }\n        }\n        \n        public void set(Object object) {\n            throw new UnsupportedOperationException(\"ListIterator does not support set\");\n        }\n    }\n    \n}\n"}]}
{"project": "Collections", "bug_id": 6, "classes_modified": [{"class_name": "org.apache.commons.collections.map.Flat3Map", "buggy_version": "/*\n *  Licensed to the Apache Software Foundation (ASF) under one or more\n *  contributor license agreements.  See the NOTICE file distributed with\n *  this work for additional information regarding copyright ownership.\n *  The ASF licenses this file to You under the Apache License, Version 2.0\n *  (the \"License\"); you may not use this file except in compliance with\n *  the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.apache.commons.collections.map;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.AbstractCollection;\nimport java.util.AbstractSet;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Set;\n\nimport org.apache.commons.collections.IterableMap;\nimport org.apache.commons.collections.MapIterator;\nimport org.apache.commons.collections.ResettableIterator;\nimport org.apache.commons.collections.iterators.EmptyIterator;\nimport org.apache.commons.collections.iterators.EmptyMapIterator;\n\n/**\n * A <code>Map</code> implementation that stores data in simple fields until\n * the size is greater than 3.\n * <p>\n * This map is designed for performance and can outstrip HashMap.\n * It also has good garbage collection characteristics.\n * <ul>\n * <li>Optimised for operation at size 3 or less.\n * <li>Still works well once size 3 exceeded.\n * <li>Gets at size 3 or less are about 0-10% faster than HashMap,\n * <li>Puts at size 3 or less are over 4 times faster than HashMap.\n * <li>Performance 5% slower than HashMap once size 3 exceeded once.\n * </ul>\n * The design uses two distinct modes of operation - flat and delegate.\n * While the map is size 3 or less, operations map straight onto fields using\n * switch statements. Once size 4 is reached, the map switches to delegate mode\n * and only switches back when cleared. In delegate mode, all operations are\n * forwarded straight to a HashMap resulting in the 5% performance loss.\n * <p>\n * The performance gains on puts are due to not needing to create a Map Entry\n * object. This is a large saving not only in performance but in garbage collection.\n * <p>\n * Whilst in flat mode this map is also easy for the garbage collector to dispatch.\n * This is because it contains no complex objects or arrays which slow the progress.\n * <p>\n * Do not use <code>Flat3Map</code> if the size is likely to grow beyond 3.\n * <p>\n * <strong>Note that Flat3Map is not synchronized and is not thread-safe.</strong>\n * If you wish to use this map from multiple threads concurrently, you must use\n * appropriate synchronization. The simplest approach is to wrap this map\n * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw \n * exceptions when accessed by concurrent threads without synchronization.\n *\n * @since Commons Collections 3.0\n * @version $Revision$ $Date$\n *\n * @author Stephen Colebourne\n */\npublic class Flat3Map implements IterableMap, Serializable, Cloneable {\n\n    /** Serialization version */\n    private static final long serialVersionUID = -6701087419741928296L;\n\n    /** The size of the map, used while in flat mode */\n    private transient int size;\n    /** Hash, used while in flat mode */\n    private transient int hash1;\n    /** Hash, used while in flat mode */\n    private transient int hash2;\n    /** Hash, used while in flat mode */\n    private transient int hash3;\n    /** Key, used while in flat mode */\n    private transient Object key1;\n    /** Key, used while in flat mode */\n    private transient Object key2;\n    /** Key, used while in flat mode */\n    private transient Object key3;\n    /** Value, used while in flat mode */\n    private transient Object value1;\n    /** Value, used while in flat mode */\n    private transient Object value2;\n    /** Value, used while in flat mode */\n    private transient Object value3;\n    /** Map, used while in delegate mode */\n    private transient AbstractHashedMap delegateMap;\n\n    /**\n     * Constructor.\n     */\n    public Flat3Map() {\n        super();\n    }\n\n    /**\n     * Constructor copying elements from another map.\n     *\n     * @param map  the map to copy\n     * @throws NullPointerException if the map is null\n     */\n    public Flat3Map(Map map) {\n        super();\n        putAll(map);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the value mapped to the key specified.\n     * \n     * @param key  the key\n     * @return the mapped value, null if no match\n     */\n    public Object get(Object key) {\n        if (delegateMap != null) {\n            return delegateMap.get(key);\n        }\n        if (key == null) {\n            switch (size) {\n                // drop through\n                case 3:\n                    if (key3 == null) return value3;\n                case 2:\n                    if (key2 == null) return value2;\n                case 1:\n                    if (key1 == null) return value1;\n            }\n        } else {\n            if (size > 0) {\n                int hashCode = key.hashCode();\n                switch (size) {\n                    // drop through\n                    case 3:\n                        if (hash3 == hashCode && key.equals(key3)) return value3;\n                    case 2:\n                        if (hash2 == hashCode && key.equals(key2)) return value2;\n                    case 1:\n                        if (hash1 == hashCode && key.equals(key1)) return value1;\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Gets the size of the map.\n     * \n     * @return the size\n     */\n    public int size() {\n        if (delegateMap != null) {\n            return delegateMap.size();\n        }\n        return size;\n    }\n\n    /**\n     * Checks whether the map is currently empty.\n     * \n     * @return true if the map is currently size zero\n     */\n    public boolean isEmpty() {\n        return (size() == 0);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks whether the map contains the specified key.\n     * \n     * @param key  the key to search for\n     * @return true if the map contains the key\n     */\n    public boolean containsKey(Object key) {\n        if (delegateMap != null) {\n            return delegateMap.containsKey(key);\n        }\n        if (key == null) {\n            switch (size) {  // drop through\n                case 3:\n                    if (key3 == null) return true;\n                case 2:\n                    if (key2 == null) return true;\n                case 1:\n                    if (key1 == null) return true;\n            }\n        } else {\n            if (size > 0) {\n                int hashCode = key.hashCode();\n                switch (size) {  // drop through\n                    case 3:\n                        if (hash3 == hashCode && key.equals(key3)) return true;\n                    case 2:\n                        if (hash2 == hashCode && key.equals(key2)) return true;\n                    case 1:\n                        if (hash1 == hashCode && key.equals(key1)) return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Checks whether the map contains the specified value.\n     * \n     * @param value  the value to search for\n     * @return true if the map contains the key\n     */\n    public boolean containsValue(Object value) {\n        if (delegateMap != null) {\n            return delegateMap.containsValue(value);\n        }\n        if (value == null) {  // drop through\n            switch (size) {\n                case 3:\n                    if (value3 == null) return true;\n                case 2:\n                    if (value2 == null) return true;\n                case 1:\n                    if (value1 == null) return true;\n            }\n        } else {\n            switch (size) {  // drop through\n                case 3:\n                    if (value.equals(value3)) return true;\n                case 2:\n                    if (value.equals(value2)) return true;\n                case 1:\n                    if (value.equals(value1)) return true;\n            }\n        }\n        return false;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Puts a key-value mapping into this map.\n     * \n     * @param key  the key to add\n     * @param value  the value to add\n     * @return the value previously mapped to this key, null if none\n     */\n    public Object put(Object key, Object value) {\n        if (delegateMap != null) {\n            return delegateMap.put(key, value);\n        }\n        // change existing mapping\n        if (key == null) {\n            switch (size) {  // drop through\n                case 3:\n                    if (key3 == null) {\n                        Object old = value3;\n                        value3 = value;\n                        return old;\n                    }\n                case 2:\n                    if (key2 == null) {\n                        Object old = value2;\n                        value2 = value;\n                        return old;\n                    }\n                case 1:\n                    if (key1 == null) {\n                        Object old = value1;\n                        value1 = value;\n                        return old;\n                    }\n            }\n        } else {\n            if (size > 0) {\n                int hashCode = key.hashCode();\n                switch (size) {  // drop through\n                    case 3:\n                        if (hash3 == hashCode && key.equals(key3)) {\n                            Object old = value3;\n                            value3 = value;\n                            return old;\n                        }\n                    case 2:\n                        if (hash2 == hashCode && key.equals(key2)) {\n                            Object old = value2;\n                            value2 = value;\n                            return old;\n                        }\n                    case 1:\n                        if (hash1 == hashCode && key.equals(key1)) {\n                            Object old = value1;\n                            value1 = value;\n                            return old;\n                        }\n                }\n            }\n        }\n        \n        // add new mapping\n        switch (size) {\n            default:\n                convertToMap();\n                delegateMap.put(key, value);\n                return null;\n            case 2:\n                hash3 = (key == null ? 0 : key.hashCode());\n                key3 = key;\n                value3 = value;\n                break;\n            case 1:\n                hash2 = (key == null ? 0 : key.hashCode());\n                key2 = key;\n                value2 = value;\n                break;\n            case 0:\n                hash1 = (key == null ? 0 : key.hashCode());\n                key1 = key;\n                value1 = value;\n                break;\n        }\n        size++;\n        return null;\n    }\n\n    /**\n     * Puts all the values from the specified map into this map.\n     * \n     * @param map  the map to add\n     * @throws NullPointerException if the map is null\n     */\n    public void putAll(Map map) {\n        int size = map.size();\n        if (size == 0) {\n            return;\n        }\n        if (delegateMap != null) {\n            delegateMap.putAll(map);\n            return;\n        }\n        if (size < 4) {\n            for (Iterator it = map.entrySet().iterator(); it.hasNext();) {\n                Map.Entry entry = (Map.Entry) it.next();\n                put(entry.getKey(), entry.getValue());\n            }\n        } else {\n            convertToMap();\n            delegateMap.putAll(map);\n        }\n    }\n\n    /**\n     * Converts the flat map data to a map.\n     */\n    private void convertToMap() {\n        delegateMap = createDelegateMap();\n        switch (size) {  // drop through\n            case 3:\n                delegateMap.put(key3, value3);\n            case 2:\n                delegateMap.put(key2, value2);\n            case 1:\n                delegateMap.put(key1, value1);\n        }\n        \n        size = 0;\n        hash1 = hash2 = hash3 = 0;\n        key1 = key2 = key3 = null;\n        value1 = value2 = value3 = null;\n    }\n\n    /**\n     * Create an instance of the map used for storage when in delegation mode.\n     * <p>\n     * This can be overridden by subclasses to provide a different map implementation.\n     * Not every AbstractHashedMap is suitable, identity and reference based maps\n     * would be poor choices.\n     *\n     * @return a new AbstractHashedMap or subclass\n     * @since Commons Collections 3.1\n     */\n    protected AbstractHashedMap createDelegateMap() {\n        return new HashedMap();\n    }\n\n    /**\n     * Removes the specified mapping from this map.\n     * \n     * @param key  the mapping to remove\n     * @return the value mapped to the removed key, null if key not in map\n     */\n    public Object remove(Object key) {\n        if (delegateMap != null) {\n            return delegateMap.remove(key);\n        }\n        if (size == 0) {\n            return null;\n        }\n        if (key == null) {\n            switch (size) {  // drop through\n                case 3:\n                    if (key3 == null) {\n                        Object old = value3;\n                        hash3 = 0;\n                        key3 = null;\n                        value3 = null;\n                        size = 2;\n                        return old;\n                    }\n                    if (key2 == null) {\n                        Object old = value3;\n                        hash2 = hash3;\n                        key2 = key3;\n                        value2 = value3;\n                        hash3 = 0;\n                        key3 = null;\n                        value3 = null;\n                        size = 2;\n                        return old;\n                    }\n                    if (key1 == null) {\n                        Object old = value3;\n                        hash1 = hash3;\n                        key1 = key3;\n                        value1 = value3;\n                        hash3 = 0;\n                        key3 = null;\n                        value3 = null;\n                        size = 2;\n                        return old;\n                    }\n                    return null;\n                case 2:\n                    if (key2 == null) {\n                        Object old = value2;\n                        hash2 = 0;\n                        key2 = null;\n                        value2 = null;\n                        size = 1;\n                        return old;\n                    }\n                    if (key1 == null) {\n                        Object old = value2;\n                        hash1 = hash2;\n                        key1 = key2;\n                        value1 = value2;\n                        hash2 = 0;\n                        key2 = null;\n                        value2 = null;\n                        size = 1;\n                        return old;\n                    }\n                    return null;\n                case 1:\n                    if (key1 == null) {\n                        Object old = value1;\n                        hash1 = 0;\n                        key1 = null;\n                        value1 = null;\n                        size = 0;\n                        return old;\n                    }\n            }\n        } else {\n            if (size > 0) {\n                int hashCode = key.hashCode();\n                switch (size) {  // drop through\n                    case 3:\n                        if (hash3 == hashCode && key.equals(key3)) {\n                            Object old = value3;\n                            hash3 = 0;\n                            key3 = null;\n                            value3 = null;\n                            size = 2;\n                            return old;\n                        }\n                        if (hash2 == hashCode && key.equals(key2)) {\n                            Object old = value3;\n                            hash2 = hash3;\n                            key2 = key3;\n                            value2 = value3;\n                            hash3 = 0;\n                            key3 = null;\n                            value3 = null;\n                            size = 2;\n                            return old;\n                        }\n                        if (hash1 == hashCode && key.equals(key1)) {\n                            Object old = value3;\n                            hash1 = hash3;\n                            key1 = key3;\n                            value1 = value3;\n                            hash3 = 0;\n                            key3 = null;\n                            value3 = null;\n                            size = 2;\n                            return old;\n                        }\n                        return null;\n                    case 2:\n                        if (hash2 == hashCode && key.equals(key2)) {\n                            Object old = value2;\n                            hash2 = 0;\n                            key2 = null;\n                            value2 = null;\n                            size = 1;\n                            return old;\n                        }\n                        if (hash1 == hashCode && key.equals(key1)) {\n                            Object old = value2;\n                            hash1 = hash2;\n                            key1 = key2;\n                            value1 = value2;\n                            hash2 = 0;\n                            key2 = null;\n                            value2 = null;\n                            size = 1;\n                            return old;\n                        }\n                        return null;\n                    case 1:\n                        if (hash1 == hashCode && key.equals(key1)) {\n                            Object old = value1;\n                            hash1 = 0;\n                            key1 = null;\n                            value1 = null;\n                            size = 0;\n                            return old;\n                        }\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Clears the map, resetting the size to zero and nullifying references\n     * to avoid garbage collection issues.\n     */\n    public void clear() {\n        if (delegateMap != null) {\n            delegateMap.clear();  // should aid gc\n            delegateMap = null;  // switch back to flat mode\n        } else {\n            size = 0;\n            hash1 = hash2 = hash3 = 0;\n            key1 = key2 = key3 = null;\n            value1 = value2 = value3 = null;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets an iterator over the map.\n     * Changes made to the iterator affect this map.\n     * <p>\n     * A MapIterator returns the keys in the map. It also provides convenient\n     * methods to get the key and value, and set the value.\n     * It avoids the need to create an entrySet/keySet/values object.\n     * It also avoids creating the Map Entry object.\n     * \n     * @return the map iterator\n     */\n    public MapIterator mapIterator() {\n        if (delegateMap != null) {\n            return delegateMap.mapIterator();\n        }\n        if (size == 0) {\n            return EmptyMapIterator.INSTANCE;\n        }\n        return new FlatMapIterator(this);\n    }\n\n    /**\n     * FlatMapIterator\n     */\n    static class FlatMapIterator implements MapIterator, ResettableIterator {\n        private final Flat3Map parent;\n        private int nextIndex = 0;\n        private boolean canRemove = false;\n        \n        FlatMapIterator(Flat3Map parent) {\n            super();\n            this.parent = parent;\n        }\n\n        public boolean hasNext() {\n            return (nextIndex < parent.size);\n        }\n\n        public Object next() {\n            if (hasNext() == false) {\n                throw new NoSuchElementException(AbstractHashedMap.NO_NEXT_ENTRY);\n            }\n            canRemove = true;\n            nextIndex++;\n            return getKey();\n        }\n\n        public void remove() {\n            if (canRemove == false) {\n                throw new IllegalStateException(AbstractHashedMap.REMOVE_INVALID);\n            }\n            parent.remove(getKey());\n            nextIndex--;\n            canRemove = false;\n        }\n\n        public Object getKey() {\n            if (canRemove == false) {\n                throw new IllegalStateException(AbstractHashedMap.GETKEY_INVALID);\n            }\n            switch (nextIndex) {\n                case 3:\n                    return parent.key3;\n                case 2:\n                    return parent.key2;\n                case 1:\n                    return parent.key1;\n            }\n            throw new IllegalStateException(\"Invalid map index\");\n        }\n\n        public Object getValue() {\n            if (canRemove == false) {\n                throw new IllegalStateException(AbstractHashedMap.GETVALUE_INVALID);\n            }\n            switch (nextIndex) {\n                case 3:\n                    return parent.value3;\n                case 2:\n                    return parent.value2;\n                case 1:\n                    return parent.value1;\n            }\n            throw new IllegalStateException(\"Invalid map index\");\n        }\n\n        public Object setValue(Object value) {\n            if (canRemove == false) {\n                throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n            }\n            Object old = getValue();\n            switch (nextIndex) {\n                case 3: \n                    parent.value3 = value;\n                    break;\n                case 2:\n                    parent.value2 = value;\n                    break;\n                case 1:\n                    parent.value1 = value;\n                    break;\n            }\n            return old;\n        }\n        \n        public void reset() {\n            nextIndex = 0;\n            canRemove = false;\n        }\n        \n        public String toString() {\n            if (canRemove) {\n                return \"Iterator[\" + getKey() + \"=\" + getValue() + \"]\";\n            } else {\n                return \"Iterator[]\";\n            }\n        }\n    }\n    \n    /**\n     * Gets the entrySet view of the map.\n     * Changes made to the view affect this map.\n     * The Map Entry is not an independent object and changes as the \n     * iterator progresses.\n     * To simply iterate through the entries, use {@link #mapIterator()}.\n     * \n     * @return the entrySet view\n     */\n    public Set entrySet() {\n        if (delegateMap != null) {\n            return delegateMap.entrySet();\n        }\n        return new EntrySet(this);\n    }\n    \n    /**\n     * EntrySet\n     */\n    static class EntrySet extends AbstractSet {\n        private final Flat3Map parent;\n        \n        EntrySet(Flat3Map parent) {\n            super();\n            this.parent = parent;\n        }\n\n        public int size() {\n            return parent.size();\n        }\n        \n        public void clear() {\n            parent.clear();\n        }\n        \n        public boolean remove(Object obj) {\n            if (obj instanceof Map.Entry == false) {\n                return false;\n            }\n            Map.Entry entry = (Map.Entry) obj;\n            Object key = entry.getKey();\n            boolean result = parent.containsKey(key);\n            parent.remove(key);\n            return result;\n        }\n\n        public Iterator iterator() {\n            if (parent.delegateMap != null) {\n                return parent.delegateMap.entrySet().iterator();\n            }\n            if (parent.size() == 0) {\n                return EmptyIterator.INSTANCE;\n            }\n            return new EntrySetIterator(parent);\n        }\n    }\n\n    /**\n     * EntrySetIterator and MapEntry\n     */\n    static class EntrySetIterator implements Iterator, Map.Entry {\n        private final Flat3Map parent;\n        private int nextIndex = 0;\n        private boolean canRemove = false;\n        \n        EntrySetIterator(Flat3Map parent) {\n            super();\n            this.parent = parent;\n        }\n\n        public boolean hasNext() {\n            return (nextIndex < parent.size);\n        }\n\n        public Object next() {\n            if (hasNext() == false) {\n                throw new NoSuchElementException(AbstractHashedMap.NO_NEXT_ENTRY);\n            }\n            canRemove = true;\n            nextIndex++;\n            return this;\n        }\n\n        public void remove() {\n            if (canRemove == false) {\n                throw new IllegalStateException(AbstractHashedMap.REMOVE_INVALID);\n            }\n            parent.remove(getKey());\n            nextIndex--;\n            canRemove = false;\n        }\n\n        public Object getKey() {\n            if (canRemove == false) {\n                throw new IllegalStateException(AbstractHashedMap.GETKEY_INVALID);\n            }\n            switch (nextIndex) {\n                case 3:\n                    return parent.key3;\n                case 2:\n                    return parent.key2;\n                case 1:\n                    return parent.key1;\n            }\n            throw new IllegalStateException(\"Invalid map index\");\n        }\n\n        public Object getValue() {\n            if (canRemove == false) {\n                throw new IllegalStateException(AbstractHashedMap.GETVALUE_INVALID);\n            }\n            switch (nextIndex) {\n                case 3:\n                    return parent.value3;\n                case 2:\n                    return parent.value2;\n                case 1:\n                    return parent.value1;\n            }\n            throw new IllegalStateException(\"Invalid map index\");\n        }\n\n        public Object setValue(Object value) {\n            if (canRemove == false) {\n                throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n            }\n            Object old = getValue();\n            switch (nextIndex) {\n                case 3: \n                    parent.value3 = value;\n                    break;\n                case 2:\n                    parent.value2 = value;\n                    break;\n                case 1:\n                    parent.value1 = value;\n                    break;\n            }\n            return old;\n        }\n        \n        public boolean equals(Object obj) {\n            if (canRemove == false) {\n                return false;\n            }\n            if (obj instanceof Map.Entry == false) {\n                return false;\n            }\n            Map.Entry other = (Map.Entry) obj;\n            Object key = getKey();\n            Object value = getValue();\n            return (key == null ? other.getKey() == null : key.equals(other.getKey())) &&\n                   (value == null ? other.getValue() == null : value.equals(other.getValue()));\n        }\n        \n        public int hashCode() {\n            if (canRemove == false) {\n                return 0;\n            }\n            Object key = getKey();\n            Object value = getValue();\n            return (key == null ? 0 : key.hashCode()) ^\n                   (value == null ? 0 : value.hashCode());\n        }\n        \n        public String toString() {\n            if (canRemove) {\n                return getKey() + \"=\" + getValue();\n            } else {\n                return \"\";\n            }\n        }\n    }\n    \n    /**\n     * Gets the keySet view of the map.\n     * Changes made to the view affect this map.\n     * To simply iterate through the keys, use {@link #mapIterator()}.\n     * \n     * @return the keySet view\n     */\n    public Set keySet() {\n        if (delegateMap != null) {\n            return delegateMap.keySet();\n        }\n        return new KeySet(this);\n    }\n\n    /**\n     * KeySet\n     */\n    static class KeySet extends AbstractSet {\n        private final Flat3Map parent;\n        \n        KeySet(Flat3Map parent) {\n            super();\n            this.parent = parent;\n        }\n\n        public int size() {\n            return parent.size();\n        }\n        \n        public void clear() {\n            parent.clear();\n        }\n        \n        public boolean contains(Object key) {\n            return parent.containsKey(key);\n        }\n\n        public boolean remove(Object key) {\n            boolean result = parent.containsKey(key);\n            parent.remove(key);\n            return result;\n        }\n\n        public Iterator iterator() {\n            if (parent.delegateMap != null) {\n                return parent.delegateMap.keySet().iterator();\n            }\n            if (parent.size() == 0) {\n                return EmptyIterator.INSTANCE;\n            }\n            return new KeySetIterator(parent);\n        }\n    }\n\n    /**\n     * KeySetIterator\n     */\n    static class KeySetIterator extends EntrySetIterator {\n        \n        KeySetIterator(Flat3Map parent) {\n            super(parent);\n        }\n\n        public Object next() {\n            super.next();\n            return getKey();\n        }\n    }\n    \n    /**\n     * Gets the values view of the map.\n     * Changes made to the view affect this map.\n     * To simply iterate through the values, use {@link #mapIterator()}.\n     * \n     * @return the values view\n     */\n    public Collection values() {\n        if (delegateMap != null) {\n            return delegateMap.values();\n        }\n        return new Values(this);\n    }\n\n    /**\n     * Values\n     */\n    static class Values extends AbstractCollection {\n        private final Flat3Map parent;\n        \n        Values(Flat3Map parent) {\n            super();\n            this.parent = parent;\n        }\n\n        public int size() {\n            return parent.size();\n        }\n        \n        public void clear() {\n            parent.clear();\n        }\n        \n        public boolean contains(Object value) {\n            return parent.containsValue(value);\n        }\n\n        public Iterator iterator() {\n            if (parent.delegateMap != null) {\n                return parent.delegateMap.values().iterator();\n            }\n            if (parent.size() == 0) {\n                return EmptyIterator.INSTANCE;\n            }\n            return new ValuesIterator(parent);\n        }\n    }\n\n    /**\n     * ValuesIterator\n     */\n    static class ValuesIterator extends EntrySetIterator {\n        \n        ValuesIterator(Flat3Map parent) {\n            super(parent);\n        }\n\n        public Object next() {\n            super.next();\n            return getValue();\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Write the map out using a custom routine.\n     */\n    private void writeObject(ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        out.writeInt(size());\n        for (MapIterator it = mapIterator(); it.hasNext();) {\n            out.writeObject(it.next());  // key\n            out.writeObject(it.getValue());  // value\n        }\n    }\n\n    /**\n     * Read the map in using a custom routine.\n     */\n    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        int count = in.readInt();\n        if (count > 3) {\n            delegateMap = createDelegateMap();\n        }\n        for (int i = count; i > 0; i--) {\n            put(in.readObject(), in.readObject());\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Clones the map without cloning the keys or values.\n     *\n     * @return a shallow clone\n     * @since Commons Collections 3.1\n     */\n    public Object clone() {\n        try {\n            Flat3Map cloned = (Flat3Map) super.clone();\n            if (cloned.delegateMap != null) {\n                cloned.delegateMap = (HashedMap) cloned.delegateMap.clone();\n            }\n            return cloned;\n        } catch (CloneNotSupportedException ex) {\n            throw new InternalError();\n        }\n    }\n\n    /**\n     * Compares this map with another.\n     * \n     * @param obj  the object to compare to\n     * @return true if equal\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (delegateMap != null) {\n            return delegateMap.equals(obj);\n        }\n        if (obj instanceof Map == false) {\n            return false;\n        }\n        Map other = (Map) obj;\n        if (size != other.size()) {\n            return false;\n        }\n        if (size > 0) {\n            Object otherValue = null;\n            switch (size) {  // drop through\n                case 3:\n                    if (other.containsKey(key3) == false) {\n                        return false;\n                    }\n                    otherValue = other.get(key3);\n                    if (value3 == null ? otherValue != null : !value3.equals(otherValue)) {\n                        return false;\n                    }\n                case 2:\n                    if (other.containsKey(key2) == false) {\n                        return false;\n                    }\n                    otherValue = other.get(key2);\n                    if (value2 == null ? otherValue != null : !value2.equals(otherValue)) {\n                        return false;\n                    }\n                case 1:\n                    if (other.containsKey(key1) == false) {\n                        return false;\n                    }\n                    otherValue = other.get(key1);\n                    if (value1 == null ? otherValue != null : !value1.equals(otherValue)) {\n                        return false;\n                    }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Gets the standard Map hashCode.\n     * \n     * @return the hash code defined in the Map interface\n     */\n    public int hashCode() {\n        if (delegateMap != null) {\n            return delegateMap.hashCode();\n        }\n        int total = 0;\n        switch (size) {  // drop through\n            case 3:\n                total += (hash3 ^ (value3 == null ? 0 : value3.hashCode()));\n            case 2:\n                total += (hash2 ^ (value2 == null ? 0 : value2.hashCode()));\n            case 1:\n                total += (hash1 ^ (value1 == null ? 0 : value1.hashCode()));\n        }\n        return total;\n    }\n\n    /**\n     * Gets the map as a String.\n     * \n     * @return a string version of the map\n     */\n    public String toString() {\n        if (delegateMap != null) {\n            return delegateMap.toString();\n        }\n        if (size == 0) {\n            return \"{}\";\n        }\n        StringBuffer buf = new StringBuffer(128);\n        buf.append('{');\n        switch (size) {  // drop through\n            case 3:\n                buf.append((key3 == this ? \"(this Map)\" : key3));\n                buf.append('=');\n                buf.append((value3 == this ? \"(this Map)\" : value3));\n                buf.append(',');\n            case 2:\n                buf.append((key2 == this ? \"(this Map)\" : key2));\n                buf.append('=');\n                buf.append((value2 == this ? \"(this Map)\" : value2));\n                buf.append(',');\n            case 1:\n                buf.append((key1 == this ? \"(this Map)\" : key1));\n                buf.append('=');\n                buf.append((value1 == this ? \"(this Map)\" : value1));\n        }\n        buf.append('}');\n        return buf.toString();\n    }\n\n}\n", "fixed_version": "/*\n *  Licensed to the Apache Software Foundation (ASF) under one or more\n *  contributor license agreements.  See the NOTICE file distributed with\n *  this work for additional information regarding copyright ownership.\n *  The ASF licenses this file to You under the Apache License, Version 2.0\n *  (the \"License\"); you may not use this file except in compliance with\n *  the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.apache.commons.collections.map;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.AbstractCollection;\nimport java.util.AbstractSet;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Set;\n\nimport org.apache.commons.collections.IterableMap;\nimport org.apache.commons.collections.MapIterator;\nimport org.apache.commons.collections.ResettableIterator;\nimport org.apache.commons.collections.iterators.EmptyIterator;\nimport org.apache.commons.collections.iterators.EmptyMapIterator;\n\n/**\n * A <code>Map</code> implementation that stores data in simple fields until\n * the size is greater than 3.\n * <p>\n * This map is designed for performance and can outstrip HashMap.\n * It also has good garbage collection characteristics.\n * <ul>\n * <li>Optimised for operation at size 3 or less.\n * <li>Still works well once size 3 exceeded.\n * <li>Gets at size 3 or less are about 0-10% faster than HashMap,\n * <li>Puts at size 3 or less are over 4 times faster than HashMap.\n * <li>Performance 5% slower than HashMap once size 3 exceeded once.\n * </ul>\n * The design uses two distinct modes of operation - flat and delegate.\n * While the map is size 3 or less, operations map straight onto fields using\n * switch statements. Once size 4 is reached, the map switches to delegate mode\n * and only switches back when cleared. In delegate mode, all operations are\n * forwarded straight to a HashMap resulting in the 5% performance loss.\n * <p>\n * The performance gains on puts are due to not needing to create a Map Entry\n * object. This is a large saving not only in performance but in garbage collection.\n * <p>\n * Whilst in flat mode this map is also easy for the garbage collector to dispatch.\n * This is because it contains no complex objects or arrays which slow the progress.\n * <p>\n * Do not use <code>Flat3Map</code> if the size is likely to grow beyond 3.\n * <p>\n * <strong>Note that Flat3Map is not synchronized and is not thread-safe.</strong>\n * If you wish to use this map from multiple threads concurrently, you must use\n * appropriate synchronization. The simplest approach is to wrap this map\n * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw \n * exceptions when accessed by concurrent threads without synchronization.\n *\n * @since Commons Collections 3.0\n * @version $Revision$ $Date$\n *\n * @author Stephen Colebourne\n */\npublic class Flat3Map implements IterableMap, Serializable, Cloneable {\n\n    /** Serialization version */\n    private static final long serialVersionUID = -6701087419741928296L;\n\n    /** The size of the map, used while in flat mode */\n    private transient int size;\n    /** Hash, used while in flat mode */\n    private transient int hash1;\n    /** Hash, used while in flat mode */\n    private transient int hash2;\n    /** Hash, used while in flat mode */\n    private transient int hash3;\n    /** Key, used while in flat mode */\n    private transient Object key1;\n    /** Key, used while in flat mode */\n    private transient Object key2;\n    /** Key, used while in flat mode */\n    private transient Object key3;\n    /** Value, used while in flat mode */\n    private transient Object value1;\n    /** Value, used while in flat mode */\n    private transient Object value2;\n    /** Value, used while in flat mode */\n    private transient Object value3;\n    /** Map, used while in delegate mode */\n    private transient AbstractHashedMap delegateMap;\n\n    /**\n     * Constructor.\n     */\n    public Flat3Map() {\n        super();\n    }\n\n    /**\n     * Constructor copying elements from another map.\n     *\n     * @param map  the map to copy\n     * @throws NullPointerException if the map is null\n     */\n    public Flat3Map(Map map) {\n        super();\n        putAll(map);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the value mapped to the key specified.\n     * \n     * @param key  the key\n     * @return the mapped value, null if no match\n     */\n    public Object get(Object key) {\n        if (delegateMap != null) {\n            return delegateMap.get(key);\n        }\n        if (key == null) {\n            switch (size) {\n                // drop through\n                case 3:\n                    if (key3 == null) return value3;\n                case 2:\n                    if (key2 == null) return value2;\n                case 1:\n                    if (key1 == null) return value1;\n            }\n        } else {\n            if (size > 0) {\n                int hashCode = key.hashCode();\n                switch (size) {\n                    // drop through\n                    case 3:\n                        if (hash3 == hashCode && key.equals(key3)) return value3;\n                    case 2:\n                        if (hash2 == hashCode && key.equals(key2)) return value2;\n                    case 1:\n                        if (hash1 == hashCode && key.equals(key1)) return value1;\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Gets the size of the map.\n     * \n     * @return the size\n     */\n    public int size() {\n        if (delegateMap != null) {\n            return delegateMap.size();\n        }\n        return size;\n    }\n\n    /**\n     * Checks whether the map is currently empty.\n     * \n     * @return true if the map is currently size zero\n     */\n    public boolean isEmpty() {\n        return (size() == 0);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks whether the map contains the specified key.\n     * \n     * @param key  the key to search for\n     * @return true if the map contains the key\n     */\n    public boolean containsKey(Object key) {\n        if (delegateMap != null) {\n            return delegateMap.containsKey(key);\n        }\n        if (key == null) {\n            switch (size) {  // drop through\n                case 3:\n                    if (key3 == null) return true;\n                case 2:\n                    if (key2 == null) return true;\n                case 1:\n                    if (key1 == null) return true;\n            }\n        } else {\n            if (size > 0) {\n                int hashCode = key.hashCode();\n                switch (size) {  // drop through\n                    case 3:\n                        if (hash3 == hashCode && key.equals(key3)) return true;\n                    case 2:\n                        if (hash2 == hashCode && key.equals(key2)) return true;\n                    case 1:\n                        if (hash1 == hashCode && key.equals(key1)) return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Checks whether the map contains the specified value.\n     * \n     * @param value  the value to search for\n     * @return true if the map contains the key\n     */\n    public boolean containsValue(Object value) {\n        if (delegateMap != null) {\n            return delegateMap.containsValue(value);\n        }\n        if (value == null) {  // drop through\n            switch (size) {\n                case 3:\n                    if (value3 == null) return true;\n                case 2:\n                    if (value2 == null) return true;\n                case 1:\n                    if (value1 == null) return true;\n            }\n        } else {\n            switch (size) {  // drop through\n                case 3:\n                    if (value.equals(value3)) return true;\n                case 2:\n                    if (value.equals(value2)) return true;\n                case 1:\n                    if (value.equals(value1)) return true;\n            }\n        }\n        return false;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Puts a key-value mapping into this map.\n     * \n     * @param key  the key to add\n     * @param value  the value to add\n     * @return the value previously mapped to this key, null if none\n     */\n    public Object put(Object key, Object value) {\n        if (delegateMap != null) {\n            return delegateMap.put(key, value);\n        }\n        // change existing mapping\n        if (key == null) {\n            switch (size) {  // drop through\n                case 3:\n                    if (key3 == null) {\n                        Object old = value3;\n                        value3 = value;\n                        return old;\n                    }\n                case 2:\n                    if (key2 == null) {\n                        Object old = value2;\n                        value2 = value;\n                        return old;\n                    }\n                case 1:\n                    if (key1 == null) {\n                        Object old = value1;\n                        value1 = value;\n                        return old;\n                    }\n            }\n        } else {\n            if (size > 0) {\n                int hashCode = key.hashCode();\n                switch (size) {  // drop through\n                    case 3:\n                        if (hash3 == hashCode && key.equals(key3)) {\n                            Object old = value3;\n                            value3 = value;\n                            return old;\n                        }\n                    case 2:\n                        if (hash2 == hashCode && key.equals(key2)) {\n                            Object old = value2;\n                            value2 = value;\n                            return old;\n                        }\n                    case 1:\n                        if (hash1 == hashCode && key.equals(key1)) {\n                            Object old = value1;\n                            value1 = value;\n                            return old;\n                        }\n                }\n            }\n        }\n        \n        // add new mapping\n        switch (size) {\n            default:\n                convertToMap();\n                delegateMap.put(key, value);\n                return null;\n            case 2:\n                hash3 = (key == null ? 0 : key.hashCode());\n                key3 = key;\n                value3 = value;\n                break;\n            case 1:\n                hash2 = (key == null ? 0 : key.hashCode());\n                key2 = key;\n                value2 = value;\n                break;\n            case 0:\n                hash1 = (key == null ? 0 : key.hashCode());\n                key1 = key;\n                value1 = value;\n                break;\n        }\n        size++;\n        return null;\n    }\n\n    /**\n     * Puts all the values from the specified map into this map.\n     * \n     * @param map  the map to add\n     * @throws NullPointerException if the map is null\n     */\n    public void putAll(Map map) {\n        int size = map.size();\n        if (size == 0) {\n            return;\n        }\n        if (delegateMap != null) {\n            delegateMap.putAll(map);\n            return;\n        }\n        if (size < 4) {\n            for (Iterator it = map.entrySet().iterator(); it.hasNext();) {\n                Map.Entry entry = (Map.Entry) it.next();\n                put(entry.getKey(), entry.getValue());\n            }\n        } else {\n            convertToMap();\n            delegateMap.putAll(map);\n        }\n    }\n\n    /**\n     * Converts the flat map data to a map.\n     */\n    private void convertToMap() {\n        delegateMap = createDelegateMap();\n        switch (size) {  // drop through\n            case 3:\n                delegateMap.put(key3, value3);\n            case 2:\n                delegateMap.put(key2, value2);\n            case 1:\n                delegateMap.put(key1, value1);\n        }\n        \n        size = 0;\n        hash1 = hash2 = hash3 = 0;\n        key1 = key2 = key3 = null;\n        value1 = value2 = value3 = null;\n    }\n\n    /**\n     * Create an instance of the map used for storage when in delegation mode.\n     * <p>\n     * This can be overridden by subclasses to provide a different map implementation.\n     * Not every AbstractHashedMap is suitable, identity and reference based maps\n     * would be poor choices.\n     *\n     * @return a new AbstractHashedMap or subclass\n     * @since Commons Collections 3.1\n     */\n    protected AbstractHashedMap createDelegateMap() {\n        return new HashedMap();\n    }\n\n    /**\n     * Removes the specified mapping from this map.\n     * \n     * @param key  the mapping to remove\n     * @return the value mapped to the removed key, null if key not in map\n     */\n    public Object remove(Object key) {\n        if (delegateMap != null) {\n            return delegateMap.remove(key);\n        }\n        if (size == 0) {\n            return null;\n        }\n        if (key == null) {\n            switch (size) {  // drop through\n                case 3:\n                    if (key3 == null) {\n                        Object old = value3;\n                        hash3 = 0;\n                        key3 = null;\n                        value3 = null;\n                        size = 2;\n                        return old;\n                    }\n                    if (key2 == null) {\n                        Object old = value2;\n                        hash2 = hash3;\n                        key2 = key3;\n                        value2 = value3;\n                        hash3 = 0;\n                        key3 = null;\n                        value3 = null;\n                        size = 2;\n                        return old;\n                    }\n                    if (key1 == null) {\n                        Object old = value1;\n                        hash1 = hash3;\n                        key1 = key3;\n                        value1 = value3;\n                        hash3 = 0;\n                        key3 = null;\n                        value3 = null;\n                        size = 2;\n                        return old;\n                    }\n                    return null;\n                case 2:\n                    if (key2 == null) {\n                        Object old = value2;\n                        hash2 = 0;\n                        key2 = null;\n                        value2 = null;\n                        size = 1;\n                        return old;\n                    }\n                    if (key1 == null) {\n                        Object old = value1;\n                        hash1 = hash2;\n                        key1 = key2;\n                        value1 = value2;\n                        hash2 = 0;\n                        key2 = null;\n                        value2 = null;\n                        size = 1;\n                        return old;\n                    }\n                    return null;\n                case 1:\n                    if (key1 == null) {\n                        Object old = value1;\n                        hash1 = 0;\n                        key1 = null;\n                        value1 = null;\n                        size = 0;\n                        return old;\n                    }\n            }\n        } else {\n            if (size > 0) {\n                int hashCode = key.hashCode();\n                switch (size) {  // drop through\n                    case 3:\n                        if (hash3 == hashCode && key.equals(key3)) {\n                            Object old = value3;\n                            hash3 = 0;\n                            key3 = null;\n                            value3 = null;\n                            size = 2;\n                            return old;\n                        }\n                        if (hash2 == hashCode && key.equals(key2)) {\n                            Object old = value2;\n                            hash2 = hash3;\n                            key2 = key3;\n                            value2 = value3;\n                            hash3 = 0;\n                            key3 = null;\n                            value3 = null;\n                            size = 2;\n                            return old;\n                        }\n                        if (hash1 == hashCode && key.equals(key1)) {\n                            Object old = value1;\n                            hash1 = hash3;\n                            key1 = key3;\n                            value1 = value3;\n                            hash3 = 0;\n                            key3 = null;\n                            value3 = null;\n                            size = 2;\n                            return old;\n                        }\n                        return null;\n                    case 2:\n                        if (hash2 == hashCode && key.equals(key2)) {\n                            Object old = value2;\n                            hash2 = 0;\n                            key2 = null;\n                            value2 = null;\n                            size = 1;\n                            return old;\n                        }\n                        if (hash1 == hashCode && key.equals(key1)) {\n                            Object old = value1;\n                            hash1 = hash2;\n                            key1 = key2;\n                            value1 = value2;\n                            hash2 = 0;\n                            key2 = null;\n                            value2 = null;\n                            size = 1;\n                            return old;\n                        }\n                        return null;\n                    case 1:\n                        if (hash1 == hashCode && key.equals(key1)) {\n                            Object old = value1;\n                            hash1 = 0;\n                            key1 = null;\n                            value1 = null;\n                            size = 0;\n                            return old;\n                        }\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Clears the map, resetting the size to zero and nullifying references\n     * to avoid garbage collection issues.\n     */\n    public void clear() {\n        if (delegateMap != null) {\n            delegateMap.clear();  // should aid gc\n            delegateMap = null;  // switch back to flat mode\n        } else {\n            size = 0;\n            hash1 = hash2 = hash3 = 0;\n            key1 = key2 = key3 = null;\n            value1 = value2 = value3 = null;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets an iterator over the map.\n     * Changes made to the iterator affect this map.\n     * <p>\n     * A MapIterator returns the keys in the map. It also provides convenient\n     * methods to get the key and value, and set the value.\n     * It avoids the need to create an entrySet/keySet/values object.\n     * It also avoids creating the Map Entry object.\n     * \n     * @return the map iterator\n     */\n    public MapIterator mapIterator() {\n        if (delegateMap != null) {\n            return delegateMap.mapIterator();\n        }\n        if (size == 0) {\n            return EmptyMapIterator.INSTANCE;\n        }\n        return new FlatMapIterator(this);\n    }\n\n    /**\n     * FlatMapIterator\n     */\n    static class FlatMapIterator implements MapIterator, ResettableIterator {\n        private final Flat3Map parent;\n        private int nextIndex = 0;\n        private boolean canRemove = false;\n        \n        FlatMapIterator(Flat3Map parent) {\n            super();\n            this.parent = parent;\n        }\n\n        public boolean hasNext() {\n            return (nextIndex < parent.size);\n        }\n\n        public Object next() {\n            if (hasNext() == false) {\n                throw new NoSuchElementException(AbstractHashedMap.NO_NEXT_ENTRY);\n            }\n            canRemove = true;\n            nextIndex++;\n            return getKey();\n        }\n\n        public void remove() {\n            if (canRemove == false) {\n                throw new IllegalStateException(AbstractHashedMap.REMOVE_INVALID);\n            }\n            parent.remove(getKey());\n            nextIndex--;\n            canRemove = false;\n        }\n\n        public Object getKey() {\n            if (canRemove == false) {\n                throw new IllegalStateException(AbstractHashedMap.GETKEY_INVALID);\n            }\n            switch (nextIndex) {\n                case 3:\n                    return parent.key3;\n                case 2:\n                    return parent.key2;\n                case 1:\n                    return parent.key1;\n            }\n            throw new IllegalStateException(\"Invalid map index\");\n        }\n\n        public Object getValue() {\n            if (canRemove == false) {\n                throw new IllegalStateException(AbstractHashedMap.GETVALUE_INVALID);\n            }\n            switch (nextIndex) {\n                case 3:\n                    return parent.value3;\n                case 2:\n                    return parent.value2;\n                case 1:\n                    return parent.value1;\n            }\n            throw new IllegalStateException(\"Invalid map index\");\n        }\n\n        public Object setValue(Object value) {\n            if (canRemove == false) {\n                throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n            }\n            Object old = getValue();\n            switch (nextIndex) {\n                case 3: \n                    parent.value3 = value;\n                    break;\n                case 2:\n                    parent.value2 = value;\n                    break;\n                case 1:\n                    parent.value1 = value;\n                    break;\n            }\n            return old;\n        }\n        \n        public void reset() {\n            nextIndex = 0;\n            canRemove = false;\n        }\n        \n        public String toString() {\n            if (canRemove) {\n                return \"Iterator[\" + getKey() + \"=\" + getValue() + \"]\";\n            } else {\n                return \"Iterator[]\";\n            }\n        }\n    }\n    \n    /**\n     * Gets the entrySet view of the map.\n     * Changes made to the view affect this map.\n     * The Map Entry is not an independent object and changes as the \n     * iterator progresses.\n     * To simply iterate through the entries, use {@link #mapIterator()}.\n     * \n     * @return the entrySet view\n     */\n    public Set entrySet() {\n        if (delegateMap != null) {\n            return delegateMap.entrySet();\n        }\n        return new EntrySet(this);\n    }\n    \n    /**\n     * EntrySet\n     */\n    static class EntrySet extends AbstractSet {\n        private final Flat3Map parent;\n        \n        EntrySet(Flat3Map parent) {\n            super();\n            this.parent = parent;\n        }\n\n        public int size() {\n            return parent.size();\n        }\n        \n        public void clear() {\n            parent.clear();\n        }\n        \n        public boolean remove(Object obj) {\n            if (obj instanceof Map.Entry == false) {\n                return false;\n            }\n            Map.Entry entry = (Map.Entry) obj;\n            Object key = entry.getKey();\n            boolean result = parent.containsKey(key);\n            parent.remove(key);\n            return result;\n        }\n\n        public Iterator iterator() {\n            if (parent.delegateMap != null) {\n                return parent.delegateMap.entrySet().iterator();\n            }\n            if (parent.size() == 0) {\n                return EmptyIterator.INSTANCE;\n            }\n            return new EntrySetIterator(parent);\n        }\n    }\n\n    /**\n     * EntrySetIterator and MapEntry\n     */\n    static class EntrySetIterator implements Iterator, Map.Entry {\n        private final Flat3Map parent;\n        private int nextIndex = 0;\n        private boolean canRemove = false;\n        \n        EntrySetIterator(Flat3Map parent) {\n            super();\n            this.parent = parent;\n        }\n\n        public boolean hasNext() {\n            return (nextIndex < parent.size);\n        }\n\n        public Object next() {\n            if (hasNext() == false) {\n                throw new NoSuchElementException(AbstractHashedMap.NO_NEXT_ENTRY);\n            }\n            canRemove = true;\n            nextIndex++;\n            return this;\n        }\n\n        public void remove() {\n            if (canRemove == false) {\n                throw new IllegalStateException(AbstractHashedMap.REMOVE_INVALID);\n            }\n            parent.remove(getKey());\n            nextIndex--;\n            canRemove = false;\n        }\n\n        public Object getKey() {\n            if (canRemove == false) {\n                throw new IllegalStateException(AbstractHashedMap.GETKEY_INVALID);\n            }\n            switch (nextIndex) {\n                case 3:\n                    return parent.key3;\n                case 2:\n                    return parent.key2;\n                case 1:\n                    return parent.key1;\n            }\n            throw new IllegalStateException(\"Invalid map index\");\n        }\n\n        public Object getValue() {\n            if (canRemove == false) {\n                throw new IllegalStateException(AbstractHashedMap.GETVALUE_INVALID);\n            }\n            switch (nextIndex) {\n                case 3:\n                    return parent.value3;\n                case 2:\n                    return parent.value2;\n                case 1:\n                    return parent.value1;\n            }\n            throw new IllegalStateException(\"Invalid map index\");\n        }\n\n        public Object setValue(Object value) {\n            if (canRemove == false) {\n                throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n            }\n            Object old = getValue();\n            switch (nextIndex) {\n                case 3: \n                    parent.value3 = value;\n                    break;\n                case 2:\n                    parent.value2 = value;\n                    break;\n                case 1:\n                    parent.value1 = value;\n                    break;\n            }\n            return old;\n        }\n        \n        public boolean equals(Object obj) {\n            if (canRemove == false) {\n                return false;\n            }\n            if (obj instanceof Map.Entry == false) {\n                return false;\n            }\n            Map.Entry other = (Map.Entry) obj;\n            Object key = getKey();\n            Object value = getValue();\n            return (key == null ? other.getKey() == null : key.equals(other.getKey())) &&\n                   (value == null ? other.getValue() == null : value.equals(other.getValue()));\n        }\n        \n        public int hashCode() {\n            if (canRemove == false) {\n                return 0;\n            }\n            Object key = getKey();\n            Object value = getValue();\n            return (key == null ? 0 : key.hashCode()) ^\n                   (value == null ? 0 : value.hashCode());\n        }\n        \n        public String toString() {\n            if (canRemove) {\n                return getKey() + \"=\" + getValue();\n            } else {\n                return \"\";\n            }\n        }\n    }\n    \n    /**\n     * Gets the keySet view of the map.\n     * Changes made to the view affect this map.\n     * To simply iterate through the keys, use {@link #mapIterator()}.\n     * \n     * @return the keySet view\n     */\n    public Set keySet() {\n        if (delegateMap != null) {\n            return delegateMap.keySet();\n        }\n        return new KeySet(this);\n    }\n\n    /**\n     * KeySet\n     */\n    static class KeySet extends AbstractSet {\n        private final Flat3Map parent;\n        \n        KeySet(Flat3Map parent) {\n            super();\n            this.parent = parent;\n        }\n\n        public int size() {\n            return parent.size();\n        }\n        \n        public void clear() {\n            parent.clear();\n        }\n        \n        public boolean contains(Object key) {\n            return parent.containsKey(key);\n        }\n\n        public boolean remove(Object key) {\n            boolean result = parent.containsKey(key);\n            parent.remove(key);\n            return result;\n        }\n\n        public Iterator iterator() {\n            if (parent.delegateMap != null) {\n                return parent.delegateMap.keySet().iterator();\n            }\n            if (parent.size() == 0) {\n                return EmptyIterator.INSTANCE;\n            }\n            return new KeySetIterator(parent);\n        }\n    }\n\n    /**\n     * KeySetIterator\n     */\n    static class KeySetIterator extends EntrySetIterator {\n        \n        KeySetIterator(Flat3Map parent) {\n            super(parent);\n        }\n\n        public Object next() {\n            super.next();\n            return getKey();\n        }\n    }\n    \n    /**\n     * Gets the values view of the map.\n     * Changes made to the view affect this map.\n     * To simply iterate through the values, use {@link #mapIterator()}.\n     * \n     * @return the values view\n     */\n    public Collection values() {\n        if (delegateMap != null) {\n            return delegateMap.values();\n        }\n        return new Values(this);\n    }\n\n    /**\n     * Values\n     */\n    static class Values extends AbstractCollection {\n        private final Flat3Map parent;\n        \n        Values(Flat3Map parent) {\n            super();\n            this.parent = parent;\n        }\n\n        public int size() {\n            return parent.size();\n        }\n        \n        public void clear() {\n            parent.clear();\n        }\n        \n        public boolean contains(Object value) {\n            return parent.containsValue(value);\n        }\n\n        public Iterator iterator() {\n            if (parent.delegateMap != null) {\n                return parent.delegateMap.values().iterator();\n            }\n            if (parent.size() == 0) {\n                return EmptyIterator.INSTANCE;\n            }\n            return new ValuesIterator(parent);\n        }\n    }\n\n    /**\n     * ValuesIterator\n     */\n    static class ValuesIterator extends EntrySetIterator {\n        \n        ValuesIterator(Flat3Map parent) {\n            super(parent);\n        }\n\n        public Object next() {\n            super.next();\n            return getValue();\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Write the map out using a custom routine.\n     */\n    private void writeObject(ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        out.writeInt(size());\n        for (MapIterator it = mapIterator(); it.hasNext();) {\n            out.writeObject(it.next());  // key\n            out.writeObject(it.getValue());  // value\n        }\n    }\n\n    /**\n     * Read the map in using a custom routine.\n     */\n    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        int count = in.readInt();\n        if (count > 3) {\n            delegateMap = createDelegateMap();\n        }\n        for (int i = count; i > 0; i--) {\n            put(in.readObject(), in.readObject());\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Clones the map without cloning the keys or values.\n     *\n     * @return a shallow clone\n     * @since Commons Collections 3.1\n     */\n    public Object clone() {\n        try {\n            Flat3Map cloned = (Flat3Map) super.clone();\n            if (cloned.delegateMap != null) {\n                cloned.delegateMap = (HashedMap) cloned.delegateMap.clone();\n            }\n            return cloned;\n        } catch (CloneNotSupportedException ex) {\n            throw new InternalError();\n        }\n    }\n\n    /**\n     * Compares this map with another.\n     * \n     * @param obj  the object to compare to\n     * @return true if equal\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (delegateMap != null) {\n            return delegateMap.equals(obj);\n        }\n        if (obj instanceof Map == false) {\n            return false;\n        }\n        Map other = (Map) obj;\n        if (size != other.size()) {\n            return false;\n        }\n        if (size > 0) {\n            Object otherValue = null;\n            switch (size) {  // drop through\n                case 3:\n                    if (other.containsKey(key3) == false) {\n                        return false;\n                    }\n                    otherValue = other.get(key3);\n                    if (value3 == null ? otherValue != null : !value3.equals(otherValue)) {\n                        return false;\n                    }\n                case 2:\n                    if (other.containsKey(key2) == false) {\n                        return false;\n                    }\n                    otherValue = other.get(key2);\n                    if (value2 == null ? otherValue != null : !value2.equals(otherValue)) {\n                        return false;\n                    }\n                case 1:\n                    if (other.containsKey(key1) == false) {\n                        return false;\n                    }\n                    otherValue = other.get(key1);\n                    if (value1 == null ? otherValue != null : !value1.equals(otherValue)) {\n                        return false;\n                    }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Gets the standard Map hashCode.\n     * \n     * @return the hash code defined in the Map interface\n     */\n    public int hashCode() {\n        if (delegateMap != null) {\n            return delegateMap.hashCode();\n        }\n        int total = 0;\n        switch (size) {  // drop through\n            case 3:\n                total += (hash3 ^ (value3 == null ? 0 : value3.hashCode()));\n            case 2:\n                total += (hash2 ^ (value2 == null ? 0 : value2.hashCode()));\n            case 1:\n                total += (hash1 ^ (value1 == null ? 0 : value1.hashCode()));\n        }\n        return total;\n    }\n\n    /**\n     * Gets the map as a String.\n     * \n     * @return a string version of the map\n     */\n    public String toString() {\n        if (delegateMap != null) {\n            return delegateMap.toString();\n        }\n        if (size == 0) {\n            return \"{}\";\n        }\n        StringBuffer buf = new StringBuffer(128);\n        buf.append('{');\n        switch (size) {  // drop through\n            case 3:\n                buf.append((key3 == this ? \"(this Map)\" : key3));\n                buf.append('=');\n                buf.append((value3 == this ? \"(this Map)\" : value3));\n                buf.append(',');\n            case 2:\n                buf.append((key2 == this ? \"(this Map)\" : key2));\n                buf.append('=');\n                buf.append((value2 == this ? \"(this Map)\" : value2));\n                buf.append(',');\n            case 1:\n                buf.append((key1 == this ? \"(this Map)\" : key1));\n                buf.append('=');\n                buf.append((value1 == this ? \"(this Map)\" : value1));\n        }\n        buf.append('}');\n        return buf.toString();\n    }\n\n}\n"}]}
{"project": "Collections", "bug_id": 7, "classes_modified": [{"class_name": "org.apache.commons.collections.ExtendedProperties", "buggy_version": "/*\n *  Licensed to the Apache Software Foundation (ASF) under one or more\n *  contributor license agreements.  See the NOTICE file distributed with\n *  this work for additional information regarding copyright ownership.\n *  The ASF licenses this file to You under the Apache License, Version 2.0\n *  (the \"License\"); you may not use this file except in compliance with\n *  the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.apache.commons.collections;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.LineNumberReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.UnsupportedEncodingException;\nimport java.util.ArrayList;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Properties;\nimport java.util.StringTokenizer;\nimport java.util.Vector;\n\n/**\n * This class extends normal Java properties by adding the possibility\n * to use the same key many times concatenating the value strings\n * instead of overwriting them.\n * <p>\n * <b>Please consider using the <code>PropertiesConfiguration</code> class in\n * Commons-Configuration as soon as it is released.</b>\n * <p>\n * The Extended Properties syntax is explained here:\n *\n * <ul>\n *  <li>\n *   Each property has the syntax <code>key = value</code>\n *  </li>\n *  <li>\n *   The <i>key</i> may use any character but the equal sign '='.\n *  </li>\n *  <li>\n *   <i>value</i> may be separated on different lines if a backslash\n *   is placed at the end of the line that continues below.\n *  </li>\n *  <li>\n *   If <i>value</i> is a list of strings, each token is separated\n *   by a comma ','.\n *  </li>\n *  <li>\n *   Commas in each token are escaped placing a backslash right before\n *   the comma.\n *  </li>\n *  <li>\n *   Backslashes are escaped by using two consecutive backslashes i.e. \\\\\n *  </li>\n *  <li>\n *   If a <i>key</i> is used more than once, the values are appended\n *   as if they were on the same line separated with commas.\n *  </li>\n *  <li>\n *   Blank lines and lines starting with character '#' are skipped.\n *  </li>\n *  <li>\n *   If a property is named \"include\" (or whatever is defined by\n *   setInclude() and getInclude() and the value of that property is\n *   the full path to a file on disk, that file will be included into\n *   the ConfigurationsRepository. You can also pull in files relative\n *   to the parent configuration file. So if you have something\n *   like the following:\n *\n *   include = additional.properties\n *\n *   Then \"additional.properties\" is expected to be in the same\n *   directory as the parent configuration file.\n * \n *   Duplicate name values will be replaced, so be careful.\n *\n *  </li>\n * </ul>\n *\n * <p>Here is an example of a valid extended properties file:\n *\n * <p><pre>\n *      # lines starting with # are comments\n *\n *      # This is the simplest property\n *      key = value\n *\n *      # A long property may be separated on multiple lines\n *      longvalue = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa \\\n *                  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n *\n *      # This is a property with many tokens\n *      tokens_on_a_line = first token, second token\n *\n *      # This sequence generates exactly the same result\n *      tokens_on_multiple_lines = first token\n *      tokens_on_multiple_lines = second token\n *\n *      # commas may be escaped in tokens\n *      commas.escaped = Hi\\, what'up?\n * </pre>\n *\n * <p><b>NOTE</b>: this class has <b>not</b> been written for\n * performance nor low memory usage.  In fact, it's way slower than it\n * could be and generates too much memory garbage.  But since\n * performance is not an issue during intialization (and there is not\n * much time to improve it), I wrote it this way.  If you don't like\n * it, go ahead and tune it up!\n *\n * @since Commons Collections 1.0\n * @version $Revision$ $Date$\n * \n * @author <a href=\"mailto:stefano@apache.org\">Stefano Mazzocchi</a>\n * @author <a href=\"mailto:jon@latchkey.com\">Jon S. Stevens</a>\n * @author <a href=\"mailto:daveb@miceda-data\">Dave Bryson</a>\n * @author <a href=\"mailto:jvanzyl@periapt.com\">Jason van Zyl</a>\n * @author <a href=\"mailto:geirm@optonline.net\">Geir Magnusson Jr.</a>\n * @author <a href=\"mailto:leon@opticode.co.za\">Leon Messerschmidt</a>\n * @author <a href=\"mailto:kjohnson@transparent.com\">Kent Johnson</a>\n * @author <a href=\"mailto:dlr@finemaltcoding.com\">Daniel Rall</a>\n * @author <a href=\"mailto:ipriha@surfeu.fi\">Ilkka Priha</a>\n * @author Janek Bogucki\n * @author Mohan Kishore\n * @author Stephen Colebourne\n * @author Shinobu Kawai\n * @author <a href=\"mailto:hps@intermeta.de\">Henning P. Schmiedehausen</a>\n */\npublic class ExtendedProperties extends Hashtable {\n    \n    /**\n     * Default configurations repository.\n     */\n    private ExtendedProperties defaults;\n\n    /**\n     * The file connected to this repository (holding comments and\n     * such).\n     *\n     * @serial\n     */\n    protected String file;\n\n    /**\n     * Base path of the configuration file used to create\n     * this ExtendedProperties object.\n     */\n    protected String basePath;\n\n    /**\n     * File separator.\n     */\n    protected String fileSeparator = System.getProperty(\"file.separator\");\n\n    /**\n     * Has this configuration been intialized.\n     */\n    protected boolean isInitialized = false;\n\n    /**\n     * This is the name of the property that can point to other\n     * properties file for including other properties files.\n     */\n    private String includePropertyName = null;\n\n    /**\n     * This is the default name of the property that can point to other\n     * properties file for including other properties files.\n     * \n     * @deprecated Use getInclude() and setInclude() methods which operate\n     * on an instance variable from v3.3. Due to be removed in v4.0.\n     */\n    protected static String include = \"include\";\n\n    /**\n     * These are the keys in the order they listed\n     * in the configuration file. This is useful when\n     * you wish to perform operations with configuration\n     * information in a particular order.\n     */\n    protected ArrayList keysAsListed = new ArrayList();\n\n    protected final static String START_TOKEN=\"${\";\n    protected final static String END_TOKEN=\"}\";\n\n\n    /**\n     * Interpolate key names to handle ${key} stuff\n     *\n     * @param base string to interpolate\n     * @return returns the key name with the ${key} substituted\n     */\n    protected String interpolate(String base) {\n        // COPIED from [configuration] 2003-12-29\n        return (interpolateHelper(base, null));\n    }\n\n    /**\n     * Recursive handler for multiple levels of interpolation.\n     *\n     * When called the first time, priorVariables should be null.\n     *\n     * @param base string with the ${key} variables\n     * @param priorVariables serves two purposes: to allow checking for\n     * loops, and creating a meaningful exception message should a loop\n     * occur.  It's 0'th element will be set to the value of base from\n     * the first call.  All subsequent interpolated variables are added\n     * afterward.\n     *\n     * @return the string with the interpolation taken care of\n     */\n    protected String interpolateHelper(String base, List priorVariables) {\n        // COPIED from [configuration] 2003-12-29\n        if (base == null) {\n            return null;\n        }\n\n        // on the first call initialize priorVariables\n        // and add base as the first element\n        if (priorVariables == null) {\n            priorVariables = new ArrayList();\n            priorVariables.add(base);\n        }\n\n        int begin = -1;\n        int end = -1;\n        int prec = 0 - END_TOKEN.length();\n        String variable = null;\n        StringBuffer result = new StringBuffer();\n\n        // FIXME: we should probably allow the escaping of the start token\n        while (((begin = base.indexOf(START_TOKEN, prec + END_TOKEN.length())) > -1)\n            && ((end = base.indexOf(END_TOKEN, begin)) > -1)) {\n            result.append(base.substring(prec + END_TOKEN.length(), begin));\n            variable = base.substring(begin + START_TOKEN.length(), end);\n\n            // if we've got a loop, create a useful exception message and throw\n            if (priorVariables.contains(variable)) {\n                String initialBase = priorVariables.remove(0).toString();\n                priorVariables.add(variable);\n                StringBuffer priorVariableSb = new StringBuffer();\n\n                // create a nice trace of interpolated variables like so:\n                // var1->var2->var3\n                for (Iterator it = priorVariables.iterator(); it.hasNext();) {\n                    priorVariableSb.append(it.next());\n                    if (it.hasNext()) {\n                        priorVariableSb.append(\"->\");\n                    }\n                }\n\n                throw new IllegalStateException(\n                    \"infinite loop in property interpolation of \" + initialBase + \": \" + priorVariableSb.toString());\n            }\n            // otherwise, add this variable to the interpolation list.\n            else {\n                priorVariables.add(variable);\n            }\n\n            //QUESTION: getProperty or getPropertyDirect\n            Object value = getProperty(variable);\n            if (value != null) {\n                result.append(interpolateHelper(value.toString(), priorVariables));\n\n                // pop the interpolated variable off the stack\n                // this maintains priorVariables correctness for\n                // properties with multiple interpolations, e.g.\n                // prop.name=${some.other.prop1}/blahblah/${some.other.prop2}\n                priorVariables.remove(priorVariables.size() - 1);\n            } else if (defaults != null && defaults.getString(variable, null) != null) {\n                result.append(defaults.getString(variable));\n            } else {\n                //variable not defined - so put it back in the value\n                result.append(START_TOKEN).append(variable).append(END_TOKEN);\n            }\n            prec = end;\n        }\n        result.append(base.substring(prec + END_TOKEN.length(), base.length()));\n\n        return result.toString();\n    }\n    \n    /**\n     * Inserts a backslash before every comma and backslash. \n     */\n    private static String escape(String s) {\n        StringBuffer buf = new StringBuffer(s);\n        for (int i = 0; i < buf.length(); i++) {\n            char c = buf.charAt(i);\n            if (c == ',' || c == '\\\\') {\n                buf.insert(i, '\\\\');\n                i++;\n            }\n        }\n        return buf.toString();\n    }\n    \n    /**\n     * Removes a backslash from every pair of backslashes. \n     */\n    private static String unescape(String s) {\n        StringBuffer buf = new StringBuffer(s);\n        for (int i = 0; i < buf.length() - 1; i++) {\n            char c1 = buf.charAt(i);\n            char c2 = buf.charAt(i + 1);\n            if (c1 == '\\\\' && c2 == '\\\\') {\n                buf.deleteCharAt(i);\n            }\n        }\n        return buf.toString();\n    }\n\n    /**\n     * Counts the number of successive times 'ch' appears in the\n     * 'line' before the position indicated by the 'index'.\n     */\n    private static int countPreceding(String line, int index, char ch) {\n        int i;\n        for (i = index - 1; i >= 0; i--) {\n            if (line.charAt(i) != ch) {\n                break;\n            }\n        }\n        return index - 1 - i;\n    }\n\n    /**\n     * Checks if the line ends with odd number of backslashes \n     */\n    private static boolean endsWithSlash(String line) {\n        if (!line.endsWith(\"\\\\\")) {\n            return false;\n        }\n        return (countPreceding(line, line.length() - 1, '\\\\') % 2 == 0);\n    }\n\n    /**\n     * This class is used to read properties lines.  These lines do\n     * not terminate with new-line chars but rather when there is no\n     * backslash sign a the end of the line.  This is used to\n     * concatenate multiple lines for readability.\n     */\n    static class PropertiesReader extends LineNumberReader {\n        /**\n         * Constructor.\n         *\n         * @param reader A Reader.\n         */\n        public PropertiesReader(Reader reader) {\n            super(reader);\n        }\n\n        /**\n         * Read a property.\n         *\n         * @return a String property\n         * @throws IOException if there is difficulty reading the source.\n         */\n        public String readProperty() throws IOException {\n            StringBuffer buffer = new StringBuffer();\n            String line = readLine();\n            while (line != null) {\n                line = line.trim();\n                if ((line.length() != 0) && (line.charAt(0) != '#')) {\n                    if (endsWithSlash(line)) {\n                        line = line.substring(0, line.length() - 1);\n                        buffer.append(line);\n                    } else {\n                        buffer.append(line);\n                        return buffer.toString();  // normal method end\n                    }\n                }\n                line = readLine();\n            }\n            return null;  // EOF reached\n        }\n    }\n\n    /**\n     * This class divides into tokens a property value.  Token\n     * separator is \",\" but commas into the property value are escaped\n     * using the backslash in front.\n     */\n    static class PropertiesTokenizer extends StringTokenizer {\n        /**\n         * The property delimiter used while parsing (a comma).\n         */\n        static final String DELIMITER = \",\";\n\n        /**\n         * Constructor.\n         *\n         * @param string A String.\n         */\n        public PropertiesTokenizer(String string) {\n            super(string, DELIMITER);\n        }\n\n        /**\n         * Check whether the object has more tokens.\n         *\n         * @return True if the object has more tokens.\n         */\n        public boolean hasMoreTokens() {\n            return super.hasMoreTokens();\n        }\n\n        /**\n         * Get next token.\n         *\n         * @return A String.\n         */\n        public String nextToken() {\n            StringBuffer buffer = new StringBuffer();\n\n            while (hasMoreTokens()) {\n                String token = super.nextToken();\n                if (endsWithSlash(token)) {\n                    buffer.append(token.substring(0, token.length() - 1));\n                    buffer.append(DELIMITER);\n                } else {\n                    buffer.append(token);\n                    break;\n                }\n            }\n\n            return buffer.toString().trim();\n        }\n    }\n\n    /**\n     * Creates an empty extended properties object.\n     */\n    public ExtendedProperties() {\n        super();\n    }\n\n    /**\n     * Creates and loads the extended properties from the specified file.\n     *\n     * @param file  the filename to load\n     * @throws IOException if a file error occurs\n     */\n    public ExtendedProperties(String file) throws IOException {\n        this(file, null);\n    }\n\n    /**\n     * Creates and loads the extended properties from the specified file.\n     *\n     * @param file  the filename to load\n     * @param defaultFile  a second filename to load default values from\n     * @throws IOException if a file error occurs\n     */\n    public ExtendedProperties(String file, String defaultFile) throws IOException {\n        this.file = file;\n\n        basePath = new File(file).getAbsolutePath();\n        basePath = basePath.substring(0, basePath.lastIndexOf(fileSeparator) + 1);\n\n        FileInputStream in = null;\n        try {\n            in = new FileInputStream(file);\n            this.load(in);\n        } finally {\n            try {\n                if (in != null) {\n                    in.close();\n                }\n            } catch (IOException ex) {}\n        }\n\n        if (defaultFile != null) {\n            defaults = new ExtendedProperties(defaultFile);\n        }\n    }\n\n    /**\n     * Indicate to client code whether property\n     * resources have been initialized or not.\n     */\n    public boolean isInitialized() {\n        return isInitialized;\n    }\n\n    /**\n     * Gets the property value for including other properties files.\n     * By default it is \"include\".\n     * <p>\n     * NOTE: Prior to v3.3 this method accessed a static variable.\n     * It now accesses an instance variable. For compatability, if the\n     * instance variable has not been set then the previous static\n     * variable is then accessed. However, the protected static variable\n     * can now only be set by subclasses.\n     * In v4.0, the static variable will be removed.\n     *\n     * @return the property name which includes another property\n     */\n    public String getInclude() {\n        if (includePropertyName == null) {\n            return include;  // backwards compatability\n        }\n        if (\"\".equals(includePropertyName)) {\n            return null;  // hack to allow backwards compatability\n        }\n        return includePropertyName;\n    }\n\n    /**\n     * Sets the property value for including other properties files.\n     * By default it is \"include\".\n     * <p>\n     * NOTE: Prior to v3.3 this method set a static variable and affected all\n     * users of the class. It now sets an instance variable.\n     * An empty string is also now converted to null internally.\n     * In v4.0, the static variable will be removed.\n     *\n     * @param inc  the property name which includes another property, empty converted to null\n     */\n    public void setInclude(String inc) {\n        if (inc == null) {\n            inc = \"\";  // hack to allow backwards compatability\n        }\n        includePropertyName = inc;\n    }\n\n    /**\n     * Load the properties from the given input stream.\n     *\n     * @param input  the InputStream to load from\n     * @throws IOException if an IO error occurs\n     */\n    public void load(InputStream input) throws IOException {\n        load(input, null);\n    }\n\n    /**\n     * Load the properties from the given input stream\n     * and using the specified encoding.\n     *\n     * @param input  the InputStream to load from\n     * @param enc  the encoding to use\n     * @throws IOException if an IO error occurs\n     */\n    public synchronized void load(InputStream input, String enc) throws IOException {\n        PropertiesReader reader = null;\n        if (enc != null) {\n            try {\n                reader = new PropertiesReader(new InputStreamReader(input, enc));\n                \n            } catch (UnsupportedEncodingException ex) {\n                // Another try coming up....\n            }\n        }\n        \n        if (reader == null) {\n            try {\n                reader = new PropertiesReader(new InputStreamReader(input, \"8859_1\"));\n                \n            } catch (UnsupportedEncodingException ex) {\n                // ISO8859-1 support is required on java platforms but....\n                // If it's not supported, use the system default encoding\n                reader = new PropertiesReader(new InputStreamReader(input));\n            }\n        }\n\n        try {\n            String includeProperty = getInclude();\n            while (true) {\n                String line = reader.readProperty();\n                if (line == null) {\n                    return;  // EOF\n                }\n                int equalSign = line.indexOf('=');\n\n                if (equalSign > 0) {\n                    String key = line.substring(0, equalSign).trim();\n                    String value = line.substring(equalSign + 1).trim();\n\n                    // Configure produces lines like this ... just ignore them\n                    if (\"\".equals(value)) {\n                        continue;\n                    }\n\n                    if (includeProperty != null && key.equalsIgnoreCase(includeProperty)) {\n                        // Recursively load properties files.\n                        File file = null;\n\n                        if (value.startsWith(fileSeparator)) {\n                            // We have an absolute path so we'll use this\n                            file = new File(value);\n                            \n                        } else {\n                            // We have a relative path, and we have two \n                            // possible forms here. If we have the \"./\" form\n                            // then just strip that off first before continuing.\n                            if (value.startsWith(\".\" + fileSeparator)) {\n                                value = value.substring(2);\n                            }\n\n                            file = new File(basePath + value);\n                        }\n\n                        if (file != null && file.exists() && file.canRead()) {\n                            load(new FileInputStream(file));\n                        }\n                    } else {\n                        addProperty(key, value);\n                    }\n                }\n            }\n        } finally {\n            // Loading is initializing\n            isInitialized = true;\n        }\n    }\n\n    /**\n     * Gets a property from the configuration.\n     *\n     * @param key property to retrieve\n     * @return value as object. Will return user value if exists,\n     *        if not then default value if exists, otherwise null\n     */\n    public Object getProperty(String key) {\n        // first, try to get from the 'user value' store\n        Object obj = this.get(key);\n\n        if (obj == null) {\n            // if there isn't a value there, get it from the\n            // defaults if we have them\n            if (defaults != null) {\n                obj = defaults.get(key);\n            }\n        }\n\n        return obj;\n    }\n    \n    /**\n     * Add a property to the configuration. If it already\n     * exists then the value stated here will be added\n     * to the configuration entry. For example, if\n     *\n     * <code>resource.loader = file</code>\n     *\n     * is already present in the configuration and you\n     *\n     * <code>addProperty(\"resource.loader\", \"classpath\")</code>\n     *\n     * Then you will end up with a Vector like the\n     * following:\n     *\n     * <code>[\"file\", \"classpath\"]</code>\n     *\n     * @param key  the key to add\n     * @param value  the value to add\n     */\n    public void addProperty(String key, Object value) {\n        if (value instanceof String) {\n            String str = (String) value;\n            if (str.indexOf(PropertiesTokenizer.DELIMITER) > 0) {\n                // token contains commas, so must be split apart then added\n                PropertiesTokenizer tokenizer = new PropertiesTokenizer(str);\n                while (tokenizer.hasMoreTokens()) {\n                    String token = tokenizer.nextToken();\n                    addPropertyInternal(key, unescape(token));\n                }\n            } else {\n                // token contains no commas, so can be simply added\n                addPropertyInternal(key, unescape(str));\n            }\n        } else {\n            addPropertyInternal(key, value);\n        }\n\n        // Adding a property connotes initialization\n        isInitialized = true;\n    }\n\n    /**\n     * Adds a key/value pair to the map.  This routine does\n     * no magic morphing.  It ensures the keylist is maintained\n     *\n     * @param key  the key to store at\n     * @param value  the decoded object to store\n     */\n    private void addPropertyDirect(String key, Object value) {\n        // safety check\n        if (!containsKey(key)) {\n            keysAsListed.add(key);\n        }\n        put(key, value);\n    }\n\n    /**\n     * Adds a decoded property to the map w/o checking for commas - used\n     * internally when a property has been broken up into\n     * strings that could contain escaped commas to prevent\n     * the inadvertent vectorization.\n     * <p>\n     * Thanks to Leon Messerschmidt for this one.\n     *\n     * @param key  the key to store at\n     * @param value  the decoded object to store\n     */\n    private void addPropertyInternal(String key, Object value) {\n        Object current = this.get(key);\n\n        if (current instanceof String) {\n            // one object already in map - convert it to a vector\n            List values = new Vector(2);\n            values.add(current);\n            values.add(value);\n            put(key, values);\n            \n        } else if (current instanceof List) {\n            // already a list - just add the new token\n            ((List) current).add(value);\n            \n        } else {\n            // brand new key - store in keysAsListed to retain order\n            if (!containsKey(key)) {\n                keysAsListed.add(key);\n            }\n            put(key, value);\n        }\n    }\n\n    /**\n     * Set a property, this will replace any previously\n     * set values. Set values is implicitly a call\n     * to clearProperty(key), addProperty(key,value).\n     *\n     * @param key  the key to set\n     * @param value  the value to set\n     */\n    public void setProperty(String key, Object value) {\n        clearProperty(key);\n        addProperty(key, value);\n    }\n    \n    /**\n     * Save the properties to the given output stream.\n     * <p>\n     * The stream is not closed, but it is flushed.\n     *\n     * @param output  an OutputStream, may be null\n     * @param header  a textual comment to act as a file header\n     * @throws IOException if an IO error occurs\n     */\n    public synchronized void save(OutputStream output, String header) throws IOException {\n        if (output == null) {\n            return;\n        }\n        PrintWriter theWrtr = new PrintWriter(output);\n        if (header != null) {\n            theWrtr.println(header);\n        }\n        \n        Enumeration theKeys = keys();\n        while (theKeys.hasMoreElements()) {\n            String key = (String) theKeys.nextElement();\n            Object value = get(key);\n            if (value != null) {\n                if (value instanceof String) {\n                    StringBuffer currentOutput = new StringBuffer();\n                    currentOutput.append(key);\n                    currentOutput.append(\"=\");\n                    currentOutput.append(escape((String) value));\n                    theWrtr.println(currentOutput.toString());\n                    \n                } else if (value instanceof List) {\n                    List values = (List) value;\n                    for (Iterator it = values.iterator(); it.hasNext(); ) {\n                        String currentElement = (String) it.next();\n                        StringBuffer currentOutput = new StringBuffer();\n                        currentOutput.append(key);\n                        currentOutput.append(\"=\");\n                        currentOutput.append(escape(currentElement));\n                        theWrtr.println(currentOutput.toString());\n                    }\n                }\n            }\n            theWrtr.println();\n            theWrtr.flush();\n        }\n    }\n\n    /**\n     * Combines an existing Hashtable with this Hashtable.\n     * <p>\n     * Warning: It will overwrite previous entries without warning.\n     *\n     * @param props  the properties to combine\n     */\n    public void combine(ExtendedProperties props) {\n        for (Iterator it = props.getKeys(); it.hasNext();) {\n            String key = (String) it.next();\n            setProperty(key, props.get(key));\n        }\n    }\n    \n    /**\n     * Clear a property in the configuration.\n     *\n     * @param key  the property key to remove along with corresponding value\n     */\n    public void clearProperty(String key) {\n        if (containsKey(key)) {\n            // we also need to rebuild the keysAsListed or else\n            // things get *very* confusing\n            for (int i = 0; i < keysAsListed.size(); i++) {\n                if (( keysAsListed.get(i)).equals(key)) {\n                    keysAsListed.remove(i);\n                    break;\n                }\n            }\n            remove(key);\n        }\n    }\n\n    /**\n     * Get the list of the keys contained in the configuration\n     * repository.\n     *\n     * @return an Iterator over the keys\n     */\n    public Iterator getKeys() {\n        return keysAsListed.iterator();\n    }\n\n    /**\n     * Get the list of the keys contained in the configuration\n     * repository that match the specified prefix.\n     *\n     * @param prefix  the prefix to match\n     * @return an Iterator of keys that match the prefix\n     */\n    public Iterator getKeys(String prefix) {\n        Iterator keys = getKeys();\n        ArrayList matchingKeys = new ArrayList();\n\n        while (keys.hasNext()) {\n            Object key = keys.next();\n\n            if (key instanceof String && ((String) key).startsWith(prefix)) {\n                matchingKeys.add(key);\n            }\n        }\n        return matchingKeys.iterator();\n    }\n\n    /**\n     * Create an ExtendedProperties object that is a subset\n     * of this one. Take into account duplicate keys\n     * by using the setProperty() in ExtendedProperties.\n     *\n     * @param prefix  the prefix to get a subset for\n     * @return a new independent ExtendedProperties\n     */\n    public ExtendedProperties subset(String prefix) {\n        ExtendedProperties c = new ExtendedProperties();\n        Iterator keys = getKeys();\n        boolean validSubset = false;\n\n        while (keys.hasNext()) {\n            Object key = keys.next();\n\n            if (key instanceof String && ((String) key).startsWith(prefix)) {\n                if (!validSubset) {\n                    validSubset = true;\n                }\n\n                /*\n                 * Check to make sure that c.subset(prefix) doesn't\n                 * blow up when there is only a single property\n                 * with the key prefix. This is not a useful\n                 * subset but it is a valid subset.\n                 */\n                String newKey = null;\n                if (((String) key).length() == prefix.length()) {\n                    newKey = prefix;\n                } else {\n                    newKey = ((String) key).substring(prefix.length() + 1);\n                }\n\n                /*\n                 *  use addPropertyDirect() - this will plug the data as \n                 *  is into the Map, but will also do the right thing\n                 *  re key accounting\n                 */\n                c.addPropertyDirect(newKey, get(key));\n            }\n        }\n\n        if (validSubset) {\n            return c;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Display the configuration for debugging purposes to System.out.\n     */\n    public void display() {\n        Iterator i = getKeys();\n\n        while (i.hasNext()) {\n            String key = (String) i.next();\n            Object value = get(key);\n            System.out.println(key + \" => \" + value);\n        }\n    }\n\n    /**\n     * Get a string associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated string.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a String.\n     */\n    public String getString(String key) {\n        return getString(key, null);\n    }\n\n    /**\n     * Get a string associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated string if key is found,\n     * default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a String.\n     */\n    public String getString(String key, String defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof String) {\n            return interpolate((String) value);\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return interpolate(defaults.getString(key, defaultValue));\n            } else {\n                return interpolate(defaultValue);\n            }\n        } else if (value instanceof List) {\n            return interpolate((String) ((List) value).get(0));\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a String object\");\n        }\n    }\n\n    /**\n     * Get a list of properties associated with the given\n     * configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated properties if key is found.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a String/List.\n     * @throws IllegalArgumentException if one of the tokens is\n     * malformed (does not contain an equals sign).\n     */\n    public Properties getProperties(String key) {\n        return getProperties(key, new Properties());\n    }\n\n    /**\n     * Get a list of properties associated with the given\n     * configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated properties if key is found.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a String/List.\n     * @throws IllegalArgumentException if one of the tokens is\n     * malformed (does not contain an equals sign).\n     */\n    public Properties getProperties(String key, Properties defaults) {\n        /*\n         * Grab an array of the tokens for this key.\n         */\n        String[] tokens = getStringArray(key);\n\n        // Each token is of the form 'key=value'.\n        Properties props = new Properties(defaults);\n        for (int i = 0; i < tokens.length; i++) {\n            String token = tokens[i];\n            int equalSign = token.indexOf('=');\n            if (equalSign > 0) {\n                String pkey = token.substring(0, equalSign).trim();\n                String pvalue = token.substring(equalSign + 1).trim();\n                props.put(pkey, pvalue);\n            } else {\n                throw new IllegalArgumentException('\\'' + token + \"' does not contain \" + \"an equals sign\");\n            }\n        }\n        return props;\n    }\n\n    /**\n     * Get an array of strings associated with the given configuration\n     * key.\n     *\n     * @param key The configuration key.\n     * @return The associated string array if key is found.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a String/List.\n     */\n    public String[] getStringArray(String key) {\n        Object value = get(key);\n\n        List values;\n        if (value instanceof String) {\n            values = new Vector(1);\n            values.add(value);\n            \n        } else if (value instanceof List) {\n            values = (List) value;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getStringArray(key);\n            } else {\n                return new String[0];\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a String/List object\");\n        }\n\n        String[] tokens = new String[values.size()];\n        for (int i = 0; i < tokens.length; i++) {\n            tokens[i] = (String) values.get(i);\n        }\n\n        return tokens;\n    }\n\n    /**\n     * Get a Vector of strings associated with the given configuration\n     * key.\n     *\n     * @param key The configuration key.\n     * @return The associated Vector.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Vector.\n     */\n    public Vector getVector(String key) {\n        return getVector(key, null);\n    }\n\n    /**\n     * Get a Vector of strings associated with the given configuration key.\n     * <p>\n     * The list is a copy of the internal data of this object, and as\n     * such you may alter it freely.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated Vector.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Vector.\n     */\n    public Vector getVector(String key, Vector defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof List) {\n            return new Vector((List) value);\n            \n        } else if (value instanceof String) {\n            Vector values = new Vector(1);\n            values.add(value);\n            put(key, values);\n            return values;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getVector(key, defaultValue);\n            } else {\n                return ((defaultValue == null) ? new Vector() : defaultValue);\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Vector object\");\n        }\n    }\n\n    /**\n     * Get a List of strings associated with the given configuration key.\n     * <p>\n     * The list is a copy of the internal data of this object, and as\n     * such you may alter it freely.\n     *\n     * @param key The configuration key.\n     * @return The associated List object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a List.\n     * @since Commons Collections 3.2\n     */\n    public List getList(String key) {\n        return getList(key, null);\n    }\n\n    /**\n     * Get a List of strings associated with the given configuration key.\n     * <p>\n     * The list is a copy of the internal data of this object, and as\n     * such you may alter it freely.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated List.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a List.\n     * @since Commons Collections 3.2\n     */\n    public List getList(String key, List defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof List) {\n            return new ArrayList((List) value);\n            \n        } else if (value instanceof String) {\n            List values = new ArrayList(1);\n            values.add(value);\n            put(key, values);\n            return values;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getList(key, defaultValue);\n            } else {\n                return ((defaultValue == null) ? new ArrayList() : defaultValue);\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a List object\");\n        }\n    }\n\n    /**\n     * Get a boolean associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated boolean.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Boolean.\n     */\n    public boolean getBoolean(String key) {\n        Boolean b = getBoolean(key, null);\n        if (b != null) {\n            return b.booleanValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a boolean associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated boolean.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Boolean.\n     */\n    public boolean getBoolean(String key, boolean defaultValue) {\n        return getBoolean(key, new Boolean(defaultValue)).booleanValue();\n    }\n\n    /**\n     * Get a boolean associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated boolean if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Boolean.\n     */\n    public Boolean getBoolean(String key, Boolean defaultValue) {\n\n        Object value = get(key);\n\n        if (value instanceof Boolean) {\n            return (Boolean) value;\n            \n        } else if (value instanceof String) {\n            String s = testBoolean((String) value);\n            Boolean b = new Boolean(s);\n            put(key, b);\n            return b;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getBoolean(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Boolean object\");\n        }\n    }\n\n    /**\n     * Test whether the string represent by value maps to a boolean\n     * value or not. We will allow <code>true</code>, <code>on</code>,\n     * and <code>yes</code> for a <code>true</code> boolean value, and\n     * <code>false</code>, <code>off</code>, and <code>no</code> for\n     * <code>false</code> boolean values.  Case of value to test for\n     * boolean status is ignored.\n     *\n     * @param value  the value to test for boolean state\n     * @return <code>true</code> or <code>false</code> if the supplied\n     * text maps to a boolean value, or <code>null</code> otherwise.\n     */\n    public String testBoolean(String value) {\n        String s = value.toLowerCase();\n\n        if (s.equals(\"true\") || s.equals(\"on\") || s.equals(\"yes\")) {\n            return \"true\";\n        } else if (s.equals(\"false\") || s.equals(\"off\") || s.equals(\"no\")) {\n            return \"false\";\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Get a byte associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated byte.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Byte.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public byte getByte(String key) {\n        Byte b = getByte(key, null);\n        if (b != null) {\n            return b.byteValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \" doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a byte associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated byte.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Byte.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public byte getByte(String key, byte defaultValue) {\n        return getByte(key, new Byte(defaultValue)).byteValue();\n    }\n\n    /**\n     * Get a byte associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated byte if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Byte.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public Byte getByte(String key, Byte defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Byte) {\n            return (Byte) value;\n            \n        } else if (value instanceof String) {\n            Byte b = new Byte((String) value);\n            put(key, b);\n            return b;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getByte(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Byte object\");\n        }\n    }\n\n    /**\n     * Get a short associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated short.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Short.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public short getShort(String key) {\n        Short s = getShort(key, null);\n        if (s != null) {\n            return s.shortValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a short associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated short.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Short.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public short getShort(String key, short defaultValue) {\n        return getShort(key, new Short(defaultValue)).shortValue();\n    }\n\n    /**\n     * Get a short associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated short if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Short.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public Short getShort(String key, Short defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Short) {\n            return (Short) value;\n            \n        } else if (value instanceof String) {\n            Short s = new Short((String) value);\n            put(key, s);\n            return s;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getShort(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Short object\");\n        }\n    }\n\n    /**\n     * The purpose of this method is to get the configuration resource\n     * with the given name as an integer.\n     *\n     * @param name The resource name.\n     * @return The value of the resource as an integer.\n     */\n    public int getInt(String name) {\n        return getInteger(name);\n    }\n\n    /**\n     * The purpose of this method is to get the configuration resource\n     * with the given name as an integer, or a default value.\n     *\n     * @param name The resource name\n     * @param def The default value of the resource.\n     * @return The value of the resource as an integer.\n     */\n    public int getInt(String name, int def) {\n        return getInteger(name, def);\n    }\n\n    /**\n     * Get a int associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated int.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Integer.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public int getInteger(String key) {\n        Integer i = getInteger(key, null);\n        if (i != null) {\n            return i.intValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a int associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated int.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Integer.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public int getInteger(String key, int defaultValue) {\n        Integer i = getInteger(key, null);\n\n        if (i == null) {\n            return defaultValue;\n        }\n        return i.intValue();\n    }\n\n    /**\n     * Get a int associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated int if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Integer.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public Integer getInteger(String key, Integer defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Integer) {\n            return (Integer) value;\n            \n        } else if (value instanceof String) {\n            Integer i = new Integer((String) value);\n            put(key, i);\n            return i;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getInteger(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Integer object\");\n        }\n    }\n\n    /**\n     * Get a long associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated long.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Long.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public long getLong(String key) {\n        Long l = getLong(key, null);\n        if (l != null) {\n            return l.longValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a long associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated long.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Long.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public long getLong(String key, long defaultValue) {\n        return getLong(key, new Long(defaultValue)).longValue();\n    }\n\n    /**\n     * Get a long associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated long if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Long.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public Long getLong(String key, Long defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Long) {\n            return (Long) value;\n            \n        } else if (value instanceof String) {\n            Long l = new Long((String) value);\n            put(key, l);\n            return l;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getLong(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Long object\");\n        }\n    }\n\n    /**\n     * Get a float associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated float.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Float.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public float getFloat(String key) {\n        Float f = getFloat(key, null);\n        if (f != null) {\n            return f.floatValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a float associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated float.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Float.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public float getFloat(String key, float defaultValue) {\n        return getFloat(key, new Float(defaultValue)).floatValue();\n    }\n\n    /**\n     * Get a float associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated float if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Float.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public Float getFloat(String key, Float defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Float) {\n            return (Float) value;\n            \n        } else if (value instanceof String) {\n            Float f = new Float((String) value);\n            put(key, f);\n            return f;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getFloat(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Float object\");\n        }\n    }\n\n    /**\n     * Get a double associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated double.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Double.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public double getDouble(String key) {\n        Double d = getDouble(key, null);\n        if (d != null) {\n            return d.doubleValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a double associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated double.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Double.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public double getDouble(String key, double defaultValue) {\n        return getDouble(key, new Double(defaultValue)).doubleValue();\n    }\n\n    /**\n     * Get a double associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated double if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Double.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public Double getDouble(String key, Double defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Double) {\n            return (Double) value;\n            \n        } else if (value instanceof String) {\n            Double d = new Double((String) value);\n            put(key, d);\n            return d;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getDouble(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Double object\");\n        }\n    }\n\n    /**\n     * Convert a standard properties class into a configuration class.\n     * <p>\n     * NOTE: From Commons Collections 3.2 this method will pick up\n     * any default parent Properties of the specified input object.\n     *\n     * @param props  the properties object to convert\n     * @return new ExtendedProperties created from props\n     */\n    public static ExtendedProperties convertProperties(Properties props) {\n        ExtendedProperties c = new ExtendedProperties();\n\n        for (Enumeration e = props.propertyNames(); e.hasMoreElements();) {\n            String s = (String) e.nextElement();\n            c.setProperty(s, props.getProperty(s));\n        }\n\n        return c;\n    }\n\n    /**\n     * Add a new property specified by the key to the \n     * ExtendedProperties.\n     *\n     * @param key specifying the property\n     * @param value for the property\n     * @return old value of the property\n     */\n\n    /**\n     * Add a map full of key/value pairs to the ExtendedProperties. \n     * If the added map is an ExtendedProperties class, then the \n     * order of the added properties is maintained. \n     *\n     * @param map full of key/value pair data\n     */\n    public void putAll(Map map) {\n        if (map instanceof ExtendedProperties) {\n            for (Iterator it = ((ExtendedProperties) map).getKeys(); it.hasNext(); ) {\n                Object key = it.next();\n                put(key, map.get(key));\n            }\n        } else {\n            for (Iterator it = map.entrySet().iterator(); it.hasNext(); ) {\n                Map.Entry entry = (Map.Entry) it.next();\n                put(entry.getKey(), entry.getValue());\n            }\n        }\n    }\n\n\n    /**\n     * Remove the property specified by the key from the \n     * ExtendedProperties.\n     *\n     * @param key specifying the property\n     * @return old value of the property\n     */\n\n}\n", "fixed_version": "/*\n *  Licensed to the Apache Software Foundation (ASF) under one or more\n *  contributor license agreements.  See the NOTICE file distributed with\n *  this work for additional information regarding copyright ownership.\n *  The ASF licenses this file to You under the Apache License, Version 2.0\n *  (the \"License\"); you may not use this file except in compliance with\n *  the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.apache.commons.collections;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.LineNumberReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.UnsupportedEncodingException;\nimport java.util.ArrayList;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Properties;\nimport java.util.StringTokenizer;\nimport java.util.Vector;\n\n/**\n * This class extends normal Java properties by adding the possibility\n * to use the same key many times concatenating the value strings\n * instead of overwriting them.\n * <p>\n * <b>Please consider using the <code>PropertiesConfiguration</code> class in\n * Commons-Configuration as soon as it is released.</b>\n * <p>\n * The Extended Properties syntax is explained here:\n *\n * <ul>\n *  <li>\n *   Each property has the syntax <code>key = value</code>\n *  </li>\n *  <li>\n *   The <i>key</i> may use any character but the equal sign '='.\n *  </li>\n *  <li>\n *   <i>value</i> may be separated on different lines if a backslash\n *   is placed at the end of the line that continues below.\n *  </li>\n *  <li>\n *   If <i>value</i> is a list of strings, each token is separated\n *   by a comma ','.\n *  </li>\n *  <li>\n *   Commas in each token are escaped placing a backslash right before\n *   the comma.\n *  </li>\n *  <li>\n *   Backslashes are escaped by using two consecutive backslashes i.e. \\\\\n *  </li>\n *  <li>\n *   If a <i>key</i> is used more than once, the values are appended\n *   as if they were on the same line separated with commas.\n *  </li>\n *  <li>\n *   Blank lines and lines starting with character '#' are skipped.\n *  </li>\n *  <li>\n *   If a property is named \"include\" (or whatever is defined by\n *   setInclude() and getInclude() and the value of that property is\n *   the full path to a file on disk, that file will be included into\n *   the ConfigurationsRepository. You can also pull in files relative\n *   to the parent configuration file. So if you have something\n *   like the following:\n *\n *   include = additional.properties\n *\n *   Then \"additional.properties\" is expected to be in the same\n *   directory as the parent configuration file.\n * \n *   Duplicate name values will be replaced, so be careful.\n *\n *  </li>\n * </ul>\n *\n * <p>Here is an example of a valid extended properties file:\n *\n * <p><pre>\n *      # lines starting with # are comments\n *\n *      # This is the simplest property\n *      key = value\n *\n *      # A long property may be separated on multiple lines\n *      longvalue = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa \\\n *                  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n *\n *      # This is a property with many tokens\n *      tokens_on_a_line = first token, second token\n *\n *      # This sequence generates exactly the same result\n *      tokens_on_multiple_lines = first token\n *      tokens_on_multiple_lines = second token\n *\n *      # commas may be escaped in tokens\n *      commas.escaped = Hi\\, what'up?\n * </pre>\n *\n * <p><b>NOTE</b>: this class has <b>not</b> been written for\n * performance nor low memory usage.  In fact, it's way slower than it\n * could be and generates too much memory garbage.  But since\n * performance is not an issue during intialization (and there is not\n * much time to improve it), I wrote it this way.  If you don't like\n * it, go ahead and tune it up!\n *\n * @since Commons Collections 1.0\n * @version $Revision$ $Date$\n * \n * @author <a href=\"mailto:stefano@apache.org\">Stefano Mazzocchi</a>\n * @author <a href=\"mailto:jon@latchkey.com\">Jon S. Stevens</a>\n * @author <a href=\"mailto:daveb@miceda-data\">Dave Bryson</a>\n * @author <a href=\"mailto:jvanzyl@periapt.com\">Jason van Zyl</a>\n * @author <a href=\"mailto:geirm@optonline.net\">Geir Magnusson Jr.</a>\n * @author <a href=\"mailto:leon@opticode.co.za\">Leon Messerschmidt</a>\n * @author <a href=\"mailto:kjohnson@transparent.com\">Kent Johnson</a>\n * @author <a href=\"mailto:dlr@finemaltcoding.com\">Daniel Rall</a>\n * @author <a href=\"mailto:ipriha@surfeu.fi\">Ilkka Priha</a>\n * @author Janek Bogucki\n * @author Mohan Kishore\n * @author Stephen Colebourne\n * @author Shinobu Kawai\n * @author <a href=\"mailto:hps@intermeta.de\">Henning P. Schmiedehausen</a>\n */\npublic class ExtendedProperties extends Hashtable {\n    \n    /**\n     * Default configurations repository.\n     */\n    private ExtendedProperties defaults;\n\n    /**\n     * The file connected to this repository (holding comments and\n     * such).\n     *\n     * @serial\n     */\n    protected String file;\n\n    /**\n     * Base path of the configuration file used to create\n     * this ExtendedProperties object.\n     */\n    protected String basePath;\n\n    /**\n     * File separator.\n     */\n    protected String fileSeparator = System.getProperty(\"file.separator\");\n\n    /**\n     * Has this configuration been intialized.\n     */\n    protected boolean isInitialized = false;\n\n    /**\n     * This is the name of the property that can point to other\n     * properties file for including other properties files.\n     */\n    private String includePropertyName = null;\n\n    /**\n     * This is the default name of the property that can point to other\n     * properties file for including other properties files.\n     * \n     * @deprecated Use getInclude() and setInclude() methods which operate\n     * on an instance variable from v3.3. Due to be removed in v4.0.\n     */\n    protected static String include = \"include\";\n\n    /**\n     * These are the keys in the order they listed\n     * in the configuration file. This is useful when\n     * you wish to perform operations with configuration\n     * information in a particular order.\n     */\n    protected ArrayList keysAsListed = new ArrayList();\n\n    protected final static String START_TOKEN=\"${\";\n    protected final static String END_TOKEN=\"}\";\n\n\n    /**\n     * Interpolate key names to handle ${key} stuff\n     *\n     * @param base string to interpolate\n     * @return returns the key name with the ${key} substituted\n     */\n    protected String interpolate(String base) {\n        // COPIED from [configuration] 2003-12-29\n        return (interpolateHelper(base, null));\n    }\n\n    /**\n     * Recursive handler for multiple levels of interpolation.\n     *\n     * When called the first time, priorVariables should be null.\n     *\n     * @param base string with the ${key} variables\n     * @param priorVariables serves two purposes: to allow checking for\n     * loops, and creating a meaningful exception message should a loop\n     * occur.  It's 0'th element will be set to the value of base from\n     * the first call.  All subsequent interpolated variables are added\n     * afterward.\n     *\n     * @return the string with the interpolation taken care of\n     */\n    protected String interpolateHelper(String base, List priorVariables) {\n        // COPIED from [configuration] 2003-12-29\n        if (base == null) {\n            return null;\n        }\n\n        // on the first call initialize priorVariables\n        // and add base as the first element\n        if (priorVariables == null) {\n            priorVariables = new ArrayList();\n            priorVariables.add(base);\n        }\n\n        int begin = -1;\n        int end = -1;\n        int prec = 0 - END_TOKEN.length();\n        String variable = null;\n        StringBuffer result = new StringBuffer();\n\n        // FIXME: we should probably allow the escaping of the start token\n        while (((begin = base.indexOf(START_TOKEN, prec + END_TOKEN.length())) > -1)\n            && ((end = base.indexOf(END_TOKEN, begin)) > -1)) {\n            result.append(base.substring(prec + END_TOKEN.length(), begin));\n            variable = base.substring(begin + START_TOKEN.length(), end);\n\n            // if we've got a loop, create a useful exception message and throw\n            if (priorVariables.contains(variable)) {\n                String initialBase = priorVariables.remove(0).toString();\n                priorVariables.add(variable);\n                StringBuffer priorVariableSb = new StringBuffer();\n\n                // create a nice trace of interpolated variables like so:\n                // var1->var2->var3\n                for (Iterator it = priorVariables.iterator(); it.hasNext();) {\n                    priorVariableSb.append(it.next());\n                    if (it.hasNext()) {\n                        priorVariableSb.append(\"->\");\n                    }\n                }\n\n                throw new IllegalStateException(\n                    \"infinite loop in property interpolation of \" + initialBase + \": \" + priorVariableSb.toString());\n            }\n            // otherwise, add this variable to the interpolation list.\n            else {\n                priorVariables.add(variable);\n            }\n\n            //QUESTION: getProperty or getPropertyDirect\n            Object value = getProperty(variable);\n            if (value != null) {\n                result.append(interpolateHelper(value.toString(), priorVariables));\n\n                // pop the interpolated variable off the stack\n                // this maintains priorVariables correctness for\n                // properties with multiple interpolations, e.g.\n                // prop.name=${some.other.prop1}/blahblah/${some.other.prop2}\n                priorVariables.remove(priorVariables.size() - 1);\n            } else if (defaults != null && defaults.getString(variable, null) != null) {\n                result.append(defaults.getString(variable));\n            } else {\n                //variable not defined - so put it back in the value\n                result.append(START_TOKEN).append(variable).append(END_TOKEN);\n            }\n            prec = end;\n        }\n        result.append(base.substring(prec + END_TOKEN.length(), base.length()));\n\n        return result.toString();\n    }\n    \n    /**\n     * Inserts a backslash before every comma and backslash. \n     */\n    private static String escape(String s) {\n        StringBuffer buf = new StringBuffer(s);\n        for (int i = 0; i < buf.length(); i++) {\n            char c = buf.charAt(i);\n            if (c == ',' || c == '\\\\') {\n                buf.insert(i, '\\\\');\n                i++;\n            }\n        }\n        return buf.toString();\n    }\n    \n    /**\n     * Removes a backslash from every pair of backslashes. \n     */\n    private static String unescape(String s) {\n        StringBuffer buf = new StringBuffer(s);\n        for (int i = 0; i < buf.length() - 1; i++) {\n            char c1 = buf.charAt(i);\n            char c2 = buf.charAt(i + 1);\n            if (c1 == '\\\\' && c2 == '\\\\') {\n                buf.deleteCharAt(i);\n            }\n        }\n        return buf.toString();\n    }\n\n    /**\n     * Counts the number of successive times 'ch' appears in the\n     * 'line' before the position indicated by the 'index'.\n     */\n    private static int countPreceding(String line, int index, char ch) {\n        int i;\n        for (i = index - 1; i >= 0; i--) {\n            if (line.charAt(i) != ch) {\n                break;\n            }\n        }\n        return index - 1 - i;\n    }\n\n    /**\n     * Checks if the line ends with odd number of backslashes \n     */\n    private static boolean endsWithSlash(String line) {\n        if (!line.endsWith(\"\\\\\")) {\n            return false;\n        }\n        return (countPreceding(line, line.length() - 1, '\\\\') % 2 == 0);\n    }\n\n    /**\n     * This class is used to read properties lines.  These lines do\n     * not terminate with new-line chars but rather when there is no\n     * backslash sign a the end of the line.  This is used to\n     * concatenate multiple lines for readability.\n     */\n    static class PropertiesReader extends LineNumberReader {\n        /**\n         * Constructor.\n         *\n         * @param reader A Reader.\n         */\n        public PropertiesReader(Reader reader) {\n            super(reader);\n        }\n\n        /**\n         * Read a property.\n         *\n         * @return a String property\n         * @throws IOException if there is difficulty reading the source.\n         */\n        public String readProperty() throws IOException {\n            StringBuffer buffer = new StringBuffer();\n            String line = readLine();\n            while (line != null) {\n                line = line.trim();\n                if ((line.length() != 0) && (line.charAt(0) != '#')) {\n                    if (endsWithSlash(line)) {\n                        line = line.substring(0, line.length() - 1);\n                        buffer.append(line);\n                    } else {\n                        buffer.append(line);\n                        return buffer.toString();  // normal method end\n                    }\n                }\n                line = readLine();\n            }\n            return null;  // EOF reached\n        }\n    }\n\n    /**\n     * This class divides into tokens a property value.  Token\n     * separator is \",\" but commas into the property value are escaped\n     * using the backslash in front.\n     */\n    static class PropertiesTokenizer extends StringTokenizer {\n        /**\n         * The property delimiter used while parsing (a comma).\n         */\n        static final String DELIMITER = \",\";\n\n        /**\n         * Constructor.\n         *\n         * @param string A String.\n         */\n        public PropertiesTokenizer(String string) {\n            super(string, DELIMITER);\n        }\n\n        /**\n         * Check whether the object has more tokens.\n         *\n         * @return True if the object has more tokens.\n         */\n        public boolean hasMoreTokens() {\n            return super.hasMoreTokens();\n        }\n\n        /**\n         * Get next token.\n         *\n         * @return A String.\n         */\n        public String nextToken() {\n            StringBuffer buffer = new StringBuffer();\n\n            while (hasMoreTokens()) {\n                String token = super.nextToken();\n                if (endsWithSlash(token)) {\n                    buffer.append(token.substring(0, token.length() - 1));\n                    buffer.append(DELIMITER);\n                } else {\n                    buffer.append(token);\n                    break;\n                }\n            }\n\n            return buffer.toString().trim();\n        }\n    }\n\n    /**\n     * Creates an empty extended properties object.\n     */\n    public ExtendedProperties() {\n        super();\n    }\n\n    /**\n     * Creates and loads the extended properties from the specified file.\n     *\n     * @param file  the filename to load\n     * @throws IOException if a file error occurs\n     */\n    public ExtendedProperties(String file) throws IOException {\n        this(file, null);\n    }\n\n    /**\n     * Creates and loads the extended properties from the specified file.\n     *\n     * @param file  the filename to load\n     * @param defaultFile  a second filename to load default values from\n     * @throws IOException if a file error occurs\n     */\n    public ExtendedProperties(String file, String defaultFile) throws IOException {\n        this.file = file;\n\n        basePath = new File(file).getAbsolutePath();\n        basePath = basePath.substring(0, basePath.lastIndexOf(fileSeparator) + 1);\n\n        FileInputStream in = null;\n        try {\n            in = new FileInputStream(file);\n            this.load(in);\n        } finally {\n            try {\n                if (in != null) {\n                    in.close();\n                }\n            } catch (IOException ex) {}\n        }\n\n        if (defaultFile != null) {\n            defaults = new ExtendedProperties(defaultFile);\n        }\n    }\n\n    /**\n     * Indicate to client code whether property\n     * resources have been initialized or not.\n     */\n    public boolean isInitialized() {\n        return isInitialized;\n    }\n\n    /**\n     * Gets the property value for including other properties files.\n     * By default it is \"include\".\n     * <p>\n     * NOTE: Prior to v3.3 this method accessed a static variable.\n     * It now accesses an instance variable. For compatability, if the\n     * instance variable has not been set then the previous static\n     * variable is then accessed. However, the protected static variable\n     * can now only be set by subclasses.\n     * In v4.0, the static variable will be removed.\n     *\n     * @return the property name which includes another property\n     */\n    public String getInclude() {\n        if (includePropertyName == null) {\n            return include;  // backwards compatability\n        }\n        if (\"\".equals(includePropertyName)) {\n            return null;  // hack to allow backwards compatability\n        }\n        return includePropertyName;\n    }\n\n    /**\n     * Sets the property value for including other properties files.\n     * By default it is \"include\".\n     * <p>\n     * NOTE: Prior to v3.3 this method set a static variable and affected all\n     * users of the class. It now sets an instance variable.\n     * An empty string is also now converted to null internally.\n     * In v4.0, the static variable will be removed.\n     *\n     * @param inc  the property name which includes another property, empty converted to null\n     */\n    public void setInclude(String inc) {\n        if (inc == null) {\n            inc = \"\";  // hack to allow backwards compatability\n        }\n        includePropertyName = inc;\n    }\n\n    /**\n     * Load the properties from the given input stream.\n     *\n     * @param input  the InputStream to load from\n     * @throws IOException if an IO error occurs\n     */\n    public void load(InputStream input) throws IOException {\n        load(input, null);\n    }\n\n    /**\n     * Load the properties from the given input stream\n     * and using the specified encoding.\n     *\n     * @param input  the InputStream to load from\n     * @param enc  the encoding to use\n     * @throws IOException if an IO error occurs\n     */\n    public synchronized void load(InputStream input, String enc) throws IOException {\n        PropertiesReader reader = null;\n        if (enc != null) {\n            try {\n                reader = new PropertiesReader(new InputStreamReader(input, enc));\n                \n            } catch (UnsupportedEncodingException ex) {\n                // Another try coming up....\n            }\n        }\n        \n        if (reader == null) {\n            try {\n                reader = new PropertiesReader(new InputStreamReader(input, \"8859_1\"));\n                \n            } catch (UnsupportedEncodingException ex) {\n                // ISO8859-1 support is required on java platforms but....\n                // If it's not supported, use the system default encoding\n                reader = new PropertiesReader(new InputStreamReader(input));\n            }\n        }\n\n        try {\n            String includeProperty = getInclude();\n            while (true) {\n                String line = reader.readProperty();\n                if (line == null) {\n                    return;  // EOF\n                }\n                int equalSign = line.indexOf('=');\n\n                if (equalSign > 0) {\n                    String key = line.substring(0, equalSign).trim();\n                    String value = line.substring(equalSign + 1).trim();\n\n                    // Configure produces lines like this ... just ignore them\n                    if (\"\".equals(value)) {\n                        continue;\n                    }\n\n                    if (includeProperty != null && key.equalsIgnoreCase(includeProperty)) {\n                        // Recursively load properties files.\n                        File file = null;\n\n                        if (value.startsWith(fileSeparator)) {\n                            // We have an absolute path so we'll use this\n                            file = new File(value);\n                            \n                        } else {\n                            // We have a relative path, and we have two \n                            // possible forms here. If we have the \"./\" form\n                            // then just strip that off first before continuing.\n                            if (value.startsWith(\".\" + fileSeparator)) {\n                                value = value.substring(2);\n                            }\n\n                            file = new File(basePath + value);\n                        }\n\n                        if (file != null && file.exists() && file.canRead()) {\n                            load(new FileInputStream(file));\n                        }\n                    } else {\n                        addProperty(key, value);\n                    }\n                }\n            }\n        } finally {\n            // Loading is initializing\n            isInitialized = true;\n        }\n    }\n\n    /**\n     * Gets a property from the configuration.\n     *\n     * @param key property to retrieve\n     * @return value as object. Will return user value if exists,\n     *        if not then default value if exists, otherwise null\n     */\n    public Object getProperty(String key) {\n        // first, try to get from the 'user value' store\n        Object obj = super.get(key);\n\n        if (obj == null) {\n            // if there isn't a value there, get it from the\n            // defaults if we have them\n            if (defaults != null) {\n                obj = defaults.get(key);\n            }\n        }\n\n        return obj;\n    }\n    \n    /**\n     * Add a property to the configuration. If it already\n     * exists then the value stated here will be added\n     * to the configuration entry. For example, if\n     *\n     * <code>resource.loader = file</code>\n     *\n     * is already present in the configuration and you\n     *\n     * <code>addProperty(\"resource.loader\", \"classpath\")</code>\n     *\n     * Then you will end up with a Vector like the\n     * following:\n     *\n     * <code>[\"file\", \"classpath\"]</code>\n     *\n     * @param key  the key to add\n     * @param value  the value to add\n     */\n    public void addProperty(String key, Object value) {\n        if (value instanceof String) {\n            String str = (String) value;\n            if (str.indexOf(PropertiesTokenizer.DELIMITER) > 0) {\n                // token contains commas, so must be split apart then added\n                PropertiesTokenizer tokenizer = new PropertiesTokenizer(str);\n                while (tokenizer.hasMoreTokens()) {\n                    String token = tokenizer.nextToken();\n                    addPropertyInternal(key, unescape(token));\n                }\n            } else {\n                // token contains no commas, so can be simply added\n                addPropertyInternal(key, unescape(str));\n            }\n        } else {\n            addPropertyInternal(key, value);\n        }\n\n        // Adding a property connotes initialization\n        isInitialized = true;\n    }\n\n    /**\n     * Adds a key/value pair to the map.  This routine does\n     * no magic morphing.  It ensures the keylist is maintained\n     *\n     * @param key  the key to store at\n     * @param value  the decoded object to store\n     */\n    private void addPropertyDirect(String key, Object value) {\n        // safety check\n        if (!containsKey(key)) {\n            keysAsListed.add(key);\n        }\n        super.put(key, value);\n    }\n\n    /**\n     * Adds a decoded property to the map w/o checking for commas - used\n     * internally when a property has been broken up into\n     * strings that could contain escaped commas to prevent\n     * the inadvertent vectorization.\n     * <p>\n     * Thanks to Leon Messerschmidt for this one.\n     *\n     * @param key  the key to store at\n     * @param value  the decoded object to store\n     */\n    private void addPropertyInternal(String key, Object value) {\n        Object current = this.get(key);\n\n        if (current instanceof String) {\n            // one object already in map - convert it to a vector\n            List values = new Vector(2);\n            values.add(current);\n            values.add(value);\n            super.put(key, values);\n            \n        } else if (current instanceof List) {\n            // already a list - just add the new token\n            ((List) current).add(value);\n            \n        } else {\n            // brand new key - store in keysAsListed to retain order\n            if (!containsKey(key)) {\n                keysAsListed.add(key);\n            }\n            super.put(key, value);\n        }\n    }\n\n    /**\n     * Set a property, this will replace any previously\n     * set values. Set values is implicitly a call\n     * to clearProperty(key), addProperty(key,value).\n     *\n     * @param key  the key to set\n     * @param value  the value to set\n     */\n    public void setProperty(String key, Object value) {\n        clearProperty(key);\n        addProperty(key, value);\n    }\n    \n    /**\n     * Save the properties to the given output stream.\n     * <p>\n     * The stream is not closed, but it is flushed.\n     *\n     * @param output  an OutputStream, may be null\n     * @param header  a textual comment to act as a file header\n     * @throws IOException if an IO error occurs\n     */\n    public synchronized void save(OutputStream output, String header) throws IOException {\n        if (output == null) {\n            return;\n        }\n        PrintWriter theWrtr = new PrintWriter(output);\n        if (header != null) {\n            theWrtr.println(header);\n        }\n        \n        Enumeration theKeys = keys();\n        while (theKeys.hasMoreElements()) {\n            String key = (String) theKeys.nextElement();\n            Object value = get(key);\n            if (value != null) {\n                if (value instanceof String) {\n                    StringBuffer currentOutput = new StringBuffer();\n                    currentOutput.append(key);\n                    currentOutput.append(\"=\");\n                    currentOutput.append(escape((String) value));\n                    theWrtr.println(currentOutput.toString());\n                    \n                } else if (value instanceof List) {\n                    List values = (List) value;\n                    for (Iterator it = values.iterator(); it.hasNext(); ) {\n                        String currentElement = (String) it.next();\n                        StringBuffer currentOutput = new StringBuffer();\n                        currentOutput.append(key);\n                        currentOutput.append(\"=\");\n                        currentOutput.append(escape(currentElement));\n                        theWrtr.println(currentOutput.toString());\n                    }\n                }\n            }\n            theWrtr.println();\n            theWrtr.flush();\n        }\n    }\n\n    /**\n     * Combines an existing Hashtable with this Hashtable.\n     * <p>\n     * Warning: It will overwrite previous entries without warning.\n     *\n     * @param props  the properties to combine\n     */\n    public void combine(ExtendedProperties props) {\n        for (Iterator it = props.getKeys(); it.hasNext();) {\n            String key = (String) it.next();\n            setProperty(key, props.get(key));\n        }\n    }\n    \n    /**\n     * Clear a property in the configuration.\n     *\n     * @param key  the property key to remove along with corresponding value\n     */\n    public void clearProperty(String key) {\n        if (containsKey(key)) {\n            // we also need to rebuild the keysAsListed or else\n            // things get *very* confusing\n            for (int i = 0; i < keysAsListed.size(); i++) {\n                if (( keysAsListed.get(i)).equals(key)) {\n                    keysAsListed.remove(i);\n                    break;\n                }\n            }\n            super.remove(key);\n        }\n    }\n\n    /**\n     * Get the list of the keys contained in the configuration\n     * repository.\n     *\n     * @return an Iterator over the keys\n     */\n    public Iterator getKeys() {\n        return keysAsListed.iterator();\n    }\n\n    /**\n     * Get the list of the keys contained in the configuration\n     * repository that match the specified prefix.\n     *\n     * @param prefix  the prefix to match\n     * @return an Iterator of keys that match the prefix\n     */\n    public Iterator getKeys(String prefix) {\n        Iterator keys = getKeys();\n        ArrayList matchingKeys = new ArrayList();\n\n        while (keys.hasNext()) {\n            Object key = keys.next();\n\n            if (key instanceof String && ((String) key).startsWith(prefix)) {\n                matchingKeys.add(key);\n            }\n        }\n        return matchingKeys.iterator();\n    }\n\n    /**\n     * Create an ExtendedProperties object that is a subset\n     * of this one. Take into account duplicate keys\n     * by using the setProperty() in ExtendedProperties.\n     *\n     * @param prefix  the prefix to get a subset for\n     * @return a new independent ExtendedProperties\n     */\n    public ExtendedProperties subset(String prefix) {\n        ExtendedProperties c = new ExtendedProperties();\n        Iterator keys = getKeys();\n        boolean validSubset = false;\n\n        while (keys.hasNext()) {\n            Object key = keys.next();\n\n            if (key instanceof String && ((String) key).startsWith(prefix)) {\n                if (!validSubset) {\n                    validSubset = true;\n                }\n\n                /*\n                 * Check to make sure that c.subset(prefix) doesn't\n                 * blow up when there is only a single property\n                 * with the key prefix. This is not a useful\n                 * subset but it is a valid subset.\n                 */\n                String newKey = null;\n                if (((String) key).length() == prefix.length()) {\n                    newKey = prefix;\n                } else {\n                    newKey = ((String) key).substring(prefix.length() + 1);\n                }\n\n                /*\n                 *  use addPropertyDirect() - this will plug the data as \n                 *  is into the Map, but will also do the right thing\n                 *  re key accounting\n                 */\n                c.addPropertyDirect(newKey, get(key));\n            }\n        }\n\n        if (validSubset) {\n            return c;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Display the configuration for debugging purposes to System.out.\n     */\n    public void display() {\n        Iterator i = getKeys();\n\n        while (i.hasNext()) {\n            String key = (String) i.next();\n            Object value = get(key);\n            System.out.println(key + \" => \" + value);\n        }\n    }\n\n    /**\n     * Get a string associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated string.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a String.\n     */\n    public String getString(String key) {\n        return getString(key, null);\n    }\n\n    /**\n     * Get a string associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated string if key is found,\n     * default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a String.\n     */\n    public String getString(String key, String defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof String) {\n            return interpolate((String) value);\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return interpolate(defaults.getString(key, defaultValue));\n            } else {\n                return interpolate(defaultValue);\n            }\n        } else if (value instanceof List) {\n            return interpolate((String) ((List) value).get(0));\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a String object\");\n        }\n    }\n\n    /**\n     * Get a list of properties associated with the given\n     * configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated properties if key is found.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a String/List.\n     * @throws IllegalArgumentException if one of the tokens is\n     * malformed (does not contain an equals sign).\n     */\n    public Properties getProperties(String key) {\n        return getProperties(key, new Properties());\n    }\n\n    /**\n     * Get a list of properties associated with the given\n     * configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated properties if key is found.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a String/List.\n     * @throws IllegalArgumentException if one of the tokens is\n     * malformed (does not contain an equals sign).\n     */\n    public Properties getProperties(String key, Properties defaults) {\n        /*\n         * Grab an array of the tokens for this key.\n         */\n        String[] tokens = getStringArray(key);\n\n        // Each token is of the form 'key=value'.\n        Properties props = new Properties(defaults);\n        for (int i = 0; i < tokens.length; i++) {\n            String token = tokens[i];\n            int equalSign = token.indexOf('=');\n            if (equalSign > 0) {\n                String pkey = token.substring(0, equalSign).trim();\n                String pvalue = token.substring(equalSign + 1).trim();\n                props.put(pkey, pvalue);\n            } else {\n                throw new IllegalArgumentException('\\'' + token + \"' does not contain \" + \"an equals sign\");\n            }\n        }\n        return props;\n    }\n\n    /**\n     * Get an array of strings associated with the given configuration\n     * key.\n     *\n     * @param key The configuration key.\n     * @return The associated string array if key is found.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a String/List.\n     */\n    public String[] getStringArray(String key) {\n        Object value = get(key);\n\n        List values;\n        if (value instanceof String) {\n            values = new Vector(1);\n            values.add(value);\n            \n        } else if (value instanceof List) {\n            values = (List) value;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getStringArray(key);\n            } else {\n                return new String[0];\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a String/List object\");\n        }\n\n        String[] tokens = new String[values.size()];\n        for (int i = 0; i < tokens.length; i++) {\n            tokens[i] = (String) values.get(i);\n        }\n\n        return tokens;\n    }\n\n    /**\n     * Get a Vector of strings associated with the given configuration\n     * key.\n     *\n     * @param key The configuration key.\n     * @return The associated Vector.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Vector.\n     */\n    public Vector getVector(String key) {\n        return getVector(key, null);\n    }\n\n    /**\n     * Get a Vector of strings associated with the given configuration key.\n     * <p>\n     * The list is a copy of the internal data of this object, and as\n     * such you may alter it freely.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated Vector.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Vector.\n     */\n    public Vector getVector(String key, Vector defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof List) {\n            return new Vector((List) value);\n            \n        } else if (value instanceof String) {\n            Vector values = new Vector(1);\n            values.add(value);\n            super.put(key, values);\n            return values;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getVector(key, defaultValue);\n            } else {\n                return ((defaultValue == null) ? new Vector() : defaultValue);\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Vector object\");\n        }\n    }\n\n    /**\n     * Get a List of strings associated with the given configuration key.\n     * <p>\n     * The list is a copy of the internal data of this object, and as\n     * such you may alter it freely.\n     *\n     * @param key The configuration key.\n     * @return The associated List object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a List.\n     * @since Commons Collections 3.2\n     */\n    public List getList(String key) {\n        return getList(key, null);\n    }\n\n    /**\n     * Get a List of strings associated with the given configuration key.\n     * <p>\n     * The list is a copy of the internal data of this object, and as\n     * such you may alter it freely.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated List.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a List.\n     * @since Commons Collections 3.2\n     */\n    public List getList(String key, List defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof List) {\n            return new ArrayList((List) value);\n            \n        } else if (value instanceof String) {\n            List values = new ArrayList(1);\n            values.add(value);\n            super.put(key, values);\n            return values;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getList(key, defaultValue);\n            } else {\n                return ((defaultValue == null) ? new ArrayList() : defaultValue);\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a List object\");\n        }\n    }\n\n    /**\n     * Get a boolean associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated boolean.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Boolean.\n     */\n    public boolean getBoolean(String key) {\n        Boolean b = getBoolean(key, null);\n        if (b != null) {\n            return b.booleanValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a boolean associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated boolean.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Boolean.\n     */\n    public boolean getBoolean(String key, boolean defaultValue) {\n        return getBoolean(key, new Boolean(defaultValue)).booleanValue();\n    }\n\n    /**\n     * Get a boolean associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated boolean if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Boolean.\n     */\n    public Boolean getBoolean(String key, Boolean defaultValue) {\n\n        Object value = get(key);\n\n        if (value instanceof Boolean) {\n            return (Boolean) value;\n            \n        } else if (value instanceof String) {\n            String s = testBoolean((String) value);\n            Boolean b = new Boolean(s);\n            super.put(key, b);\n            return b;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getBoolean(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Boolean object\");\n        }\n    }\n\n    /**\n     * Test whether the string represent by value maps to a boolean\n     * value or not. We will allow <code>true</code>, <code>on</code>,\n     * and <code>yes</code> for a <code>true</code> boolean value, and\n     * <code>false</code>, <code>off</code>, and <code>no</code> for\n     * <code>false</code> boolean values.  Case of value to test for\n     * boolean status is ignored.\n     *\n     * @param value  the value to test for boolean state\n     * @return <code>true</code> or <code>false</code> if the supplied\n     * text maps to a boolean value, or <code>null</code> otherwise.\n     */\n    public String testBoolean(String value) {\n        String s = value.toLowerCase();\n\n        if (s.equals(\"true\") || s.equals(\"on\") || s.equals(\"yes\")) {\n            return \"true\";\n        } else if (s.equals(\"false\") || s.equals(\"off\") || s.equals(\"no\")) {\n            return \"false\";\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Get a byte associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated byte.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Byte.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public byte getByte(String key) {\n        Byte b = getByte(key, null);\n        if (b != null) {\n            return b.byteValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \" doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a byte associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated byte.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Byte.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public byte getByte(String key, byte defaultValue) {\n        return getByte(key, new Byte(defaultValue)).byteValue();\n    }\n\n    /**\n     * Get a byte associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated byte if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Byte.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public Byte getByte(String key, Byte defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Byte) {\n            return (Byte) value;\n            \n        } else if (value instanceof String) {\n            Byte b = new Byte((String) value);\n            super.put(key, b);\n            return b;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getByte(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Byte object\");\n        }\n    }\n\n    /**\n     * Get a short associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated short.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Short.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public short getShort(String key) {\n        Short s = getShort(key, null);\n        if (s != null) {\n            return s.shortValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a short associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated short.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Short.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public short getShort(String key, short defaultValue) {\n        return getShort(key, new Short(defaultValue)).shortValue();\n    }\n\n    /**\n     * Get a short associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated short if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Short.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public Short getShort(String key, Short defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Short) {\n            return (Short) value;\n            \n        } else if (value instanceof String) {\n            Short s = new Short((String) value);\n            super.put(key, s);\n            return s;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getShort(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Short object\");\n        }\n    }\n\n    /**\n     * The purpose of this method is to get the configuration resource\n     * with the given name as an integer.\n     *\n     * @param name The resource name.\n     * @return The value of the resource as an integer.\n     */\n    public int getInt(String name) {\n        return getInteger(name);\n    }\n\n    /**\n     * The purpose of this method is to get the configuration resource\n     * with the given name as an integer, or a default value.\n     *\n     * @param name The resource name\n     * @param def The default value of the resource.\n     * @return The value of the resource as an integer.\n     */\n    public int getInt(String name, int def) {\n        return getInteger(name, def);\n    }\n\n    /**\n     * Get a int associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated int.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Integer.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public int getInteger(String key) {\n        Integer i = getInteger(key, null);\n        if (i != null) {\n            return i.intValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a int associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated int.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Integer.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public int getInteger(String key, int defaultValue) {\n        Integer i = getInteger(key, null);\n\n        if (i == null) {\n            return defaultValue;\n        }\n        return i.intValue();\n    }\n\n    /**\n     * Get a int associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated int if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Integer.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public Integer getInteger(String key, Integer defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Integer) {\n            return (Integer) value;\n            \n        } else if (value instanceof String) {\n            Integer i = new Integer((String) value);\n            super.put(key, i);\n            return i;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getInteger(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Integer object\");\n        }\n    }\n\n    /**\n     * Get a long associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated long.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Long.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public long getLong(String key) {\n        Long l = getLong(key, null);\n        if (l != null) {\n            return l.longValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a long associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated long.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Long.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public long getLong(String key, long defaultValue) {\n        return getLong(key, new Long(defaultValue)).longValue();\n    }\n\n    /**\n     * Get a long associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated long if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Long.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public Long getLong(String key, Long defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Long) {\n            return (Long) value;\n            \n        } else if (value instanceof String) {\n            Long l = new Long((String) value);\n            super.put(key, l);\n            return l;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getLong(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Long object\");\n        }\n    }\n\n    /**\n     * Get a float associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated float.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Float.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public float getFloat(String key) {\n        Float f = getFloat(key, null);\n        if (f != null) {\n            return f.floatValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a float associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated float.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Float.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public float getFloat(String key, float defaultValue) {\n        return getFloat(key, new Float(defaultValue)).floatValue();\n    }\n\n    /**\n     * Get a float associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated float if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Float.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public Float getFloat(String key, Float defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Float) {\n            return (Float) value;\n            \n        } else if (value instanceof String) {\n            Float f = new Float((String) value);\n            super.put(key, f);\n            return f;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getFloat(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Float object\");\n        }\n    }\n\n    /**\n     * Get a double associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated double.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Double.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public double getDouble(String key) {\n        Double d = getDouble(key, null);\n        if (d != null) {\n            return d.doubleValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a double associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated double.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Double.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public double getDouble(String key, double defaultValue) {\n        return getDouble(key, new Double(defaultValue)).doubleValue();\n    }\n\n    /**\n     * Get a double associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated double if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Double.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public Double getDouble(String key, Double defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Double) {\n            return (Double) value;\n            \n        } else if (value instanceof String) {\n            Double d = new Double((String) value);\n            super.put(key, d);\n            return d;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getDouble(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Double object\");\n        }\n    }\n\n    /**\n     * Convert a standard properties class into a configuration class.\n     * <p>\n     * NOTE: From Commons Collections 3.2 this method will pick up\n     * any default parent Properties of the specified input object.\n     *\n     * @param props  the properties object to convert\n     * @return new ExtendedProperties created from props\n     */\n    public static ExtendedProperties convertProperties(Properties props) {\n        ExtendedProperties c = new ExtendedProperties();\n\n        for (Enumeration e = props.propertyNames(); e.hasMoreElements();) {\n            String s = (String) e.nextElement();\n            c.setProperty(s, props.getProperty(s));\n        }\n\n        return c;\n    }\n\n    /**\n     * Add a new property specified by the key to the \n     * ExtendedProperties.\n     *\n     * @param key specifying the property\n     * @param value for the property\n     * @return old value of the property\n     */\n    public Object put(Object key, Object value) {\n        String strKey = String.valueOf(key);\n        Object ret = getProperty(strKey);\n        addProperty(strKey, value);\n        return ret;\n    }\n\n    /**\n     * Add a map full of key/value pairs to the ExtendedProperties. \n     * If the added map is an ExtendedProperties class, then the \n     * order of the added properties is maintained. \n     *\n     * @param map full of key/value pair data\n     */\n    public void putAll(Map map) {\n        if (map instanceof ExtendedProperties) {\n            for (Iterator it = ((ExtendedProperties) map).getKeys(); it.hasNext(); ) {\n                Object key = it.next();\n                put(key, map.get(key));\n            }\n        } else {\n            for (Iterator it = map.entrySet().iterator(); it.hasNext(); ) {\n                Map.Entry entry = (Map.Entry) it.next();\n                put(entry.getKey(), entry.getValue());\n            }\n        }\n    }\n\n\n    /**\n     * Remove the property specified by the key from the \n     * ExtendedProperties.\n     *\n     * @param key specifying the property\n     * @return old value of the property\n     */\n    public Object remove(Object key) {\n        String strKey = String.valueOf(key);\n        Object ret = getProperty(strKey);\n        clearProperty(strKey);\n        return ret;\n    }\n\n}\n"}]}
{"project": "Collections", "bug_id": 8, "classes_modified": [{"class_name": "org.apache.commons.collections.buffer.UnboundedFifoBuffer", "buggy_version": "/*\n *  Licensed to the Apache Software Foundation (ASF) under one or more\n *  contributor license agreements.  See the NOTICE file distributed with\n *  this work for additional information regarding copyright ownership.\n *  The ASF licenses this file to You under the Apache License, Version 2.0\n *  (the \"License\"); you may not use this file except in compliance with\n *  the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.apache.commons.collections.buffer;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.AbstractCollection;\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\n\nimport org.apache.commons.collections.Buffer;\nimport org.apache.commons.collections.BufferUnderflowException;\n\n/**\n * UnboundedFifoBuffer is a very efficient implementation of\n * <code>Buffer</code> that can grow to any size.\n * According to performance testing, it exhibits a constant access time, but it\n * also outperforms ArrayList when used for the same purpose.\n * <p>\n * The removal order of an <code>UnboundedFifoBuffer</code> is based on the insertion\n * order; elements are removed in the same order in which they were added.\n * The iteration order is the same as the removal order.\n * <p>\n * The {@link #remove()} and {@link #get()} operations perform in constant time.\n * The {@link #add(Object)} operation performs in amortized constant time.  All\n * other operations perform in linear time or worse.\n * <p>\n * Note that this implementation is not synchronized.  The following can be\n * used to provide synchronized access to your <code>UnboundedFifoBuffer</code>:\n * <pre>\n *   Buffer fifo = BufferUtils.synchronizedBuffer(new UnboundedFifoBuffer());\n * </pre>\n * <p>\n * This buffer prevents null objects from being added.\n * <p>\n * This class is Serializable from Commons Collections 3.1.\n * \n * @since Commons Collections 3.0 (previously in main package v2.1)\n * @version $Revision$ $Date$\n *\n * @author Avalon\n * @author Federico Barbieri\n * @author Berin Loritsch\n * @author Paul Jack\n * @author Stephen Colebourne\n * @author Andreas Schlosser\n * @author Thomas Knych\n * @author Jordan Krey\n */\npublic class UnboundedFifoBuffer extends AbstractCollection implements Buffer, Serializable {\n    // invariant: buffer.length > size()\n    //   ie.buffer always has at least one empty entry\n\n    /** Serialization vesrion */\n    private static final long serialVersionUID = -3482960336579541419L;\n\n    /** The array of objects in the buffer. */\n    protected transient Object[] buffer;\n    /** The current head index. */\n    protected transient int head;\n    /** The current tail index. */\n    protected transient int tail;\n\n    /**\n     * Constructs an UnboundedFifoBuffer with the default number of elements.\n     * It is exactly the same as performing the following:\n     *\n     * <pre>\n     *   new UnboundedFifoBuffer(32);\n     * </pre>\n     */\n    public UnboundedFifoBuffer() {\n        this(32);\n    }\n\n    /**\n     * Constructs an UnboundedFifoBuffer with the specified number of elements.\n     * The integer must be a positive integer.\n     * \n     * @param initialSize  the initial size of the buffer\n     * @throws IllegalArgumentException  if the size is less than 1\n     */\n    public UnboundedFifoBuffer(int initialSize) {\n        if (initialSize <= 0) {\n            throw new IllegalArgumentException(\"The size must be greater than 0\");\n        }\n        buffer = new Object[initialSize + 1];\n        head = 0;\n        tail = 0;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Write the buffer out using a custom routine.\n     * \n     * @param out  the output stream\n     * @throws IOException\n     */\n    private void writeObject(ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        out.writeInt(size());\n        for (Iterator it = iterator(); it.hasNext();) {\n            out.writeObject(it.next());\n        }\n    }\n\n    /**\n     * Read the buffer in using a custom routine.\n     * \n     * @param in  the input stream\n     * @throws IOException\n     * @throws ClassNotFoundException\n     */\n    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        int size = in.readInt();\n        buffer = new Object[size + 1];\n        for (int i = 0; i < size; i++) {\n            buffer[i] = in.readObject();\n        }\n        head = 0;\n        tail = size;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns the number of elements stored in the buffer.\n     *\n     * @return this buffer's size\n     */\n    public int size() {\n        int size = 0;\n\n        if (tail < head) {\n            size = buffer.length - head + tail;\n        } else {\n            size = tail - head;\n        }\n\n        return size;\n    }\n\n    /**\n     * Returns true if this buffer is empty; false otherwise.\n     *\n     * @return true if this buffer is empty\n     */\n    public boolean isEmpty() {\n        return (size() == 0);\n    }\n\n    /**\n     * Adds the given element to this buffer.\n     *\n     * @param obj  the element to add\n     * @return true, always\n     * @throws NullPointerException  if the given element is null\n     */\n    public boolean add(final Object obj) {\n        if (obj == null) {\n            throw new NullPointerException(\"Attempted to add null object to buffer\");\n        }\n\n        if (size() + 1 >= buffer.length) {\n            // copy contents to a new buffer array\n            Object[] tmp = new Object[((buffer.length - 1) * 2) + 1];\n            int j = 0;\n            // move head to element zero in the new array\n            for (int i = head; i != tail;) {\n                tmp[j] = buffer[i];\n                buffer[i] = null;\n\n                j++;\n                i = increment(i);\n            }\n            buffer = tmp;\n            head = 0;\n            tail = j;\n        }\n\n        buffer[tail] = obj;\n        tail = increment(tail);\n        return true;\n    }\n\n    /**\n     * Returns the next object in the buffer.\n     *\n     * @return the next object in the buffer\n     * @throws BufferUnderflowException  if this buffer is empty\n     */\n    public Object get() {\n        if (isEmpty()) {\n            throw new BufferUnderflowException(\"The buffer is already empty\");\n        }\n\n        return buffer[head];\n    }\n\n    /**\n     * Removes the next object from the buffer\n     *\n     * @return the removed object\n     * @throws BufferUnderflowException  if this buffer is empty\n     */\n    public Object remove() {\n        if (isEmpty()) {\n            throw new BufferUnderflowException(\"The buffer is already empty\");\n        }\n\n        Object element = buffer[head];\n        if (element != null) {\n            buffer[head] = null;\n            head = increment(head);\n        }\n        return element;\n    }\n\n    /**\n     * Increments the internal index.\n     * \n     * @param index  the index to increment\n     * @return the updated index\n     */\n    private int increment(int index) {\n        index++;\n        if (index >= buffer.length) {\n            index = 0;\n        }\n        return index;\n    }\n\n    /**\n     * Decrements the internal index.\n     * \n     * @param index  the index to decrement\n     * @return the updated index\n     */\n    private int decrement(int index) {\n        index--;\n        if (index < 0) {\n            index = buffer.length - 1;\n        }\n        return index;\n    }\n\n    /**\n     * Returns an iterator over this buffer's elements.\n     *\n     * @return an iterator over this buffer's elements\n     */\n    public Iterator iterator() {\n        return new Iterator() {\n\n            private int index = head;\n            private int lastReturnedIndex = -1;\n\n            public boolean hasNext() {\n                return index != tail;\n\n            }\n\n            public Object next() {\n                if (!hasNext()) {\n                    throw new NoSuchElementException();\n                }\n                lastReturnedIndex = index;\n                index = increment(index);\n                return buffer[lastReturnedIndex];\n            }\n\n            public void remove() {\n                if (lastReturnedIndex == -1) {\n                    throw new IllegalStateException();\n                }\n\n                // First element can be removed quickly\n                if (lastReturnedIndex == head) {\n                    UnboundedFifoBuffer.this.remove();\n                    lastReturnedIndex = -1;\n                    return;\n                }\n\n                // Other elements require us to shift the subsequent elements\n                int i = increment(lastReturnedIndex);\n                while (i != tail) {\n                    buffer[decrement(i)] = buffer[i];\n                    i = increment(i);\n                }\n\n                lastReturnedIndex = -1;\n                tail = decrement(tail);\n                buffer[tail] = null;\n                index = decrement(index);\n            }\n\n        };\n    }\n\n}\n", "fixed_version": "/*\n *  Licensed to the Apache Software Foundation (ASF) under one or more\n *  contributor license agreements.  See the NOTICE file distributed with\n *  this work for additional information regarding copyright ownership.\n *  The ASF licenses this file to You under the Apache License, Version 2.0\n *  (the \"License\"); you may not use this file except in compliance with\n *  the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.apache.commons.collections.buffer;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.AbstractCollection;\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\n\nimport org.apache.commons.collections.Buffer;\nimport org.apache.commons.collections.BufferUnderflowException;\n\n/**\n * UnboundedFifoBuffer is a very efficient implementation of\n * <code>Buffer</code> that can grow to any size.\n * According to performance testing, it exhibits a constant access time, but it\n * also outperforms ArrayList when used for the same purpose.\n * <p>\n * The removal order of an <code>UnboundedFifoBuffer</code> is based on the insertion\n * order; elements are removed in the same order in which they were added.\n * The iteration order is the same as the removal order.\n * <p>\n * The {@link #remove()} and {@link #get()} operations perform in constant time.\n * The {@link #add(Object)} operation performs in amortized constant time.  All\n * other operations perform in linear time or worse.\n * <p>\n * Note that this implementation is not synchronized.  The following can be\n * used to provide synchronized access to your <code>UnboundedFifoBuffer</code>:\n * <pre>\n *   Buffer fifo = BufferUtils.synchronizedBuffer(new UnboundedFifoBuffer());\n * </pre>\n * <p>\n * This buffer prevents null objects from being added.\n * <p>\n * This class is Serializable from Commons Collections 3.1.\n * \n * @since Commons Collections 3.0 (previously in main package v2.1)\n * @version $Revision$ $Date$\n *\n * @author Avalon\n * @author Federico Barbieri\n * @author Berin Loritsch\n * @author Paul Jack\n * @author Stephen Colebourne\n * @author Andreas Schlosser\n * @author Thomas Knych\n * @author Jordan Krey\n */\npublic class UnboundedFifoBuffer extends AbstractCollection implements Buffer, Serializable {\n    // invariant: buffer.length > size()\n    //   ie.buffer always has at least one empty entry\n\n    /** Serialization vesrion */\n    private static final long serialVersionUID = -3482960336579541419L;\n\n    /** The array of objects in the buffer. */\n    protected transient Object[] buffer;\n    /** The current head index. */\n    protected transient int head;\n    /** The current tail index. */\n    protected transient int tail;\n\n    /**\n     * Constructs an UnboundedFifoBuffer with the default number of elements.\n     * It is exactly the same as performing the following:\n     *\n     * <pre>\n     *   new UnboundedFifoBuffer(32);\n     * </pre>\n     */\n    public UnboundedFifoBuffer() {\n        this(32);\n    }\n\n    /**\n     * Constructs an UnboundedFifoBuffer with the specified number of elements.\n     * The integer must be a positive integer.\n     * \n     * @param initialSize  the initial size of the buffer\n     * @throws IllegalArgumentException  if the size is less than 1\n     */\n    public UnboundedFifoBuffer(int initialSize) {\n        if (initialSize <= 0) {\n            throw new IllegalArgumentException(\"The size must be greater than 0\");\n        }\n        buffer = new Object[initialSize + 1];\n        head = 0;\n        tail = 0;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Write the buffer out using a custom routine.\n     * \n     * @param out  the output stream\n     * @throws IOException\n     */\n    private void writeObject(ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        out.writeInt(size());\n        out.writeInt(buffer.length);\n        for (Iterator it = iterator(); it.hasNext();) {\n            out.writeObject(it.next());\n        }\n    }\n\n    /**\n     * Read the buffer in using a custom routine.\n     * \n     * @param in  the input stream\n     * @throws IOException\n     * @throws ClassNotFoundException\n     */\n    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        int size = in.readInt();\n        int length = in.readInt();\n        buffer = new Object[length];\n        for (int i = 0; i < size; i++) {\n            buffer[i] = in.readObject();\n        }\n        head = 0;\n        tail = size;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns the number of elements stored in the buffer.\n     *\n     * @return this buffer's size\n     */\n    public int size() {\n        int size = 0;\n\n        if (tail < head) {\n            size = buffer.length - head + tail;\n        } else {\n            size = tail - head;\n        }\n\n        return size;\n    }\n\n    /**\n     * Returns true if this buffer is empty; false otherwise.\n     *\n     * @return true if this buffer is empty\n     */\n    public boolean isEmpty() {\n        return (size() == 0);\n    }\n\n    /**\n     * Adds the given element to this buffer.\n     *\n     * @param obj  the element to add\n     * @return true, always\n     * @throws NullPointerException  if the given element is null\n     */\n    public boolean add(final Object obj) {\n        if (obj == null) {\n            throw new NullPointerException(\"Attempted to add null object to buffer\");\n        }\n\n        if (size() + 1 >= buffer.length) {\n            // copy contents to a new buffer array\n            Object[] tmp = new Object[((buffer.length - 1) * 2) + 1];\n            int j = 0;\n            // move head to element zero in the new array\n            for (int i = head; i != tail;) {\n                tmp[j] = buffer[i];\n                buffer[i] = null;\n\n                j++;\n                i = increment(i);\n            }\n            buffer = tmp;\n            head = 0;\n            tail = j;\n        }\n\n        buffer[tail] = obj;\n        tail = increment(tail);\n        return true;\n    }\n\n    /**\n     * Returns the next object in the buffer.\n     *\n     * @return the next object in the buffer\n     * @throws BufferUnderflowException  if this buffer is empty\n     */\n    public Object get() {\n        if (isEmpty()) {\n            throw new BufferUnderflowException(\"The buffer is already empty\");\n        }\n\n        return buffer[head];\n    }\n\n    /**\n     * Removes the next object from the buffer\n     *\n     * @return the removed object\n     * @throws BufferUnderflowException  if this buffer is empty\n     */\n    public Object remove() {\n        if (isEmpty()) {\n            throw new BufferUnderflowException(\"The buffer is already empty\");\n        }\n\n        Object element = buffer[head];\n        if (element != null) {\n            buffer[head] = null;\n            head = increment(head);\n        }\n        return element;\n    }\n\n    /**\n     * Increments the internal index.\n     * \n     * @param index  the index to increment\n     * @return the updated index\n     */\n    private int increment(int index) {\n        index++;\n        if (index >= buffer.length) {\n            index = 0;\n        }\n        return index;\n    }\n\n    /**\n     * Decrements the internal index.\n     * \n     * @param index  the index to decrement\n     * @return the updated index\n     */\n    private int decrement(int index) {\n        index--;\n        if (index < 0) {\n            index = buffer.length - 1;\n        }\n        return index;\n    }\n\n    /**\n     * Returns an iterator over this buffer's elements.\n     *\n     * @return an iterator over this buffer's elements\n     */\n    public Iterator iterator() {\n        return new Iterator() {\n\n            private int index = head;\n            private int lastReturnedIndex = -1;\n\n            public boolean hasNext() {\n                return index != tail;\n\n            }\n\n            public Object next() {\n                if (!hasNext()) {\n                    throw new NoSuchElementException();\n                }\n                lastReturnedIndex = index;\n                index = increment(index);\n                return buffer[lastReturnedIndex];\n            }\n\n            public void remove() {\n                if (lastReturnedIndex == -1) {\n                    throw new IllegalStateException();\n                }\n\n                // First element can be removed quickly\n                if (lastReturnedIndex == head) {\n                    UnboundedFifoBuffer.this.remove();\n                    lastReturnedIndex = -1;\n                    return;\n                }\n\n                // Other elements require us to shift the subsequent elements\n                int i = increment(lastReturnedIndex);\n                while (i != tail) {\n                    buffer[decrement(i)] = buffer[i];\n                    i = increment(i);\n                }\n\n                lastReturnedIndex = -1;\n                tail = decrement(tail);\n                buffer[tail] = null;\n                index = decrement(index);\n            }\n\n        };\n    }\n\n}\n"}]}
{"project": "Collections", "bug_id": 9, "classes_modified": [{"class_name": "org.apache.commons.collections.ExtendedProperties", "buggy_version": "/*\n *  Licensed to the Apache Software Foundation (ASF) under one or more\n *  contributor license agreements.  See the NOTICE file distributed with\n *  this work for additional information regarding copyright ownership.\n *  The ASF licenses this file to You under the Apache License, Version 2.0\n *  (the \"License\"); you may not use this file except in compliance with\n *  the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.apache.commons.collections;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.LineNumberReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.UnsupportedEncodingException;\nimport java.util.ArrayList;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Properties;\nimport java.util.StringTokenizer;\nimport java.util.Vector;\n\n/**\n * This class extends normal Java properties by adding the possibility\n * to use the same key many times concatenating the value strings\n * instead of overwriting them.\n * <p>\n * <b>Please consider using the <code>PropertiesConfiguration</code> class in\n * Commons-Configuration as soon as it is released.</b>\n * <p>\n * The Extended Properties syntax is explained here:\n *\n * <ul>\n *  <li>\n *   Each property has the syntax <code>key = value</code>\n *  </li>\n *  <li>\n *   The <i>key</i> may use any character but the equal sign '='.\n *  </li>\n *  <li>\n *   <i>value</i> may be separated on different lines if a backslash\n *   is placed at the end of the line that continues below.\n *  </li>\n *  <li>\n *   If <i>value</i> is a list of strings, each token is separated\n *   by a comma ','.\n *  </li>\n *  <li>\n *   Commas in each token are escaped placing a backslash right before\n *   the comma.\n *  </li>\n *  <li>\n *   Backslashes are escaped by using two consecutive backslashes i.e. \\\\\n *  </li>\n *  <li>\n *   If a <i>key</i> is used more than once, the values are appended\n *   as if they were on the same line separated with commas.\n *  </li>\n *  <li>\n *   Blank lines and lines starting with character '#' are skipped.\n *  </li>\n *  <li>\n *   If a property is named \"include\" (or whatever is defined by\n *   setInclude() and getInclude() and the value of that property is\n *   the full path to a file on disk, that file will be included into\n *   the ConfigurationsRepository. You can also pull in files relative\n *   to the parent configuration file. So if you have something\n *   like the following:\n *\n *   include = additional.properties\n *\n *   Then \"additional.properties\" is expected to be in the same\n *   directory as the parent configuration file.\n * \n *   Duplicate name values will be replaced, so be careful.\n *\n *  </li>\n * </ul>\n *\n * <p>Here is an example of a valid extended properties file:\n *\n * <p><pre>\n *      # lines starting with # are comments\n *\n *      # This is the simplest property\n *      key = value\n *\n *      # A long property may be separated on multiple lines\n *      longvalue = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa \\\n *                  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n *\n *      # This is a property with many tokens\n *      tokens_on_a_line = first token, second token\n *\n *      # This sequence generates exactly the same result\n *      tokens_on_multiple_lines = first token\n *      tokens_on_multiple_lines = second token\n *\n *      # commas may be escaped in tokens\n *      commas.escaped = Hi\\, what'up?\n * </pre>\n *\n * <p><b>NOTE</b>: this class has <b>not</b> been written for\n * performance nor low memory usage.  In fact, it's way slower than it\n * could be and generates too much memory garbage.  But since\n * performance is not an issue during intialization (and there is not\n * much time to improve it), I wrote it this way.  If you don't like\n * it, go ahead and tune it up!\n *\n * @since Commons Collections 1.0\n * @version $Revision$ $Date$\n * \n * @author <a href=\"mailto:stefano@apache.org\">Stefano Mazzocchi</a>\n * @author <a href=\"mailto:jon@latchkey.com\">Jon S. Stevens</a>\n * @author <a href=\"mailto:daveb@miceda-data\">Dave Bryson</a>\n * @author <a href=\"mailto:jvanzyl@periapt.com\">Jason van Zyl</a>\n * @author <a href=\"mailto:geirm@optonline.net\">Geir Magnusson Jr.</a>\n * @author <a href=\"mailto:leon@opticode.co.za\">Leon Messerschmidt</a>\n * @author <a href=\"mailto:kjohnson@transparent.com\">Kent Johnson</a>\n * @author <a href=\"mailto:dlr@finemaltcoding.com\">Daniel Rall</a>\n * @author <a href=\"mailto:ipriha@surfeu.fi\">Ilkka Priha</a>\n * @author Janek Bogucki\n * @author Mohan Kishore\n * @author Stephen Colebourne\n * @author Shinobu Kawai\n * @author <a href=\"mailto:hps@intermeta.de\">Henning P. Schmiedehausen</a>\n */\npublic class ExtendedProperties extends Hashtable {\n    \n    /**\n     * Default configurations repository.\n     */\n    private ExtendedProperties defaults;\n\n    /**\n     * The file connected to this repository (holding comments and\n     * such).\n     *\n     * @serial\n     */\n    protected String file;\n\n    /**\n     * Base path of the configuration file used to create\n     * this ExtendedProperties object.\n     */\n    protected String basePath;\n\n    /**\n     * File separator.\n     */\n    protected String fileSeparator = System.getProperty(\"file.separator\");\n\n    /**\n     * Has this configuration been intialized.\n     */\n    protected boolean isInitialized = false;\n\n    /**\n     * This is the name of the property that can point to other\n     * properties file for including other properties files.\n     */\n    private String includePropertyName = null;\n\n    /**\n     * This is the default name of the property that can point to other\n     * properties file for including other properties files.\n     * \n     * @deprecated Use getInclude() and setInclude() methods which operate\n     * on an instance variable from v3.3. Due to be removed in v4.0.\n     */\n    protected static String include = \"include\";\n\n    /**\n     * These are the keys in the order they listed\n     * in the configuration file. This is useful when\n     * you wish to perform operations with configuration\n     * information in a particular order.\n     */\n    protected ArrayList keysAsListed = new ArrayList();\n\n    protected final static String START_TOKEN=\"${\";\n    protected final static String END_TOKEN=\"}\";\n\n\n    /**\n     * Interpolate key names to handle ${key} stuff\n     *\n     * @param base string to interpolate\n     * @return returns the key name with the ${key} substituted\n     */\n    protected String interpolate(String base) {\n        // COPIED from [configuration] 2003-12-29\n        return (interpolateHelper(base, null));\n    }\n\n    /**\n     * Recursive handler for multiple levels of interpolation.\n     *\n     * When called the first time, priorVariables should be null.\n     *\n     * @param base string with the ${key} variables\n     * @param priorVariables serves two purposes: to allow checking for\n     * loops, and creating a meaningful exception message should a loop\n     * occur.  It's 0'th element will be set to the value of base from\n     * the first call.  All subsequent interpolated variables are added\n     * afterward.\n     *\n     * @return the string with the interpolation taken care of\n     */\n    protected String interpolateHelper(String base, List priorVariables) {\n        // COPIED from [configuration] 2003-12-29\n        if (base == null) {\n            return null;\n        }\n\n        // on the first call initialize priorVariables\n        // and add base as the first element\n        if (priorVariables == null) {\n            priorVariables = new ArrayList();\n            priorVariables.add(base);\n        }\n\n        int begin = -1;\n        int end = -1;\n        int prec = 0 - END_TOKEN.length();\n        String variable = null;\n        StringBuffer result = new StringBuffer();\n\n        // FIXME: we should probably allow the escaping of the start token\n        while (((begin = base.indexOf(START_TOKEN, prec + END_TOKEN.length())) > -1)\n            && ((end = base.indexOf(END_TOKEN, begin)) > -1)) {\n            result.append(base.substring(prec + END_TOKEN.length(), begin));\n            variable = base.substring(begin + START_TOKEN.length(), end);\n\n            // if we've got a loop, create a useful exception message and throw\n            if (priorVariables.contains(variable)) {\n                String initialBase = priorVariables.remove(0).toString();\n                priorVariables.add(variable);\n                StringBuffer priorVariableSb = new StringBuffer();\n\n                // create a nice trace of interpolated variables like so:\n                // var1->var2->var3\n                for (Iterator it = priorVariables.iterator(); it.hasNext();) {\n                    priorVariableSb.append(it.next());\n                    if (it.hasNext()) {\n                        priorVariableSb.append(\"->\");\n                    }\n                }\n\n                throw new IllegalStateException(\n                    \"infinite loop in property interpolation of \" + initialBase + \": \" + priorVariableSb.toString());\n            }\n            // otherwise, add this variable to the interpolation list.\n            else {\n                priorVariables.add(variable);\n            }\n\n            //QUESTION: getProperty or getPropertyDirect\n            Object value = getProperty(variable);\n            if (value != null) {\n                result.append(interpolateHelper(value.toString(), priorVariables));\n\n                // pop the interpolated variable off the stack\n                // this maintains priorVariables correctness for\n                // properties with multiple interpolations, e.g.\n                // prop.name=${some.other.prop1}/blahblah/${some.other.prop2}\n                priorVariables.remove(priorVariables.size() - 1);\n            } else if (defaults != null && defaults.getString(variable, null) != null) {\n                result.append(defaults.getString(variable));\n            } else {\n                //variable not defined - so put it back in the value\n                result.append(START_TOKEN).append(variable).append(END_TOKEN);\n            }\n            prec = end;\n        }\n        result.append(base.substring(prec + END_TOKEN.length(), base.length()));\n\n        return result.toString();\n    }\n    \n    /**\n     * Inserts a backslash before every comma and backslash. \n     */\n    private static String escape(String s) {\n        StringBuffer buf = new StringBuffer(s);\n        for (int i = 0; i < buf.length(); i++) {\n            char c = buf.charAt(i);\n            if (c == ',' || c == '\\\\') {\n                buf.insert(i, '\\\\');\n                i++;\n            }\n        }\n        return buf.toString();\n    }\n    \n    /**\n     * Removes a backslash from every pair of backslashes. \n     */\n    private static String unescape(String s) {\n        StringBuffer buf = new StringBuffer(s);\n        for (int i = 0; i < buf.length() - 1; i++) {\n            char c1 = buf.charAt(i);\n            char c2 = buf.charAt(i + 1);\n            if (c1 == '\\\\' && c2 == '\\\\') {\n                buf.deleteCharAt(i);\n            }\n        }\n        return buf.toString();\n    }\n\n    /**\n     * Counts the number of successive times 'ch' appears in the\n     * 'line' before the position indicated by the 'index'.\n     */\n    private static int countPreceding(String line, int index, char ch) {\n        int i;\n        for (i = index - 1; i >= 0; i--) {\n            if (line.charAt(i) != ch) {\n                break;\n            }\n        }\n        return index - 1 - i;\n    }\n\n    /**\n     * Checks if the line ends with odd number of backslashes \n     */\n    private static boolean endsWithSlash(String line) {\n        if (!line.endsWith(\"\\\\\")) {\n            return false;\n        }\n        return (countPreceding(line, line.length() - 1, '\\\\') % 2 == 0);\n    }\n\n    /**\n     * This class is used to read properties lines.  These lines do\n     * not terminate with new-line chars but rather when there is no\n     * backslash sign a the end of the line.  This is used to\n     * concatenate multiple lines for readability.\n     */\n    static class PropertiesReader extends LineNumberReader {\n        /**\n         * Constructor.\n         *\n         * @param reader A Reader.\n         */\n        public PropertiesReader(Reader reader) {\n            super(reader);\n        }\n\n        /**\n         * Read a property.\n         *\n         * @return a String property\n         * @throws IOException if there is difficulty reading the source.\n         */\n        public String readProperty() throws IOException {\n            StringBuffer buffer = new StringBuffer();\n            String line = readLine();\n            while (line != null) {\n                line = line.trim();\n                if ((line.length() != 0) && (line.charAt(0) != '#')) {\n                    if (endsWithSlash(line)) {\n                        line = line.substring(0, line.length() - 1);\n                        buffer.append(line);\n                    } else {\n                        buffer.append(line);\n                        return buffer.toString();  // normal method end\n                    }\n                }\n                line = readLine();\n            }\n            return null;  // EOF reached\n        }\n    }\n\n    /**\n     * This class divides into tokens a property value.  Token\n     * separator is \",\" but commas into the property value are escaped\n     * using the backslash in front.\n     */\n    static class PropertiesTokenizer extends StringTokenizer {\n        /**\n         * The property delimiter used while parsing (a comma).\n         */\n        static final String DELIMITER = \",\";\n\n        /**\n         * Constructor.\n         *\n         * @param string A String.\n         */\n        public PropertiesTokenizer(String string) {\n            super(string, DELIMITER);\n        }\n\n        /**\n         * Check whether the object has more tokens.\n         *\n         * @return True if the object has more tokens.\n         */\n        public boolean hasMoreTokens() {\n            return super.hasMoreTokens();\n        }\n\n        /**\n         * Get next token.\n         *\n         * @return A String.\n         */\n        public String nextToken() {\n            StringBuffer buffer = new StringBuffer();\n\n            while (hasMoreTokens()) {\n                String token = super.nextToken();\n                if (endsWithSlash(token)) {\n                    buffer.append(token.substring(0, token.length() - 1));\n                    buffer.append(DELIMITER);\n                } else {\n                    buffer.append(token);\n                    break;\n                }\n            }\n\n            return buffer.toString().trim();\n        }\n    }\n\n    /**\n     * Creates an empty extended properties object.\n     */\n    public ExtendedProperties() {\n        super();\n    }\n\n    /**\n     * Creates and loads the extended properties from the specified file.\n     *\n     * @param file  the filename to load\n     * @throws IOException if a file error occurs\n     */\n    public ExtendedProperties(String file) throws IOException {\n        this(file, null);\n    }\n\n    /**\n     * Creates and loads the extended properties from the specified file.\n     *\n     * @param file  the filename to load\n     * @param defaultFile  a second filename to load default values from\n     * @throws IOException if a file error occurs\n     */\n    public ExtendedProperties(String file, String defaultFile) throws IOException {\n        this.file = file;\n\n        basePath = new File(file).getAbsolutePath();\n        basePath = basePath.substring(0, basePath.lastIndexOf(fileSeparator) + 1);\n\n        FileInputStream in = null;\n        try {\n            in = new FileInputStream(file);\n            this.load(in);\n        } finally {\n            try {\n                if (in != null) {\n                    in.close();\n                }\n            } catch (IOException ex) {}\n        }\n\n        if (defaultFile != null) {\n            defaults = new ExtendedProperties(defaultFile);\n        }\n    }\n\n    /**\n     * Indicate to client code whether property\n     * resources have been initialized or not.\n     */\n    public boolean isInitialized() {\n        return isInitialized;\n    }\n\n    /**\n     * Gets the property value for including other properties files.\n     * By default it is \"include\".\n     * <p>\n     * NOTE: Prior to v3.3 this method accessed a static variable.\n     * It now accesses an instance variable. For compatability, if the\n     * instance variable has not been set then the previous static\n     * variable is then accessed. However, the protected static variable\n     * can now only be set by subclasses.\n     * In v4.0, the static variable will be removed.\n     *\n     * @return the property name which includes another property\n     */\n    public String getInclude() {\n        if (includePropertyName == null) {\n            return include;  // backwards compatability\n        }\n        if (\"\".equals(includePropertyName)) {\n            return null;  // hack to allow backwards compatability\n        }\n        return includePropertyName;\n    }\n\n    /**\n     * Sets the property value for including other properties files.\n     * By default it is \"include\".\n     * <p>\n     * NOTE: Prior to v3.3 this method set a static variable and affected all\n     * users of the class. It now sets an instance variable.\n     * An empty string is also now converted to null internally.\n     * In v4.0, the static variable will be removed.\n     *\n     * @param inc  the property name which includes another property, empty converted to null\n     */\n    public void setInclude(String inc) {\n        if (inc == null) {\n            inc = \"\";  // hack to allow backwards compatability\n        }\n        includePropertyName = inc;\n    }\n\n    /**\n     * Load the properties from the given input stream.\n     *\n     * @param input  the InputStream to load from\n     * @throws IOException if an IO error occurs\n     */\n    public void load(InputStream input) throws IOException {\n        load(input, null);\n    }\n\n    /**\n     * Load the properties from the given input stream\n     * and using the specified encoding.\n     *\n     * @param input  the InputStream to load from\n     * @param enc  the encoding to use\n     * @throws IOException if an IO error occurs\n     */\n    public synchronized void load(InputStream input, String enc) throws IOException {\n        PropertiesReader reader = null;\n        if (enc != null) {\n            try {\n                reader = new PropertiesReader(new InputStreamReader(input, enc));\n                \n            } catch (UnsupportedEncodingException ex) {\n                // Another try coming up....\n            }\n        }\n        \n        if (reader == null) {\n            try {\n                reader = new PropertiesReader(new InputStreamReader(input, \"8859_1\"));\n                \n            } catch (UnsupportedEncodingException ex) {\n                // ISO8859-1 support is required on java platforms but....\n                // If it's not supported, use the system default encoding\n                reader = new PropertiesReader(new InputStreamReader(input));\n            }\n        }\n\n        try {\n            String includeProperty = getInclude();\n            while (true) {\n                String line = reader.readProperty();\n                if (line == null) {\n                    return;  // EOF\n                }\n                int equalSign = line.indexOf('=');\n\n                if (equalSign > 0) {\n                    String key = line.substring(0, equalSign).trim();\n                    String value = line.substring(equalSign + 1).trim();\n\n                    // Configure produces lines like this ... just ignore them\n                    if (\"\".equals(value)) {\n                        continue;\n                    }\n\n                    if (includeProperty != null && key.equalsIgnoreCase(includeProperty)) {\n                        // Recursively load properties files.\n                        File file = null;\n\n                        if (value.startsWith(fileSeparator)) {\n                            // We have an absolute path so we'll use this\n                            file = new File(value);\n                            \n                        } else {\n                            // We have a relative path, and we have two \n                            // possible forms here. If we have the \"./\" form\n                            // then just strip that off first before continuing.\n                            if (value.startsWith(\".\" + fileSeparator)) {\n                                value = value.substring(2);\n                            }\n\n                            file = new File(basePath + value);\n                        }\n\n                        if (file != null && file.exists() && file.canRead()) {\n                            load(new FileInputStream(file));\n                        }\n                    } else {\n                        addProperty(key, value);\n                    }\n                }\n            }\n        } finally {\n            // Loading is initializing\n            isInitialized = true;\n        }\n    }\n\n    /**\n     * Gets a property from the configuration.\n     *\n     * @param key property to retrieve\n     * @return value as object. Will return user value if exists,\n     *        if not then default value if exists, otherwise null\n     */\n    public Object getProperty(String key) {\n        // first, try to get from the 'user value' store\n        Object obj = super.get(key);\n\n        if (obj == null) {\n            // if there isn't a value there, get it from the\n            // defaults if we have them\n            if (defaults != null) {\n                obj = defaults.get(key);\n            }\n        }\n\n        return obj;\n    }\n    \n    /**\n     * Add a property to the configuration. If it already\n     * exists then the value stated here will be added\n     * to the configuration entry. For example, if\n     *\n     * <code>resource.loader = file</code>\n     *\n     * is already present in the configuration and you\n     *\n     * <code>addProperty(\"resource.loader\", \"classpath\")</code>\n     *\n     * Then you will end up with a Vector like the\n     * following:\n     *\n     * <code>[\"file\", \"classpath\"]</code>\n     *\n     * @param key  the key to add\n     * @param value  the value to add\n     */\n    public void addProperty(String key, Object value) {\n        if (value instanceof String) {\n            String str = (String) value;\n            if (str.indexOf(PropertiesTokenizer.DELIMITER) > 0) {\n                // token contains commas, so must be split apart then added\n                PropertiesTokenizer tokenizer = new PropertiesTokenizer(str);\n                while (tokenizer.hasMoreTokens()) {\n                    String token = tokenizer.nextToken();\n                    addPropertyInternal(key, unescape(token));\n                }\n            } else {\n                // token contains no commas, so can be simply added\n                addPropertyInternal(key, unescape(str));\n            }\n        } else {\n            addPropertyInternal(key, value);\n        }\n\n        // Adding a property connotes initialization\n        isInitialized = true;\n    }\n\n    /**\n     * Adds a key/value pair to the map.  This routine does\n     * no magic morphing.  It ensures the keylist is maintained\n     *\n     * @param key  the key to store at\n     * @param value  the decoded object to store\n     */\n    private void addPropertyDirect(String key, Object value) {\n        // safety check\n        if (!containsKey(key)) {\n            keysAsListed.add(key);\n        }\n        super.put(key, value);\n    }\n\n    /**\n     * Adds a decoded property to the map w/o checking for commas - used\n     * internally when a property has been broken up into\n     * strings that could contain escaped commas to prevent\n     * the inadvertent vectorization.\n     * <p>\n     * Thanks to Leon Messerschmidt for this one.\n     *\n     * @param key  the key to store at\n     * @param value  the decoded object to store\n     */\n    private void addPropertyInternal(String key, Object value) {\n        Object current = this.get(key);\n\n        if (current instanceof String) {\n            // one object already in map - convert it to a vector\n            List values = new Vector(2);\n            values.add(current);\n            values.add(value);\n            super.put(key, values);\n            \n        } else if (current instanceof List) {\n            // already a list - just add the new token\n            ((List) current).add(value);\n            \n        } else {\n            // brand new key - store in keysAsListed to retain order\n            if (!containsKey(key)) {\n                keysAsListed.add(key);\n            }\n            super.put(key, value);\n        }\n    }\n\n    /**\n     * Set a property, this will replace any previously\n     * set values. Set values is implicitly a call\n     * to clearProperty(key), addProperty(key,value).\n     *\n     * @param key  the key to set\n     * @param value  the value to set\n     */\n    public void setProperty(String key, Object value) {\n        clearProperty(key);\n        addProperty(key, value);\n    }\n    \n    /**\n     * Save the properties to the given output stream.\n     * <p>\n     * The stream is not closed, but it is flushed.\n     *\n     * @param output  an OutputStream, may be null\n     * @param header  a textual comment to act as a file header\n     * @throws IOException if an IO error occurs\n     */\n    public synchronized void save(OutputStream output, String header) throws IOException {\n        if (output == null) {\n            return;\n        }\n        PrintWriter theWrtr = new PrintWriter(output);\n        if (header != null) {\n            theWrtr.println(header);\n        }\n        \n        Enumeration theKeys = keys();\n        while (theKeys.hasMoreElements()) {\n            String key = (String) theKeys.nextElement();\n            Object value = get(key);\n            if (value != null) {\n                if (value instanceof String) {\n                    StringBuffer currentOutput = new StringBuffer();\n                    currentOutput.append(key);\n                    currentOutput.append(\"=\");\n                    currentOutput.append(escape((String) value));\n                    theWrtr.println(currentOutput.toString());\n                    \n                } else if (value instanceof List) {\n                    List values = (List) value;\n                    for (Iterator it = values.iterator(); it.hasNext(); ) {\n                        String currentElement = (String) it.next();\n                        StringBuffer currentOutput = new StringBuffer();\n                        currentOutput.append(key);\n                        currentOutput.append(\"=\");\n                        currentOutput.append(escape(currentElement));\n                        theWrtr.println(currentOutput.toString());\n                    }\n                }\n            }\n            theWrtr.println();\n            theWrtr.flush();\n        }\n    }\n\n    /**\n     * Combines an existing Hashtable with this Hashtable.\n     * <p>\n     * Warning: It will overwrite previous entries without warning.\n     *\n     * @param props  the properties to combine\n     */\n    public void combine(ExtendedProperties props) {\n        for (Iterator it = props.getKeys(); it.hasNext();) {\n            String key = (String) it.next();\n            setProperty(key, props.get(key));\n        }\n    }\n    \n    /**\n     * Clear a property in the configuration.\n     *\n     * @param key  the property key to remove along with corresponding value\n     */\n    public void clearProperty(String key) {\n        if (containsKey(key)) {\n            // we also need to rebuild the keysAsListed or else\n            // things get *very* confusing\n            for (int i = 0; i < keysAsListed.size(); i++) {\n                if (( keysAsListed.get(i)).equals(key)) {\n                    keysAsListed.remove(i);\n                    break;\n                }\n            }\n            super.remove(key);\n        }\n    }\n\n    /**\n     * Get the list of the keys contained in the configuration\n     * repository.\n     *\n     * @return an Iterator over the keys\n     */\n    public Iterator getKeys() {\n        return keysAsListed.iterator();\n    }\n\n    /**\n     * Get the list of the keys contained in the configuration\n     * repository that match the specified prefix.\n     *\n     * @param prefix  the prefix to match\n     * @return an Iterator of keys that match the prefix\n     */\n    public Iterator getKeys(String prefix) {\n        Iterator keys = getKeys();\n        ArrayList matchingKeys = new ArrayList();\n\n        while (keys.hasNext()) {\n            Object key = keys.next();\n\n            if (key instanceof String && ((String) key).startsWith(prefix)) {\n                matchingKeys.add(key);\n            }\n        }\n        return matchingKeys.iterator();\n    }\n\n    /**\n     * Create an ExtendedProperties object that is a subset\n     * of this one. Take into account duplicate keys\n     * by using the setProperty() in ExtendedProperties.\n     *\n     * @param prefix  the prefix to get a subset for\n     * @return a new independent ExtendedProperties\n     */\n    public ExtendedProperties subset(String prefix) {\n        ExtendedProperties c = new ExtendedProperties();\n        Iterator keys = getKeys();\n        boolean validSubset = false;\n\n        while (keys.hasNext()) {\n            Object key = keys.next();\n\n            if (key instanceof String && ((String) key).startsWith(prefix)) {\n                if (!validSubset) {\n                    validSubset = true;\n                }\n\n                /*\n                 * Check to make sure that c.subset(prefix) doesn't\n                 * blow up when there is only a single property\n                 * with the key prefix. This is not a useful\n                 * subset but it is a valid subset.\n                 */\n                String newKey = null;\n                if (((String) key).length() == prefix.length()) {\n                    newKey = prefix;\n                } else {\n                    newKey = ((String) key).substring(prefix.length() + 1);\n                }\n\n                /*\n                 *  use addPropertyDirect() - this will plug the data as \n                 *  is into the Map, but will also do the right thing\n                 *  re key accounting\n                 */\n                c.addPropertyDirect(newKey, get(key));\n            }\n        }\n\n        if (validSubset) {\n            return c;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Display the configuration for debugging purposes to System.out.\n     */\n    public void display() {\n        Iterator i = getKeys();\n\n        while (i.hasNext()) {\n            String key = (String) i.next();\n            Object value = get(key);\n            System.out.println(key + \" => \" + value);\n        }\n    }\n\n    /**\n     * Get a string associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated string.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a String.\n     */\n    public String getString(String key) {\n        return getString(key, null);\n    }\n\n    /**\n     * Get a string associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated string if key is found,\n     * default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a String.\n     */\n    public String getString(String key, String defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof String) {\n            return interpolate((String) value);\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return interpolate(defaults.getString(key, defaultValue));\n            } else {\n                return interpolate(defaultValue);\n            }\n        } else if (value instanceof List) {\n            return interpolate((String) ((List) value).get(0));\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a String object\");\n        }\n    }\n\n    /**\n     * Get a list of properties associated with the given\n     * configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated properties if key is found.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a String/List.\n     * @throws IllegalArgumentException if one of the tokens is\n     * malformed (does not contain an equals sign).\n     */\n    public Properties getProperties(String key) {\n        return getProperties(key, new Properties());\n    }\n\n    /**\n     * Get a list of properties associated with the given\n     * configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated properties if key is found.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a String/List.\n     * @throws IllegalArgumentException if one of the tokens is\n     * malformed (does not contain an equals sign).\n     */\n    public Properties getProperties(String key, Properties defaults) {\n        /*\n         * Grab an array of the tokens for this key.\n         */\n        String[] tokens = getStringArray(key);\n\n        // Each token is of the form 'key=value'.\n        Properties props = new Properties(defaults);\n        for (int i = 0; i < tokens.length; i++) {\n            String token = tokens[i];\n            int equalSign = token.indexOf('=');\n            if (equalSign > 0) {\n                String pkey = token.substring(0, equalSign).trim();\n                String pvalue = token.substring(equalSign + 1).trim();\n                props.put(pkey, pvalue);\n            } else {\n                throw new IllegalArgumentException('\\'' + token + \"' does not contain \" + \"an equals sign\");\n            }\n        }\n        return props;\n    }\n\n    /**\n     * Get an array of strings associated with the given configuration\n     * key.\n     *\n     * @param key The configuration key.\n     * @return The associated string array if key is found.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a String/List.\n     */\n    public String[] getStringArray(String key) {\n        Object value = get(key);\n\n        List values;\n        if (value instanceof String) {\n            values = new Vector(1);\n            values.add(value);\n            \n        } else if (value instanceof List) {\n            values = (List) value;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getStringArray(key);\n            } else {\n                return new String[0];\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a String/List object\");\n        }\n\n        String[] tokens = new String[values.size()];\n        for (int i = 0; i < tokens.length; i++) {\n            tokens[i] = (String) values.get(i);\n        }\n\n        return tokens;\n    }\n\n    /**\n     * Get a Vector of strings associated with the given configuration\n     * key.\n     *\n     * @param key The configuration key.\n     * @return The associated Vector.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Vector.\n     */\n    public Vector getVector(String key) {\n        return getVector(key, null);\n    }\n\n    /**\n     * Get a Vector of strings associated with the given configuration key.\n     * <p>\n     * The list is a copy of the internal data of this object, and as\n     * such you may alter it freely.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated Vector.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Vector.\n     */\n    public Vector getVector(String key, Vector defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof List) {\n            return new Vector((List) value);\n            \n        } else if (value instanceof String) {\n            Vector values = new Vector(1);\n            values.add(value);\n            super.put(key, values);\n            return values;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getVector(key, defaultValue);\n            } else {\n                return ((defaultValue == null) ? new Vector() : defaultValue);\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Vector object\");\n        }\n    }\n\n    /**\n     * Get a List of strings associated with the given configuration key.\n     * <p>\n     * The list is a copy of the internal data of this object, and as\n     * such you may alter it freely.\n     *\n     * @param key The configuration key.\n     * @return The associated List object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a List.\n     * @since Commons Collections 3.2\n     */\n    public List getList(String key) {\n        return getList(key, null);\n    }\n\n    /**\n     * Get a List of strings associated with the given configuration key.\n     * <p>\n     * The list is a copy of the internal data of this object, and as\n     * such you may alter it freely.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated List.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a List.\n     * @since Commons Collections 3.2\n     */\n    public List getList(String key, List defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof List) {\n            return new ArrayList((List) value);\n            \n        } else if (value instanceof String) {\n            List values = new ArrayList(1);\n            values.add(value);\n            super.put(key, values);\n            return values;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getList(key, defaultValue);\n            } else {\n                return ((defaultValue == null) ? new ArrayList() : defaultValue);\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a List object\");\n        }\n    }\n\n    /**\n     * Get a boolean associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated boolean.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Boolean.\n     */\n    public boolean getBoolean(String key) {\n        Boolean b = getBoolean(key, null);\n        if (b != null) {\n            return b.booleanValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a boolean associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated boolean.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Boolean.\n     */\n    public boolean getBoolean(String key, boolean defaultValue) {\n        return getBoolean(key, new Boolean(defaultValue)).booleanValue();\n    }\n\n    /**\n     * Get a boolean associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated boolean if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Boolean.\n     */\n    public Boolean getBoolean(String key, Boolean defaultValue) {\n\n        Object value = get(key);\n\n        if (value instanceof Boolean) {\n            return (Boolean) value;\n            \n        } else if (value instanceof String) {\n            String s = testBoolean((String) value);\n            Boolean b = new Boolean(s);\n            super.put(key, b);\n            return b;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getBoolean(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Boolean object\");\n        }\n    }\n\n    /**\n     * Test whether the string represent by value maps to a boolean\n     * value or not. We will allow <code>true</code>, <code>on</code>,\n     * and <code>yes</code> for a <code>true</code> boolean value, and\n     * <code>false</code>, <code>off</code>, and <code>no</code> for\n     * <code>false</code> boolean values.  Case of value to test for\n     * boolean status is ignored.\n     *\n     * @param value  the value to test for boolean state\n     * @return <code>true</code> or <code>false</code> if the supplied\n     * text maps to a boolean value, or <code>null</code> otherwise.\n     */\n    public String testBoolean(String value) {\n        String s = value.toLowerCase();\n\n        if (s.equals(\"true\") || s.equals(\"on\") || s.equals(\"yes\")) {\n            return \"true\";\n        } else if (s.equals(\"false\") || s.equals(\"off\") || s.equals(\"no\")) {\n            return \"false\";\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Get a byte associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated byte.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Byte.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public byte getByte(String key) {\n        Byte b = getByte(key, null);\n        if (b != null) {\n            return b.byteValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \" doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a byte associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated byte.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Byte.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public byte getByte(String key, byte defaultValue) {\n        return getByte(key, new Byte(defaultValue)).byteValue();\n    }\n\n    /**\n     * Get a byte associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated byte if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Byte.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public Byte getByte(String key, Byte defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Byte) {\n            return (Byte) value;\n            \n        } else if (value instanceof String) {\n            Byte b = new Byte((String) value);\n            super.put(key, b);\n            return b;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getByte(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Byte object\");\n        }\n    }\n\n    /**\n     * Get a short associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated short.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Short.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public short getShort(String key) {\n        Short s = getShort(key, null);\n        if (s != null) {\n            return s.shortValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a short associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated short.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Short.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public short getShort(String key, short defaultValue) {\n        return getShort(key, new Short(defaultValue)).shortValue();\n    }\n\n    /**\n     * Get a short associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated short if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Short.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public Short getShort(String key, Short defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Short) {\n            return (Short) value;\n            \n        } else if (value instanceof String) {\n            Short s = new Short((String) value);\n            super.put(key, s);\n            return s;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getShort(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Short object\");\n        }\n    }\n\n    /**\n     * The purpose of this method is to get the configuration resource\n     * with the given name as an integer.\n     *\n     * @param name The resource name.\n     * @return The value of the resource as an integer.\n     */\n    public int getInt(String name) {\n        return getInteger(name);\n    }\n\n    /**\n     * The purpose of this method is to get the configuration resource\n     * with the given name as an integer, or a default value.\n     *\n     * @param name The resource name\n     * @param def The default value of the resource.\n     * @return The value of the resource as an integer.\n     */\n    public int getInt(String name, int def) {\n        return getInteger(name, def);\n    }\n\n    /**\n     * Get a int associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated int.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Integer.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public int getInteger(String key) {\n        Integer i = getInteger(key, null);\n        if (i != null) {\n            return i.intValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a int associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated int.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Integer.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public int getInteger(String key, int defaultValue) {\n        Integer i = getInteger(key, null);\n\n        if (i == null) {\n            return defaultValue;\n        }\n        return i.intValue();\n    }\n\n    /**\n     * Get a int associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated int if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Integer.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public Integer getInteger(String key, Integer defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Integer) {\n            return (Integer) value;\n            \n        } else if (value instanceof String) {\n            Integer i = new Integer((String) value);\n            super.put(key, i);\n            return i;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getInteger(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Integer object\");\n        }\n    }\n\n    /**\n     * Get a long associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated long.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Long.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public long getLong(String key) {\n        Long l = getLong(key, null);\n        if (l != null) {\n            return l.longValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a long associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated long.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Long.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public long getLong(String key, long defaultValue) {\n        return getLong(key, new Long(defaultValue)).longValue();\n    }\n\n    /**\n     * Get a long associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated long if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Long.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public Long getLong(String key, Long defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Long) {\n            return (Long) value;\n            \n        } else if (value instanceof String) {\n            Long l = new Long((String) value);\n            super.put(key, l);\n            return l;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getLong(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Long object\");\n        }\n    }\n\n    /**\n     * Get a float associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated float.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Float.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public float getFloat(String key) {\n        Float f = getFloat(key, null);\n        if (f != null) {\n            return f.floatValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a float associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated float.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Float.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public float getFloat(String key, float defaultValue) {\n        return getFloat(key, new Float(defaultValue)).floatValue();\n    }\n\n    /**\n     * Get a float associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated float if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Float.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public Float getFloat(String key, Float defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Float) {\n            return (Float) value;\n            \n        } else if (value instanceof String) {\n            Float f = new Float((String) value);\n            super.put(key, f);\n            return f;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getFloat(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Float object\");\n        }\n    }\n\n    /**\n     * Get a double associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated double.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Double.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public double getDouble(String key) {\n        Double d = getDouble(key, null);\n        if (d != null) {\n            return d.doubleValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a double associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated double.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Double.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public double getDouble(String key, double defaultValue) {\n        return getDouble(key, new Double(defaultValue)).doubleValue();\n    }\n\n    /**\n     * Get a double associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated double if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Double.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public Double getDouble(String key, Double defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Double) {\n            return (Double) value;\n            \n        } else if (value instanceof String) {\n            Double d = new Double((String) value);\n            super.put(key, d);\n            return d;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getDouble(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Double object\");\n        }\n    }\n\n    /**\n     * Convert a standard properties class into a configuration class.\n     * <p>\n     * NOTE: From Commons Collections 3.2 this method will pick up\n     * any default parent Properties of the specified input object.\n     *\n     * @param props  the properties object to convert\n     * @return new ExtendedProperties created from props\n     */\n    public static ExtendedProperties convertProperties(Properties props) {\n        ExtendedProperties c = new ExtendedProperties();\n\n        for (Enumeration e = props.propertyNames(); e.hasMoreElements();) {\n            String s = (String) e.nextElement();\n            c.setProperty(s, props.getProperty(s));\n        }\n\n        return c;\n    }\n\n    /**\n     * Add a new property specified by the key to the \n     * ExtendedProperties.\n     *\n     * @param key specifying the property\n     * @param value for the property\n     * @return old value of the property\n     */\n    public Object put(Object key, Object value) {\n        String strKey = String.valueOf(key);\n        Object ret = getProperty(strKey);\n        addProperty(strKey, value);\n        return ret;\n    }\n\n    /**\n     * Add a map full of key/value pairs to the ExtendedProperties. \n     * If the added map is an ExtendedProperties class, then the \n     * order of the added properties is maintained. \n     *\n     * @param map full of key/value pair data\n     */\n    public void putAll(Map map) {\n        if (map instanceof ExtendedProperties) {\n            for (Iterator it = ((ExtendedProperties) map).getKeys(); it.hasNext(); ) {\n                Object key = it.next();\n                put(key, map.get(key));\n            }\n        } else {\n            for (Iterator it = map.entrySet().iterator(); it.hasNext(); ) {\n                Map.Entry entry = (Map.Entry) it.next();\n                put(entry.getKey(), entry.getValue());\n            }\n        }\n    }\n\n\n    /**\n     * Remove the property specified by the key from the \n     * ExtendedProperties.\n     *\n     * @param key specifying the property\n     * @return old value of the property\n     */\n    public Object remove(Object key) {\n        String strKey = String.valueOf(key);\n        Object ret = getProperty(strKey);\n        clearProperty(strKey);\n        return ret;\n    }\n\n}\n", "fixed_version": "/*\n *  Licensed to the Apache Software Foundation (ASF) under one or more\n *  contributor license agreements.  See the NOTICE file distributed with\n *  this work for additional information regarding copyright ownership.\n *  The ASF licenses this file to You under the Apache License, Version 2.0\n *  (the \"License\"); you may not use this file except in compliance with\n *  the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.apache.commons.collections;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.LineNumberReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.UnsupportedEncodingException;\nimport java.util.ArrayList;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Properties;\nimport java.util.StringTokenizer;\nimport java.util.Vector;\n\n/**\n * This class extends normal Java properties by adding the possibility\n * to use the same key many times concatenating the value strings\n * instead of overwriting them.\n * <p>\n * <b>Please consider using the <code>PropertiesConfiguration</code> class in\n * Commons-Configuration as soon as it is released.</b>\n * <p>\n * The Extended Properties syntax is explained here:\n *\n * <ul>\n *  <li>\n *   Each property has the syntax <code>key = value</code>\n *  </li>\n *  <li>\n *   The <i>key</i> may use any character but the equal sign '='.\n *  </li>\n *  <li>\n *   <i>value</i> may be separated on different lines if a backslash\n *   is placed at the end of the line that continues below.\n *  </li>\n *  <li>\n *   If <i>value</i> is a list of strings, each token is separated\n *   by a comma ','.\n *  </li>\n *  <li>\n *   Commas in each token are escaped placing a backslash right before\n *   the comma.\n *  </li>\n *  <li>\n *   Backslashes are escaped by using two consecutive backslashes i.e. \\\\\n *  </li>\n *  <li>\n *   If a <i>key</i> is used more than once, the values are appended\n *   as if they were on the same line separated with commas.\n *  </li>\n *  <li>\n *   Blank lines and lines starting with character '#' are skipped.\n *  </li>\n *  <li>\n *   If a property is named \"include\" (or whatever is defined by\n *   setInclude() and getInclude() and the value of that property is\n *   the full path to a file on disk, that file will be included into\n *   the ConfigurationsRepository. You can also pull in files relative\n *   to the parent configuration file. So if you have something\n *   like the following:\n *\n *   include = additional.properties\n *\n *   Then \"additional.properties\" is expected to be in the same\n *   directory as the parent configuration file.\n * \n *   Duplicate name values will be replaced, so be careful.\n *\n *  </li>\n * </ul>\n *\n * <p>Here is an example of a valid extended properties file:\n *\n * <p><pre>\n *      # lines starting with # are comments\n *\n *      # This is the simplest property\n *      key = value\n *\n *      # A long property may be separated on multiple lines\n *      longvalue = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa \\\n *                  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n *\n *      # This is a property with many tokens\n *      tokens_on_a_line = first token, second token\n *\n *      # This sequence generates exactly the same result\n *      tokens_on_multiple_lines = first token\n *      tokens_on_multiple_lines = second token\n *\n *      # commas may be escaped in tokens\n *      commas.escaped = Hi\\, what'up?\n * </pre>\n *\n * <p><b>NOTE</b>: this class has <b>not</b> been written for\n * performance nor low memory usage.  In fact, it's way slower than it\n * could be and generates too much memory garbage.  But since\n * performance is not an issue during intialization (and there is not\n * much time to improve it), I wrote it this way.  If you don't like\n * it, go ahead and tune it up!\n *\n * @since Commons Collections 1.0\n * @version $Revision$ $Date$\n * \n * @author <a href=\"mailto:stefano@apache.org\">Stefano Mazzocchi</a>\n * @author <a href=\"mailto:jon@latchkey.com\">Jon S. Stevens</a>\n * @author <a href=\"mailto:daveb@miceda-data\">Dave Bryson</a>\n * @author <a href=\"mailto:jvanzyl@periapt.com\">Jason van Zyl</a>\n * @author <a href=\"mailto:geirm@optonline.net\">Geir Magnusson Jr.</a>\n * @author <a href=\"mailto:leon@opticode.co.za\">Leon Messerschmidt</a>\n * @author <a href=\"mailto:kjohnson@transparent.com\">Kent Johnson</a>\n * @author <a href=\"mailto:dlr@finemaltcoding.com\">Daniel Rall</a>\n * @author <a href=\"mailto:ipriha@surfeu.fi\">Ilkka Priha</a>\n * @author Janek Bogucki\n * @author Mohan Kishore\n * @author Stephen Colebourne\n * @author Shinobu Kawai\n * @author <a href=\"mailto:hps@intermeta.de\">Henning P. Schmiedehausen</a>\n */\npublic class ExtendedProperties extends Hashtable {\n    \n    /**\n     * Default configurations repository.\n     */\n    private ExtendedProperties defaults;\n\n    /**\n     * The file connected to this repository (holding comments and\n     * such).\n     *\n     * @serial\n     */\n    protected String file;\n\n    /**\n     * Base path of the configuration file used to create\n     * this ExtendedProperties object.\n     */\n    protected String basePath;\n\n    /**\n     * File separator.\n     */\n    protected String fileSeparator = System.getProperty(\"file.separator\");\n\n    /**\n     * Has this configuration been intialized.\n     */\n    protected boolean isInitialized = false;\n\n    /**\n     * This is the name of the property that can point to other\n     * properties file for including other properties files.\n     */\n    private String includePropertyName = null;\n\n    /**\n     * This is the default name of the property that can point to other\n     * properties file for including other properties files.\n     * \n     * @deprecated Use getInclude() and setInclude() methods which operate\n     * on an instance variable from v3.3. Due to be removed in v4.0.\n     */\n    protected static String include = \"include\";\n\n    /**\n     * These are the keys in the order they listed\n     * in the configuration file. This is useful when\n     * you wish to perform operations with configuration\n     * information in a particular order.\n     */\n    protected ArrayList keysAsListed = new ArrayList();\n\n    protected final static String START_TOKEN=\"${\";\n    protected final static String END_TOKEN=\"}\";\n\n\n    /**\n     * Interpolate key names to handle ${key} stuff\n     *\n     * @param base string to interpolate\n     * @return returns the key name with the ${key} substituted\n     */\n    protected String interpolate(String base) {\n        // COPIED from [configuration] 2003-12-29\n        return (interpolateHelper(base, null));\n    }\n\n    /**\n     * Recursive handler for multiple levels of interpolation.\n     *\n     * When called the first time, priorVariables should be null.\n     *\n     * @param base string with the ${key} variables\n     * @param priorVariables serves two purposes: to allow checking for\n     * loops, and creating a meaningful exception message should a loop\n     * occur.  It's 0'th element will be set to the value of base from\n     * the first call.  All subsequent interpolated variables are added\n     * afterward.\n     *\n     * @return the string with the interpolation taken care of\n     */\n    protected String interpolateHelper(String base, List priorVariables) {\n        // COPIED from [configuration] 2003-12-29\n        if (base == null) {\n            return null;\n        }\n\n        // on the first call initialize priorVariables\n        // and add base as the first element\n        if (priorVariables == null) {\n            priorVariables = new ArrayList();\n            priorVariables.add(base);\n        }\n\n        int begin = -1;\n        int end = -1;\n        int prec = 0 - END_TOKEN.length();\n        String variable = null;\n        StringBuffer result = new StringBuffer();\n\n        // FIXME: we should probably allow the escaping of the start token\n        while (((begin = base.indexOf(START_TOKEN, prec + END_TOKEN.length())) > -1)\n            && ((end = base.indexOf(END_TOKEN, begin)) > -1)) {\n            result.append(base.substring(prec + END_TOKEN.length(), begin));\n            variable = base.substring(begin + START_TOKEN.length(), end);\n\n            // if we've got a loop, create a useful exception message and throw\n            if (priorVariables.contains(variable)) {\n                String initialBase = priorVariables.remove(0).toString();\n                priorVariables.add(variable);\n                StringBuffer priorVariableSb = new StringBuffer();\n\n                // create a nice trace of interpolated variables like so:\n                // var1->var2->var3\n                for (Iterator it = priorVariables.iterator(); it.hasNext();) {\n                    priorVariableSb.append(it.next());\n                    if (it.hasNext()) {\n                        priorVariableSb.append(\"->\");\n                    }\n                }\n\n                throw new IllegalStateException(\n                    \"infinite loop in property interpolation of \" + initialBase + \": \" + priorVariableSb.toString());\n            }\n            // otherwise, add this variable to the interpolation list.\n            else {\n                priorVariables.add(variable);\n            }\n\n            //QUESTION: getProperty or getPropertyDirect\n            Object value = getProperty(variable);\n            if (value != null) {\n                result.append(interpolateHelper(value.toString(), priorVariables));\n\n                // pop the interpolated variable off the stack\n                // this maintains priorVariables correctness for\n                // properties with multiple interpolations, e.g.\n                // prop.name=${some.other.prop1}/blahblah/${some.other.prop2}\n                priorVariables.remove(priorVariables.size() - 1);\n            } else if (defaults != null && defaults.getString(variable, null) != null) {\n                result.append(defaults.getString(variable));\n            } else {\n                //variable not defined - so put it back in the value\n                result.append(START_TOKEN).append(variable).append(END_TOKEN);\n            }\n            prec = end;\n        }\n        result.append(base.substring(prec + END_TOKEN.length(), base.length()));\n\n        return result.toString();\n    }\n    \n    /**\n     * Inserts a backslash before every comma and backslash. \n     */\n    private static String escape(String s) {\n        StringBuffer buf = new StringBuffer(s);\n        for (int i = 0; i < buf.length(); i++) {\n            char c = buf.charAt(i);\n            if (c == ',' || c == '\\\\') {\n                buf.insert(i, '\\\\');\n                i++;\n            }\n        }\n        return buf.toString();\n    }\n    \n    /**\n     * Removes a backslash from every pair of backslashes. \n     */\n    private static String unescape(String s) {\n        StringBuffer buf = new StringBuffer(s);\n        for (int i = 0; i < buf.length() - 1; i++) {\n            char c1 = buf.charAt(i);\n            char c2 = buf.charAt(i + 1);\n            if (c1 == '\\\\' && c2 == '\\\\') {\n                buf.deleteCharAt(i);\n            }\n        }\n        return buf.toString();\n    }\n\n    /**\n     * Counts the number of successive times 'ch' appears in the\n     * 'line' before the position indicated by the 'index'.\n     */\n    private static int countPreceding(String line, int index, char ch) {\n        int i;\n        for (i = index - 1; i >= 0; i--) {\n            if (line.charAt(i) != ch) {\n                break;\n            }\n        }\n        return index - 1 - i;\n    }\n\n    /**\n     * Checks if the line ends with odd number of backslashes \n     */\n    private static boolean endsWithSlash(String line) {\n        if (!line.endsWith(\"\\\\\")) {\n            return false;\n        }\n        return (countPreceding(line, line.length() - 1, '\\\\') % 2 == 0);\n    }\n\n    /**\n     * This class is used to read properties lines.  These lines do\n     * not terminate with new-line chars but rather when there is no\n     * backslash sign a the end of the line.  This is used to\n     * concatenate multiple lines for readability.\n     */\n    static class PropertiesReader extends LineNumberReader {\n        /**\n         * Constructor.\n         *\n         * @param reader A Reader.\n         */\n        public PropertiesReader(Reader reader) {\n            super(reader);\n        }\n\n        /**\n         * Read a property.\n         *\n         * @return a String property\n         * @throws IOException if there is difficulty reading the source.\n         */\n        public String readProperty() throws IOException {\n            StringBuffer buffer = new StringBuffer();\n            String line = readLine();\n            while (line != null) {\n                line = line.trim();\n                if ((line.length() != 0) && (line.charAt(0) != '#')) {\n                    if (endsWithSlash(line)) {\n                        line = line.substring(0, line.length() - 1);\n                        buffer.append(line);\n                    } else {\n                        buffer.append(line);\n                        return buffer.toString();  // normal method end\n                    }\n                }\n                line = readLine();\n            }\n            return null;  // EOF reached\n        }\n    }\n\n    /**\n     * This class divides into tokens a property value.  Token\n     * separator is \",\" but commas into the property value are escaped\n     * using the backslash in front.\n     */\n    static class PropertiesTokenizer extends StringTokenizer {\n        /**\n         * The property delimiter used while parsing (a comma).\n         */\n        static final String DELIMITER = \",\";\n\n        /**\n         * Constructor.\n         *\n         * @param string A String.\n         */\n        public PropertiesTokenizer(String string) {\n            super(string, DELIMITER);\n        }\n\n        /**\n         * Check whether the object has more tokens.\n         *\n         * @return True if the object has more tokens.\n         */\n        public boolean hasMoreTokens() {\n            return super.hasMoreTokens();\n        }\n\n        /**\n         * Get next token.\n         *\n         * @return A String.\n         */\n        public String nextToken() {\n            StringBuffer buffer = new StringBuffer();\n\n            while (hasMoreTokens()) {\n                String token = super.nextToken();\n                if (endsWithSlash(token)) {\n                    buffer.append(token.substring(0, token.length() - 1));\n                    buffer.append(DELIMITER);\n                } else {\n                    buffer.append(token);\n                    break;\n                }\n            }\n\n            return buffer.toString().trim();\n        }\n    }\n\n    /**\n     * Creates an empty extended properties object.\n     */\n    public ExtendedProperties() {\n        super();\n    }\n\n    /**\n     * Creates and loads the extended properties from the specified file.\n     *\n     * @param file  the filename to load\n     * @throws IOException if a file error occurs\n     */\n    public ExtendedProperties(String file) throws IOException {\n        this(file, null);\n    }\n\n    /**\n     * Creates and loads the extended properties from the specified file.\n     *\n     * @param file  the filename to load\n     * @param defaultFile  a second filename to load default values from\n     * @throws IOException if a file error occurs\n     */\n    public ExtendedProperties(String file, String defaultFile) throws IOException {\n        this.file = file;\n\n        basePath = new File(file).getAbsolutePath();\n        basePath = basePath.substring(0, basePath.lastIndexOf(fileSeparator) + 1);\n\n        FileInputStream in = null;\n        try {\n            in = new FileInputStream(file);\n            this.load(in);\n        } finally {\n            try {\n                if (in != null) {\n                    in.close();\n                }\n            } catch (IOException ex) {}\n        }\n\n        if (defaultFile != null) {\n            defaults = new ExtendedProperties(defaultFile);\n        }\n    }\n\n    /**\n     * Indicate to client code whether property\n     * resources have been initialized or not.\n     */\n    public boolean isInitialized() {\n        return isInitialized;\n    }\n\n    /**\n     * Gets the property value for including other properties files.\n     * By default it is \"include\".\n     * <p>\n     * NOTE: Prior to v3.3 this method accessed a static variable.\n     * It now accesses an instance variable. For compatability, if the\n     * instance variable has not been set then the previous static\n     * variable is then accessed. However, the protected static variable\n     * can now only be set by subclasses.\n     * In v4.0, the static variable will be removed.\n     *\n     * @return the property name which includes another property\n     */\n    public String getInclude() {\n        if (includePropertyName == null) {\n            return include;  // backwards compatability\n        }\n        if (\"\".equals(includePropertyName)) {\n            return null;  // hack to allow backwards compatability\n        }\n        return includePropertyName;\n    }\n\n    /**\n     * Sets the property value for including other properties files.\n     * By default it is \"include\".\n     * <p>\n     * NOTE: Prior to v3.3 this method set a static variable and affected all\n     * users of the class. It now sets an instance variable.\n     * An empty string is also now converted to null internally.\n     * In v4.0, the static variable will be removed.\n     *\n     * @param inc  the property name which includes another property, empty converted to null\n     */\n    public void setInclude(String inc) {\n        if (inc == null) {\n            inc = \"\";  // hack to allow backwards compatability\n        }\n        includePropertyName = inc;\n    }\n\n    /**\n     * Load the properties from the given input stream.\n     *\n     * @param input  the InputStream to load from\n     * @throws IOException if an IO error occurs\n     */\n    public void load(InputStream input) throws IOException {\n        load(input, null);\n    }\n\n    /**\n     * Load the properties from the given input stream\n     * and using the specified encoding.\n     *\n     * @param input  the InputStream to load from\n     * @param enc  the encoding to use\n     * @throws IOException if an IO error occurs\n     */\n    public synchronized void load(InputStream input, String enc) throws IOException {\n        PropertiesReader reader = null;\n        if (enc != null) {\n            try {\n                reader = new PropertiesReader(new InputStreamReader(input, enc));\n                \n            } catch (UnsupportedEncodingException ex) {\n                // Another try coming up....\n            }\n        }\n        \n        if (reader == null) {\n            try {\n                reader = new PropertiesReader(new InputStreamReader(input, \"8859_1\"));\n                \n            } catch (UnsupportedEncodingException ex) {\n                // ISO8859-1 support is required on java platforms but....\n                // If it's not supported, use the system default encoding\n                reader = new PropertiesReader(new InputStreamReader(input));\n            }\n        }\n\n        try {\n            String includeProperty = getInclude();\n            while (true) {\n                String line = reader.readProperty();\n                if (line == null) {\n                    return;  // EOF\n                }\n                int equalSign = line.indexOf('=');\n\n                if (equalSign > 0) {\n                    String key = line.substring(0, equalSign).trim();\n                    String value = line.substring(equalSign + 1).trim();\n\n                    // Configure produces lines like this ... just ignore them\n                    if (\"\".equals(value)) {\n                        continue;\n                    }\n\n                    if (includeProperty != null && key.equalsIgnoreCase(includeProperty)) {\n                        // Recursively load properties files.\n                        File file = null;\n\n                        if (value.startsWith(fileSeparator)) {\n                            // We have an absolute path so we'll use this\n                            file = new File(value);\n                            \n                        } else {\n                            // We have a relative path, and we have two \n                            // possible forms here. If we have the \"./\" form\n                            // then just strip that off first before continuing.\n                            if (value.startsWith(\".\" + fileSeparator)) {\n                                value = value.substring(2);\n                            }\n\n                            file = new File(basePath + value);\n                        }\n\n                        if (file != null && file.exists() && file.canRead()) {\n                            load(new FileInputStream(file));\n                        }\n                    } else {\n                        addProperty(key, value);\n                    }\n                }\n            }\n        } finally {\n            // Loading is initializing\n            isInitialized = true;\n        }\n    }\n\n    /**\n     * Gets a property from the configuration.\n     *\n     * @param key property to retrieve\n     * @return value as object. Will return user value if exists,\n     *        if not then default value if exists, otherwise null\n     */\n    public Object getProperty(String key) {\n        // first, try to get from the 'user value' store\n        Object obj = super.get(key);\n\n        if (obj == null) {\n            // if there isn't a value there, get it from the\n            // defaults if we have them\n            if (defaults != null) {\n                obj = defaults.get(key);\n            }\n        }\n\n        return obj;\n    }\n    \n    /**\n     * Add a property to the configuration. If it already\n     * exists then the value stated here will be added\n     * to the configuration entry. For example, if\n     *\n     * <code>resource.loader = file</code>\n     *\n     * is already present in the configuration and you\n     *\n     * <code>addProperty(\"resource.loader\", \"classpath\")</code>\n     *\n     * Then you will end up with a Vector like the\n     * following:\n     *\n     * <code>[\"file\", \"classpath\"]</code>\n     *\n     * @param key  the key to add\n     * @param value  the value to add\n     */\n    public void addProperty(String key, Object value) {\n        if (value instanceof String) {\n            String str = (String) value;\n            if (str.indexOf(PropertiesTokenizer.DELIMITER) > 0) {\n                // token contains commas, so must be split apart then added\n                PropertiesTokenizer tokenizer = new PropertiesTokenizer(str);\n                while (tokenizer.hasMoreTokens()) {\n                    String token = tokenizer.nextToken();\n                    addPropertyInternal(key, unescape(token));\n                }\n            } else {\n                // token contains no commas, so can be simply added\n                addPropertyInternal(key, unescape(str));\n            }\n        } else {\n            addPropertyInternal(key, value);\n        }\n\n        // Adding a property connotes initialization\n        isInitialized = true;\n    }\n\n    /**\n     * Adds a key/value pair to the map.  This routine does\n     * no magic morphing.  It ensures the keylist is maintained\n     *\n     * @param key  the key to store at\n     * @param value  the decoded object to store\n     */\n    private void addPropertyDirect(String key, Object value) {\n        // safety check\n        if (!containsKey(key)) {\n            keysAsListed.add(key);\n        }\n        super.put(key, value);\n    }\n\n    /**\n     * Adds a decoded property to the map w/o checking for commas - used\n     * internally when a property has been broken up into\n     * strings that could contain escaped commas to prevent\n     * the inadvertent vectorization.\n     * <p>\n     * Thanks to Leon Messerschmidt for this one.\n     *\n     * @param key  the key to store at\n     * @param value  the decoded object to store\n     */\n    private void addPropertyInternal(String key, Object value) {\n        Object current = this.get(key);\n\n        if (current instanceof String) {\n            // one object already in map - convert it to a vector\n            List values = new Vector(2);\n            values.add(current);\n            values.add(value);\n            super.put(key, values);\n            \n        } else if (current instanceof List) {\n            // already a list - just add the new token\n            ((List) current).add(value);\n            \n        } else {\n            // brand new key - store in keysAsListed to retain order\n            if (!containsKey(key)) {\n                keysAsListed.add(key);\n            }\n            super.put(key, value);\n        }\n    }\n\n    /**\n     * Set a property, this will replace any previously\n     * set values. Set values is implicitly a call\n     * to clearProperty(key), addProperty(key,value).\n     *\n     * @param key  the key to set\n     * @param value  the value to set\n     */\n    public void setProperty(String key, Object value) {\n        clearProperty(key);\n        addProperty(key, value);\n    }\n    \n    /**\n     * Save the properties to the given output stream.\n     * <p>\n     * The stream is not closed, but it is flushed.\n     *\n     * @param output  an OutputStream, may be null\n     * @param header  a textual comment to act as a file header\n     * @throws IOException if an IO error occurs\n     */\n    public synchronized void save(OutputStream output, String header) throws IOException {\n        if (output == null) {\n            return;\n        }\n        PrintWriter theWrtr = new PrintWriter(output);\n        if (header != null) {\n            theWrtr.println(header);\n        }\n        \n        Enumeration theKeys = keys();\n        while (theKeys.hasMoreElements()) {\n            String key = (String) theKeys.nextElement();\n            Object value = get(key);\n            if (value != null) {\n                if (value instanceof String) {\n                    StringBuffer currentOutput = new StringBuffer();\n                    currentOutput.append(key);\n                    currentOutput.append(\"=\");\n                    currentOutput.append(escape((String) value));\n                    theWrtr.println(currentOutput.toString());\n                    \n                } else if (value instanceof List) {\n                    List values = (List) value;\n                    for (Iterator it = values.iterator(); it.hasNext(); ) {\n                        String currentElement = (String) it.next();\n                        StringBuffer currentOutput = new StringBuffer();\n                        currentOutput.append(key);\n                        currentOutput.append(\"=\");\n                        currentOutput.append(escape(currentElement));\n                        theWrtr.println(currentOutput.toString());\n                    }\n                }\n            }\n            theWrtr.println();\n            theWrtr.flush();\n        }\n    }\n\n    /**\n     * Combines an existing Hashtable with this Hashtable.\n     * <p>\n     * Warning: It will overwrite previous entries without warning.\n     *\n     * @param props  the properties to combine\n     */\n    public void combine(ExtendedProperties props) {\n        for (Iterator it = props.getKeys(); it.hasNext();) {\n            String key = (String) it.next();\n            super.put(key, props.get(key));\n        }\n    }\n    \n    /**\n     * Clear a property in the configuration.\n     *\n     * @param key  the property key to remove along with corresponding value\n     */\n    public void clearProperty(String key) {\n        if (containsKey(key)) {\n            // we also need to rebuild the keysAsListed or else\n            // things get *very* confusing\n            for (int i = 0; i < keysAsListed.size(); i++) {\n                if (( keysAsListed.get(i)).equals(key)) {\n                    keysAsListed.remove(i);\n                    break;\n                }\n            }\n            super.remove(key);\n        }\n    }\n\n    /**\n     * Get the list of the keys contained in the configuration\n     * repository.\n     *\n     * @return an Iterator over the keys\n     */\n    public Iterator getKeys() {\n        return keysAsListed.iterator();\n    }\n\n    /**\n     * Get the list of the keys contained in the configuration\n     * repository that match the specified prefix.\n     *\n     * @param prefix  the prefix to match\n     * @return an Iterator of keys that match the prefix\n     */\n    public Iterator getKeys(String prefix) {\n        Iterator keys = getKeys();\n        ArrayList matchingKeys = new ArrayList();\n\n        while (keys.hasNext()) {\n            Object key = keys.next();\n\n            if (key instanceof String && ((String) key).startsWith(prefix)) {\n                matchingKeys.add(key);\n            }\n        }\n        return matchingKeys.iterator();\n    }\n\n    /**\n     * Create an ExtendedProperties object that is a subset\n     * of this one. Take into account duplicate keys\n     * by using the setProperty() in ExtendedProperties.\n     *\n     * @param prefix  the prefix to get a subset for\n     * @return a new independent ExtendedProperties\n     */\n    public ExtendedProperties subset(String prefix) {\n        ExtendedProperties c = new ExtendedProperties();\n        Iterator keys = getKeys();\n        boolean validSubset = false;\n\n        while (keys.hasNext()) {\n            Object key = keys.next();\n\n            if (key instanceof String && ((String) key).startsWith(prefix)) {\n                if (!validSubset) {\n                    validSubset = true;\n                }\n\n                /*\n                 * Check to make sure that c.subset(prefix) doesn't\n                 * blow up when there is only a single property\n                 * with the key prefix. This is not a useful\n                 * subset but it is a valid subset.\n                 */\n                String newKey = null;\n                if (((String) key).length() == prefix.length()) {\n                    newKey = prefix;\n                } else {\n                    newKey = ((String) key).substring(prefix.length() + 1);\n                }\n\n                /*\n                 *  use addPropertyDirect() - this will plug the data as \n                 *  is into the Map, but will also do the right thing\n                 *  re key accounting\n                 */\n                c.addPropertyDirect(newKey, get(key));\n            }\n        }\n\n        if (validSubset) {\n            return c;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Display the configuration for debugging purposes to System.out.\n     */\n    public void display() {\n        Iterator i = getKeys();\n\n        while (i.hasNext()) {\n            String key = (String) i.next();\n            Object value = get(key);\n            System.out.println(key + \" => \" + value);\n        }\n    }\n\n    /**\n     * Get a string associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated string.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a String.\n     */\n    public String getString(String key) {\n        return getString(key, null);\n    }\n\n    /**\n     * Get a string associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated string if key is found,\n     * default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a String.\n     */\n    public String getString(String key, String defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof String) {\n            return interpolate((String) value);\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return interpolate(defaults.getString(key, defaultValue));\n            } else {\n                return interpolate(defaultValue);\n            }\n        } else if (value instanceof List) {\n            return interpolate((String) ((List) value).get(0));\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a String object\");\n        }\n    }\n\n    /**\n     * Get a list of properties associated with the given\n     * configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated properties if key is found.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a String/List.\n     * @throws IllegalArgumentException if one of the tokens is\n     * malformed (does not contain an equals sign).\n     */\n    public Properties getProperties(String key) {\n        return getProperties(key, new Properties());\n    }\n\n    /**\n     * Get a list of properties associated with the given\n     * configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated properties if key is found.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a String/List.\n     * @throws IllegalArgumentException if one of the tokens is\n     * malformed (does not contain an equals sign).\n     */\n    public Properties getProperties(String key, Properties defaults) {\n        /*\n         * Grab an array of the tokens for this key.\n         */\n        String[] tokens = getStringArray(key);\n\n        // Each token is of the form 'key=value'.\n        Properties props = new Properties(defaults);\n        for (int i = 0; i < tokens.length; i++) {\n            String token = tokens[i];\n            int equalSign = token.indexOf('=');\n            if (equalSign > 0) {\n                String pkey = token.substring(0, equalSign).trim();\n                String pvalue = token.substring(equalSign + 1).trim();\n                props.put(pkey, pvalue);\n            } else {\n                throw new IllegalArgumentException('\\'' + token + \"' does not contain \" + \"an equals sign\");\n            }\n        }\n        return props;\n    }\n\n    /**\n     * Get an array of strings associated with the given configuration\n     * key.\n     *\n     * @param key The configuration key.\n     * @return The associated string array if key is found.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a String/List.\n     */\n    public String[] getStringArray(String key) {\n        Object value = get(key);\n\n        List values;\n        if (value instanceof String) {\n            values = new Vector(1);\n            values.add(value);\n            \n        } else if (value instanceof List) {\n            values = (List) value;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getStringArray(key);\n            } else {\n                return new String[0];\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a String/List object\");\n        }\n\n        String[] tokens = new String[values.size()];\n        for (int i = 0; i < tokens.length; i++) {\n            tokens[i] = (String) values.get(i);\n        }\n\n        return tokens;\n    }\n\n    /**\n     * Get a Vector of strings associated with the given configuration\n     * key.\n     *\n     * @param key The configuration key.\n     * @return The associated Vector.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Vector.\n     */\n    public Vector getVector(String key) {\n        return getVector(key, null);\n    }\n\n    /**\n     * Get a Vector of strings associated with the given configuration key.\n     * <p>\n     * The list is a copy of the internal data of this object, and as\n     * such you may alter it freely.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated Vector.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Vector.\n     */\n    public Vector getVector(String key, Vector defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof List) {\n            return new Vector((List) value);\n            \n        } else if (value instanceof String) {\n            Vector values = new Vector(1);\n            values.add(value);\n            super.put(key, values);\n            return values;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getVector(key, defaultValue);\n            } else {\n                return ((defaultValue == null) ? new Vector() : defaultValue);\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Vector object\");\n        }\n    }\n\n    /**\n     * Get a List of strings associated with the given configuration key.\n     * <p>\n     * The list is a copy of the internal data of this object, and as\n     * such you may alter it freely.\n     *\n     * @param key The configuration key.\n     * @return The associated List object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a List.\n     * @since Commons Collections 3.2\n     */\n    public List getList(String key) {\n        return getList(key, null);\n    }\n\n    /**\n     * Get a List of strings associated with the given configuration key.\n     * <p>\n     * The list is a copy of the internal data of this object, and as\n     * such you may alter it freely.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated List.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a List.\n     * @since Commons Collections 3.2\n     */\n    public List getList(String key, List defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof List) {\n            return new ArrayList((List) value);\n            \n        } else if (value instanceof String) {\n            List values = new ArrayList(1);\n            values.add(value);\n            super.put(key, values);\n            return values;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getList(key, defaultValue);\n            } else {\n                return ((defaultValue == null) ? new ArrayList() : defaultValue);\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a List object\");\n        }\n    }\n\n    /**\n     * Get a boolean associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated boolean.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Boolean.\n     */\n    public boolean getBoolean(String key) {\n        Boolean b = getBoolean(key, null);\n        if (b != null) {\n            return b.booleanValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a boolean associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated boolean.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Boolean.\n     */\n    public boolean getBoolean(String key, boolean defaultValue) {\n        return getBoolean(key, new Boolean(defaultValue)).booleanValue();\n    }\n\n    /**\n     * Get a boolean associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated boolean if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Boolean.\n     */\n    public Boolean getBoolean(String key, Boolean defaultValue) {\n\n        Object value = get(key);\n\n        if (value instanceof Boolean) {\n            return (Boolean) value;\n            \n        } else if (value instanceof String) {\n            String s = testBoolean((String) value);\n            Boolean b = new Boolean(s);\n            super.put(key, b);\n            return b;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getBoolean(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Boolean object\");\n        }\n    }\n\n    /**\n     * Test whether the string represent by value maps to a boolean\n     * value or not. We will allow <code>true</code>, <code>on</code>,\n     * and <code>yes</code> for a <code>true</code> boolean value, and\n     * <code>false</code>, <code>off</code>, and <code>no</code> for\n     * <code>false</code> boolean values.  Case of value to test for\n     * boolean status is ignored.\n     *\n     * @param value  the value to test for boolean state\n     * @return <code>true</code> or <code>false</code> if the supplied\n     * text maps to a boolean value, or <code>null</code> otherwise.\n     */\n    public String testBoolean(String value) {\n        String s = value.toLowerCase();\n\n        if (s.equals(\"true\") || s.equals(\"on\") || s.equals(\"yes\")) {\n            return \"true\";\n        } else if (s.equals(\"false\") || s.equals(\"off\") || s.equals(\"no\")) {\n            return \"false\";\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Get a byte associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated byte.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Byte.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public byte getByte(String key) {\n        Byte b = getByte(key, null);\n        if (b != null) {\n            return b.byteValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \" doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a byte associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated byte.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Byte.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public byte getByte(String key, byte defaultValue) {\n        return getByte(key, new Byte(defaultValue)).byteValue();\n    }\n\n    /**\n     * Get a byte associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated byte if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Byte.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public Byte getByte(String key, Byte defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Byte) {\n            return (Byte) value;\n            \n        } else if (value instanceof String) {\n            Byte b = new Byte((String) value);\n            super.put(key, b);\n            return b;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getByte(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Byte object\");\n        }\n    }\n\n    /**\n     * Get a short associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated short.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Short.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public short getShort(String key) {\n        Short s = getShort(key, null);\n        if (s != null) {\n            return s.shortValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a short associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated short.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Short.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public short getShort(String key, short defaultValue) {\n        return getShort(key, new Short(defaultValue)).shortValue();\n    }\n\n    /**\n     * Get a short associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated short if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Short.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public Short getShort(String key, Short defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Short) {\n            return (Short) value;\n            \n        } else if (value instanceof String) {\n            Short s = new Short((String) value);\n            super.put(key, s);\n            return s;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getShort(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Short object\");\n        }\n    }\n\n    /**\n     * The purpose of this method is to get the configuration resource\n     * with the given name as an integer.\n     *\n     * @param name The resource name.\n     * @return The value of the resource as an integer.\n     */\n    public int getInt(String name) {\n        return getInteger(name);\n    }\n\n    /**\n     * The purpose of this method is to get the configuration resource\n     * with the given name as an integer, or a default value.\n     *\n     * @param name The resource name\n     * @param def The default value of the resource.\n     * @return The value of the resource as an integer.\n     */\n    public int getInt(String name, int def) {\n        return getInteger(name, def);\n    }\n\n    /**\n     * Get a int associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated int.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Integer.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public int getInteger(String key) {\n        Integer i = getInteger(key, null);\n        if (i != null) {\n            return i.intValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a int associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated int.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Integer.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public int getInteger(String key, int defaultValue) {\n        Integer i = getInteger(key, null);\n\n        if (i == null) {\n            return defaultValue;\n        }\n        return i.intValue();\n    }\n\n    /**\n     * Get a int associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated int if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Integer.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public Integer getInteger(String key, Integer defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Integer) {\n            return (Integer) value;\n            \n        } else if (value instanceof String) {\n            Integer i = new Integer((String) value);\n            super.put(key, i);\n            return i;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getInteger(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Integer object\");\n        }\n    }\n\n    /**\n     * Get a long associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated long.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Long.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public long getLong(String key) {\n        Long l = getLong(key, null);\n        if (l != null) {\n            return l.longValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a long associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated long.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Long.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public long getLong(String key, long defaultValue) {\n        return getLong(key, new Long(defaultValue)).longValue();\n    }\n\n    /**\n     * Get a long associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated long if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Long.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public Long getLong(String key, Long defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Long) {\n            return (Long) value;\n            \n        } else if (value instanceof String) {\n            Long l = new Long((String) value);\n            super.put(key, l);\n            return l;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getLong(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Long object\");\n        }\n    }\n\n    /**\n     * Get a float associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated float.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Float.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public float getFloat(String key) {\n        Float f = getFloat(key, null);\n        if (f != null) {\n            return f.floatValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a float associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated float.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Float.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public float getFloat(String key, float defaultValue) {\n        return getFloat(key, new Float(defaultValue)).floatValue();\n    }\n\n    /**\n     * Get a float associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated float if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Float.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public Float getFloat(String key, Float defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Float) {\n            return (Float) value;\n            \n        } else if (value instanceof String) {\n            Float f = new Float((String) value);\n            super.put(key, f);\n            return f;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getFloat(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Float object\");\n        }\n    }\n\n    /**\n     * Get a double associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated double.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Double.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public double getDouble(String key) {\n        Double d = getDouble(key, null);\n        if (d != null) {\n            return d.doubleValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a double associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated double.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Double.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public double getDouble(String key, double defaultValue) {\n        return getDouble(key, new Double(defaultValue)).doubleValue();\n    }\n\n    /**\n     * Get a double associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated double if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Double.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public Double getDouble(String key, Double defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Double) {\n            return (Double) value;\n            \n        } else if (value instanceof String) {\n            Double d = new Double((String) value);\n            super.put(key, d);\n            return d;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getDouble(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Double object\");\n        }\n    }\n\n    /**\n     * Convert a standard properties class into a configuration class.\n     * <p>\n     * NOTE: From Commons Collections 3.2 this method will pick up\n     * any default parent Properties of the specified input object.\n     *\n     * @param props  the properties object to convert\n     * @return new ExtendedProperties created from props\n     */\n    public static ExtendedProperties convertProperties(Properties props) {\n        ExtendedProperties c = new ExtendedProperties();\n\n        for (Enumeration e = props.propertyNames(); e.hasMoreElements();) {\n            String s = (String) e.nextElement();\n            c.setProperty(s, props.getProperty(s));\n        }\n\n        return c;\n    }\n\n    /**\n     * Add a new property specified by the key to the \n     * ExtendedProperties.\n     *\n     * @param key specifying the property\n     * @param value for the property\n     * @return old value of the property\n     */\n    public Object put(Object key, Object value) {\n        String strKey = String.valueOf(key);\n        Object ret = getProperty(strKey);\n        addProperty(strKey, value);\n        return ret;\n    }\n\n    /**\n     * Add a map full of key/value pairs to the ExtendedProperties. \n     * If the added map is an ExtendedProperties class, then the \n     * order of the added properties is maintained. \n     *\n     * @param map full of key/value pair data\n     */\n    public void putAll(Map map) {\n        if (map instanceof ExtendedProperties) {\n            for (Iterator it = ((ExtendedProperties) map).getKeys(); it.hasNext(); ) {\n                Object key = it.next();\n                put(key, map.get(key));\n            }\n        } else {\n            for (Iterator it = map.entrySet().iterator(); it.hasNext(); ) {\n                Map.Entry entry = (Map.Entry) it.next();\n                put(entry.getKey(), entry.getValue());\n            }\n        }\n    }\n\n\n    /**\n     * Remove the property specified by the key from the \n     * ExtendedProperties.\n     *\n     * @param key specifying the property\n     * @return old value of the property\n     */\n    public Object remove(Object key) {\n        String strKey = String.valueOf(key);\n        Object ret = getProperty(strKey);\n        clearProperty(strKey);\n        return ret;\n    }\n\n}\n"}]}
{"project": "Collections", "bug_id": 10, "classes_modified": [{"class_name": "org.apache.commons.collections.map.MultiValueMap", "buggy_version": "/*\n *  Licensed to the Apache Software Foundation (ASF) under one or more\n *  contributor license agreements.  See the NOTICE file distributed with\n *  this work for additional information regarding copyright ownership.\n *  The ASF licenses this file to You under the Apache License, Version 2.0\n *  (the \"License\"); you may not use this file except in compliance with\n *  the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.apache.commons.collections.map;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\n\nimport java.util.AbstractCollection;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.apache.commons.collections.Factory;\nimport org.apache.commons.collections.FunctorException;\nimport org.apache.commons.collections.MultiMap;\nimport org.apache.commons.collections.iterators.EmptyIterator;\nimport org.apache.commons.collections.iterators.IteratorChain;\n\n/**\n * A MultiValueMap decorates another map, allowing it to have\n * more than one value for a key.\n * <p>\n * A <code>MultiMap</code> is a Map with slightly different semantics.\n * Putting a value into the map will add the value to a Collection at that key.\n * Getting a value will return a Collection, holding all the values put to that key.\n * <p>\n * This implementation is a decorator, allowing any Map implementation\n * to be used as the base.\n * <p>\n * In addition, this implementation allows the type of collection used\n * for the values to be controlled. By default, an <code>ArrayList</code>\n * is used, however a <code>Class</code> to instantiate may be specified,\n * or a factory that returns a <code>Collection</code> instance.\n * <p>\n * <strong>Note that MultiValueMap is not synchronized and is not thread-safe.</strong>\n * If you wish to use this map from multiple threads concurrently, you must use\n * appropriate synchronization. This class may throw exceptions when accessed\n * by concurrent threads without synchronization.\n *\n * @author James Carman\n * @author Christopher Berry\n * @author James Strachan\n * @author Steve Downey\n * @author Stephen Colebourne\n * @author Julien Buret\n * @author Serhiy Yevtushenko\n * @version $Revision$ $Date$\n * @since Commons Collections 3.2\n */\npublic class MultiValueMap extends AbstractMapDecorator implements MultiMap {\n\n    /** Serialization version */\n\n    /** The factory for creating value collections. */\n    private final Factory collectionFactory;\n    /** The cached values. */\n    private transient Collection valuesView;\n\n    /**\n     * Creates a map which wraps the given map and\n     * maps keys to ArrayLists.\n     *\n     * @param map  the map to wrap\n     */\n    public static MultiValueMap decorate(Map map) {\n        return new MultiValueMap(map, new ReflectionFactory(ArrayList.class));\n    }\n\n    /**\n     * Creates a map which decorates the given <code>map</code> and\n     * maps keys to collections of type <code>collectionClass</code>.\n     *\n     * @param map  the map to wrap\n     * @param collectionClass  the type of the collection class\n     */\n    public static MultiValueMap decorate(Map map, Class collectionClass) {\n        return new MultiValueMap(map, new ReflectionFactory(collectionClass));\n    }\n\n    /**\n     * Creates a map which decorates the given <code>map</code> and\n     * creates the value collections using the supplied <code>collectionFactory</code>.\n     *\n     * @param map  the map to decorate\n     * @param collectionFactory  the collection factory (must return a Collection object).\n     */\n    public static MultiValueMap decorate(Map map, Factory collectionFactory) {\n        return new MultiValueMap(map, collectionFactory);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Creates a MultiValueMap based on a <code>HashMap</code> and\n     * storing the multiple values in an <code>ArrayList</code>.\n     */\n    public MultiValueMap() {\n        this(new HashMap(), new ReflectionFactory(ArrayList.class));\n    }\n\n    /**\n     * Creates a MultiValueMap which decorates the given <code>map</code> and\n     * creates the value collections using the supplied <code>collectionFactory</code>.\n     *\n     * @param map  the map to decorate\n     * @param collectionFactory  the collection factory which must return a Collection instance\n     */\n    protected MultiValueMap(Map map, Factory collectionFactory) {\n        super(map);\n        if (collectionFactory == null) {\n            throw new IllegalArgumentException(\"The factory must not be null\");\n        }\n        this.collectionFactory = collectionFactory;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Write the map out using a custom routine.\n     * \n     * @param out  the output stream\n     * @throws IOException\n     * @since Commons Collections 3.3\n     */\n    private void writeObject(ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        out.writeObject(map);\n    }\n\n    /**\n     * Read the map in using a custom routine.\n     * \n     * @param in  the input stream\n     * @throws IOException\n     * @throws ClassNotFoundException\n     * @since Commons Collections 3.3\n     */\n    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        map = (Map) in.readObject();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Clear the map.\n     */\n    public void clear() {\n        // If you believe that you have GC issues here, try uncommenting this code\n//        Set pairs = getMap().entrySet();\n//        Iterator pairsIterator = pairs.iterator();\n//        while (pairsIterator.hasNext()) {\n//            Map.Entry keyValuePair = (Map.Entry) pairsIterator.next();\n//            Collection coll = (Collection) keyValuePair.getValue();\n//            coll.clear();\n//        }\n        getMap().clear();\n    }\n\n    /**\n     * Removes a specific value from map.\n     * <p>\n     * The item is removed from the collection mapped to the specified key.\n     * Other values attached to that key are unaffected.\n     * <p>\n     * If the last value for a key is removed, <code>null</code> will be returned\n     * from a subsequant <code>get(key)</code>.\n     *\n     * @param key  the key to remove from\n     * @param value the value to remove\n     * @return the value removed (which was passed in), null if nothing removed\n     */\n    public Object removeMapping(Object key, Object value) {\n        Collection valuesForKey = getCollection(key);\n        if (valuesForKey == null) {\n            return null;\n        }\n        boolean removed = valuesForKey.remove(value);\n        if (removed == false) {\n            return null;\n        }\n        if (valuesForKey.isEmpty()) {\n            remove(key);\n        }\n        return value;\n    }\n\n    /**\n     * Checks whether the map contains the value specified.\n     * <p>\n     * This checks all collections against all keys for the value, and thus could be slow.\n     *\n     * @param value  the value to search for\n     * @return true if the map contains the value\n     */\n    public boolean containsValue(Object value) {\n        Set pairs = getMap().entrySet();\n        if (pairs == null) {\n            return false;\n        }\n        Iterator pairsIterator = pairs.iterator();\n        while (pairsIterator.hasNext()) {\n            Map.Entry keyValuePair = (Map.Entry) pairsIterator.next();\n            Collection coll = (Collection) keyValuePair.getValue();\n            if (coll.contains(value)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Adds the value to the collection associated with the specified key.\n     * <p>\n     * Unlike a normal <code>Map</code> the previous value is not replaced.\n     * Instead the new value is added to the collection stored against the key.\n     *\n     * @param key  the key to store against\n     * @param value  the value to add to the collection at the key\n     * @return the value added if the map changed and null if the map did not change\n     */\n    public Object put(Object key, Object value) {\n        boolean result = false;\n        Collection coll = getCollection(key);\n        if (coll == null) {\n            coll = createCollection(1);  // might produce a non-empty collection\n            coll.add(value);\n            if (coll.size() > 0) {\n                // only add if non-zero size to maintain class state\n                getMap().put(key, coll);\n                result = true;  // map definitely changed\n            }\n        } else {\n            result = coll.add(value);\n        }\n        return (result ? value : null);\n    }\n\n    /**\n     * Override superclass to ensure that MultiMap instances are\n     * correctly handled.\n     * <p>\n     * If you call this method with a normal map, each entry is\n     * added using <code>put(Object,Object)</code>.\n     * If you call this method with a multi map, each entry is\n     * added using <code>putAll(Object,Collection)</code>.\n     *\n     * @param map  the map to copy (either a normal or multi map)\n     */\n    public void putAll(Map map) {\n        if (map instanceof MultiMap) {\n            for (Iterator it = map.entrySet().iterator(); it.hasNext();) {\n                Map.Entry entry = (Map.Entry) it.next();\n                Collection coll = (Collection) entry.getValue();\n                putAll(entry.getKey(), coll);\n            }\n        } else {\n            for (Iterator it = map.entrySet().iterator(); it.hasNext();) {\n                Map.Entry entry = (Map.Entry) it.next();\n                put(entry.getKey(), entry.getValue());\n            }\n        }\n    }\n\n    /**\n     * Gets a collection containing all the values in the map.\n     * <p>\n     * This returns a collection containing the combination of values from all keys.\n     *\n     * @return a collection view of the values contained in this map\n     */\n    public Collection values() {\n        if (valuesView == null) {\n            valuesView = new Values();\n        }\n        return valuesView;\n    }\n\n    /**\n     * Checks whether the collection at the specified key contains the value.\n     *\n     * @param value  the value to search for\n     * @return true if the map contains the value\n     */\n    public boolean containsValue(Object key, Object value) {\n        Collection coll = getCollection(key);\n        if (coll == null) {\n            return false;\n        }\n        return coll.contains(value);\n    }\n\n    /**\n     * Gets the collection mapped to the specified key.\n     * This method is a convenience method to typecast the result of <code>get(key)</code>.\n     *\n     * @param key  the key to retrieve\n     * @return the collection mapped to the key, null if no mapping\n     */\n    public Collection getCollection(Object key) {\n        return (Collection) getMap().get(key);\n    }\n\n    /**\n     * Gets the size of the collection mapped to the specified key.\n     *\n     * @param key  the key to get size for\n     * @return the size of the collection at the key, zero if key not in map\n     */\n    public int size(Object key) {\n        Collection coll = getCollection(key);\n        if (coll == null) {\n            return 0;\n        }\n        return coll.size();\n    }\n\n    /**\n     * Adds a collection of values to the collection associated with\n     * the specified key.\n     *\n     * @param key  the key to store against\n     * @param values  the values to add to the collection at the key, null ignored\n     * @return true if this map changed\n     */\n    public boolean putAll(Object key, Collection values) {\n        if (values == null || values.size() == 0) {\n            return false;\n        }\n        boolean result = false;\n        Collection coll = getCollection(key);\n        if (coll == null) {\n            coll = createCollection(values.size());  // might produce a non-empty collection\n            coll.addAll(values);\n            if (coll.size() > 0) {\n                // only add if non-zero size to maintain class state\n                getMap().put(key, coll);\n                result = true;  // map definitely changed\n            }\n        } else {\n            result = coll.addAll(values);\n        }\n        return result;\n    }\n\n    /**\n     * Gets an iterator for the collection mapped to the specified key.\n     *\n     * @param key  the key to get an iterator for\n     * @return the iterator of the collection at the key, empty iterator if key not in map\n     */\n    public Iterator iterator(Object key) {\n        if (!containsKey(key)) {\n            return EmptyIterator.INSTANCE;\n        } else {\n            return new ValuesIterator(key);\n        }\n    }\n\n    /**\n     * Gets the total size of the map by counting all the values.\n     *\n     * @return the total size of the map counting all values\n     */\n    public int totalSize() {\n        int total = 0;\n        Collection values = getMap().values();\n        for (Iterator it = values.iterator(); it.hasNext();) {\n            Collection coll = (Collection) it.next();\n            total += coll.size();\n        }\n        return total;\n    }\n\n    /**\n     * Creates a new instance of the map value Collection container\n     * using the factory.\n     * <p>\n     * This method can be overridden to perform your own processing\n     * instead of using the factory.\n     *\n     * @param size  the collection size that is about to be added\n     * @return the new collection\n     */\n    protected Collection createCollection(int size) {\n        return (Collection) collectionFactory.create();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Inner class that provides the values view.\n     */\n    private class Values extends AbstractCollection {\n        public Iterator iterator() {\n            final IteratorChain chain = new IteratorChain();\n            for (Iterator it = keySet().iterator(); it.hasNext();) {\n                chain.addIterator(new ValuesIterator(it.next()));\n            }\n            return chain;\n        }\n\n        public int size() {\n            return totalSize();\n        }\n\n        public void clear() {\n            MultiValueMap.this.clear();\n        }\n    }\n\n    /**\n     * Inner class that provides the values iterator.\n     */\n    private class ValuesIterator implements Iterator {\n        private final Object key;\n        private final Collection values;\n        private final Iterator iterator;\n\n        public ValuesIterator(Object key) {\n            this.key = key;\n            this.values = getCollection(key);\n            this.iterator = values.iterator();\n        }\n\n        public void remove() {\n            iterator.remove();\n            if (values.isEmpty()) {\n                MultiValueMap.this.remove(key);\n            }\n        }\n\n        public boolean hasNext() {\n            return iterator.hasNext();\n        }\n\n        public Object next() {\n            return iterator.next();\n        }\n    }\n\n    /**\n     * Inner class that provides a simple reflection factory.\n     */\n    private static class ReflectionFactory implements Factory {\n        private final Class clazz;\n\n        public ReflectionFactory(Class clazz) {\n            this.clazz = clazz;\n        }\n\n        public Object create() {\n            try {\n                return clazz.newInstance();\n            } catch (Exception ex) {\n                throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex);\n            }\n        }\n    }\n\n}\n", "fixed_version": "/*\n *  Licensed to the Apache Software Foundation (ASF) under one or more\n *  contributor license agreements.  See the NOTICE file distributed with\n *  this work for additional information regarding copyright ownership.\n *  The ASF licenses this file to You under the Apache License, Version 2.0\n *  (the \"License\"); you may not use this file except in compliance with\n *  the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.apache.commons.collections.map;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\n\nimport java.util.AbstractCollection;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.apache.commons.collections.Factory;\nimport org.apache.commons.collections.FunctorException;\nimport org.apache.commons.collections.MultiMap;\nimport org.apache.commons.collections.iterators.EmptyIterator;\nimport org.apache.commons.collections.iterators.IteratorChain;\n\n/**\n * A MultiValueMap decorates another map, allowing it to have\n * more than one value for a key.\n * <p>\n * A <code>MultiMap</code> is a Map with slightly different semantics.\n * Putting a value into the map will add the value to a Collection at that key.\n * Getting a value will return a Collection, holding all the values put to that key.\n * <p>\n * This implementation is a decorator, allowing any Map implementation\n * to be used as the base.\n * <p>\n * In addition, this implementation allows the type of collection used\n * for the values to be controlled. By default, an <code>ArrayList</code>\n * is used, however a <code>Class</code> to instantiate may be specified,\n * or a factory that returns a <code>Collection</code> instance.\n * <p>\n * <strong>Note that MultiValueMap is not synchronized and is not thread-safe.</strong>\n * If you wish to use this map from multiple threads concurrently, you must use\n * appropriate synchronization. This class may throw exceptions when accessed\n * by concurrent threads without synchronization.\n *\n * @author James Carman\n * @author Christopher Berry\n * @author James Strachan\n * @author Steve Downey\n * @author Stephen Colebourne\n * @author Julien Buret\n * @author Serhiy Yevtushenko\n * @version $Revision$ $Date$\n * @since Commons Collections 3.2\n */\npublic class MultiValueMap extends AbstractMapDecorator implements MultiMap, Serializable {\n\n    /** Serialization version */\n    private static final long serialVersionUID = -2214159910087182007L;\n\n    /** The factory for creating value collections. */\n    private final Factory collectionFactory;\n    /** The cached values. */\n    private transient Collection valuesView;\n\n    /**\n     * Creates a map which wraps the given map and\n     * maps keys to ArrayLists.\n     *\n     * @param map  the map to wrap\n     */\n    public static MultiValueMap decorate(Map map) {\n        return new MultiValueMap(map, new ReflectionFactory(ArrayList.class));\n    }\n\n    /**\n     * Creates a map which decorates the given <code>map</code> and\n     * maps keys to collections of type <code>collectionClass</code>.\n     *\n     * @param map  the map to wrap\n     * @param collectionClass  the type of the collection class\n     */\n    public static MultiValueMap decorate(Map map, Class collectionClass) {\n        return new MultiValueMap(map, new ReflectionFactory(collectionClass));\n    }\n\n    /**\n     * Creates a map which decorates the given <code>map</code> and\n     * creates the value collections using the supplied <code>collectionFactory</code>.\n     *\n     * @param map  the map to decorate\n     * @param collectionFactory  the collection factory (must return a Collection object).\n     */\n    public static MultiValueMap decorate(Map map, Factory collectionFactory) {\n        return new MultiValueMap(map, collectionFactory);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Creates a MultiValueMap based on a <code>HashMap</code> and\n     * storing the multiple values in an <code>ArrayList</code>.\n     */\n    public MultiValueMap() {\n        this(new HashMap(), new ReflectionFactory(ArrayList.class));\n    }\n\n    /**\n     * Creates a MultiValueMap which decorates the given <code>map</code> and\n     * creates the value collections using the supplied <code>collectionFactory</code>.\n     *\n     * @param map  the map to decorate\n     * @param collectionFactory  the collection factory which must return a Collection instance\n     */\n    protected MultiValueMap(Map map, Factory collectionFactory) {\n        super(map);\n        if (collectionFactory == null) {\n            throw new IllegalArgumentException(\"The factory must not be null\");\n        }\n        this.collectionFactory = collectionFactory;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Write the map out using a custom routine.\n     * \n     * @param out  the output stream\n     * @throws IOException\n     * @since Commons Collections 3.3\n     */\n    private void writeObject(ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        out.writeObject(map);\n    }\n\n    /**\n     * Read the map in using a custom routine.\n     * \n     * @param in  the input stream\n     * @throws IOException\n     * @throws ClassNotFoundException\n     * @since Commons Collections 3.3\n     */\n    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        map = (Map) in.readObject();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Clear the map.\n     */\n    public void clear() {\n        // If you believe that you have GC issues here, try uncommenting this code\n//        Set pairs = getMap().entrySet();\n//        Iterator pairsIterator = pairs.iterator();\n//        while (pairsIterator.hasNext()) {\n//            Map.Entry keyValuePair = (Map.Entry) pairsIterator.next();\n//            Collection coll = (Collection) keyValuePair.getValue();\n//            coll.clear();\n//        }\n        getMap().clear();\n    }\n\n    /**\n     * Removes a specific value from map.\n     * <p>\n     * The item is removed from the collection mapped to the specified key.\n     * Other values attached to that key are unaffected.\n     * <p>\n     * If the last value for a key is removed, <code>null</code> will be returned\n     * from a subsequant <code>get(key)</code>.\n     *\n     * @param key  the key to remove from\n     * @param value the value to remove\n     * @return the value removed (which was passed in), null if nothing removed\n     */\n    public Object removeMapping(Object key, Object value) {\n        Collection valuesForKey = getCollection(key);\n        if (valuesForKey == null) {\n            return null;\n        }\n        boolean removed = valuesForKey.remove(value);\n        if (removed == false) {\n            return null;\n        }\n        if (valuesForKey.isEmpty()) {\n            remove(key);\n        }\n        return value;\n    }\n\n    /**\n     * Checks whether the map contains the value specified.\n     * <p>\n     * This checks all collections against all keys for the value, and thus could be slow.\n     *\n     * @param value  the value to search for\n     * @return true if the map contains the value\n     */\n    public boolean containsValue(Object value) {\n        Set pairs = getMap().entrySet();\n        if (pairs == null) {\n            return false;\n        }\n        Iterator pairsIterator = pairs.iterator();\n        while (pairsIterator.hasNext()) {\n            Map.Entry keyValuePair = (Map.Entry) pairsIterator.next();\n            Collection coll = (Collection) keyValuePair.getValue();\n            if (coll.contains(value)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Adds the value to the collection associated with the specified key.\n     * <p>\n     * Unlike a normal <code>Map</code> the previous value is not replaced.\n     * Instead the new value is added to the collection stored against the key.\n     *\n     * @param key  the key to store against\n     * @param value  the value to add to the collection at the key\n     * @return the value added if the map changed and null if the map did not change\n     */\n    public Object put(Object key, Object value) {\n        boolean result = false;\n        Collection coll = getCollection(key);\n        if (coll == null) {\n            coll = createCollection(1);  // might produce a non-empty collection\n            coll.add(value);\n            if (coll.size() > 0) {\n                // only add if non-zero size to maintain class state\n                getMap().put(key, coll);\n                result = true;  // map definitely changed\n            }\n        } else {\n            result = coll.add(value);\n        }\n        return (result ? value : null);\n    }\n\n    /**\n     * Override superclass to ensure that MultiMap instances are\n     * correctly handled.\n     * <p>\n     * If you call this method with a normal map, each entry is\n     * added using <code>put(Object,Object)</code>.\n     * If you call this method with a multi map, each entry is\n     * added using <code>putAll(Object,Collection)</code>.\n     *\n     * @param map  the map to copy (either a normal or multi map)\n     */\n    public void putAll(Map map) {\n        if (map instanceof MultiMap) {\n            for (Iterator it = map.entrySet().iterator(); it.hasNext();) {\n                Map.Entry entry = (Map.Entry) it.next();\n                Collection coll = (Collection) entry.getValue();\n                putAll(entry.getKey(), coll);\n            }\n        } else {\n            for (Iterator it = map.entrySet().iterator(); it.hasNext();) {\n                Map.Entry entry = (Map.Entry) it.next();\n                put(entry.getKey(), entry.getValue());\n            }\n        }\n    }\n\n    /**\n     * Gets a collection containing all the values in the map.\n     * <p>\n     * This returns a collection containing the combination of values from all keys.\n     *\n     * @return a collection view of the values contained in this map\n     */\n    public Collection values() {\n        if (valuesView == null) {\n            valuesView = new Values();\n        }\n        return valuesView;\n    }\n\n    /**\n     * Checks whether the collection at the specified key contains the value.\n     *\n     * @param value  the value to search for\n     * @return true if the map contains the value\n     */\n    public boolean containsValue(Object key, Object value) {\n        Collection coll = getCollection(key);\n        if (coll == null) {\n            return false;\n        }\n        return coll.contains(value);\n    }\n\n    /**\n     * Gets the collection mapped to the specified key.\n     * This method is a convenience method to typecast the result of <code>get(key)</code>.\n     *\n     * @param key  the key to retrieve\n     * @return the collection mapped to the key, null if no mapping\n     */\n    public Collection getCollection(Object key) {\n        return (Collection) getMap().get(key);\n    }\n\n    /**\n     * Gets the size of the collection mapped to the specified key.\n     *\n     * @param key  the key to get size for\n     * @return the size of the collection at the key, zero if key not in map\n     */\n    public int size(Object key) {\n        Collection coll = getCollection(key);\n        if (coll == null) {\n            return 0;\n        }\n        return coll.size();\n    }\n\n    /**\n     * Adds a collection of values to the collection associated with\n     * the specified key.\n     *\n     * @param key  the key to store against\n     * @param values  the values to add to the collection at the key, null ignored\n     * @return true if this map changed\n     */\n    public boolean putAll(Object key, Collection values) {\n        if (values == null || values.size() == 0) {\n            return false;\n        }\n        boolean result = false;\n        Collection coll = getCollection(key);\n        if (coll == null) {\n            coll = createCollection(values.size());  // might produce a non-empty collection\n            coll.addAll(values);\n            if (coll.size() > 0) {\n                // only add if non-zero size to maintain class state\n                getMap().put(key, coll);\n                result = true;  // map definitely changed\n            }\n        } else {\n            result = coll.addAll(values);\n        }\n        return result;\n    }\n\n    /**\n     * Gets an iterator for the collection mapped to the specified key.\n     *\n     * @param key  the key to get an iterator for\n     * @return the iterator of the collection at the key, empty iterator if key not in map\n     */\n    public Iterator iterator(Object key) {\n        if (!containsKey(key)) {\n            return EmptyIterator.INSTANCE;\n        } else {\n            return new ValuesIterator(key);\n        }\n    }\n\n    /**\n     * Gets the total size of the map by counting all the values.\n     *\n     * @return the total size of the map counting all values\n     */\n    public int totalSize() {\n        int total = 0;\n        Collection values = getMap().values();\n        for (Iterator it = values.iterator(); it.hasNext();) {\n            Collection coll = (Collection) it.next();\n            total += coll.size();\n        }\n        return total;\n    }\n\n    /**\n     * Creates a new instance of the map value Collection container\n     * using the factory.\n     * <p>\n     * This method can be overridden to perform your own processing\n     * instead of using the factory.\n     *\n     * @param size  the collection size that is about to be added\n     * @return the new collection\n     */\n    protected Collection createCollection(int size) {\n        return (Collection) collectionFactory.create();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Inner class that provides the values view.\n     */\n    private class Values extends AbstractCollection {\n        public Iterator iterator() {\n            final IteratorChain chain = new IteratorChain();\n            for (Iterator it = keySet().iterator(); it.hasNext();) {\n                chain.addIterator(new ValuesIterator(it.next()));\n            }\n            return chain;\n        }\n\n        public int size() {\n            return totalSize();\n        }\n\n        public void clear() {\n            MultiValueMap.this.clear();\n        }\n    }\n\n    /**\n     * Inner class that provides the values iterator.\n     */\n    private class ValuesIterator implements Iterator {\n        private final Object key;\n        private final Collection values;\n        private final Iterator iterator;\n\n        public ValuesIterator(Object key) {\n            this.key = key;\n            this.values = getCollection(key);\n            this.iterator = values.iterator();\n        }\n\n        public void remove() {\n            iterator.remove();\n            if (values.isEmpty()) {\n                MultiValueMap.this.remove(key);\n            }\n        }\n\n        public boolean hasNext() {\n            return iterator.hasNext();\n        }\n\n        public Object next() {\n            return iterator.next();\n        }\n    }\n\n    /**\n     * Inner class that provides a simple reflection factory.\n     */\n    private static class ReflectionFactory implements Factory, Serializable {\n        private final Class clazz;\n\n        public ReflectionFactory(Class clazz) {\n            this.clazz = clazz;\n        }\n\n        public Object create() {\n            try {\n                return clazz.newInstance();\n            } catch (Exception ex) {\n                throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex);\n            }\n        }\n    }\n\n}\n"}]}
{"project": "Collections", "bug_id": 11, "classes_modified": [{"class_name": "org.apache.commons.collections.keyvalue.MultiKey", "buggy_version": "/*\n *  Licensed to the Apache Software Foundation (ASF) under one or more\n *  contributor license agreements.  See the NOTICE file distributed with\n *  this work for additional information regarding copyright ownership.\n *  The ASF licenses this file to You under the Apache License, Version 2.0\n *  (the \"License\"); you may not use this file except in compliance with\n *  the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.apache.commons.collections.keyvalue;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.Serializable;\nimport java.util.Arrays;\n\n/** \n * A <code>MultiKey</code> allows multiple map keys to be merged together.\n * <p>\n * The purpose of this class is to avoid the need to write code to handle\n * maps of maps. An example might be the need to look up a file name by \n * key and locale. The typical solution might be nested maps. This class\n * can be used instead by creating an instance passing in the key and locale.\n * <p>\n * Example usage:\n * <pre>\n * // populate map with data mapping key+locale to localizedText\n * Map map = new HashMap();\n * MultiKey multiKey = new MultiKey(key, locale);\n * map.put(multiKey, localizedText);\n *\n * // later retrieve the localized text\n * MultiKey multiKey = new MultiKey(key, locale);\n * String localizedText = (String) map.get(multiKey);\n * </pre>\n * \n * @since Commons Collections 3.0\n * @version $Revision$ $Date$\n * \n * @author Howard Lewis Ship\n * @author Stephen Colebourne\n */\npublic class MultiKey implements Serializable {\n    // This class could implement List, but that would confuse it's purpose\n\n    /** Serialisation version */\n    private static final long serialVersionUID = 4465448607415788805L;\n\n    /** The individual keys */\n    private final Object[] keys;\n    /** The cached hashCode */\n    private transient int hashCode;\n    \n    /**\n     * Constructor taking two keys.\n     * <p>\n     * The keys should be immutable\n     * If they are not then they must not be changed after adding to the MultiKey.\n     * \n     * @param key1  the first key\n     * @param key2  the second key\n     */\n    public MultiKey(Object key1, Object key2) {\n        this(new Object[] {key1, key2}, false);\n    }\n    \n    /**\n     * Constructor taking three keys.\n     * <p>\n     * The keys should be immutable\n     * If they are not then they must not be changed after adding to the MultiKey.\n     * \n     * @param key1  the first key\n     * @param key2  the second key\n     * @param key3  the third key\n     */\n    public MultiKey(Object key1, Object key2, Object key3) {\n        this(new Object[] {key1, key2, key3}, false);\n    }\n    \n    /**\n     * Constructor taking four keys.\n     * <p>\n     * The keys should be immutable\n     * If they are not then they must not be changed after adding to the MultiKey.\n     * \n     * @param key1  the first key\n     * @param key2  the second key\n     * @param key3  the third key\n     * @param key4  the fourth key\n     */\n    public MultiKey(Object key1, Object key2, Object key3, Object key4) {\n        this(new Object[] {key1, key2, key3, key4}, false);\n    }\n    \n    /**\n     * Constructor taking five keys.\n     * <p>\n     * The keys should be immutable\n     * If they are not then they must not be changed after adding to the MultiKey.\n     * \n     * @param key1  the first key\n     * @param key2  the second key\n     * @param key3  the third key\n     * @param key4  the fourth key\n     * @param key5  the fifth key\n     */\n    public MultiKey(Object key1, Object key2, Object key3, Object key4, Object key5) {\n        this(new Object[] {key1, key2, key3, key4, key5}, false);\n    }\n    \n    /**\n     * Constructor taking an array of keys which is cloned.\n     * <p>\n     * The keys should be immutable\n     * If they are not then they must not be changed after adding to the MultiKey.\n     * <p>\n     * This is equivalent to <code>new MultiKey(keys, true)</code>.\n     *\n     * @param keys  the array of keys, not null\n     * @throws IllegalArgumentException if the key array is null\n     */\n    public MultiKey(Object[] keys) {\n        this(keys, true);\n    }\n    \n    /**\n     * Constructor taking an array of keys, optionally choosing whether to clone.\n     * <p>\n     * <b>If the array is not cloned, then it must not be modified.</b>\n     * <p>\n     * This method is public for performance reasons only, to avoid a clone.\n     * The hashcode is calculated once here in this method.\n     * Therefore, changing the array passed in would not change the hashcode but\n     * would change the equals method, which is a bug.\n     * <p>\n     * This is the only fully safe usage of this constructor, as the object array\n     * is never made available in a variable:\n     * <pre>\n     * new MultiKey(new Object[] {...}, false);\n     * </pre>\n     * <p>\n     * The keys should be immutable\n     * If they are not then they must not be changed after adding to the MultiKey.\n     *\n     * @param keys  the array of keys, not null\n     * @param makeClone  true to clone the array, false to assign it\n     * @throws IllegalArgumentException if the key array is null\n     * @since Commons Collections 3.1\n     */\n    public MultiKey(Object[] keys, boolean makeClone) {\n        super();\n        if (keys == null) {\n            throw new IllegalArgumentException(\"The array of keys must not be null\");\n        }\n        if (makeClone) {\n            this.keys = (Object[]) keys.clone();\n        } else {\n            this.keys = keys;\n        }\n        \n        calculateHashCode(keys);\n    }\n    \n    //-----------------------------------------------------------------------\n    /**\n     * Gets a clone of the array of keys.\n     * <p>\n     * The keys should be immutable\n     * If they are not then they must not be changed.\n     * \n     * @return the individual keys\n     */\n    public Object[] getKeys() {\n        return (Object[]) keys.clone();\n    }\n    \n    /**\n     * Gets the key at the specified index.\n     * <p>\n     * The key should be immutable.\n     * If it is not then it must not be changed.\n     * \n     * @param index  the index to retrieve\n     * @return the key at the index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     * @since Commons Collections 3.1\n     */\n    public Object getKey(int index) {\n        return keys[index];\n    }\n    \n    /**\n     * Gets the size of the list of keys.\n     * \n     * @return the size of the list of keys\n     * @since Commons Collections 3.1\n     */\n    public int size() {\n        return keys.length;\n    }\n    \n    //-----------------------------------------------------------------------\n    /**\n     * Compares this object to another.\n     * <p>\n     * To be equal, the other object must be a <code>MultiKey</code> with the\n     * same number of keys which are also equal.\n     * \n     * @param other  the other object to compare to\n     * @return true if equal\n     */\n    public boolean equals(Object other) {\n        if (other == this) {\n            return true;\n        }\n        if (other instanceof MultiKey) {\n            MultiKey otherMulti = (MultiKey) other;\n            return Arrays.equals(keys, otherMulti.keys);\n        }\n        return false;\n    }\n\n    /**\n     * Gets the combined hash code that is computed from all the keys.\n     * <p>\n     * This value is computed once and then cached, so elements should not\n     * change their hash codes once created (note that this is the same \n     * constraint that would be used if the individual keys elements were\n     * themselves {@link java.util.Map Map} keys.\n     * \n     * @return the hash code\n     */\n    public int hashCode() {\n        return hashCode;\n    }\n\n    /**\n     * Gets a debugging string version of the key.\n     * \n     * @return a debugging string\n     */\n    public String toString() {\n        return \"MultiKey\" + Arrays.asList(keys).toString();\n    }\n\n\t/**\n\t * Calculate the hash code of the instance using the provided keys.\n\t * @param keys\n\t */\n\tprivate void calculateHashCode(Object[] keys)\n\t{\n\t\tint total = 0;\n        for (int i = 0; i < keys.length; i++) {\n            if (keys[i] != null) {\n                total ^= keys[i].hashCode();\n            }\n        }\n        hashCode = total;\n\t}\n\t\n\t/**\n\t * Recalculate the hash code after deserialization. The hash code of some\n\t * keys might have change (hash codes based on the system hash code are\n\t * only stable for the same process). \n\t * @return the instance with recalculated hash code\n\t */\n}\n", "fixed_version": "/*\n *  Licensed to the Apache Software Foundation (ASF) under one or more\n *  contributor license agreements.  See the NOTICE file distributed with\n *  this work for additional information regarding copyright ownership.\n *  The ASF licenses this file to You under the Apache License, Version 2.0\n *  (the \"License\"); you may not use this file except in compliance with\n *  the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.apache.commons.collections.keyvalue;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.Serializable;\nimport java.util.Arrays;\n\n/** \n * A <code>MultiKey</code> allows multiple map keys to be merged together.\n * <p>\n * The purpose of this class is to avoid the need to write code to handle\n * maps of maps. An example might be the need to look up a file name by \n * key and locale. The typical solution might be nested maps. This class\n * can be used instead by creating an instance passing in the key and locale.\n * <p>\n * Example usage:\n * <pre>\n * // populate map with data mapping key+locale to localizedText\n * Map map = new HashMap();\n * MultiKey multiKey = new MultiKey(key, locale);\n * map.put(multiKey, localizedText);\n *\n * // later retrieve the localized text\n * MultiKey multiKey = new MultiKey(key, locale);\n * String localizedText = (String) map.get(multiKey);\n * </pre>\n * \n * @since Commons Collections 3.0\n * @version $Revision$ $Date$\n * \n * @author Howard Lewis Ship\n * @author Stephen Colebourne\n */\npublic class MultiKey implements Serializable {\n    // This class could implement List, but that would confuse it's purpose\n\n    /** Serialisation version */\n    private static final long serialVersionUID = 4465448607415788805L;\n\n    /** The individual keys */\n    private final Object[] keys;\n    /** The cached hashCode */\n    private transient int hashCode;\n    \n    /**\n     * Constructor taking two keys.\n     * <p>\n     * The keys should be immutable\n     * If they are not then they must not be changed after adding to the MultiKey.\n     * \n     * @param key1  the first key\n     * @param key2  the second key\n     */\n    public MultiKey(Object key1, Object key2) {\n        this(new Object[] {key1, key2}, false);\n    }\n    \n    /**\n     * Constructor taking three keys.\n     * <p>\n     * The keys should be immutable\n     * If they are not then they must not be changed after adding to the MultiKey.\n     * \n     * @param key1  the first key\n     * @param key2  the second key\n     * @param key3  the third key\n     */\n    public MultiKey(Object key1, Object key2, Object key3) {\n        this(new Object[] {key1, key2, key3}, false);\n    }\n    \n    /**\n     * Constructor taking four keys.\n     * <p>\n     * The keys should be immutable\n     * If they are not then they must not be changed after adding to the MultiKey.\n     * \n     * @param key1  the first key\n     * @param key2  the second key\n     * @param key3  the third key\n     * @param key4  the fourth key\n     */\n    public MultiKey(Object key1, Object key2, Object key3, Object key4) {\n        this(new Object[] {key1, key2, key3, key4}, false);\n    }\n    \n    /**\n     * Constructor taking five keys.\n     * <p>\n     * The keys should be immutable\n     * If they are not then they must not be changed after adding to the MultiKey.\n     * \n     * @param key1  the first key\n     * @param key2  the second key\n     * @param key3  the third key\n     * @param key4  the fourth key\n     * @param key5  the fifth key\n     */\n    public MultiKey(Object key1, Object key2, Object key3, Object key4, Object key5) {\n        this(new Object[] {key1, key2, key3, key4, key5}, false);\n    }\n    \n    /**\n     * Constructor taking an array of keys which is cloned.\n     * <p>\n     * The keys should be immutable\n     * If they are not then they must not be changed after adding to the MultiKey.\n     * <p>\n     * This is equivalent to <code>new MultiKey(keys, true)</code>.\n     *\n     * @param keys  the array of keys, not null\n     * @throws IllegalArgumentException if the key array is null\n     */\n    public MultiKey(Object[] keys) {\n        this(keys, true);\n    }\n    \n    /**\n     * Constructor taking an array of keys, optionally choosing whether to clone.\n     * <p>\n     * <b>If the array is not cloned, then it must not be modified.</b>\n     * <p>\n     * This method is public for performance reasons only, to avoid a clone.\n     * The hashcode is calculated once here in this method.\n     * Therefore, changing the array passed in would not change the hashcode but\n     * would change the equals method, which is a bug.\n     * <p>\n     * This is the only fully safe usage of this constructor, as the object array\n     * is never made available in a variable:\n     * <pre>\n     * new MultiKey(new Object[] {...}, false);\n     * </pre>\n     * <p>\n     * The keys should be immutable\n     * If they are not then they must not be changed after adding to the MultiKey.\n     *\n     * @param keys  the array of keys, not null\n     * @param makeClone  true to clone the array, false to assign it\n     * @throws IllegalArgumentException if the key array is null\n     * @since Commons Collections 3.1\n     */\n    public MultiKey(Object[] keys, boolean makeClone) {\n        super();\n        if (keys == null) {\n            throw new IllegalArgumentException(\"The array of keys must not be null\");\n        }\n        if (makeClone) {\n            this.keys = (Object[]) keys.clone();\n        } else {\n            this.keys = keys;\n        }\n        \n        calculateHashCode(keys);\n    }\n    \n    //-----------------------------------------------------------------------\n    /**\n     * Gets a clone of the array of keys.\n     * <p>\n     * The keys should be immutable\n     * If they are not then they must not be changed.\n     * \n     * @return the individual keys\n     */\n    public Object[] getKeys() {\n        return (Object[]) keys.clone();\n    }\n    \n    /**\n     * Gets the key at the specified index.\n     * <p>\n     * The key should be immutable.\n     * If it is not then it must not be changed.\n     * \n     * @param index  the index to retrieve\n     * @return the key at the index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     * @since Commons Collections 3.1\n     */\n    public Object getKey(int index) {\n        return keys[index];\n    }\n    \n    /**\n     * Gets the size of the list of keys.\n     * \n     * @return the size of the list of keys\n     * @since Commons Collections 3.1\n     */\n    public int size() {\n        return keys.length;\n    }\n    \n    //-----------------------------------------------------------------------\n    /**\n     * Compares this object to another.\n     * <p>\n     * To be equal, the other object must be a <code>MultiKey</code> with the\n     * same number of keys which are also equal.\n     * \n     * @param other  the other object to compare to\n     * @return true if equal\n     */\n    public boolean equals(Object other) {\n        if (other == this) {\n            return true;\n        }\n        if (other instanceof MultiKey) {\n            MultiKey otherMulti = (MultiKey) other;\n            return Arrays.equals(keys, otherMulti.keys);\n        }\n        return false;\n    }\n\n    /**\n     * Gets the combined hash code that is computed from all the keys.\n     * <p>\n     * This value is computed once and then cached, so elements should not\n     * change their hash codes once created (note that this is the same \n     * constraint that would be used if the individual keys elements were\n     * themselves {@link java.util.Map Map} keys.\n     * \n     * @return the hash code\n     */\n    public int hashCode() {\n        return hashCode;\n    }\n\n    /**\n     * Gets a debugging string version of the key.\n     * \n     * @return a debugging string\n     */\n    public String toString() {\n        return \"MultiKey\" + Arrays.asList(keys).toString();\n    }\n\n\t/**\n\t * Calculate the hash code of the instance using the provided keys.\n\t * @param keys\n\t */\n\tprivate void calculateHashCode(Object[] keys)\n\t{\n\t\tint total = 0;\n        for (int i = 0; i < keys.length; i++) {\n            if (keys[i] != null) {\n                total ^= keys[i].hashCode();\n            }\n        }\n        hashCode = total;\n\t}\n\t\n\t/**\n\t * Recalculate the hash code after deserialization. The hash code of some\n\t * keys might have change (hash codes based on the system hash code are\n\t * only stable for the same process). \n\t * @return the instance with recalculated hash code\n\t */\n\tprivate Object readResolve() {\n\t\tcalculateHashCode(keys);\n\t\treturn this;\n\t}\n}\n"}]}
{"project": "Collections", "bug_id": 12, "classes_modified": [{"class_name": "org.apache.commons.collections.ExtendedProperties", "buggy_version": "/*\n *  Licensed to the Apache Software Foundation (ASF) under one or more\n *  contributor license agreements.  See the NOTICE file distributed with\n *  this work for additional information regarding copyright ownership.\n *  The ASF licenses this file to You under the Apache License, Version 2.0\n *  (the \"License\"); you may not use this file except in compliance with\n *  the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.apache.commons.collections;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.LineNumberReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.UnsupportedEncodingException;\nimport java.util.ArrayList;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Properties;\nimport java.util.StringTokenizer;\nimport java.util.Vector;\n\n/**\n * This class extends normal Java properties by adding the possibility\n * to use the same key many times concatenating the value strings\n * instead of overwriting them.\n * <p>\n * <b>Please consider using the\n * {@link org.apache.commons.configuration.PropertiesConfiguration} class in\n * <a href=\"http://commons.apache.org/configuration\">Commons Configuration</a>.\n * It's an evolution of <code>ExtendedProperties</code> supporting more\n * features like automatic reloading, advanced interpolation, more type\n * conversions, changes notifications and file layout preservation.</b>\n * <p>\n * The Extended Properties syntax is explained here:\n *\n * <ul>\n *  <li>\n *   Each property has the syntax <code>key = value</code>\n *  </li>\n *  <li>\n *   The <i>key</i> may use any character but the equal sign '='.\n *  </li>\n *  <li>\n *   <i>value</i> may be separated on different lines if a backslash\n *   is placed at the end of the line that continues below.\n *  </li>\n *  <li>\n *   If <i>value</i> is a list of strings, each token is separated\n *   by a comma ','.\n *  </li>\n *  <li>\n *   Commas in each token are escaped placing a backslash right before\n *   the comma.\n *  </li>\n *  <li>\n *   Backslashes are escaped by using two consecutive backslashes i.e. \\\\\n *  </li>\n *  <li>\n *   If a <i>key</i> is used more than once, the values are appended\n *   as if they were on the same line separated with commas.\n *  </li>\n *  <li>\n *   Blank lines and lines starting with character '#' are skipped.\n *  </li>\n *  <li>\n *   If a property is named \"include\" (or whatever is defined by\n *   setInclude() and getInclude() and the value of that property is\n *   the full path to a file on disk, that file will be included into\n *   the ConfigurationsRepository. You can also pull in files relative\n *   to the parent configuration file. So if you have something\n *   like the following:\n *\n *   include = additional.properties\n *\n *   Then \"additional.properties\" is expected to be in the same\n *   directory as the parent configuration file.\n * \n *   Duplicate name values will be replaced, so be careful.\n *\n *  </li>\n * </ul>\n *\n * <p>Here is an example of a valid extended properties file:\n *\n * <p><pre>\n *      # lines starting with # are comments\n *\n *      # This is the simplest property\n *      key = value\n *\n *      # A long property may be separated on multiple lines\n *      longvalue = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa \\\n *                  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n *\n *      # This is a property with many tokens\n *      tokens_on_a_line = first token, second token\n *\n *      # This sequence generates exactly the same result\n *      tokens_on_multiple_lines = first token\n *      tokens_on_multiple_lines = second token\n *\n *      # commas may be escaped in tokens\n *      commas.escaped = Hi\\, what'up?\n * </pre>\n *\n * <p><b>NOTE</b>: this class has <b>not</b> been written for\n * performance nor low memory usage.  In fact, it's way slower than it\n * could be and generates too much memory garbage.  But since\n * performance is not an issue during intialization (and there is not\n * much time to improve it), I wrote it this way.  If you don't like\n * it, go ahead and tune it up!\n *\n * @since Commons Collections 1.0\n * @version $Revision$ $Date$\n * \n * @author <a href=\"mailto:stefano@apache.org\">Stefano Mazzocchi</a>\n * @author <a href=\"mailto:jon@latchkey.com\">Jon S. Stevens</a>\n * @author <a href=\"mailto:daveb@miceda-data\">Dave Bryson</a>\n * @author <a href=\"mailto:jvanzyl@periapt.com\">Jason van Zyl</a>\n * @author <a href=\"mailto:geirm@optonline.net\">Geir Magnusson Jr.</a>\n * @author <a href=\"mailto:leon@opticode.co.za\">Leon Messerschmidt</a>\n * @author <a href=\"mailto:kjohnson@transparent.com\">Kent Johnson</a>\n * @author <a href=\"mailto:dlr@finemaltcoding.com\">Daniel Rall</a>\n * @author <a href=\"mailto:ipriha@surfeu.fi\">Ilkka Priha</a>\n * @author Janek Bogucki\n * @author Mohan Kishore\n * @author Stephen Colebourne\n * @author Shinobu Kawai\n * @author <a href=\"mailto:hps@intermeta.de\">Henning P. Schmiedehausen</a>\n */\npublic class ExtendedProperties extends Hashtable {\n    \n    /**\n     * Default configurations repository.\n     */\n    private ExtendedProperties defaults;\n\n    /**\n     * The file connected to this repository (holding comments and\n     * such).\n     *\n     * @serial\n     */\n    protected String file;\n\n    /**\n     * Base path of the configuration file used to create\n     * this ExtendedProperties object.\n     */\n    protected String basePath;\n\n    /**\n     * File separator.\n     */\n    protected String fileSeparator = System.getProperty(\"file.separator\");\n\n    /**\n     * Has this configuration been intialized.\n     */\n    protected boolean isInitialized = false;\n\n    /**\n     * This is the name of the property that can point to other\n     * properties file for including other properties files.\n     */\n    private String includePropertyName = null;\n\n    /**\n     * This is the default name of the property that can point to other\n     * properties file for including other properties files.\n     * \n     * @deprecated Use getInclude() and setInclude() methods which operate\n     * on an instance variable from v3.3. Due to be removed in v4.0.\n     */\n    protected static String include = \"include\";\n\n    /**\n     * These are the keys in the order they listed\n     * in the configuration file. This is useful when\n     * you wish to perform operations with configuration\n     * information in a particular order.\n     */\n    protected ArrayList keysAsListed = new ArrayList();\n\n    protected final static String START_TOKEN=\"${\";\n    protected final static String END_TOKEN=\"}\";\n\n\n    /**\n     * Interpolate key names to handle ${key} stuff\n     *\n     * @param base string to interpolate\n     * @return returns the key name with the ${key} substituted\n     */\n    protected String interpolate(String base) {\n        // COPIED from [configuration] 2003-12-29\n        return (interpolateHelper(base, null));\n    }\n\n    /**\n     * Recursive handler for multiple levels of interpolation.\n     *\n     * When called the first time, priorVariables should be null.\n     *\n     * @param base string with the ${key} variables\n     * @param priorVariables serves two purposes: to allow checking for\n     * loops, and creating a meaningful exception message should a loop\n     * occur.  It's 0'th element will be set to the value of base from\n     * the first call.  All subsequent interpolated variables are added\n     * afterward.\n     *\n     * @return the string with the interpolation taken care of\n     */\n    protected String interpolateHelper(String base, List priorVariables) {\n        // COPIED from [configuration] 2003-12-29\n        if (base == null) {\n            return null;\n        }\n\n        // on the first call initialize priorVariables\n        // and add base as the first element\n        if (priorVariables == null) {\n            priorVariables = new ArrayList();\n            priorVariables.add(base);\n        }\n\n        int begin = -1;\n        int end = -1;\n        int prec = 0 - END_TOKEN.length();\n        String variable = null;\n        StringBuffer result = new StringBuffer();\n\n        // FIXME: we should probably allow the escaping of the start token\n        while (((begin = base.indexOf(START_TOKEN, prec + END_TOKEN.length())) > -1)\n            && ((end = base.indexOf(END_TOKEN, begin)) > -1)) {\n            result.append(base.substring(prec + END_TOKEN.length(), begin));\n            variable = base.substring(begin + START_TOKEN.length(), end);\n\n            // if we've got a loop, create a useful exception message and throw\n            if (priorVariables.contains(variable)) {\n                String initialBase = priorVariables.remove(0).toString();\n                priorVariables.add(variable);\n                StringBuffer priorVariableSb = new StringBuffer();\n\n                // create a nice trace of interpolated variables like so:\n                // var1->var2->var3\n                for (Iterator it = priorVariables.iterator(); it.hasNext();) {\n                    priorVariableSb.append(it.next());\n                    if (it.hasNext()) {\n                        priorVariableSb.append(\"->\");\n                    }\n                }\n\n                throw new IllegalStateException(\n                    \"infinite loop in property interpolation of \" + initialBase + \": \" + priorVariableSb.toString());\n            }\n            // otherwise, add this variable to the interpolation list.\n            else {\n                priorVariables.add(variable);\n            }\n\n            //QUESTION: getProperty or getPropertyDirect\n            Object value = getProperty(variable);\n            if (value != null) {\n                result.append(interpolateHelper(value.toString(), priorVariables));\n\n                // pop the interpolated variable off the stack\n                // this maintains priorVariables correctness for\n                // properties with multiple interpolations, e.g.\n                // prop.name=${some.other.prop1}/blahblah/${some.other.prop2}\n                priorVariables.remove(priorVariables.size() - 1);\n            } else if (defaults != null && defaults.getString(variable, null) != null) {\n                result.append(defaults.getString(variable));\n            } else {\n                //variable not defined - so put it back in the value\n                result.append(START_TOKEN).append(variable).append(END_TOKEN);\n            }\n            prec = end;\n        }\n        result.append(base.substring(prec + END_TOKEN.length(), base.length()));\n\n        return result.toString();\n    }\n    \n    /**\n     * Inserts a backslash before every comma and backslash. \n     */\n    private static String escape(String s) {\n        StringBuffer buf = new StringBuffer(s);\n        for (int i = 0; i < buf.length(); i++) {\n            char c = buf.charAt(i);\n            if (c == ',' || c == '\\\\') {\n                buf.insert(i, '\\\\');\n                i++;\n            }\n        }\n        return buf.toString();\n    }\n    \n    /**\n     * Removes a backslash from every pair of backslashes. \n     */\n    private static String unescape(String s) {\n        StringBuffer buf = new StringBuffer(s);\n        for (int i = 0; i < buf.length() - 1; i++) {\n            char c1 = buf.charAt(i);\n            char c2 = buf.charAt(i + 1);\n            if (c1 == '\\\\' && c2 == '\\\\') {\n                buf.deleteCharAt(i);\n            }\n        }\n        return buf.toString();\n    }\n\n    /**\n     * Counts the number of successive times 'ch' appears in the\n     * 'line' before the position indicated by the 'index'.\n     */\n    private static int countPreceding(String line, int index, char ch) {\n        int i;\n        for (i = index - 1; i >= 0; i--) {\n            if (line.charAt(i) != ch) {\n                break;\n            }\n        }\n        return index - 1 - i;\n    }\n\n    /**\n     * Checks if the line ends with odd number of backslashes \n     */\n    private static boolean endsWithSlash(String line) {\n        if (!line.endsWith(\"\\\\\")) {\n            return false;\n        }\n        return (countPreceding(line, line.length() - 1, '\\\\') % 2 == 0);\n    }\n\n    /**\n     * This class is used to read properties lines.  These lines do\n     * not terminate with new-line chars but rather when there is no\n     * backslash sign a the end of the line.  This is used to\n     * concatenate multiple lines for readability.\n     */\n    static class PropertiesReader extends LineNumberReader {\n        /**\n         * Constructor.\n         *\n         * @param reader A Reader.\n         */\n        public PropertiesReader(Reader reader) {\n            super(reader);\n        }\n\n        /**\n         * Read a property.\n         *\n         * @return a String property\n         * @throws IOException if there is difficulty reading the source.\n         */\n        public String readProperty() throws IOException {\n            StringBuffer buffer = new StringBuffer();\n            String line = readLine();\n            while (line != null) {\n                line = line.trim();\n                if ((line.length() != 0) && (line.charAt(0) != '#')) {\n                    if (endsWithSlash(line)) {\n                        line = line.substring(0, line.length() - 1);\n                        buffer.append(line);\n                    } else {\n                        buffer.append(line);\n                        return buffer.toString();  // normal method end\n                    }\n                }\n                line = readLine();\n            }\n            return null;  // EOF reached\n        }\n    }\n\n    /**\n     * This class divides into tokens a property value.  Token\n     * separator is \",\" but commas into the property value are escaped\n     * using the backslash in front.\n     */\n    static class PropertiesTokenizer extends StringTokenizer {\n        /**\n         * The property delimiter used while parsing (a comma).\n         */\n        static final String DELIMITER = \",\";\n\n        /**\n         * Constructor.\n         *\n         * @param string A String.\n         */\n        public PropertiesTokenizer(String string) {\n            super(string, DELIMITER);\n        }\n\n        /**\n         * Check whether the object has more tokens.\n         *\n         * @return True if the object has more tokens.\n         */\n        public boolean hasMoreTokens() {\n            return super.hasMoreTokens();\n        }\n\n        /**\n         * Get next token.\n         *\n         * @return A String.\n         */\n        public String nextToken() {\n            StringBuffer buffer = new StringBuffer();\n\n            while (hasMoreTokens()) {\n                String token = super.nextToken();\n                if (endsWithSlash(token)) {\n                    buffer.append(token.substring(0, token.length() - 1));\n                    buffer.append(DELIMITER);\n                } else {\n                    buffer.append(token);\n                    break;\n                }\n            }\n\n            return buffer.toString().trim();\n        }\n    }\n\n    /**\n     * Creates an empty extended properties object.\n     */\n    public ExtendedProperties() {\n        super();\n    }\n\n    /**\n     * Creates and loads the extended properties from the specified file.\n     *\n     * @param file  the filename to load\n     * @throws IOException if a file error occurs\n     */\n    public ExtendedProperties(String file) throws IOException {\n        this(file, null);\n    }\n\n    /**\n     * Creates and loads the extended properties from the specified file.\n     *\n     * @param file  the filename to load\n     * @param defaultFile  a second filename to load default values from\n     * @throws IOException if a file error occurs\n     */\n    public ExtendedProperties(String file, String defaultFile) throws IOException {\n        this.file = file;\n\n        basePath = new File(file).getAbsolutePath();\n        basePath = basePath.substring(0, basePath.lastIndexOf(fileSeparator) + 1);\n\n        FileInputStream in = null;\n        try {\n            in = new FileInputStream(file);\n            this.load(in);\n        } finally {\n            try {\n                if (in != null) {\n                    in.close();\n                }\n            } catch (IOException ex) {}\n        }\n\n        if (defaultFile != null) {\n            defaults = new ExtendedProperties(defaultFile);\n        }\n    }\n\n    /**\n     * Indicate to client code whether property\n     * resources have been initialized or not.\n     */\n    public boolean isInitialized() {\n        return isInitialized;\n    }\n\n    /**\n     * Gets the property value for including other properties files.\n     * By default it is \"include\".\n     * <p>\n     * NOTE: Prior to v3.3 this method accessed a static variable.\n     * It now accesses an instance variable. For compatability, if the\n     * instance variable has not been set then the previous static\n     * variable is then accessed. However, the protected static variable\n     * can now only be set by subclasses.\n     * In v4.0, the static variable will be removed.\n     *\n     * @return the property name which includes another property\n     */\n    public String getInclude() {\n        if (includePropertyName == null) {\n            return include;  // backwards compatability\n        }\n        if (\"\".equals(includePropertyName)) {\n            return null;  // hack to allow backwards compatability\n        }\n        return includePropertyName;\n    }\n\n    /**\n     * Sets the property value for including other properties files.\n     * By default it is \"include\".\n     * <p>\n     * NOTE: Prior to v3.3 this method set a static variable and affected all\n     * users of the class. It now sets an instance variable.\n     * An empty string is also now converted to null internally.\n     * In v4.0, the static variable will be removed.\n     *\n     * @param inc  the property name which includes another property, empty converted to null\n     */\n    public void setInclude(String inc) {\n        if (inc == null) {\n            inc = \"\";  // hack to allow backwards compatability\n        }\n        includePropertyName = inc;\n    }\n\n    /**\n     * Load the properties from the given input stream.\n     *\n     * @param input  the InputStream to load from\n     * @throws IOException if an IO error occurs\n     */\n    public void load(InputStream input) throws IOException {\n        load(input, null);\n    }\n\n    /**\n     * Load the properties from the given input stream\n     * and using the specified encoding.\n     *\n     * @param input  the InputStream to load from\n     * @param enc  the encoding to use\n     * @throws IOException if an IO error occurs\n     */\n    public synchronized void load(InputStream input, String enc) throws IOException {\n        PropertiesReader reader = null;\n        if (enc != null) {\n            try {\n                reader = new PropertiesReader(new InputStreamReader(input, enc));\n                \n            } catch (UnsupportedEncodingException ex) {\n                // Another try coming up....\n            }\n        }\n        \n        if (reader == null) {\n            try {\n                reader = new PropertiesReader(new InputStreamReader(input, \"8859_1\"));\n                \n            } catch (UnsupportedEncodingException ex) {\n                // ISO8859-1 support is required on java platforms but....\n                // If it's not supported, use the system default encoding\n                reader = new PropertiesReader(new InputStreamReader(input));\n            }\n        }\n\n        try {\n            String includeProperty = getInclude();\n            while (true) {\n                String line = reader.readProperty();\n                if (line == null) {\n                    return;  // EOF\n                }\n                int equalSign = line.indexOf('=');\n\n                if (equalSign > 0) {\n                    String key = line.substring(0, equalSign).trim();\n                    String value = line.substring(equalSign + 1).trim();\n\n                    /* COLLECTIONS-238 allows empty properties to exist by commenting this out\n                    // Configure produces lines like this ... just ignore them\n                    if (\"\".equals(value)) {\n                        continue;\n                    }\n                    */\n\n                    if (includeProperty != null && key.equalsIgnoreCase(includeProperty)) {\n                        // Recursively load properties files.\n                        File file = null;\n\n                        if (value.startsWith(fileSeparator)) {\n                            // We have an absolute path so we'll use this\n                            file = new File(value);\n                            \n                        } else {\n                            // We have a relative path, and we have two \n                            // possible forms here. If we have the \"./\" form\n                            // then just strip that off first before continuing.\n                            if (value.startsWith(\".\" + fileSeparator)) {\n                                value = value.substring(2);\n                            }\n\n                            file = new File(basePath + value);\n                        }\n\n                        if (file != null && file.exists() && file.canRead()) {\n                            load(new FileInputStream(file));\n                        }\n                    } else {\n                        addProperty(key, value);\n                    }\n                }\n            }\n        } finally {\n            // Loading is initializing\n            isInitialized = true;\n        }\n    }\n\n    /**\n     * Gets a property from the configuration.\n     *\n     * @param key property to retrieve\n     * @return value as object. Will return user value if exists,\n     *        if not then default value if exists, otherwise null\n     */\n    public Object getProperty(String key) {\n        // first, try to get from the 'user value' store\n        Object obj = super.get(key);\n\n        if (obj == null) {\n            // if there isn't a value there, get it from the\n            // defaults if we have them\n            if (defaults != null) {\n                obj = defaults.get(key);\n            }\n        }\n\n        return obj;\n    }\n    \n    /**\n     * Add a property to the configuration. If it already\n     * exists then the value stated here will be added\n     * to the configuration entry. For example, if\n     *\n     * <code>resource.loader = file</code>\n     *\n     * is already present in the configuration and you\n     *\n     * <code>addProperty(\"resource.loader\", \"classpath\")</code>\n     *\n     * Then you will end up with a Vector like the\n     * following:\n     *\n     * <code>[\"file\", \"classpath\"]</code>\n     *\n     * @param key  the key to add\n     * @param value  the value to add\n     */\n    public void addProperty(String key, Object value) {\n        if (value instanceof String) {\n            String str = (String) value;\n            if (str.indexOf(PropertiesTokenizer.DELIMITER) > 0) {\n                // token contains commas, so must be split apart then added\n                PropertiesTokenizer tokenizer = new PropertiesTokenizer(str);\n                while (tokenizer.hasMoreTokens()) {\n                    String token = tokenizer.nextToken();\n                    addPropertyInternal(key, unescape(token));\n                }\n            } else {\n                // token contains no commas, so can be simply added\n                addPropertyInternal(key, unescape(str));\n            }\n        } else {\n            addPropertyInternal(key, value);\n        }\n\n        // Adding a property connotes initialization\n        isInitialized = true;\n    }\n\n    /**\n     * Adds a key/value pair to the map.  This routine does\n     * no magic morphing.  It ensures the keylist is maintained\n     *\n     * @param key  the key to store at\n     * @param value  the decoded object to store\n     */\n    private void addPropertyDirect(String key, Object value) {\n        // safety check\n        if (!containsKey(key)) {\n            keysAsListed.add(key);\n        }\n        super.put(key, value);\n    }\n\n    /**\n     * Adds a decoded property to the map w/o checking for commas - used\n     * internally when a property has been broken up into\n     * strings that could contain escaped commas to prevent\n     * the inadvertent vectorization.\n     * <p>\n     * Thanks to Leon Messerschmidt for this one.\n     *\n     * @param key  the key to store at\n     * @param value  the decoded object to store\n     */\n    private void addPropertyInternal(String key, Object value) {\n        Object current = this.get(key);\n\n        if (current instanceof String) {\n            // one object already in map - convert it to a vector\n            List values = new Vector(2);\n            values.add(current);\n            values.add(value);\n            super.put(key, values);\n            \n        } else if (current instanceof List) {\n            // already a list - just add the new token\n            ((List) current).add(value);\n            \n        } else {\n            // brand new key - store in keysAsListed to retain order\n            if (!containsKey(key)) {\n                keysAsListed.add(key);\n            }\n            super.put(key, value);\n        }\n    }\n\n    /**\n     * Set a property, this will replace any previously\n     * set values. Set values is implicitly a call\n     * to clearProperty(key), addProperty(key,value).\n     *\n     * @param key  the key to set\n     * @param value  the value to set\n     */\n    public void setProperty(String key, Object value) {\n        clearProperty(key);\n        addProperty(key, value);\n    }\n    \n    /**\n     * Save the properties to the given output stream.\n     * <p>\n     * The stream is not closed, but it is flushed.\n     *\n     * @param output  an OutputStream, may be null\n     * @param header  a textual comment to act as a file header\n     * @throws IOException if an IO error occurs\n     */\n    public synchronized void save(OutputStream output, String header) throws IOException {\n        if (output == null) {\n            return;\n        }\n        PrintWriter theWrtr = new PrintWriter(output);\n        if (header != null) {\n            theWrtr.println(header);\n        }\n        \n        Enumeration theKeys = keys();\n        while (theKeys.hasMoreElements()) {\n            String key = (String) theKeys.nextElement();\n            Object value = get(key);\n            if (value != null) {\n                if (value instanceof String) {\n                    StringBuffer currentOutput = new StringBuffer();\n                    currentOutput.append(key);\n                    currentOutput.append(\"=\");\n                    currentOutput.append(escape((String) value));\n                    theWrtr.println(currentOutput.toString());\n                    \n                } else if (value instanceof List) {\n                    List values = (List) value;\n                    for (Iterator it = values.iterator(); it.hasNext(); ) {\n                        String currentElement = (String) it.next();\n                        StringBuffer currentOutput = new StringBuffer();\n                        currentOutput.append(key);\n                        currentOutput.append(\"=\");\n                        currentOutput.append(escape(currentElement));\n                        theWrtr.println(currentOutput.toString());\n                    }\n                }\n            }\n            theWrtr.println();\n            theWrtr.flush();\n        }\n    }\n\n    /**\n     * Combines an existing Hashtable with this Hashtable.\n     * <p>\n     * Warning: It will overwrite previous entries without warning.\n     *\n     * @param props  the properties to combine\n     */\n    public void combine(ExtendedProperties props) {\n        for (Iterator it = props.getKeys(); it.hasNext();) {\n            String key = (String) it.next();\n            super.put(key, props.get(key));\n        }\n    }\n    \n    /**\n     * Clear a property in the configuration.\n     *\n     * @param key  the property key to remove along with corresponding value\n     */\n    public void clearProperty(String key) {\n        if (containsKey(key)) {\n            // we also need to rebuild the keysAsListed or else\n            // things get *very* confusing\n            for (int i = 0; i < keysAsListed.size(); i++) {\n                if (( keysAsListed.get(i)).equals(key)) {\n                    keysAsListed.remove(i);\n                    break;\n                }\n            }\n            super.remove(key);\n        }\n    }\n\n    /**\n     * Get the list of the keys contained in the configuration\n     * repository.\n     *\n     * @return an Iterator over the keys\n     */\n    public Iterator getKeys() {\n        return keysAsListed.iterator();\n    }\n\n    /**\n     * Get the list of the keys contained in the configuration\n     * repository that match the specified prefix.\n     *\n     * @param prefix  the prefix to match\n     * @return an Iterator of keys that match the prefix\n     */\n    public Iterator getKeys(String prefix) {\n        Iterator keys = getKeys();\n        ArrayList matchingKeys = new ArrayList();\n\n        while (keys.hasNext()) {\n            Object key = keys.next();\n\n            if (key instanceof String && ((String) key).startsWith(prefix)) {\n                matchingKeys.add(key);\n            }\n        }\n        return matchingKeys.iterator();\n    }\n\n    /**\n     * Create an ExtendedProperties object that is a subset\n     * of this one. Take into account duplicate keys\n     * by using the setProperty() in ExtendedProperties.\n     *\n     * @param prefix  the prefix to get a subset for\n     * @return a new independent ExtendedProperties\n     */\n    public ExtendedProperties subset(String prefix) {\n        ExtendedProperties c = new ExtendedProperties();\n        Iterator keys = getKeys();\n        boolean validSubset = false;\n\n        while (keys.hasNext()) {\n            Object key = keys.next();\n\n            if (key instanceof String && ((String) key).startsWith(prefix)) {\n                if (!validSubset) {\n                    validSubset = true;\n                }\n\n                /*\n                 * Check to make sure that c.subset(prefix) doesn't\n                 * blow up when there is only a single property\n                 * with the key prefix. This is not a useful\n                 * subset but it is a valid subset.\n                 */\n                String newKey = null;\n                if (((String) key).length() == prefix.length()) {\n                    newKey = prefix;\n                } else {\n                    newKey = ((String) key).substring(prefix.length() + 1);\n                }\n\n                /*\n                 *  use addPropertyDirect() - this will plug the data as \n                 *  is into the Map, but will also do the right thing\n                 *  re key accounting\n                 */\n                c.addPropertyDirect(newKey, get(key));\n            }\n        }\n\n        if (validSubset) {\n            return c;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Display the configuration for debugging purposes to System.out.\n     */\n    public void display() {\n        Iterator i = getKeys();\n\n        while (i.hasNext()) {\n            String key = (String) i.next();\n            Object value = get(key);\n            System.out.println(key + \" => \" + value);\n        }\n    }\n\n    /**\n     * Get a string associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated string.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a String.\n     */\n    public String getString(String key) {\n        return getString(key, null);\n    }\n\n    /**\n     * Get a string associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated string if key is found,\n     * default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a String.\n     */\n    public String getString(String key, String defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof String) {\n            return interpolate((String) value);\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return interpolate(defaults.getString(key, defaultValue));\n            } else {\n                return interpolate(defaultValue);\n            }\n        } else if (value instanceof List) {\n            return interpolate((String) ((List) value).get(0));\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a String object\");\n        }\n    }\n\n    /**\n     * Get a list of properties associated with the given\n     * configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated properties if key is found.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a String/List.\n     * @throws IllegalArgumentException if one of the tokens is\n     * malformed (does not contain an equals sign).\n     */\n    public Properties getProperties(String key) {\n        return getProperties(key, new Properties());\n    }\n\n    /**\n     * Get a list of properties associated with the given\n     * configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated properties if key is found.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a String/List.\n     * @throws IllegalArgumentException if one of the tokens is\n     * malformed (does not contain an equals sign).\n     */\n    public Properties getProperties(String key, Properties defaults) {\n        /*\n         * Grab an array of the tokens for this key.\n         */\n        String[] tokens = getStringArray(key);\n\n        // Each token is of the form 'key=value'.\n        Properties props = new Properties(defaults);\n        for (int i = 0; i < tokens.length; i++) {\n            String token = tokens[i];\n            int equalSign = token.indexOf('=');\n            if (equalSign > 0) {\n                String pkey = token.substring(0, equalSign).trim();\n                String pvalue = token.substring(equalSign + 1).trim();\n                props.put(pkey, pvalue);\n            } else {\n                throw new IllegalArgumentException('\\'' + token + \"' does not contain \" + \"an equals sign\");\n            }\n        }\n        return props;\n    }\n\n    /**\n     * Get an array of strings associated with the given configuration\n     * key.\n     *\n     * @param key The configuration key.\n     * @return The associated string array if key is found.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a String/List.\n     */\n    public String[] getStringArray(String key) {\n        Object value = get(key);\n\n        List values;\n        if (value instanceof String) {\n            values = new Vector(1);\n            values.add(value);\n            \n        } else if (value instanceof List) {\n            values = (List) value;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getStringArray(key);\n            } else {\n                return new String[0];\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a String/List object\");\n        }\n\n        String[] tokens = new String[values.size()];\n        for (int i = 0; i < tokens.length; i++) {\n            tokens[i] = (String) values.get(i);\n        }\n\n        return tokens;\n    }\n\n    /**\n     * Get a Vector of strings associated with the given configuration\n     * key.\n     *\n     * @param key The configuration key.\n     * @return The associated Vector.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Vector.\n     */\n    public Vector getVector(String key) {\n        return getVector(key, null);\n    }\n\n    /**\n     * Get a Vector of strings associated with the given configuration key.\n     * <p>\n     * The list is a copy of the internal data of this object, and as\n     * such you may alter it freely.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated Vector.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Vector.\n     */\n    public Vector getVector(String key, Vector defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof List) {\n            return new Vector((List) value);\n            \n        } else if (value instanceof String) {\n            Vector values = new Vector(1);\n            values.add(value);\n            super.put(key, values);\n            return values;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getVector(key, defaultValue);\n            } else {\n                return ((defaultValue == null) ? new Vector() : defaultValue);\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Vector object\");\n        }\n    }\n\n    /**\n     * Get a List of strings associated with the given configuration key.\n     * <p>\n     * The list is a copy of the internal data of this object, and as\n     * such you may alter it freely.\n     *\n     * @param key The configuration key.\n     * @return The associated List object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a List.\n     * @since Commons Collections 3.2\n     */\n    public List getList(String key) {\n        return getList(key, null);\n    }\n\n    /**\n     * Get a List of strings associated with the given configuration key.\n     * <p>\n     * The list is a copy of the internal data of this object, and as\n     * such you may alter it freely.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated List.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a List.\n     * @since Commons Collections 3.2\n     */\n    public List getList(String key, List defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof List) {\n            return new ArrayList((List) value);\n            \n        } else if (value instanceof String) {\n            List values = new ArrayList(1);\n            values.add(value);\n            super.put(key, values);\n            return values;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getList(key, defaultValue);\n            } else {\n                return ((defaultValue == null) ? new ArrayList() : defaultValue);\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a List object\");\n        }\n    }\n\n    /**\n     * Get a boolean associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated boolean.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Boolean.\n     */\n    public boolean getBoolean(String key) {\n        Boolean b = getBoolean(key, null);\n        if (b != null) {\n            return b.booleanValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a boolean associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated boolean.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Boolean.\n     */\n    public boolean getBoolean(String key, boolean defaultValue) {\n        return getBoolean(key, new Boolean(defaultValue)).booleanValue();\n    }\n\n    /**\n     * Get a boolean associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated boolean if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Boolean.\n     */\n    public Boolean getBoolean(String key, Boolean defaultValue) {\n\n        Object value = get(key);\n\n        if (value instanceof Boolean) {\n            return (Boolean) value;\n            \n        } else if (value instanceof String) {\n            String s = testBoolean((String) value);\n            Boolean b = new Boolean(s);\n            super.put(key, b);\n            return b;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getBoolean(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Boolean object\");\n        }\n    }\n\n    /**\n     * Test whether the string represent by value maps to a boolean\n     * value or not. We will allow <code>true</code>, <code>on</code>,\n     * and <code>yes</code> for a <code>true</code> boolean value, and\n     * <code>false</code>, <code>off</code>, and <code>no</code> for\n     * <code>false</code> boolean values.  Case of value to test for\n     * boolean status is ignored.\n     *\n     * @param value  the value to test for boolean state\n     * @return <code>true</code> or <code>false</code> if the supplied\n     * text maps to a boolean value, or <code>null</code> otherwise.\n     */\n    public String testBoolean(String value) {\n        String s = value.toLowerCase(Locale.ENGLISH);\n\n        if (s.equals(\"true\") || s.equals(\"on\") || s.equals(\"yes\")) {\n            return \"true\";\n        } else if (s.equals(\"false\") || s.equals(\"off\") || s.equals(\"no\")) {\n            return \"false\";\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Get a byte associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated byte.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Byte.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public byte getByte(String key) {\n        Byte b = getByte(key, null);\n        if (b != null) {\n            return b.byteValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \" doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a byte associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated byte.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Byte.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public byte getByte(String key, byte defaultValue) {\n        return getByte(key, new Byte(defaultValue)).byteValue();\n    }\n\n    /**\n     * Get a byte associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated byte if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Byte.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public Byte getByte(String key, Byte defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Byte) {\n            return (Byte) value;\n            \n        } else if (value instanceof String) {\n            Byte b = new Byte((String) value);\n            super.put(key, b);\n            return b;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getByte(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Byte object\");\n        }\n    }\n\n    /**\n     * Get a short associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated short.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Short.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public short getShort(String key) {\n        Short s = getShort(key, null);\n        if (s != null) {\n            return s.shortValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a short associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated short.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Short.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public short getShort(String key, short defaultValue) {\n        return getShort(key, new Short(defaultValue)).shortValue();\n    }\n\n    /**\n     * Get a short associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated short if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Short.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public Short getShort(String key, Short defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Short) {\n            return (Short) value;\n            \n        } else if (value instanceof String) {\n            Short s = new Short((String) value);\n            super.put(key, s);\n            return s;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getShort(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Short object\");\n        }\n    }\n\n    /**\n     * The purpose of this method is to get the configuration resource\n     * with the given name as an integer.\n     *\n     * @param name The resource name.\n     * @return The value of the resource as an integer.\n     */\n    public int getInt(String name) {\n        return getInteger(name);\n    }\n\n    /**\n     * The purpose of this method is to get the configuration resource\n     * with the given name as an integer, or a default value.\n     *\n     * @param name The resource name\n     * @param def The default value of the resource.\n     * @return The value of the resource as an integer.\n     */\n    public int getInt(String name, int def) {\n        return getInteger(name, def);\n    }\n\n    /**\n     * Get a int associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated int.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Integer.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public int getInteger(String key) {\n        Integer i = getInteger(key, null);\n        if (i != null) {\n            return i.intValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a int associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated int.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Integer.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public int getInteger(String key, int defaultValue) {\n        Integer i = getInteger(key, null);\n\n        if (i == null) {\n            return defaultValue;\n        }\n        return i.intValue();\n    }\n\n    /**\n     * Get a int associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated int if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Integer.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public Integer getInteger(String key, Integer defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Integer) {\n            return (Integer) value;\n            \n        } else if (value instanceof String) {\n            Integer i = new Integer((String) value);\n            super.put(key, i);\n            return i;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getInteger(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Integer object\");\n        }\n    }\n\n    /**\n     * Get a long associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated long.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Long.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public long getLong(String key) {\n        Long l = getLong(key, null);\n        if (l != null) {\n            return l.longValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a long associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated long.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Long.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public long getLong(String key, long defaultValue) {\n        return getLong(key, new Long(defaultValue)).longValue();\n    }\n\n    /**\n     * Get a long associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated long if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Long.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public Long getLong(String key, Long defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Long) {\n            return (Long) value;\n            \n        } else if (value instanceof String) {\n            Long l = new Long((String) value);\n            super.put(key, l);\n            return l;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getLong(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Long object\");\n        }\n    }\n\n    /**\n     * Get a float associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated float.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Float.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public float getFloat(String key) {\n        Float f = getFloat(key, null);\n        if (f != null) {\n            return f.floatValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a float associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated float.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Float.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public float getFloat(String key, float defaultValue) {\n        return getFloat(key, new Float(defaultValue)).floatValue();\n    }\n\n    /**\n     * Get a float associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated float if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Float.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public Float getFloat(String key, Float defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Float) {\n            return (Float) value;\n            \n        } else if (value instanceof String) {\n            Float f = new Float((String) value);\n            super.put(key, f);\n            return f;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getFloat(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Float object\");\n        }\n    }\n\n    /**\n     * Get a double associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated double.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Double.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public double getDouble(String key) {\n        Double d = getDouble(key, null);\n        if (d != null) {\n            return d.doubleValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a double associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated double.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Double.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public double getDouble(String key, double defaultValue) {\n        return getDouble(key, new Double(defaultValue)).doubleValue();\n    }\n\n    /**\n     * Get a double associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated double if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Double.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public Double getDouble(String key, Double defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Double) {\n            return (Double) value;\n            \n        } else if (value instanceof String) {\n            Double d = new Double((String) value);\n            super.put(key, d);\n            return d;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getDouble(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Double object\");\n        }\n    }\n\n    /**\n     * Convert a standard properties class into a configuration class.\n     * <p>\n     * NOTE: From Commons Collections 3.2 this method will pick up\n     * any default parent Properties of the specified input object.\n     *\n     * @param props  the properties object to convert\n     * @return new ExtendedProperties created from props\n     */\n    public static ExtendedProperties convertProperties(Properties props) {\n        ExtendedProperties c = new ExtendedProperties();\n\n        for (Enumeration e = props.propertyNames(); e.hasMoreElements();) {\n            String s = (String) e.nextElement();\n            c.setProperty(s, props.getProperty(s));\n        }\n\n        return c;\n    }\n\n    /**\n     * Add a new property specified by the key to the \n     * ExtendedProperties.\n     *\n     * @param key specifying the property\n     * @param value for the property\n     * @return old value of the property\n     */\n    public Object put(Object key, Object value) {\n        String strKey = String.valueOf(key);\n        Object ret = getProperty(strKey);\n        addProperty(strKey, value);\n        return ret;\n    }\n\n    /**\n     * Add a map full of key/value pairs to the ExtendedProperties. \n     * If the added map is an ExtendedProperties class, then the \n     * order of the added properties is maintained. \n     *\n     * @param map full of key/value pair data\n     */\n    public void putAll(Map map) {\n        if (map instanceof ExtendedProperties) {\n            for (Iterator it = ((ExtendedProperties) map).getKeys(); it.hasNext(); ) {\n                Object key = it.next();\n                put(key, map.get(key));\n            }\n        } else {\n            for (Iterator it = map.entrySet().iterator(); it.hasNext(); ) {\n                Map.Entry entry = (Map.Entry) it.next();\n                put(entry.getKey(), entry.getValue());\n            }\n        }\n    }\n\n\n    /**\n     * Remove the property specified by the key from the \n     * ExtendedProperties.\n     *\n     * @param key specifying the property\n     * @return old value of the property\n     */\n    public Object remove(Object key) {\n        String strKey = String.valueOf(key);\n        Object ret = getProperty(strKey);\n        clearProperty(strKey);\n        return ret;\n    }\n\n}\n", "fixed_version": "/*\n *  Licensed to the Apache Software Foundation (ASF) under one or more\n *  contributor license agreements.  See the NOTICE file distributed with\n *  this work for additional information regarding copyright ownership.\n *  The ASF licenses this file to You under the Apache License, Version 2.0\n *  (the \"License\"); you may not use this file except in compliance with\n *  the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.apache.commons.collections;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.LineNumberReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.UnsupportedEncodingException;\nimport java.util.ArrayList;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Properties;\nimport java.util.StringTokenizer;\nimport java.util.Vector;\n\n/**\n * This class extends normal Java properties by adding the possibility\n * to use the same key many times concatenating the value strings\n * instead of overwriting them.\n * <p>\n * <b>Please consider using the\n * {@link org.apache.commons.configuration.PropertiesConfiguration} class in\n * <a href=\"http://commons.apache.org/configuration\">Commons Configuration</a>.\n * It's an evolution of <code>ExtendedProperties</code> supporting more\n * features like automatic reloading, advanced interpolation, more type\n * conversions, changes notifications and file layout preservation.</b>\n * <p>\n * The Extended Properties syntax is explained here:\n *\n * <ul>\n *  <li>\n *   Each property has the syntax <code>key = value</code>\n *  </li>\n *  <li>\n *   The <i>key</i> may use any character but the equal sign '='.\n *  </li>\n *  <li>\n *   <i>value</i> may be separated on different lines if a backslash\n *   is placed at the end of the line that continues below.\n *  </li>\n *  <li>\n *   If <i>value</i> is a list of strings, each token is separated\n *   by a comma ','.\n *  </li>\n *  <li>\n *   Commas in each token are escaped placing a backslash right before\n *   the comma.\n *  </li>\n *  <li>\n *   Backslashes are escaped by using two consecutive backslashes i.e. \\\\\n *  </li>\n *  <li>\n *   If a <i>key</i> is used more than once, the values are appended\n *   as if they were on the same line separated with commas.\n *  </li>\n *  <li>\n *   Blank lines and lines starting with character '#' are skipped.\n *  </li>\n *  <li>\n *   If a property is named \"include\" (or whatever is defined by\n *   setInclude() and getInclude() and the value of that property is\n *   the full path to a file on disk, that file will be included into\n *   the ConfigurationsRepository. You can also pull in files relative\n *   to the parent configuration file. So if you have something\n *   like the following:\n *\n *   include = additional.properties\n *\n *   Then \"additional.properties\" is expected to be in the same\n *   directory as the parent configuration file.\n * \n *   Duplicate name values will be replaced, so be careful.\n *\n *  </li>\n * </ul>\n *\n * <p>Here is an example of a valid extended properties file:\n *\n * <p><pre>\n *      # lines starting with # are comments\n *\n *      # This is the simplest property\n *      key = value\n *\n *      # A long property may be separated on multiple lines\n *      longvalue = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa \\\n *                  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n *\n *      # This is a property with many tokens\n *      tokens_on_a_line = first token, second token\n *\n *      # This sequence generates exactly the same result\n *      tokens_on_multiple_lines = first token\n *      tokens_on_multiple_lines = second token\n *\n *      # commas may be escaped in tokens\n *      commas.escaped = Hi\\, what'up?\n * </pre>\n *\n * <p><b>NOTE</b>: this class has <b>not</b> been written for\n * performance nor low memory usage.  In fact, it's way slower than it\n * could be and generates too much memory garbage.  But since\n * performance is not an issue during intialization (and there is not\n * much time to improve it), I wrote it this way.  If you don't like\n * it, go ahead and tune it up!\n *\n * @since Commons Collections 1.0\n * @version $Revision$ $Date$\n * \n * @author <a href=\"mailto:stefano@apache.org\">Stefano Mazzocchi</a>\n * @author <a href=\"mailto:jon@latchkey.com\">Jon S. Stevens</a>\n * @author <a href=\"mailto:daveb@miceda-data\">Dave Bryson</a>\n * @author <a href=\"mailto:jvanzyl@periapt.com\">Jason van Zyl</a>\n * @author <a href=\"mailto:geirm@optonline.net\">Geir Magnusson Jr.</a>\n * @author <a href=\"mailto:leon@opticode.co.za\">Leon Messerschmidt</a>\n * @author <a href=\"mailto:kjohnson@transparent.com\">Kent Johnson</a>\n * @author <a href=\"mailto:dlr@finemaltcoding.com\">Daniel Rall</a>\n * @author <a href=\"mailto:ipriha@surfeu.fi\">Ilkka Priha</a>\n * @author Janek Bogucki\n * @author Mohan Kishore\n * @author Stephen Colebourne\n * @author Shinobu Kawai\n * @author <a href=\"mailto:hps@intermeta.de\">Henning P. Schmiedehausen</a>\n */\npublic class ExtendedProperties extends Hashtable {\n    \n    /**\n     * Default configurations repository.\n     */\n    private ExtendedProperties defaults;\n\n    /**\n     * The file connected to this repository (holding comments and\n     * such).\n     *\n     * @serial\n     */\n    protected String file;\n\n    /**\n     * Base path of the configuration file used to create\n     * this ExtendedProperties object.\n     */\n    protected String basePath;\n\n    /**\n     * File separator.\n     */\n    protected String fileSeparator = System.getProperty(\"file.separator\");\n\n    /**\n     * Has this configuration been intialized.\n     */\n    protected boolean isInitialized = false;\n\n    /**\n     * This is the name of the property that can point to other\n     * properties file for including other properties files.\n     */\n    private String includePropertyName = null;\n\n    /**\n     * This is the default name of the property that can point to other\n     * properties file for including other properties files.\n     * \n     * @deprecated Use getInclude() and setInclude() methods which operate\n     * on an instance variable from v3.3. Due to be removed in v4.0.\n     */\n    protected static String include = \"include\";\n\n    /**\n     * These are the keys in the order they listed\n     * in the configuration file. This is useful when\n     * you wish to perform operations with configuration\n     * information in a particular order.\n     */\n    protected ArrayList keysAsListed = new ArrayList();\n\n    protected final static String START_TOKEN=\"${\";\n    protected final static String END_TOKEN=\"}\";\n\n\n    /**\n     * Interpolate key names to handle ${key} stuff\n     *\n     * @param base string to interpolate\n     * @return returns the key name with the ${key} substituted\n     */\n    protected String interpolate(String base) {\n        // COPIED from [configuration] 2003-12-29\n        return (interpolateHelper(base, null));\n    }\n\n    /**\n     * Recursive handler for multiple levels of interpolation.\n     *\n     * When called the first time, priorVariables should be null.\n     *\n     * @param base string with the ${key} variables\n     * @param priorVariables serves two purposes: to allow checking for\n     * loops, and creating a meaningful exception message should a loop\n     * occur.  It's 0'th element will be set to the value of base from\n     * the first call.  All subsequent interpolated variables are added\n     * afterward.\n     *\n     * @return the string with the interpolation taken care of\n     */\n    protected String interpolateHelper(String base, List priorVariables) {\n        // COPIED from [configuration] 2003-12-29\n        if (base == null) {\n            return null;\n        }\n\n        // on the first call initialize priorVariables\n        // and add base as the first element\n        if (priorVariables == null) {\n            priorVariables = new ArrayList();\n            priorVariables.add(base);\n        }\n\n        int begin = -1;\n        int end = -1;\n        int prec = 0 - END_TOKEN.length();\n        String variable = null;\n        StringBuffer result = new StringBuffer();\n\n        // FIXME: we should probably allow the escaping of the start token\n        while (((begin = base.indexOf(START_TOKEN, prec + END_TOKEN.length())) > -1)\n            && ((end = base.indexOf(END_TOKEN, begin)) > -1)) {\n            result.append(base.substring(prec + END_TOKEN.length(), begin));\n            variable = base.substring(begin + START_TOKEN.length(), end);\n\n            // if we've got a loop, create a useful exception message and throw\n            if (priorVariables.contains(variable)) {\n                String initialBase = priorVariables.remove(0).toString();\n                priorVariables.add(variable);\n                StringBuffer priorVariableSb = new StringBuffer();\n\n                // create a nice trace of interpolated variables like so:\n                // var1->var2->var3\n                for (Iterator it = priorVariables.iterator(); it.hasNext();) {\n                    priorVariableSb.append(it.next());\n                    if (it.hasNext()) {\n                        priorVariableSb.append(\"->\");\n                    }\n                }\n\n                throw new IllegalStateException(\n                    \"infinite loop in property interpolation of \" + initialBase + \": \" + priorVariableSb.toString());\n            }\n            // otherwise, add this variable to the interpolation list.\n            else {\n                priorVariables.add(variable);\n            }\n\n            //QUESTION: getProperty or getPropertyDirect\n            Object value = getProperty(variable);\n            if (value != null) {\n                result.append(interpolateHelper(value.toString(), priorVariables));\n\n                // pop the interpolated variable off the stack\n                // this maintains priorVariables correctness for\n                // properties with multiple interpolations, e.g.\n                // prop.name=${some.other.prop1}/blahblah/${some.other.prop2}\n                priorVariables.remove(priorVariables.size() - 1);\n            } else if (defaults != null && defaults.getString(variable, null) != null) {\n                result.append(defaults.getString(variable));\n            } else {\n                //variable not defined - so put it back in the value\n                result.append(START_TOKEN).append(variable).append(END_TOKEN);\n            }\n            prec = end;\n        }\n        result.append(base.substring(prec + END_TOKEN.length(), base.length()));\n\n        return result.toString();\n    }\n    \n    /**\n     * Inserts a backslash before every comma and backslash. \n     */\n    private static String escape(String s) {\n        StringBuffer buf = new StringBuffer(s);\n        for (int i = 0; i < buf.length(); i++) {\n            char c = buf.charAt(i);\n            if (c == ',' || c == '\\\\') {\n                buf.insert(i, '\\\\');\n                i++;\n            }\n        }\n        return buf.toString();\n    }\n    \n    /**\n     * Removes a backslash from every pair of backslashes. \n     */\n    private static String unescape(String s) {\n        StringBuffer buf = new StringBuffer(s);\n        for (int i = 0; i < buf.length() - 1; i++) {\n            char c1 = buf.charAt(i);\n            char c2 = buf.charAt(i + 1);\n            if (c1 == '\\\\' && c2 == '\\\\') {\n                buf.deleteCharAt(i);\n            }\n        }\n        return buf.toString();\n    }\n\n    /**\n     * Counts the number of successive times 'ch' appears in the\n     * 'line' before the position indicated by the 'index'.\n     */\n    private static int countPreceding(String line, int index, char ch) {\n        int i;\n        for (i = index - 1; i >= 0; i--) {\n            if (line.charAt(i) != ch) {\n                break;\n            }\n        }\n        return index - 1 - i;\n    }\n\n    /**\n     * Checks if the line ends with odd number of backslashes \n     */\n    private static boolean endsWithSlash(String line) {\n        if (!line.endsWith(\"\\\\\")) {\n            return false;\n        }\n        return (countPreceding(line, line.length() - 1, '\\\\') % 2 == 0);\n    }\n\n    /**\n     * This class is used to read properties lines.  These lines do\n     * not terminate with new-line chars but rather when there is no\n     * backslash sign a the end of the line.  This is used to\n     * concatenate multiple lines for readability.\n     */\n    static class PropertiesReader extends LineNumberReader {\n        /**\n         * Constructor.\n         *\n         * @param reader A Reader.\n         */\n        public PropertiesReader(Reader reader) {\n            super(reader);\n        }\n\n        /**\n         * Read a property.\n         *\n         * @return a String property\n         * @throws IOException if there is difficulty reading the source.\n         */\n        public String readProperty() throws IOException {\n            StringBuffer buffer = new StringBuffer();\n            String line = readLine();\n            while (line != null) {\n                line = line.trim();\n                if ((line.length() != 0) && (line.charAt(0) != '#')) {\n                    if (endsWithSlash(line)) {\n                        line = line.substring(0, line.length() - 1);\n                        buffer.append(line);\n                    } else {\n                        buffer.append(line);\n                        return buffer.toString();  // normal method end\n                    }\n                }\n                line = readLine();\n            }\n            return null;  // EOF reached\n        }\n    }\n\n    /**\n     * This class divides into tokens a property value.  Token\n     * separator is \",\" but commas into the property value are escaped\n     * using the backslash in front.\n     */\n    static class PropertiesTokenizer extends StringTokenizer {\n        /**\n         * The property delimiter used while parsing (a comma).\n         */\n        static final String DELIMITER = \",\";\n\n        /**\n         * Constructor.\n         *\n         * @param string A String.\n         */\n        public PropertiesTokenizer(String string) {\n            super(string, DELIMITER);\n        }\n\n        /**\n         * Check whether the object has more tokens.\n         *\n         * @return True if the object has more tokens.\n         */\n        public boolean hasMoreTokens() {\n            return super.hasMoreTokens();\n        }\n\n        /**\n         * Get next token.\n         *\n         * @return A String.\n         */\n        public String nextToken() {\n            StringBuffer buffer = new StringBuffer();\n\n            while (hasMoreTokens()) {\n                String token = super.nextToken();\n                if (endsWithSlash(token)) {\n                    buffer.append(token.substring(0, token.length() - 1));\n                    buffer.append(DELIMITER);\n                } else {\n                    buffer.append(token);\n                    break;\n                }\n            }\n\n            return buffer.toString().trim();\n        }\n    }\n\n    /**\n     * Creates an empty extended properties object.\n     */\n    public ExtendedProperties() {\n        super();\n    }\n\n    /**\n     * Creates and loads the extended properties from the specified file.\n     *\n     * @param file  the filename to load\n     * @throws IOException if a file error occurs\n     */\n    public ExtendedProperties(String file) throws IOException {\n        this(file, null);\n    }\n\n    /**\n     * Creates and loads the extended properties from the specified file.\n     *\n     * @param file  the filename to load\n     * @param defaultFile  a second filename to load default values from\n     * @throws IOException if a file error occurs\n     */\n    public ExtendedProperties(String file, String defaultFile) throws IOException {\n        this.file = file;\n\n        basePath = new File(file).getAbsolutePath();\n        basePath = basePath.substring(0, basePath.lastIndexOf(fileSeparator) + 1);\n\n        FileInputStream in = null;\n        try {\n            in = new FileInputStream(file);\n            this.load(in);\n        } finally {\n            try {\n                if (in != null) {\n                    in.close();\n                }\n            } catch (IOException ex) {}\n        }\n\n        if (defaultFile != null) {\n            defaults = new ExtendedProperties(defaultFile);\n        }\n    }\n\n    /**\n     * Indicate to client code whether property\n     * resources have been initialized or not.\n     */\n    public boolean isInitialized() {\n        return isInitialized;\n    }\n\n    /**\n     * Gets the property value for including other properties files.\n     * By default it is \"include\".\n     * <p>\n     * NOTE: Prior to v3.3 this method accessed a static variable.\n     * It now accesses an instance variable. For compatability, if the\n     * instance variable has not been set then the previous static\n     * variable is then accessed. However, the protected static variable\n     * can now only be set by subclasses.\n     * In v4.0, the static variable will be removed.\n     *\n     * @return the property name which includes another property\n     */\n    public String getInclude() {\n        if (includePropertyName == null) {\n            return include;  // backwards compatability\n        }\n        if (\"\".equals(includePropertyName)) {\n            return null;  // hack to allow backwards compatability\n        }\n        return includePropertyName;\n    }\n\n    /**\n     * Sets the property value for including other properties files.\n     * By default it is \"include\".\n     * <p>\n     * NOTE: Prior to v3.3 this method set a static variable and affected all\n     * users of the class. It now sets an instance variable.\n     * An empty string is also now converted to null internally.\n     * In v4.0, the static variable will be removed.\n     *\n     * @param inc  the property name which includes another property, empty converted to null\n     */\n    public void setInclude(String inc) {\n        if (inc == null) {\n            inc = \"\";  // hack to allow backwards compatability\n        }\n        includePropertyName = inc;\n    }\n\n    /**\n     * Load the properties from the given input stream.\n     *\n     * @param input  the InputStream to load from\n     * @throws IOException if an IO error occurs\n     */\n    public void load(InputStream input) throws IOException {\n        load(input, null);\n    }\n\n    /**\n     * Load the properties from the given input stream\n     * and using the specified encoding.\n     *\n     * @param input  the InputStream to load from\n     * @param enc  the encoding to use\n     * @throws IOException if an IO error occurs\n     */\n    public synchronized void load(InputStream input, String enc) throws IOException {\n        PropertiesReader reader = null;\n        if (enc != null) {\n            try {\n                reader = new PropertiesReader(new InputStreamReader(input, enc));\n                \n            } catch (UnsupportedEncodingException ex) {\n                // Another try coming up....\n            }\n        }\n        \n        if (reader == null) {\n            try {\n                reader = new PropertiesReader(new InputStreamReader(input, \"8859_1\"));\n                \n            } catch (UnsupportedEncodingException ex) {\n                // ISO8859-1 support is required on java platforms but....\n                // If it's not supported, use the system default encoding\n                reader = new PropertiesReader(new InputStreamReader(input));\n            }\n        }\n\n        try {\n            String includeProperty = getInclude();\n            while (true) {\n                String line = reader.readProperty();\n                if (line == null) {\n                    return;  // EOF\n                }\n                int equalSign = line.indexOf('=');\n\n                if (equalSign > 0) {\n                    String key = line.substring(0, equalSign).trim();\n                    String value = line.substring(equalSign + 1).trim();\n\n                    /* COLLECTIONS-238 allows empty properties to exist by commenting this out\n                    // Configure produces lines like this ... just ignore them\n                    if (\"\".equals(value)) {\n                        continue;\n                    }\n                    */\n\n                    if (includeProperty != null && key.equalsIgnoreCase(includeProperty)) {\n                        // Recursively load properties files.\n                        File file = null;\n\n                        if (value.startsWith(fileSeparator)) {\n                            // We have an absolute path so we'll use this\n                            file = new File(value);\n                            \n                        } else {\n                            // We have a relative path, and we have two \n                            // possible forms here. If we have the \"./\" form\n                            // then just strip that off first before continuing.\n                            if (value.startsWith(\".\" + fileSeparator)) {\n                                value = value.substring(2);\n                            }\n\n                            file = new File(basePath + value);\n                        }\n\n                        if (file != null && file.exists() && file.canRead()) {\n                            load(new FileInputStream(file));\n                        }\n                    } else {\n                        addProperty(key, value);\n                    }\n                }\n            }\n        } finally {\n            // Loading is initializing\n            isInitialized = true;\n        }\n    }\n\n    /**\n     * Gets a property from the configuration.\n     *\n     * @param key property to retrieve\n     * @return value as object. Will return user value if exists,\n     *        if not then default value if exists, otherwise null\n     */\n    public Object getProperty(String key) {\n        // first, try to get from the 'user value' store\n        Object obj = super.get(key);\n\n        if (obj == null) {\n            // if there isn't a value there, get it from the\n            // defaults if we have them\n            if (defaults != null) {\n                obj = defaults.get(key);\n            }\n        }\n\n        return obj;\n    }\n    \n    /**\n     * Add a property to the configuration. If it already\n     * exists then the value stated here will be added\n     * to the configuration entry. For example, if\n     *\n     * <code>resource.loader = file</code>\n     *\n     * is already present in the configuration and you\n     *\n     * <code>addProperty(\"resource.loader\", \"classpath\")</code>\n     *\n     * Then you will end up with a Vector like the\n     * following:\n     *\n     * <code>[\"file\", \"classpath\"]</code>\n     *\n     * @param key  the key to add\n     * @param value  the value to add\n     */\n    public void addProperty(String key, Object value) {\n        if (value instanceof String) {\n            String str = (String) value;\n            if (str.indexOf(PropertiesTokenizer.DELIMITER) > 0) {\n                // token contains commas, so must be split apart then added\n                PropertiesTokenizer tokenizer = new PropertiesTokenizer(str);\n                while (tokenizer.hasMoreTokens()) {\n                    String token = tokenizer.nextToken();\n                    addPropertyInternal(key, unescape(token));\n                }\n            } else {\n                // token contains no commas, so can be simply added\n                addPropertyInternal(key, unescape(str));\n            }\n        } else {\n            addPropertyInternal(key, value);\n        }\n\n        // Adding a property connotes initialization\n        isInitialized = true;\n    }\n\n    /**\n     * Adds a key/value pair to the map.  This routine does\n     * no magic morphing.  It ensures the keylist is maintained\n     *\n     * @param key  the key to store at\n     * @param value  the decoded object to store\n     */\n    private void addPropertyDirect(String key, Object value) {\n        // safety check\n        if (!containsKey(key)) {\n            keysAsListed.add(key);\n        }\n        super.put(key, value);\n    }\n\n    /**\n     * Adds a decoded property to the map w/o checking for commas - used\n     * internally when a property has been broken up into\n     * strings that could contain escaped commas to prevent\n     * the inadvertent vectorization.\n     * <p>\n     * Thanks to Leon Messerschmidt for this one.\n     *\n     * @param key  the key to store at\n     * @param value  the decoded object to store\n     */\n    private void addPropertyInternal(String key, Object value) {\n        Object current = this.get(key);\n\n        if (current instanceof String) {\n            // one object already in map - convert it to a vector\n            List values = new Vector(2);\n            values.add(current);\n            values.add(value);\n            super.put(key, values);\n            \n        } else if (current instanceof List) {\n            // already a list - just add the new token\n            ((List) current).add(value);\n            \n        } else {\n            // brand new key - store in keysAsListed to retain order\n            if (!containsKey(key)) {\n                keysAsListed.add(key);\n            }\n            super.put(key, value);\n        }\n    }\n\n    /**\n     * Set a property, this will replace any previously\n     * set values. Set values is implicitly a call\n     * to clearProperty(key), addProperty(key,value).\n     *\n     * @param key  the key to set\n     * @param value  the value to set\n     */\n    public void setProperty(String key, Object value) {\n        clearProperty(key);\n        addProperty(key, value);\n    }\n    \n    /**\n     * Save the properties to the given output stream.\n     * <p>\n     * The stream is not closed, but it is flushed.\n     *\n     * @param output  an OutputStream, may be null\n     * @param header  a textual comment to act as a file header\n     * @throws IOException if an IO error occurs\n     */\n    public synchronized void save(OutputStream output, String header) throws IOException {\n        if (output == null) {\n            return;\n        }\n        PrintWriter theWrtr = new PrintWriter(output);\n        if (header != null) {\n            theWrtr.println(header);\n        }\n        \n        Enumeration theKeys = keys();\n        while (theKeys.hasMoreElements()) {\n            String key = (String) theKeys.nextElement();\n            Object value = get(key);\n            if (value != null) {\n                if (value instanceof String) {\n                    StringBuffer currentOutput = new StringBuffer();\n                    currentOutput.append(key);\n                    currentOutput.append(\"=\");\n                    currentOutput.append(escape((String) value));\n                    theWrtr.println(currentOutput.toString());\n                    \n                } else if (value instanceof List) {\n                    List values = (List) value;\n                    for (Iterator it = values.iterator(); it.hasNext(); ) {\n                        String currentElement = (String) it.next();\n                        StringBuffer currentOutput = new StringBuffer();\n                        currentOutput.append(key);\n                        currentOutput.append(\"=\");\n                        currentOutput.append(escape(currentElement));\n                        theWrtr.println(currentOutput.toString());\n                    }\n                }\n            }\n            theWrtr.println();\n            theWrtr.flush();\n        }\n    }\n\n    /**\n     * Combines an existing Hashtable with this Hashtable.\n     * <p>\n     * Warning: It will overwrite previous entries without warning.\n     *\n     * @param props  the properties to combine\n     */\n    public void combine(ExtendedProperties props) {\n        for (Iterator it = props.getKeys(); it.hasNext();) {\n            String key = (String) it.next();\n            clearProperty(key);\n            addPropertyDirect(key, props.get(key));\n        }\n    }\n    \n    /**\n     * Clear a property in the configuration.\n     *\n     * @param key  the property key to remove along with corresponding value\n     */\n    public void clearProperty(String key) {\n        if (containsKey(key)) {\n            // we also need to rebuild the keysAsListed or else\n            // things get *very* confusing\n            for (int i = 0; i < keysAsListed.size(); i++) {\n                if (( keysAsListed.get(i)).equals(key)) {\n                    keysAsListed.remove(i);\n                    break;\n                }\n            }\n            super.remove(key);\n        }\n    }\n\n    /**\n     * Get the list of the keys contained in the configuration\n     * repository.\n     *\n     * @return an Iterator over the keys\n     */\n    public Iterator getKeys() {\n        return keysAsListed.iterator();\n    }\n\n    /**\n     * Get the list of the keys contained in the configuration\n     * repository that match the specified prefix.\n     *\n     * @param prefix  the prefix to match\n     * @return an Iterator of keys that match the prefix\n     */\n    public Iterator getKeys(String prefix) {\n        Iterator keys = getKeys();\n        ArrayList matchingKeys = new ArrayList();\n\n        while (keys.hasNext()) {\n            Object key = keys.next();\n\n            if (key instanceof String && ((String) key).startsWith(prefix)) {\n                matchingKeys.add(key);\n            }\n        }\n        return matchingKeys.iterator();\n    }\n\n    /**\n     * Create an ExtendedProperties object that is a subset\n     * of this one. Take into account duplicate keys\n     * by using the setProperty() in ExtendedProperties.\n     *\n     * @param prefix  the prefix to get a subset for\n     * @return a new independent ExtendedProperties\n     */\n    public ExtendedProperties subset(String prefix) {\n        ExtendedProperties c = new ExtendedProperties();\n        Iterator keys = getKeys();\n        boolean validSubset = false;\n\n        while (keys.hasNext()) {\n            Object key = keys.next();\n\n            if (key instanceof String && ((String) key).startsWith(prefix)) {\n                if (!validSubset) {\n                    validSubset = true;\n                }\n\n                /*\n                 * Check to make sure that c.subset(prefix) doesn't\n                 * blow up when there is only a single property\n                 * with the key prefix. This is not a useful\n                 * subset but it is a valid subset.\n                 */\n                String newKey = null;\n                if (((String) key).length() == prefix.length()) {\n                    newKey = prefix;\n                } else {\n                    newKey = ((String) key).substring(prefix.length() + 1);\n                }\n\n                /*\n                 *  use addPropertyDirect() - this will plug the data as \n                 *  is into the Map, but will also do the right thing\n                 *  re key accounting\n                 */\n                c.addPropertyDirect(newKey, get(key));\n            }\n        }\n\n        if (validSubset) {\n            return c;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Display the configuration for debugging purposes to System.out.\n     */\n    public void display() {\n        Iterator i = getKeys();\n\n        while (i.hasNext()) {\n            String key = (String) i.next();\n            Object value = get(key);\n            System.out.println(key + \" => \" + value);\n        }\n    }\n\n    /**\n     * Get a string associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated string.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a String.\n     */\n    public String getString(String key) {\n        return getString(key, null);\n    }\n\n    /**\n     * Get a string associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated string if key is found,\n     * default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a String.\n     */\n    public String getString(String key, String defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof String) {\n            return interpolate((String) value);\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return interpolate(defaults.getString(key, defaultValue));\n            } else {\n                return interpolate(defaultValue);\n            }\n        } else if (value instanceof List) {\n            return interpolate((String) ((List) value).get(0));\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a String object\");\n        }\n    }\n\n    /**\n     * Get a list of properties associated with the given\n     * configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated properties if key is found.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a String/List.\n     * @throws IllegalArgumentException if one of the tokens is\n     * malformed (does not contain an equals sign).\n     */\n    public Properties getProperties(String key) {\n        return getProperties(key, new Properties());\n    }\n\n    /**\n     * Get a list of properties associated with the given\n     * configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated properties if key is found.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a String/List.\n     * @throws IllegalArgumentException if one of the tokens is\n     * malformed (does not contain an equals sign).\n     */\n    public Properties getProperties(String key, Properties defaults) {\n        /*\n         * Grab an array of the tokens for this key.\n         */\n        String[] tokens = getStringArray(key);\n\n        // Each token is of the form 'key=value'.\n        Properties props = new Properties(defaults);\n        for (int i = 0; i < tokens.length; i++) {\n            String token = tokens[i];\n            int equalSign = token.indexOf('=');\n            if (equalSign > 0) {\n                String pkey = token.substring(0, equalSign).trim();\n                String pvalue = token.substring(equalSign + 1).trim();\n                props.put(pkey, pvalue);\n            } else {\n                throw new IllegalArgumentException('\\'' + token + \"' does not contain \" + \"an equals sign\");\n            }\n        }\n        return props;\n    }\n\n    /**\n     * Get an array of strings associated with the given configuration\n     * key.\n     *\n     * @param key The configuration key.\n     * @return The associated string array if key is found.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a String/List.\n     */\n    public String[] getStringArray(String key) {\n        Object value = get(key);\n\n        List values;\n        if (value instanceof String) {\n            values = new Vector(1);\n            values.add(value);\n            \n        } else if (value instanceof List) {\n            values = (List) value;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getStringArray(key);\n            } else {\n                return new String[0];\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a String/List object\");\n        }\n\n        String[] tokens = new String[values.size()];\n        for (int i = 0; i < tokens.length; i++) {\n            tokens[i] = (String) values.get(i);\n        }\n\n        return tokens;\n    }\n\n    /**\n     * Get a Vector of strings associated with the given configuration\n     * key.\n     *\n     * @param key The configuration key.\n     * @return The associated Vector.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Vector.\n     */\n    public Vector getVector(String key) {\n        return getVector(key, null);\n    }\n\n    /**\n     * Get a Vector of strings associated with the given configuration key.\n     * <p>\n     * The list is a copy of the internal data of this object, and as\n     * such you may alter it freely.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated Vector.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Vector.\n     */\n    public Vector getVector(String key, Vector defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof List) {\n            return new Vector((List) value);\n            \n        } else if (value instanceof String) {\n            Vector values = new Vector(1);\n            values.add(value);\n            super.put(key, values);\n            return values;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getVector(key, defaultValue);\n            } else {\n                return ((defaultValue == null) ? new Vector() : defaultValue);\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Vector object\");\n        }\n    }\n\n    /**\n     * Get a List of strings associated with the given configuration key.\n     * <p>\n     * The list is a copy of the internal data of this object, and as\n     * such you may alter it freely.\n     *\n     * @param key The configuration key.\n     * @return The associated List object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a List.\n     * @since Commons Collections 3.2\n     */\n    public List getList(String key) {\n        return getList(key, null);\n    }\n\n    /**\n     * Get a List of strings associated with the given configuration key.\n     * <p>\n     * The list is a copy of the internal data of this object, and as\n     * such you may alter it freely.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated List.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a List.\n     * @since Commons Collections 3.2\n     */\n    public List getList(String key, List defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof List) {\n            return new ArrayList((List) value);\n            \n        } else if (value instanceof String) {\n            List values = new ArrayList(1);\n            values.add(value);\n            super.put(key, values);\n            return values;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getList(key, defaultValue);\n            } else {\n                return ((defaultValue == null) ? new ArrayList() : defaultValue);\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a List object\");\n        }\n    }\n\n    /**\n     * Get a boolean associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated boolean.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Boolean.\n     */\n    public boolean getBoolean(String key) {\n        Boolean b = getBoolean(key, null);\n        if (b != null) {\n            return b.booleanValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a boolean associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated boolean.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Boolean.\n     */\n    public boolean getBoolean(String key, boolean defaultValue) {\n        return getBoolean(key, new Boolean(defaultValue)).booleanValue();\n    }\n\n    /**\n     * Get a boolean associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated boolean if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Boolean.\n     */\n    public Boolean getBoolean(String key, Boolean defaultValue) {\n\n        Object value = get(key);\n\n        if (value instanceof Boolean) {\n            return (Boolean) value;\n            \n        } else if (value instanceof String) {\n            String s = testBoolean((String) value);\n            Boolean b = new Boolean(s);\n            super.put(key, b);\n            return b;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getBoolean(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Boolean object\");\n        }\n    }\n\n    /**\n     * Test whether the string represent by value maps to a boolean\n     * value or not. We will allow <code>true</code>, <code>on</code>,\n     * and <code>yes</code> for a <code>true</code> boolean value, and\n     * <code>false</code>, <code>off</code>, and <code>no</code> for\n     * <code>false</code> boolean values.  Case of value to test for\n     * boolean status is ignored.\n     *\n     * @param value  the value to test for boolean state\n     * @return <code>true</code> or <code>false</code> if the supplied\n     * text maps to a boolean value, or <code>null</code> otherwise.\n     */\n    public String testBoolean(String value) {\n        String s = value.toLowerCase(Locale.ENGLISH);\n\n        if (s.equals(\"true\") || s.equals(\"on\") || s.equals(\"yes\")) {\n            return \"true\";\n        } else if (s.equals(\"false\") || s.equals(\"off\") || s.equals(\"no\")) {\n            return \"false\";\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Get a byte associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated byte.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Byte.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public byte getByte(String key) {\n        Byte b = getByte(key, null);\n        if (b != null) {\n            return b.byteValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \" doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a byte associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated byte.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Byte.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public byte getByte(String key, byte defaultValue) {\n        return getByte(key, new Byte(defaultValue)).byteValue();\n    }\n\n    /**\n     * Get a byte associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated byte if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Byte.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public Byte getByte(String key, Byte defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Byte) {\n            return (Byte) value;\n            \n        } else if (value instanceof String) {\n            Byte b = new Byte((String) value);\n            super.put(key, b);\n            return b;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getByte(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Byte object\");\n        }\n    }\n\n    /**\n     * Get a short associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated short.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Short.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public short getShort(String key) {\n        Short s = getShort(key, null);\n        if (s != null) {\n            return s.shortValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a short associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated short.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Short.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public short getShort(String key, short defaultValue) {\n        return getShort(key, new Short(defaultValue)).shortValue();\n    }\n\n    /**\n     * Get a short associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated short if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Short.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public Short getShort(String key, Short defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Short) {\n            return (Short) value;\n            \n        } else if (value instanceof String) {\n            Short s = new Short((String) value);\n            super.put(key, s);\n            return s;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getShort(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Short object\");\n        }\n    }\n\n    /**\n     * The purpose of this method is to get the configuration resource\n     * with the given name as an integer.\n     *\n     * @param name The resource name.\n     * @return The value of the resource as an integer.\n     */\n    public int getInt(String name) {\n        return getInteger(name);\n    }\n\n    /**\n     * The purpose of this method is to get the configuration resource\n     * with the given name as an integer, or a default value.\n     *\n     * @param name The resource name\n     * @param def The default value of the resource.\n     * @return The value of the resource as an integer.\n     */\n    public int getInt(String name, int def) {\n        return getInteger(name, def);\n    }\n\n    /**\n     * Get a int associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated int.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Integer.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public int getInteger(String key) {\n        Integer i = getInteger(key, null);\n        if (i != null) {\n            return i.intValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a int associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated int.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Integer.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public int getInteger(String key, int defaultValue) {\n        Integer i = getInteger(key, null);\n\n        if (i == null) {\n            return defaultValue;\n        }\n        return i.intValue();\n    }\n\n    /**\n     * Get a int associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated int if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Integer.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public Integer getInteger(String key, Integer defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Integer) {\n            return (Integer) value;\n            \n        } else if (value instanceof String) {\n            Integer i = new Integer((String) value);\n            super.put(key, i);\n            return i;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getInteger(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Integer object\");\n        }\n    }\n\n    /**\n     * Get a long associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated long.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Long.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public long getLong(String key) {\n        Long l = getLong(key, null);\n        if (l != null) {\n            return l.longValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a long associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated long.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Long.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public long getLong(String key, long defaultValue) {\n        return getLong(key, new Long(defaultValue)).longValue();\n    }\n\n    /**\n     * Get a long associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated long if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Long.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public Long getLong(String key, Long defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Long) {\n            return (Long) value;\n            \n        } else if (value instanceof String) {\n            Long l = new Long((String) value);\n            super.put(key, l);\n            return l;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getLong(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Long object\");\n        }\n    }\n\n    /**\n     * Get a float associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated float.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Float.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public float getFloat(String key) {\n        Float f = getFloat(key, null);\n        if (f != null) {\n            return f.floatValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a float associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated float.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Float.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public float getFloat(String key, float defaultValue) {\n        return getFloat(key, new Float(defaultValue)).floatValue();\n    }\n\n    /**\n     * Get a float associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated float if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Float.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public Float getFloat(String key, Float defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Float) {\n            return (Float) value;\n            \n        } else if (value instanceof String) {\n            Float f = new Float((String) value);\n            super.put(key, f);\n            return f;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getFloat(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Float object\");\n        }\n    }\n\n    /**\n     * Get a double associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated double.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Double.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public double getDouble(String key) {\n        Double d = getDouble(key, null);\n        if (d != null) {\n            return d.doubleValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a double associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated double.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Double.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public double getDouble(String key, double defaultValue) {\n        return getDouble(key, new Double(defaultValue)).doubleValue();\n    }\n\n    /**\n     * Get a double associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated double if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Double.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public Double getDouble(String key, Double defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Double) {\n            return (Double) value;\n            \n        } else if (value instanceof String) {\n            Double d = new Double((String) value);\n            super.put(key, d);\n            return d;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getDouble(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Double object\");\n        }\n    }\n\n    /**\n     * Convert a standard properties class into a configuration class.\n     * <p>\n     * NOTE: From Commons Collections 3.2 this method will pick up\n     * any default parent Properties of the specified input object.\n     *\n     * @param props  the properties object to convert\n     * @return new ExtendedProperties created from props\n     */\n    public static ExtendedProperties convertProperties(Properties props) {\n        ExtendedProperties c = new ExtendedProperties();\n\n        for (Enumeration e = props.propertyNames(); e.hasMoreElements();) {\n            String s = (String) e.nextElement();\n            c.setProperty(s, props.getProperty(s));\n        }\n\n        return c;\n    }\n\n    /**\n     * Add a new property specified by the key to the \n     * ExtendedProperties.\n     *\n     * @param key specifying the property\n     * @param value for the property\n     * @return old value of the property\n     */\n    public Object put(Object key, Object value) {\n        String strKey = String.valueOf(key);\n        Object ret = getProperty(strKey);\n        addProperty(strKey, value);\n        return ret;\n    }\n\n    /**\n     * Add a map full of key/value pairs to the ExtendedProperties. \n     * If the added map is an ExtendedProperties class, then the \n     * order of the added properties is maintained. \n     *\n     * @param map full of key/value pair data\n     */\n    public void putAll(Map map) {\n        if (map instanceof ExtendedProperties) {\n            for (Iterator it = ((ExtendedProperties) map).getKeys(); it.hasNext(); ) {\n                Object key = it.next();\n                put(key, map.get(key));\n            }\n        } else {\n            for (Iterator it = map.entrySet().iterator(); it.hasNext(); ) {\n                Map.Entry entry = (Map.Entry) it.next();\n                put(entry.getKey(), entry.getValue());\n            }\n        }\n    }\n\n\n    /**\n     * Remove the property specified by the key from the \n     * ExtendedProperties.\n     *\n     * @param key specifying the property\n     * @return old value of the property\n     */\n    public Object remove(Object key) {\n        String strKey = String.valueOf(key);\n        Object ret = getProperty(strKey);\n        clearProperty(strKey);\n        return ret;\n    }\n\n}\n"}]}
{"project": "Collections", "bug_id": 13, "classes_modified": [{"class_name": "org.apache.commons.collections.ExtendedProperties", "buggy_version": "/*\n *  Licensed to the Apache Software Foundation (ASF) under one or more\n *  contributor license agreements.  See the NOTICE file distributed with\n *  this work for additional information regarding copyright ownership.\n *  The ASF licenses this file to You under the Apache License, Version 2.0\n *  (the \"License\"); you may not use this file except in compliance with\n *  the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.apache.commons.collections;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.LineNumberReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.UnsupportedEncodingException;\nimport java.util.ArrayList;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Properties;\nimport java.util.StringTokenizer;\nimport java.util.Vector;\n\n/**\n * This class extends normal Java properties by adding the possibility\n * to use the same key many times concatenating the value strings\n * instead of overwriting them.\n * <p>\n * <b>Please consider using the\n * {@link org.apache.commons.configuration.PropertiesConfiguration} class in\n * <a href=\"http://commons.apache.org/configuration\">Commons Configuration</a>.\n * It's an evolution of <code>ExtendedProperties</code> supporting more\n * features like automatic reloading, advanced interpolation, more type\n * conversions, changes notifications and file layout preservation.</b>\n * <p>\n * The Extended Properties syntax is explained here:\n *\n * <ul>\n *  <li>\n *   Each property has the syntax <code>key = value</code>\n *  </li>\n *  <li>\n *   The <i>key</i> may use any character but the equal sign '='.\n *  </li>\n *  <li>\n *   <i>value</i> may be separated on different lines if a backslash\n *   is placed at the end of the line that continues below.\n *  </li>\n *  <li>\n *   If <i>value</i> is a list of strings, each token is separated\n *   by a comma ','.\n *  </li>\n *  <li>\n *   Commas in each token are escaped placing a backslash right before\n *   the comma.\n *  </li>\n *  <li>\n *   Backslashes are escaped by using two consecutive backslashes i.e. \\\\\n *  </li>\n *  <li>\n *   If a <i>key</i> is used more than once, the values are appended\n *   as if they were on the same line separated with commas.\n *  </li>\n *  <li>\n *   Blank lines and lines starting with character '#' are skipped.\n *  </li>\n *  <li>\n *   If a property is named \"include\" (or whatever is defined by\n *   setInclude() and getInclude() and the value of that property is\n *   the full path to a file on disk, that file will be included into\n *   the ConfigurationsRepository. You can also pull in files relative\n *   to the parent configuration file. So if you have something\n *   like the following:\n *\n *   include = additional.properties\n *\n *   Then \"additional.properties\" is expected to be in the same\n *   directory as the parent configuration file.\n * \n *   Duplicate name values will be replaced, so be careful.\n *\n *  </li>\n * </ul>\n *\n * <p>Here is an example of a valid extended properties file:\n *\n * <p><pre>\n *      # lines starting with # are comments\n *\n *      # This is the simplest property\n *      key = value\n *\n *      # A long property may be separated on multiple lines\n *      longvalue = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa \\\n *                  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n *\n *      # This is a property with many tokens\n *      tokens_on_a_line = first token, second token\n *\n *      # This sequence generates exactly the same result\n *      tokens_on_multiple_lines = first token\n *      tokens_on_multiple_lines = second token\n *\n *      # commas may be escaped in tokens\n *      commas.escaped = Hi\\, what'up?\n * </pre>\n *\n * <p><b>NOTE</b>: this class has <b>not</b> been written for\n * performance nor low memory usage.  In fact, it's way slower than it\n * could be and generates too much memory garbage.  But since\n * performance is not an issue during intialization (and there is not\n * much time to improve it), I wrote it this way.  If you don't like\n * it, go ahead and tune it up!\n *\n * @since Commons Collections 1.0\n * @version $Revision$ $Date$\n * \n * @author <a href=\"mailto:stefano@apache.org\">Stefano Mazzocchi</a>\n * @author <a href=\"mailto:jon@latchkey.com\">Jon S. Stevens</a>\n * @author <a href=\"mailto:daveb@miceda-data\">Dave Bryson</a>\n * @author <a href=\"mailto:jvanzyl@periapt.com\">Jason van Zyl</a>\n * @author <a href=\"mailto:geirm@optonline.net\">Geir Magnusson Jr.</a>\n * @author <a href=\"mailto:leon@opticode.co.za\">Leon Messerschmidt</a>\n * @author <a href=\"mailto:kjohnson@transparent.com\">Kent Johnson</a>\n * @author <a href=\"mailto:dlr@finemaltcoding.com\">Daniel Rall</a>\n * @author <a href=\"mailto:ipriha@surfeu.fi\">Ilkka Priha</a>\n * @author Janek Bogucki\n * @author Mohan Kishore\n * @author Stephen Colebourne\n * @author Shinobu Kawai\n * @author <a href=\"mailto:hps@intermeta.de\">Henning P. Schmiedehausen</a>\n */\npublic class ExtendedProperties extends Hashtable {\n    \n    /**\n     * Default configurations repository.\n     */\n    private ExtendedProperties defaults;\n\n    /**\n     * The file connected to this repository (holding comments and\n     * such).\n     *\n     * @serial\n     */\n    protected String file;\n\n    /**\n     * Base path of the configuration file used to create\n     * this ExtendedProperties object.\n     */\n    protected String basePath;\n\n    /**\n     * File separator.\n     */\n    protected String fileSeparator = System.getProperty(\"file.separator\");\n\n    /**\n     * Has this configuration been intialized.\n     */\n    protected boolean isInitialized = false;\n\n    /**\n     * This is the name of the property that can point to other\n     * properties file for including other properties files.\n     */\n    private String includePropertyName = null;\n\n    /**\n     * This is the default name of the property that can point to other\n     * properties file for including other properties files.\n     * \n     * @deprecated Use getInclude() and setInclude() methods which operate\n     * on an instance variable from v3.3. Due to be removed in v4.0.\n     */\n    protected static String include = \"include\";\n\n    /**\n     * These are the keys in the order they listed\n     * in the configuration file. This is useful when\n     * you wish to perform operations with configuration\n     * information in a particular order.\n     */\n    protected ArrayList keysAsListed = new ArrayList();\n\n    protected final static String START_TOKEN=\"${\";\n    protected final static String END_TOKEN=\"}\";\n\n\n    /**\n     * Interpolate key names to handle ${key} stuff\n     *\n     * @param base string to interpolate\n     * @return returns the key name with the ${key} substituted\n     */\n    protected String interpolate(String base) {\n        // COPIED from [configuration] 2003-12-29\n        return (interpolateHelper(base, null));\n    }\n\n    /**\n     * Recursive handler for multiple levels of interpolation.\n     *\n     * When called the first time, priorVariables should be null.\n     *\n     * @param base string with the ${key} variables\n     * @param priorVariables serves two purposes: to allow checking for\n     * loops, and creating a meaningful exception message should a loop\n     * occur.  It's 0'th element will be set to the value of base from\n     * the first call.  All subsequent interpolated variables are added\n     * afterward.\n     *\n     * @return the string with the interpolation taken care of\n     */\n    protected String interpolateHelper(String base, List priorVariables) {\n        // COPIED from [configuration] 2003-12-29\n        if (base == null) {\n            return null;\n        }\n\n        // on the first call initialize priorVariables\n        // and add base as the first element\n        if (priorVariables == null) {\n            priorVariables = new ArrayList();\n            priorVariables.add(base);\n        }\n\n        int begin = -1;\n        int end = -1;\n        int prec = 0 - END_TOKEN.length();\n        String variable = null;\n        StringBuffer result = new StringBuffer();\n\n        // FIXME: we should probably allow the escaping of the start token\n        while (((begin = base.indexOf(START_TOKEN, prec + END_TOKEN.length())) > -1)\n            && ((end = base.indexOf(END_TOKEN, begin)) > -1)) {\n            result.append(base.substring(prec + END_TOKEN.length(), begin));\n            variable = base.substring(begin + START_TOKEN.length(), end);\n\n            // if we've got a loop, create a useful exception message and throw\n            if (priorVariables.contains(variable)) {\n                String initialBase = priorVariables.remove(0).toString();\n                priorVariables.add(variable);\n                StringBuffer priorVariableSb = new StringBuffer();\n\n                // create a nice trace of interpolated variables like so:\n                // var1->var2->var3\n                for (Iterator it = priorVariables.iterator(); it.hasNext();) {\n                    priorVariableSb.append(it.next());\n                    if (it.hasNext()) {\n                        priorVariableSb.append(\"->\");\n                    }\n                }\n\n                throw new IllegalStateException(\n                    \"infinite loop in property interpolation of \" + initialBase + \": \" + priorVariableSb.toString());\n            }\n            // otherwise, add this variable to the interpolation list.\n            else {\n                priorVariables.add(variable);\n            }\n\n            //QUESTION: getProperty or getPropertyDirect\n            Object value = getProperty(variable);\n            if (value != null) {\n                result.append(interpolateHelper(value.toString(), priorVariables));\n\n                // pop the interpolated variable off the stack\n                // this maintains priorVariables correctness for\n                // properties with multiple interpolations, e.g.\n                // prop.name=${some.other.prop1}/blahblah/${some.other.prop2}\n                priorVariables.remove(priorVariables.size() - 1);\n            } else if (defaults != null && defaults.getString(variable, null) != null) {\n                result.append(defaults.getString(variable));\n            } else {\n                //variable not defined - so put it back in the value\n                result.append(START_TOKEN).append(variable).append(END_TOKEN);\n            }\n            prec = end;\n        }\n        result.append(base.substring(prec + END_TOKEN.length(), base.length()));\n\n        return result.toString();\n    }\n    \n    /**\n     * Inserts a backslash before every comma and backslash. \n     */\n    private static String escape(String s) {\n        StringBuffer buf = new StringBuffer(s);\n        for (int i = 0; i < buf.length(); i++) {\n            char c = buf.charAt(i);\n            if (c == ',' || c == '\\\\') {\n                buf.insert(i, '\\\\');\n                i++;\n            }\n        }\n        return buf.toString();\n    }\n    \n    /**\n     * Removes a backslash from every pair of backslashes. \n     */\n    private static String unescape(String s) {\n        StringBuffer buf = new StringBuffer(s);\n        for (int i = 0; i < buf.length() - 1; i++) {\n            char c1 = buf.charAt(i);\n            char c2 = buf.charAt(i + 1);\n            if (c1 == '\\\\' && c2 == '\\\\') {\n                buf.deleteCharAt(i);\n            }\n        }\n        return buf.toString();\n    }\n\n    /**\n     * Counts the number of successive times 'ch' appears in the\n     * 'line' before the position indicated by the 'index'.\n     */\n    private static int countPreceding(String line, int index, char ch) {\n        int i;\n        for (i = index - 1; i >= 0; i--) {\n            if (line.charAt(i) != ch) {\n                break;\n            }\n        }\n        return index - 1 - i;\n    }\n\n    /**\n     * Checks if the line ends with odd number of backslashes \n     */\n    private static boolean endsWithSlash(String line) {\n        if (!line.endsWith(\"\\\\\")) {\n            return false;\n        }\n        return (countPreceding(line, line.length() - 1, '\\\\') % 2 == 0);\n    }\n\n    /**\n     * This class is used to read properties lines.  These lines do\n     * not terminate with new-line chars but rather when there is no\n     * backslash sign a the end of the line.  This is used to\n     * concatenate multiple lines for readability.\n     */\n    static class PropertiesReader extends LineNumberReader {\n        /**\n         * Constructor.\n         *\n         * @param reader A Reader.\n         */\n        public PropertiesReader(Reader reader) {\n            super(reader);\n        }\n\n        /**\n         * Read a property.\n         *\n         * @return a String property\n         * @throws IOException if there is difficulty reading the source.\n         */\n        public String readProperty() throws IOException {\n            StringBuffer buffer = new StringBuffer();\n            String line = readLine();\n            while (line != null) {\n                line = line.trim();\n                if ((line.length() != 0) && (line.charAt(0) != '#')) {\n                    if (endsWithSlash(line)) {\n                        line = line.substring(0, line.length() - 1);\n                        buffer.append(line);\n                    } else {\n                        buffer.append(line);\n                        return buffer.toString();  // normal method end\n                    }\n                }\n                line = readLine();\n            }\n            return null;  // EOF reached\n        }\n    }\n\n    /**\n     * This class divides into tokens a property value.  Token\n     * separator is \",\" but commas into the property value are escaped\n     * using the backslash in front.\n     */\n    static class PropertiesTokenizer extends StringTokenizer {\n        /**\n         * The property delimiter used while parsing (a comma).\n         */\n        static final String DELIMITER = \",\";\n\n        /**\n         * Constructor.\n         *\n         * @param string A String.\n         */\n        public PropertiesTokenizer(String string) {\n            super(string, DELIMITER);\n        }\n\n        /**\n         * Check whether the object has more tokens.\n         *\n         * @return True if the object has more tokens.\n         */\n        public boolean hasMoreTokens() {\n            return super.hasMoreTokens();\n        }\n\n        /**\n         * Get next token.\n         *\n         * @return A String.\n         */\n        public String nextToken() {\n            StringBuffer buffer = new StringBuffer();\n\n            while (hasMoreTokens()) {\n                String token = super.nextToken();\n                if (endsWithSlash(token)) {\n                    buffer.append(token.substring(0, token.length() - 1));\n                    buffer.append(DELIMITER);\n                } else {\n                    buffer.append(token);\n                    break;\n                }\n            }\n\n            return buffer.toString().trim();\n        }\n    }\n\n    /**\n     * Creates an empty extended properties object.\n     */\n    public ExtendedProperties() {\n        super();\n    }\n\n    /**\n     * Creates and loads the extended properties from the specified file.\n     *\n     * @param file  the filename to load\n     * @throws IOException if a file error occurs\n     */\n    public ExtendedProperties(String file) throws IOException {\n        this(file, null);\n    }\n\n    /**\n     * Creates and loads the extended properties from the specified file.\n     *\n     * @param file  the filename to load\n     * @param defaultFile  a second filename to load default values from\n     * @throws IOException if a file error occurs\n     */\n    public ExtendedProperties(String file, String defaultFile) throws IOException {\n        this.file = file;\n\n        basePath = new File(file).getAbsolutePath();\n        basePath = basePath.substring(0, basePath.lastIndexOf(fileSeparator) + 1);\n\n        FileInputStream in = null;\n        try {\n            in = new FileInputStream(file);\n            this.load(in);\n        } finally {\n            try {\n                if (in != null) {\n                    in.close();\n                }\n            } catch (IOException ex) {}\n        }\n\n        if (defaultFile != null) {\n            defaults = new ExtendedProperties(defaultFile);\n        }\n    }\n\n    /**\n     * Indicate to client code whether property\n     * resources have been initialized or not.\n     */\n    public boolean isInitialized() {\n        return isInitialized;\n    }\n\n    /**\n     * Gets the property value for including other properties files.\n     * By default it is \"include\".\n     * <p>\n     * NOTE: Prior to v3.3 this method accessed a static variable.\n     * It now accesses an instance variable. For compatability, if the\n     * instance variable has not been set then the previous static\n     * variable is then accessed. However, the protected static variable\n     * can now only be set by subclasses.\n     * In v4.0, the static variable will be removed.\n     *\n     * @return the property name which includes another property\n     */\n    public String getInclude() {\n        if (includePropertyName == null) {\n            return include;  // backwards compatability\n        }\n        if (\"\".equals(includePropertyName)) {\n            return null;  // hack to allow backwards compatability\n        }\n        return includePropertyName;\n    }\n\n    /**\n     * Sets the property value for including other properties files.\n     * By default it is \"include\".\n     * <p>\n     * NOTE: Prior to v3.3 this method set a static variable and affected all\n     * users of the class. It now sets an instance variable.\n     * An empty string is also now converted to null internally.\n     * In v4.0, the static variable will be removed.\n     *\n     * @param inc  the property name which includes another property, empty converted to null\n     */\n    public void setInclude(String inc) {\n        if (inc == null) {\n            inc = \"\";  // hack to allow backwards compatability\n        }\n        includePropertyName = inc;\n    }\n\n    /**\n     * Load the properties from the given input stream.\n     *\n     * @param input  the InputStream to load from\n     * @throws IOException if an IO error occurs\n     */\n    public void load(InputStream input) throws IOException {\n        load(input, null);\n    }\n\n    /**\n     * Load the properties from the given input stream\n     * and using the specified encoding.\n     *\n     * @param input  the InputStream to load from\n     * @param enc  the encoding to use\n     * @throws IOException if an IO error occurs\n     */\n    public synchronized void load(InputStream input, String enc) throws IOException {\n        PropertiesReader reader = null;\n        if (enc != null) {\n            try {\n                reader = new PropertiesReader(new InputStreamReader(input, enc));\n                \n            } catch (UnsupportedEncodingException ex) {\n                // Another try coming up....\n            }\n        }\n        \n        if (reader == null) {\n            try {\n                reader = new PropertiesReader(new InputStreamReader(input, \"8859_1\"));\n                \n            } catch (UnsupportedEncodingException ex) {\n                // ISO8859-1 support is required on java platforms but....\n                // If it's not supported, use the system default encoding\n                reader = new PropertiesReader(new InputStreamReader(input));\n            }\n        }\n\n        try {\n            String includeProperty = getInclude();\n            while (true) {\n                String line = reader.readProperty();\n                if (line == null) {\n                    return;  // EOF\n                }\n                int equalSign = line.indexOf('=');\n\n                if (equalSign > 0) {\n                    String key = line.substring(0, equalSign).trim();\n                    String value = line.substring(equalSign + 1).trim();\n\n                    /* COLLECTIONS-238 allows empty properties to exist by commenting this out\n                    // Configure produces lines like this ... just ignore them\n                    if (\"\".equals(value)) {\n                        continue;\n                    }\n                    */\n\n                    if (includeProperty != null && key.equalsIgnoreCase(includeProperty)) {\n                        // Recursively load properties files.\n                        File file = null;\n\n                        if (value.startsWith(fileSeparator)) {\n                            // We have an absolute path so we'll use this\n                            file = new File(value);\n                            \n                        } else {\n                            // We have a relative path, and we have two \n                            // possible forms here. If we have the \"./\" form\n                            // then just strip that off first before continuing.\n                            if (value.startsWith(\".\" + fileSeparator)) {\n                                value = value.substring(2);\n                            }\n\n                            file = new File(basePath + value);\n                        }\n\n                        if (file != null && file.exists() && file.canRead()) {\n                            load(new FileInputStream(file));\n                        }\n                    } else {\n                        addProperty(key, value);\n                    }\n                }\n            }\n        } finally {\n            // Loading is initializing\n            isInitialized = true;\n        }\n    }\n\n    /**\n     * Gets a property from the configuration.\n     *\n     * @param key property to retrieve\n     * @return value as object. Will return user value if exists,\n     *        if not then default value if exists, otherwise null\n     */\n    public Object getProperty(String key) {\n        // first, try to get from the 'user value' store\n        Object obj = super.get(key);\n\n        if (obj == null) {\n            // if there isn't a value there, get it from the\n            // defaults if we have them\n            if (defaults != null) {\n                obj = defaults.get(key);\n            }\n        }\n\n        return obj;\n    }\n    \n    /**\n     * Add a property to the configuration. If it already\n     * exists then the value stated here will be added\n     * to the configuration entry. For example, if\n     *\n     * <code>resource.loader = file</code>\n     *\n     * is already present in the configuration and you\n     *\n     * <code>addProperty(\"resource.loader\", \"classpath\")</code>\n     *\n     * Then you will end up with a Vector like the\n     * following:\n     *\n     * <code>[\"file\", \"classpath\"]</code>\n     *\n     * @param key  the key to add\n     * @param value  the value to add\n     */\n    public void addProperty(String key, Object value) {\n        if (value instanceof String) {\n            String str = (String) value;\n            if (str.indexOf(PropertiesTokenizer.DELIMITER) > 0) {\n                // token contains commas, so must be split apart then added\n                PropertiesTokenizer tokenizer = new PropertiesTokenizer(str);\n                while (tokenizer.hasMoreTokens()) {\n                    String token = tokenizer.nextToken();\n                    addPropertyInternal(key, unescape(token));\n                }\n            } else {\n                // token contains no commas, so can be simply added\n                addPropertyInternal(key, unescape(str));\n            }\n        } else {\n            addPropertyInternal(key, value);\n        }\n\n        // Adding a property connotes initialization\n        isInitialized = true;\n    }\n\n    /**\n     * Adds a key/value pair to the map.  This routine does\n     * no magic morphing.  It ensures the keylist is maintained\n     *\n     * @param key  the key to store at\n     * @param value  the decoded object to store\n     */\n    private void addPropertyDirect(String key, Object value) {\n        // safety check\n        if (!containsKey(key)) {\n            keysAsListed.add(key);\n        }\n        super.put(key, value);\n    }\n\n    /**\n     * Adds a decoded property to the map w/o checking for commas - used\n     * internally when a property has been broken up into\n     * strings that could contain escaped commas to prevent\n     * the inadvertent vectorization.\n     * <p>\n     * Thanks to Leon Messerschmidt for this one.\n     *\n     * @param key  the key to store at\n     * @param value  the decoded object to store\n     */\n    private void addPropertyInternal(String key, Object value) {\n        Object current = this.get(key);\n\n        if (current instanceof String) {\n            // one object already in map - convert it to a vector\n            List values = new Vector(2);\n            values.add(current);\n            values.add(value);\n            super.put(key, values);\n            \n        } else if (current instanceof List) {\n            // already a list - just add the new token\n            ((List) current).add(value);\n            \n        } else {\n            // brand new key - store in keysAsListed to retain order\n            if (!containsKey(key)) {\n                keysAsListed.add(key);\n            }\n            super.put(key, value);\n        }\n    }\n\n    /**\n     * Set a property, this will replace any previously\n     * set values. Set values is implicitly a call\n     * to clearProperty(key), addProperty(key,value).\n     *\n     * @param key  the key to set\n     * @param value  the value to set\n     */\n    public void setProperty(String key, Object value) {\n        clearProperty(key);\n        addProperty(key, value);\n    }\n    \n    /**\n     * Save the properties to the given output stream.\n     * <p>\n     * The stream is not closed, but it is flushed.\n     *\n     * @param output  an OutputStream, may be null\n     * @param header  a textual comment to act as a file header\n     * @throws IOException if an IO error occurs\n     */\n    public synchronized void save(OutputStream output, String header) throws IOException {\n        if (output == null) {\n            return;\n        }\n        PrintWriter theWrtr = new PrintWriter(output);\n        if (header != null) {\n            theWrtr.println(header);\n        }\n        \n        Enumeration theKeys = keys();\n        while (theKeys.hasMoreElements()) {\n            String key = (String) theKeys.nextElement();\n            Object value = get(key);\n            if (value != null) {\n                if (value instanceof String) {\n                    StringBuffer currentOutput = new StringBuffer();\n                    currentOutput.append(key);\n                    currentOutput.append(\"=\");\n                    currentOutput.append(escape((String) value));\n                    theWrtr.println(currentOutput.toString());\n                    \n                } else if (value instanceof List) {\n                    List values = (List) value;\n                    for (Iterator it = values.iterator(); it.hasNext(); ) {\n                        String currentElement = (String) it.next();\n                        StringBuffer currentOutput = new StringBuffer();\n                        currentOutput.append(key);\n                        currentOutput.append(\"=\");\n                        currentOutput.append(escape(currentElement));\n                        theWrtr.println(currentOutput.toString());\n                    }\n                }\n            }\n            theWrtr.println();\n            theWrtr.flush();\n        }\n    }\n\n    /**\n     * Combines an existing Hashtable with this Hashtable.\n     * <p>\n     * Warning: It will overwrite previous entries without warning.\n     *\n     * @param props  the properties to combine\n     */\n    public void combine(ExtendedProperties props) {\n        for (Iterator it = props.getKeys(); it.hasNext();) {\n            String key = (String) it.next();\n            clearProperty(key);\n            addPropertyDirect(key, props.get(key));\n        }\n    }\n    \n    /**\n     * Clear a property in the configuration.\n     *\n     * @param key  the property key to remove along with corresponding value\n     */\n    public void clearProperty(String key) {\n        if (containsKey(key)) {\n            // we also need to rebuild the keysAsListed or else\n            // things get *very* confusing\n            for (int i = 0; i < keysAsListed.size(); i++) {\n                if (( keysAsListed.get(i)).equals(key)) {\n                    keysAsListed.remove(i);\n                    break;\n                }\n            }\n            super.remove(key);\n        }\n    }\n\n    /**\n     * Get the list of the keys contained in the configuration\n     * repository.\n     *\n     * @return an Iterator over the keys\n     */\n    public Iterator getKeys() {\n        return keysAsListed.iterator();\n    }\n\n    /**\n     * Get the list of the keys contained in the configuration\n     * repository that match the specified prefix.\n     *\n     * @param prefix  the prefix to match\n     * @return an Iterator of keys that match the prefix\n     */\n    public Iterator getKeys(String prefix) {\n        Iterator keys = getKeys();\n        ArrayList matchingKeys = new ArrayList();\n\n        while (keys.hasNext()) {\n            Object key = keys.next();\n\n            if (key instanceof String && ((String) key).startsWith(prefix)) {\n                matchingKeys.add(key);\n            }\n        }\n        return matchingKeys.iterator();\n    }\n\n    /**\n     * Create an ExtendedProperties object that is a subset\n     * of this one. Take into account duplicate keys\n     * by using the setProperty() in ExtendedProperties.\n     *\n     * @param prefix  the prefix to get a subset for\n     * @return a new independent ExtendedProperties\n     */\n    public ExtendedProperties subset(String prefix) {\n        ExtendedProperties c = new ExtendedProperties();\n        Iterator keys = getKeys();\n        boolean validSubset = false;\n\n        while (keys.hasNext()) {\n            Object key = keys.next();\n\n            if (key instanceof String && ((String) key).startsWith(prefix)) {\n                if (!validSubset) {\n                    validSubset = true;\n                }\n\n                /*\n                 * Check to make sure that c.subset(prefix) doesn't\n                 * blow up when there is only a single property\n                 * with the key prefix. This is not a useful\n                 * subset but it is a valid subset.\n                 */\n                String newKey = null;\n                if (((String) key).length() == prefix.length()) {\n                    newKey = prefix;\n                } else {\n                    newKey = ((String) key).substring(prefix.length() + 1);\n                }\n\n                /*\n                 *  use addPropertyDirect() - this will plug the data as \n                 *  is into the Map, but will also do the right thing\n                 *  re key accounting\n                 */\n                c.addPropertyDirect(newKey, get(key));\n            }\n        }\n\n        if (validSubset) {\n            return c;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Display the configuration for debugging purposes to System.out.\n     */\n    public void display() {\n        Iterator i = getKeys();\n\n        while (i.hasNext()) {\n            String key = (String) i.next();\n            Object value = get(key);\n            System.out.println(key + \" => \" + value);\n        }\n    }\n\n    /**\n     * Get a string associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated string.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a String.\n     */\n    public String getString(String key) {\n        return getString(key, null);\n    }\n\n    /**\n     * Get a string associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated string if key is found,\n     * default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a String.\n     */\n    public String getString(String key, String defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof String) {\n            return interpolate((String) value);\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return interpolate(defaults.getString(key, defaultValue));\n            } else {\n                return interpolate(defaultValue);\n            }\n        } else if (value instanceof List) {\n            return interpolate((String) ((List) value).get(0));\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a String object\");\n        }\n    }\n\n    /**\n     * Get a list of properties associated with the given\n     * configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated properties if key is found.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a String/List.\n     * @throws IllegalArgumentException if one of the tokens is\n     * malformed (does not contain an equals sign).\n     */\n    public Properties getProperties(String key) {\n        return getProperties(key, new Properties());\n    }\n\n    /**\n     * Get a list of properties associated with the given\n     * configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated properties if key is found.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a String/List.\n     * @throws IllegalArgumentException if one of the tokens is\n     * malformed (does not contain an equals sign).\n     */\n    public Properties getProperties(String key, Properties defaults) {\n        /*\n         * Grab an array of the tokens for this key.\n         */\n        String[] tokens = getStringArray(key);\n\n        // Each token is of the form 'key=value'.\n        Properties props = new Properties(defaults);\n        for (int i = 0; i < tokens.length; i++) {\n            String token = tokens[i];\n            int equalSign = token.indexOf('=');\n            if (equalSign > 0) {\n                String pkey = token.substring(0, equalSign).trim();\n                String pvalue = token.substring(equalSign + 1).trim();\n                props.put(pkey, pvalue);\n            } else {\n                throw new IllegalArgumentException('\\'' + token + \"' does not contain \" + \"an equals sign\");\n            }\n        }\n        return props;\n    }\n\n    /**\n     * Get an array of strings associated with the given configuration\n     * key.\n     *\n     * @param key The configuration key.\n     * @return The associated string array if key is found.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a String/List.\n     */\n    public String[] getStringArray(String key) {\n        Object value = get(key);\n\n        List values;\n        if (value instanceof String) {\n            values = new Vector(1);\n            values.add(value);\n            \n        } else if (value instanceof List) {\n            values = (List) value;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getStringArray(key);\n            } else {\n                return new String[0];\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a String/List object\");\n        }\n\n        String[] tokens = new String[values.size()];\n        for (int i = 0; i < tokens.length; i++) {\n            tokens[i] = (String) values.get(i);\n        }\n\n        return tokens;\n    }\n\n    /**\n     * Get a Vector of strings associated with the given configuration\n     * key.\n     *\n     * @param key The configuration key.\n     * @return The associated Vector.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Vector.\n     */\n    public Vector getVector(String key) {\n        return getVector(key, null);\n    }\n\n    /**\n     * Get a Vector of strings associated with the given configuration key.\n     * <p>\n     * The list is a copy of the internal data of this object, and as\n     * such you may alter it freely.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated Vector.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Vector.\n     */\n    public Vector getVector(String key, Vector defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof List) {\n            return new Vector((List) value);\n            \n        } else if (value instanceof String) {\n            Vector values = new Vector(1);\n            values.add(value);\n            super.put(key, values);\n            return values;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getVector(key, defaultValue);\n            } else {\n                return ((defaultValue == null) ? new Vector() : defaultValue);\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Vector object\");\n        }\n    }\n\n    /**\n     * Get a List of strings associated with the given configuration key.\n     * <p>\n     * The list is a copy of the internal data of this object, and as\n     * such you may alter it freely.\n     *\n     * @param key The configuration key.\n     * @return The associated List object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a List.\n     * @since Commons Collections 3.2\n     */\n    public List getList(String key) {\n        return getList(key, null);\n    }\n\n    /**\n     * Get a List of strings associated with the given configuration key.\n     * <p>\n     * The list is a copy of the internal data of this object, and as\n     * such you may alter it freely.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated List.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a List.\n     * @since Commons Collections 3.2\n     */\n    public List getList(String key, List defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof List) {\n            return new ArrayList((List) value);\n            \n        } else if (value instanceof String) {\n            List values = new ArrayList(1);\n            values.add(value);\n            super.put(key, values);\n            return values;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getList(key, defaultValue);\n            } else {\n                return ((defaultValue == null) ? new ArrayList() : defaultValue);\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a List object\");\n        }\n    }\n\n    /**\n     * Get a boolean associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated boolean.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Boolean.\n     */\n    public boolean getBoolean(String key) {\n        Boolean b = getBoolean(key, null);\n        if (b != null) {\n            return b.booleanValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a boolean associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated boolean.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Boolean.\n     */\n    public boolean getBoolean(String key, boolean defaultValue) {\n        return getBoolean(key, new Boolean(defaultValue)).booleanValue();\n    }\n\n    /**\n     * Get a boolean associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated boolean if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Boolean.\n     */\n    public Boolean getBoolean(String key, Boolean defaultValue) {\n\n        Object value = get(key);\n\n        if (value instanceof Boolean) {\n            return (Boolean) value;\n            \n        } else if (value instanceof String) {\n            String s = testBoolean((String) value);\n            Boolean b = new Boolean(s);\n            super.put(key, b);\n            return b;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getBoolean(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Boolean object\");\n        }\n    }\n\n    /**\n     * Test whether the string represent by value maps to a boolean\n     * value or not. We will allow <code>true</code>, <code>on</code>,\n     * and <code>yes</code> for a <code>true</code> boolean value, and\n     * <code>false</code>, <code>off</code>, and <code>no</code> for\n     * <code>false</code> boolean values.  Case of value to test for\n     * boolean status is ignored.\n     *\n     * @param value  the value to test for boolean state\n     * @return <code>true</code> or <code>false</code> if the supplied\n     * text maps to a boolean value, or <code>null</code> otherwise.\n     */\n    public String testBoolean(String value) {\n        String s = value.toLowerCase(Locale.ENGLISH);\n\n        if (s.equals(\"true\") || s.equals(\"on\") || s.equals(\"yes\")) {\n            return \"true\";\n        } else if (s.equals(\"false\") || s.equals(\"off\") || s.equals(\"no\")) {\n            return \"false\";\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Get a byte associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated byte.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Byte.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public byte getByte(String key) {\n        Byte b = getByte(key, null);\n        if (b != null) {\n            return b.byteValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \" doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a byte associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated byte.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Byte.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public byte getByte(String key, byte defaultValue) {\n        return getByte(key, new Byte(defaultValue)).byteValue();\n    }\n\n    /**\n     * Get a byte associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated byte if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Byte.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public Byte getByte(String key, Byte defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Byte) {\n            return (Byte) value;\n            \n        } else if (value instanceof String) {\n            Byte b = new Byte((String) value);\n            super.put(key, b);\n            return b;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getByte(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Byte object\");\n        }\n    }\n\n    /**\n     * Get a short associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated short.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Short.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public short getShort(String key) {\n        Short s = getShort(key, null);\n        if (s != null) {\n            return s.shortValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a short associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated short.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Short.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public short getShort(String key, short defaultValue) {\n        return getShort(key, new Short(defaultValue)).shortValue();\n    }\n\n    /**\n     * Get a short associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated short if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Short.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public Short getShort(String key, Short defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Short) {\n            return (Short) value;\n            \n        } else if (value instanceof String) {\n            Short s = new Short((String) value);\n            super.put(key, s);\n            return s;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getShort(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Short object\");\n        }\n    }\n\n    /**\n     * The purpose of this method is to get the configuration resource\n     * with the given name as an integer.\n     *\n     * @param name The resource name.\n     * @return The value of the resource as an integer.\n     */\n    public int getInt(String name) {\n        return getInteger(name);\n    }\n\n    /**\n     * The purpose of this method is to get the configuration resource\n     * with the given name as an integer, or a default value.\n     *\n     * @param name The resource name\n     * @param def The default value of the resource.\n     * @return The value of the resource as an integer.\n     */\n    public int getInt(String name, int def) {\n        return getInteger(name, def);\n    }\n\n    /**\n     * Get a int associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated int.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Integer.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public int getInteger(String key) {\n        Integer i = getInteger(key, null);\n        if (i != null) {\n            return i.intValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a int associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated int.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Integer.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public int getInteger(String key, int defaultValue) {\n        Integer i = getInteger(key, null);\n\n        if (i == null) {\n            return defaultValue;\n        }\n        return i.intValue();\n    }\n\n    /**\n     * Get a int associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated int if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Integer.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public Integer getInteger(String key, Integer defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Integer) {\n            return (Integer) value;\n            \n        } else if (value instanceof String) {\n            Integer i = new Integer((String) value);\n            super.put(key, i);\n            return i;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getInteger(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Integer object\");\n        }\n    }\n\n    /**\n     * Get a long associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated long.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Long.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public long getLong(String key) {\n        Long l = getLong(key, null);\n        if (l != null) {\n            return l.longValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a long associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated long.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Long.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public long getLong(String key, long defaultValue) {\n        return getLong(key, new Long(defaultValue)).longValue();\n    }\n\n    /**\n     * Get a long associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated long if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Long.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public Long getLong(String key, Long defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Long) {\n            return (Long) value;\n            \n        } else if (value instanceof String) {\n            Long l = new Long((String) value);\n            super.put(key, l);\n            return l;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getLong(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Long object\");\n        }\n    }\n\n    /**\n     * Get a float associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated float.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Float.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public float getFloat(String key) {\n        Float f = getFloat(key, null);\n        if (f != null) {\n            return f.floatValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a float associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated float.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Float.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public float getFloat(String key, float defaultValue) {\n        return getFloat(key, new Float(defaultValue)).floatValue();\n    }\n\n    /**\n     * Get a float associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated float if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Float.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public Float getFloat(String key, Float defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Float) {\n            return (Float) value;\n            \n        } else if (value instanceof String) {\n            Float f = new Float((String) value);\n            super.put(key, f);\n            return f;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getFloat(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Float object\");\n        }\n    }\n\n    /**\n     * Get a double associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated double.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Double.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public double getDouble(String key) {\n        Double d = getDouble(key, null);\n        if (d != null) {\n            return d.doubleValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a double associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated double.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Double.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public double getDouble(String key, double defaultValue) {\n        return getDouble(key, new Double(defaultValue)).doubleValue();\n    }\n\n    /**\n     * Get a double associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated double if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Double.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public Double getDouble(String key, Double defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Double) {\n            return (Double) value;\n            \n        } else if (value instanceof String) {\n            Double d = new Double((String) value);\n            super.put(key, d);\n            return d;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getDouble(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Double object\");\n        }\n    }\n\n    /**\n     * Convert a standard properties class into a configuration class.\n     * <p>\n     * NOTE: From Commons Collections 3.2 this method will pick up\n     * any default parent Properties of the specified input object.\n     * <p>\n     * As with java.util.Properties(Properties), any non-String \n     * values will not be passed on in the new ExtendedProperties \n     * object.\n     *\n     * @param props  the properties object to convert\n     * @return new ExtendedProperties created from props\n     */\n    public static ExtendedProperties convertProperties(Properties props) {\n        ExtendedProperties c = new ExtendedProperties();\n\n        for (Enumeration e = props.propertyNames(); e.hasMoreElements();) {\n            String s = (String) e.nextElement();\n            c.setProperty(s, props.getProperty(s));\n        }\n\n        return c;\n    }\n\n    /**\n     * Add a new property specified by the key to the \n     * ExtendedProperties.\n     *\n     * @param key specifying the property\n     * @param value for the property\n     * @return old value of the property\n     */\n    public Object put(Object key, Object value) {\n        String strKey = String.valueOf(key);\n        Object ret = getProperty(strKey);\n        addProperty(strKey, value);\n        return ret;\n    }\n\n    /**\n     * Add a map full of key/value pairs to the ExtendedProperties. \n     * If the added map is an ExtendedProperties class, then the \n     * order of the added properties is maintained. \n     *\n     * @param map full of key/value pair data\n     */\n    public void putAll(Map map) {\n        if (map instanceof ExtendedProperties) {\n            for (Iterator it = ((ExtendedProperties) map).getKeys(); it.hasNext(); ) {\n                Object key = it.next();\n                put(key, map.get(key));\n            }\n        } else {\n            for (Iterator it = map.entrySet().iterator(); it.hasNext(); ) {\n                Map.Entry entry = (Map.Entry) it.next();\n                put(entry.getKey(), entry.getValue());\n            }\n        }\n    }\n\n\n    /**\n     * Remove the property specified by the key from the \n     * ExtendedProperties.\n     *\n     * @param key specifying the property\n     * @return old value of the property\n     */\n    public Object remove(Object key) {\n        String strKey = String.valueOf(key);\n        Object ret = getProperty(strKey);\n        clearProperty(strKey);\n        return ret;\n    }\n\n}\n", "fixed_version": "/*\n *  Licensed to the Apache Software Foundation (ASF) under one or more\n *  contributor license agreements.  See the NOTICE file distributed with\n *  this work for additional information regarding copyright ownership.\n *  The ASF licenses this file to You under the Apache License, Version 2.0\n *  (the \"License\"); you may not use this file except in compliance with\n *  the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.apache.commons.collections;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.LineNumberReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.UnsupportedEncodingException;\nimport java.util.ArrayList;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Properties;\nimport java.util.StringTokenizer;\nimport java.util.Vector;\n\n/**\n * This class extends normal Java properties by adding the possibility\n * to use the same key many times concatenating the value strings\n * instead of overwriting them.\n * <p>\n * <b>Please consider using the\n * {@link org.apache.commons.configuration.PropertiesConfiguration} class in\n * <a href=\"http://commons.apache.org/configuration\">Commons Configuration</a>.\n * It's an evolution of <code>ExtendedProperties</code> supporting more\n * features like automatic reloading, advanced interpolation, more type\n * conversions, changes notifications and file layout preservation.</b>\n * <p>\n * The Extended Properties syntax is explained here:\n *\n * <ul>\n *  <li>\n *   Each property has the syntax <code>key = value</code>\n *  </li>\n *  <li>\n *   The <i>key</i> may use any character but the equal sign '='.\n *  </li>\n *  <li>\n *   <i>value</i> may be separated on different lines if a backslash\n *   is placed at the end of the line that continues below.\n *  </li>\n *  <li>\n *   If <i>value</i> is a list of strings, each token is separated\n *   by a comma ','.\n *  </li>\n *  <li>\n *   Commas in each token are escaped placing a backslash right before\n *   the comma.\n *  </li>\n *  <li>\n *   Backslashes are escaped by using two consecutive backslashes i.e. \\\\\n *  </li>\n *  <li>\n *   If a <i>key</i> is used more than once, the values are appended\n *   as if they were on the same line separated with commas.\n *  </li>\n *  <li>\n *   Blank lines and lines starting with character '#' are skipped.\n *  </li>\n *  <li>\n *   If a property is named \"include\" (or whatever is defined by\n *   setInclude() and getInclude() and the value of that property is\n *   the full path to a file on disk, that file will be included into\n *   the ConfigurationsRepository. You can also pull in files relative\n *   to the parent configuration file. So if you have something\n *   like the following:\n *\n *   include = additional.properties\n *\n *   Then \"additional.properties\" is expected to be in the same\n *   directory as the parent configuration file.\n * \n *   Duplicate name values will be replaced, so be careful.\n *\n *  </li>\n * </ul>\n *\n * <p>Here is an example of a valid extended properties file:\n *\n * <p><pre>\n *      # lines starting with # are comments\n *\n *      # This is the simplest property\n *      key = value\n *\n *      # A long property may be separated on multiple lines\n *      longvalue = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa \\\n *                  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n *\n *      # This is a property with many tokens\n *      tokens_on_a_line = first token, second token\n *\n *      # This sequence generates exactly the same result\n *      tokens_on_multiple_lines = first token\n *      tokens_on_multiple_lines = second token\n *\n *      # commas may be escaped in tokens\n *      commas.escaped = Hi\\, what'up?\n * </pre>\n *\n * <p><b>NOTE</b>: this class has <b>not</b> been written for\n * performance nor low memory usage.  In fact, it's way slower than it\n * could be and generates too much memory garbage.  But since\n * performance is not an issue during intialization (and there is not\n * much time to improve it), I wrote it this way.  If you don't like\n * it, go ahead and tune it up!\n *\n * @since Commons Collections 1.0\n * @version $Revision$ $Date$\n * \n * @author <a href=\"mailto:stefano@apache.org\">Stefano Mazzocchi</a>\n * @author <a href=\"mailto:jon@latchkey.com\">Jon S. Stevens</a>\n * @author <a href=\"mailto:daveb@miceda-data\">Dave Bryson</a>\n * @author <a href=\"mailto:jvanzyl@periapt.com\">Jason van Zyl</a>\n * @author <a href=\"mailto:geirm@optonline.net\">Geir Magnusson Jr.</a>\n * @author <a href=\"mailto:leon@opticode.co.za\">Leon Messerschmidt</a>\n * @author <a href=\"mailto:kjohnson@transparent.com\">Kent Johnson</a>\n * @author <a href=\"mailto:dlr@finemaltcoding.com\">Daniel Rall</a>\n * @author <a href=\"mailto:ipriha@surfeu.fi\">Ilkka Priha</a>\n * @author Janek Bogucki\n * @author Mohan Kishore\n * @author Stephen Colebourne\n * @author Shinobu Kawai\n * @author <a href=\"mailto:hps@intermeta.de\">Henning P. Schmiedehausen</a>\n */\npublic class ExtendedProperties extends Hashtable {\n    \n    /**\n     * Default configurations repository.\n     */\n    private ExtendedProperties defaults;\n\n    /**\n     * The file connected to this repository (holding comments and\n     * such).\n     *\n     * @serial\n     */\n    protected String file;\n\n    /**\n     * Base path of the configuration file used to create\n     * this ExtendedProperties object.\n     */\n    protected String basePath;\n\n    /**\n     * File separator.\n     */\n    protected String fileSeparator = System.getProperty(\"file.separator\");\n\n    /**\n     * Has this configuration been intialized.\n     */\n    protected boolean isInitialized = false;\n\n    /**\n     * This is the name of the property that can point to other\n     * properties file for including other properties files.\n     */\n    private String includePropertyName = null;\n\n    /**\n     * This is the default name of the property that can point to other\n     * properties file for including other properties files.\n     * \n     * @deprecated Use getInclude() and setInclude() methods which operate\n     * on an instance variable from v3.3. Due to be removed in v4.0.\n     */\n    protected static String include = \"include\";\n\n    /**\n     * These are the keys in the order they listed\n     * in the configuration file. This is useful when\n     * you wish to perform operations with configuration\n     * information in a particular order.\n     */\n    protected ArrayList keysAsListed = new ArrayList();\n\n    protected final static String START_TOKEN=\"${\";\n    protected final static String END_TOKEN=\"}\";\n\n\n    /**\n     * Interpolate key names to handle ${key} stuff\n     *\n     * @param base string to interpolate\n     * @return returns the key name with the ${key} substituted\n     */\n    protected String interpolate(String base) {\n        // COPIED from [configuration] 2003-12-29\n        return (interpolateHelper(base, null));\n    }\n\n    /**\n     * Recursive handler for multiple levels of interpolation.\n     *\n     * When called the first time, priorVariables should be null.\n     *\n     * @param base string with the ${key} variables\n     * @param priorVariables serves two purposes: to allow checking for\n     * loops, and creating a meaningful exception message should a loop\n     * occur.  It's 0'th element will be set to the value of base from\n     * the first call.  All subsequent interpolated variables are added\n     * afterward.\n     *\n     * @return the string with the interpolation taken care of\n     */\n    protected String interpolateHelper(String base, List priorVariables) {\n        // COPIED from [configuration] 2003-12-29\n        if (base == null) {\n            return null;\n        }\n\n        // on the first call initialize priorVariables\n        // and add base as the first element\n        if (priorVariables == null) {\n            priorVariables = new ArrayList();\n            priorVariables.add(base);\n        }\n\n        int begin = -1;\n        int end = -1;\n        int prec = 0 - END_TOKEN.length();\n        String variable = null;\n        StringBuffer result = new StringBuffer();\n\n        // FIXME: we should probably allow the escaping of the start token\n        while (((begin = base.indexOf(START_TOKEN, prec + END_TOKEN.length())) > -1)\n            && ((end = base.indexOf(END_TOKEN, begin)) > -1)) {\n            result.append(base.substring(prec + END_TOKEN.length(), begin));\n            variable = base.substring(begin + START_TOKEN.length(), end);\n\n            // if we've got a loop, create a useful exception message and throw\n            if (priorVariables.contains(variable)) {\n                String initialBase = priorVariables.remove(0).toString();\n                priorVariables.add(variable);\n                StringBuffer priorVariableSb = new StringBuffer();\n\n                // create a nice trace of interpolated variables like so:\n                // var1->var2->var3\n                for (Iterator it = priorVariables.iterator(); it.hasNext();) {\n                    priorVariableSb.append(it.next());\n                    if (it.hasNext()) {\n                        priorVariableSb.append(\"->\");\n                    }\n                }\n\n                throw new IllegalStateException(\n                    \"infinite loop in property interpolation of \" + initialBase + \": \" + priorVariableSb.toString());\n            }\n            // otherwise, add this variable to the interpolation list.\n            else {\n                priorVariables.add(variable);\n            }\n\n            //QUESTION: getProperty or getPropertyDirect\n            Object value = getProperty(variable);\n            if (value != null) {\n                result.append(interpolateHelper(value.toString(), priorVariables));\n\n                // pop the interpolated variable off the stack\n                // this maintains priorVariables correctness for\n                // properties with multiple interpolations, e.g.\n                // prop.name=${some.other.prop1}/blahblah/${some.other.prop2}\n                priorVariables.remove(priorVariables.size() - 1);\n            } else if (defaults != null && defaults.getString(variable, null) != null) {\n                result.append(defaults.getString(variable));\n            } else {\n                //variable not defined - so put it back in the value\n                result.append(START_TOKEN).append(variable).append(END_TOKEN);\n            }\n            prec = end;\n        }\n        result.append(base.substring(prec + END_TOKEN.length(), base.length()));\n\n        return result.toString();\n    }\n    \n    /**\n     * Inserts a backslash before every comma and backslash. \n     */\n    private static String escape(String s) {\n        StringBuffer buf = new StringBuffer(s);\n        for (int i = 0; i < buf.length(); i++) {\n            char c = buf.charAt(i);\n            if (c == ',' || c == '\\\\') {\n                buf.insert(i, '\\\\');\n                i++;\n            }\n        }\n        return buf.toString();\n    }\n    \n    /**\n     * Removes a backslash from every pair of backslashes. \n     */\n    private static String unescape(String s) {\n        StringBuffer buf = new StringBuffer(s);\n        for (int i = 0; i < buf.length() - 1; i++) {\n            char c1 = buf.charAt(i);\n            char c2 = buf.charAt(i + 1);\n            if (c1 == '\\\\' && c2 == '\\\\') {\n                buf.deleteCharAt(i);\n            }\n        }\n        return buf.toString();\n    }\n\n    /**\n     * Counts the number of successive times 'ch' appears in the\n     * 'line' before the position indicated by the 'index'.\n     */\n    private static int countPreceding(String line, int index, char ch) {\n        int i;\n        for (i = index - 1; i >= 0; i--) {\n            if (line.charAt(i) != ch) {\n                break;\n            }\n        }\n        return index - 1 - i;\n    }\n\n    /**\n     * Checks if the line ends with odd number of backslashes \n     */\n    private static boolean endsWithSlash(String line) {\n        if (!line.endsWith(\"\\\\\")) {\n            return false;\n        }\n        return (countPreceding(line, line.length() - 1, '\\\\') % 2 == 0);\n    }\n\n    /**\n     * This class is used to read properties lines.  These lines do\n     * not terminate with new-line chars but rather when there is no\n     * backslash sign a the end of the line.  This is used to\n     * concatenate multiple lines for readability.\n     */\n    static class PropertiesReader extends LineNumberReader {\n        /**\n         * Constructor.\n         *\n         * @param reader A Reader.\n         */\n        public PropertiesReader(Reader reader) {\n            super(reader);\n        }\n\n        /**\n         * Read a property.\n         *\n         * @return a String property\n         * @throws IOException if there is difficulty reading the source.\n         */\n        public String readProperty() throws IOException {\n            StringBuffer buffer = new StringBuffer();\n            String line = readLine();\n            while (line != null) {\n                line = line.trim();\n                if ((line.length() != 0) && (line.charAt(0) != '#')) {\n                    if (endsWithSlash(line)) {\n                        line = line.substring(0, line.length() - 1);\n                        buffer.append(line);\n                    } else {\n                        buffer.append(line);\n                        return buffer.toString();  // normal method end\n                    }\n                }\n                line = readLine();\n            }\n            return null;  // EOF reached\n        }\n    }\n\n    /**\n     * This class divides into tokens a property value.  Token\n     * separator is \",\" but commas into the property value are escaped\n     * using the backslash in front.\n     */\n    static class PropertiesTokenizer extends StringTokenizer {\n        /**\n         * The property delimiter used while parsing (a comma).\n         */\n        static final String DELIMITER = \",\";\n\n        /**\n         * Constructor.\n         *\n         * @param string A String.\n         */\n        public PropertiesTokenizer(String string) {\n            super(string, DELIMITER);\n        }\n\n        /**\n         * Check whether the object has more tokens.\n         *\n         * @return True if the object has more tokens.\n         */\n        public boolean hasMoreTokens() {\n            return super.hasMoreTokens();\n        }\n\n        /**\n         * Get next token.\n         *\n         * @return A String.\n         */\n        public String nextToken() {\n            StringBuffer buffer = new StringBuffer();\n\n            while (hasMoreTokens()) {\n                String token = super.nextToken();\n                if (endsWithSlash(token)) {\n                    buffer.append(token.substring(0, token.length() - 1));\n                    buffer.append(DELIMITER);\n                } else {\n                    buffer.append(token);\n                    break;\n                }\n            }\n\n            return buffer.toString().trim();\n        }\n    }\n\n    /**\n     * Creates an empty extended properties object.\n     */\n    public ExtendedProperties() {\n        super();\n    }\n\n    /**\n     * Creates and loads the extended properties from the specified file.\n     *\n     * @param file  the filename to load\n     * @throws IOException if a file error occurs\n     */\n    public ExtendedProperties(String file) throws IOException {\n        this(file, null);\n    }\n\n    /**\n     * Creates and loads the extended properties from the specified file.\n     *\n     * @param file  the filename to load\n     * @param defaultFile  a second filename to load default values from\n     * @throws IOException if a file error occurs\n     */\n    public ExtendedProperties(String file, String defaultFile) throws IOException {\n        this.file = file;\n\n        basePath = new File(file).getAbsolutePath();\n        basePath = basePath.substring(0, basePath.lastIndexOf(fileSeparator) + 1);\n\n        FileInputStream in = null;\n        try {\n            in = new FileInputStream(file);\n            this.load(in);\n        } finally {\n            try {\n                if (in != null) {\n                    in.close();\n                }\n            } catch (IOException ex) {}\n        }\n\n        if (defaultFile != null) {\n            defaults = new ExtendedProperties(defaultFile);\n        }\n    }\n\n    /**\n     * Indicate to client code whether property\n     * resources have been initialized or not.\n     */\n    public boolean isInitialized() {\n        return isInitialized;\n    }\n\n    /**\n     * Gets the property value for including other properties files.\n     * By default it is \"include\".\n     * <p>\n     * NOTE: Prior to v3.3 this method accessed a static variable.\n     * It now accesses an instance variable. For compatability, if the\n     * instance variable has not been set then the previous static\n     * variable is then accessed. However, the protected static variable\n     * can now only be set by subclasses.\n     * In v4.0, the static variable will be removed.\n     *\n     * @return the property name which includes another property\n     */\n    public String getInclude() {\n        if (includePropertyName == null) {\n            return include;  // backwards compatability\n        }\n        if (\"\".equals(includePropertyName)) {\n            return null;  // hack to allow backwards compatability\n        }\n        return includePropertyName;\n    }\n\n    /**\n     * Sets the property value for including other properties files.\n     * By default it is \"include\".\n     * <p>\n     * NOTE: Prior to v3.3 this method set a static variable and affected all\n     * users of the class. It now sets an instance variable.\n     * An empty string is also now converted to null internally.\n     * In v4.0, the static variable will be removed.\n     *\n     * @param inc  the property name which includes another property, empty converted to null\n     */\n    public void setInclude(String inc) {\n        if (inc == null) {\n            inc = \"\";  // hack to allow backwards compatability\n        }\n        includePropertyName = inc;\n    }\n\n    /**\n     * Load the properties from the given input stream.\n     *\n     * @param input  the InputStream to load from\n     * @throws IOException if an IO error occurs\n     */\n    public void load(InputStream input) throws IOException {\n        load(input, null);\n    }\n\n    /**\n     * Load the properties from the given input stream\n     * and using the specified encoding.\n     *\n     * @param input  the InputStream to load from\n     * @param enc  the encoding to use\n     * @throws IOException if an IO error occurs\n     */\n    public synchronized void load(InputStream input, String enc) throws IOException {\n        PropertiesReader reader = null;\n        if (enc != null) {\n            try {\n                reader = new PropertiesReader(new InputStreamReader(input, enc));\n                \n            } catch (UnsupportedEncodingException ex) {\n                // Another try coming up....\n            }\n        }\n        \n        if (reader == null) {\n            try {\n                reader = new PropertiesReader(new InputStreamReader(input, \"8859_1\"));\n                \n            } catch (UnsupportedEncodingException ex) {\n                // ISO8859-1 support is required on java platforms but....\n                // If it's not supported, use the system default encoding\n                reader = new PropertiesReader(new InputStreamReader(input));\n            }\n        }\n\n        try {\n            String includeProperty = getInclude();\n            while (true) {\n                String line = reader.readProperty();\n                if (line == null) {\n                    return;  // EOF\n                }\n                int equalSign = line.indexOf('=');\n\n                if (equalSign > 0) {\n                    String key = line.substring(0, equalSign).trim();\n                    String value = line.substring(equalSign + 1).trim();\n\n                    /* COLLECTIONS-238 allows empty properties to exist by commenting this out\n                    // Configure produces lines like this ... just ignore them\n                    if (\"\".equals(value)) {\n                        continue;\n                    }\n                    */\n\n                    if (includeProperty != null && key.equalsIgnoreCase(includeProperty)) {\n                        // Recursively load properties files.\n                        File file = null;\n\n                        if (value.startsWith(fileSeparator)) {\n                            // We have an absolute path so we'll use this\n                            file = new File(value);\n                            \n                        } else {\n                            // We have a relative path, and we have two \n                            // possible forms here. If we have the \"./\" form\n                            // then just strip that off first before continuing.\n                            if (value.startsWith(\".\" + fileSeparator)) {\n                                value = value.substring(2);\n                            }\n\n                            file = new File(basePath + value);\n                        }\n\n                        if (file != null && file.exists() && file.canRead()) {\n                            load(new FileInputStream(file));\n                        }\n                    } else {\n                        addProperty(key, value);\n                    }\n                }\n            }\n        } finally {\n            // Loading is initializing\n            isInitialized = true;\n        }\n    }\n\n    /**\n     * Gets a property from the configuration.\n     *\n     * @param key property to retrieve\n     * @return value as object. Will return user value if exists,\n     *        if not then default value if exists, otherwise null\n     */\n    public Object getProperty(String key) {\n        // first, try to get from the 'user value' store\n        Object obj = super.get(key);\n\n        if (obj == null) {\n            // if there isn't a value there, get it from the\n            // defaults if we have them\n            if (defaults != null) {\n                obj = defaults.get(key);\n            }\n        }\n\n        return obj;\n    }\n    \n    /**\n     * Add a property to the configuration. If it already\n     * exists then the value stated here will be added\n     * to the configuration entry. For example, if\n     *\n     * <code>resource.loader = file</code>\n     *\n     * is already present in the configuration and you\n     *\n     * <code>addProperty(\"resource.loader\", \"classpath\")</code>\n     *\n     * Then you will end up with a Vector like the\n     * following:\n     *\n     * <code>[\"file\", \"classpath\"]</code>\n     *\n     * @param key  the key to add\n     * @param value  the value to add\n     */\n    public void addProperty(String key, Object value) {\n        if (value instanceof String) {\n            String str = (String) value;\n            if (str.indexOf(PropertiesTokenizer.DELIMITER) > 0) {\n                // token contains commas, so must be split apart then added\n                PropertiesTokenizer tokenizer = new PropertiesTokenizer(str);\n                while (tokenizer.hasMoreTokens()) {\n                    String token = tokenizer.nextToken();\n                    addPropertyInternal(key, unescape(token));\n                }\n            } else {\n                // token contains no commas, so can be simply added\n                addPropertyInternal(key, unescape(str));\n            }\n        } else {\n            addPropertyInternal(key, value);\n        }\n\n        // Adding a property connotes initialization\n        isInitialized = true;\n    }\n\n    /**\n     * Adds a key/value pair to the map.  This routine does\n     * no magic morphing.  It ensures the keylist is maintained\n     *\n     * @param key  the key to store at\n     * @param value  the decoded object to store\n     */\n    private void addPropertyDirect(String key, Object value) {\n        // safety check\n        if (!containsKey(key)) {\n            keysAsListed.add(key);\n        }\n        super.put(key, value);\n    }\n\n    /**\n     * Adds a decoded property to the map w/o checking for commas - used\n     * internally when a property has been broken up into\n     * strings that could contain escaped commas to prevent\n     * the inadvertent vectorization.\n     * <p>\n     * Thanks to Leon Messerschmidt for this one.\n     *\n     * @param key  the key to store at\n     * @param value  the decoded object to store\n     */\n    private void addPropertyInternal(String key, Object value) {\n        Object current = this.get(key);\n\n        if (current instanceof String) {\n            // one object already in map - convert it to a vector\n            List values = new Vector(2);\n            values.add(current);\n            values.add(value);\n            super.put(key, values);\n            \n        } else if (current instanceof List) {\n            // already a list - just add the new token\n            ((List) current).add(value);\n            \n        } else {\n            // brand new key - store in keysAsListed to retain order\n            if (!containsKey(key)) {\n                keysAsListed.add(key);\n            }\n            super.put(key, value);\n        }\n    }\n\n    /**\n     * Set a property, this will replace any previously\n     * set values. Set values is implicitly a call\n     * to clearProperty(key), addProperty(key,value).\n     *\n     * @param key  the key to set\n     * @param value  the value to set\n     */\n    public void setProperty(String key, Object value) {\n        clearProperty(key);\n        addProperty(key, value);\n    }\n    \n    /**\n     * Save the properties to the given output stream.\n     * <p>\n     * The stream is not closed, but it is flushed.\n     *\n     * @param output  an OutputStream, may be null\n     * @param header  a textual comment to act as a file header\n     * @throws IOException if an IO error occurs\n     */\n    public synchronized void save(OutputStream output, String header) throws IOException {\n        if (output == null) {\n            return;\n        }\n        PrintWriter theWrtr = new PrintWriter(output);\n        if (header != null) {\n            theWrtr.println(header);\n        }\n        \n        Enumeration theKeys = keys();\n        while (theKeys.hasMoreElements()) {\n            String key = (String) theKeys.nextElement();\n            Object value = get(key);\n            if (value != null) {\n                if (value instanceof String) {\n                    StringBuffer currentOutput = new StringBuffer();\n                    currentOutput.append(key);\n                    currentOutput.append(\"=\");\n                    currentOutput.append(escape((String) value));\n                    theWrtr.println(currentOutput.toString());\n                    \n                } else if (value instanceof List) {\n                    List values = (List) value;\n                    for (Iterator it = values.iterator(); it.hasNext(); ) {\n                        String currentElement = (String) it.next();\n                        StringBuffer currentOutput = new StringBuffer();\n                        currentOutput.append(key);\n                        currentOutput.append(\"=\");\n                        currentOutput.append(escape(currentElement));\n                        theWrtr.println(currentOutput.toString());\n                    }\n                }\n            }\n            theWrtr.println();\n            theWrtr.flush();\n        }\n    }\n\n    /**\n     * Combines an existing Hashtable with this Hashtable.\n     * <p>\n     * Warning: It will overwrite previous entries without warning.\n     *\n     * @param props  the properties to combine\n     */\n    public void combine(ExtendedProperties props) {\n        for (Iterator it = props.getKeys(); it.hasNext();) {\n            String key = (String) it.next();\n            clearProperty(key);\n            addPropertyDirect(key, props.get(key));\n        }\n    }\n    \n    /**\n     * Clear a property in the configuration.\n     *\n     * @param key  the property key to remove along with corresponding value\n     */\n    public void clearProperty(String key) {\n        if (containsKey(key)) {\n            // we also need to rebuild the keysAsListed or else\n            // things get *very* confusing\n            for (int i = 0; i < keysAsListed.size(); i++) {\n                if (( keysAsListed.get(i)).equals(key)) {\n                    keysAsListed.remove(i);\n                    break;\n                }\n            }\n            super.remove(key);\n        }\n    }\n\n    /**\n     * Get the list of the keys contained in the configuration\n     * repository.\n     *\n     * @return an Iterator over the keys\n     */\n    public Iterator getKeys() {\n        return keysAsListed.iterator();\n    }\n\n    /**\n     * Get the list of the keys contained in the configuration\n     * repository that match the specified prefix.\n     *\n     * @param prefix  the prefix to match\n     * @return an Iterator of keys that match the prefix\n     */\n    public Iterator getKeys(String prefix) {\n        Iterator keys = getKeys();\n        ArrayList matchingKeys = new ArrayList();\n\n        while (keys.hasNext()) {\n            Object key = keys.next();\n\n            if (key instanceof String && ((String) key).startsWith(prefix)) {\n                matchingKeys.add(key);\n            }\n        }\n        return matchingKeys.iterator();\n    }\n\n    /**\n     * Create an ExtendedProperties object that is a subset\n     * of this one. Take into account duplicate keys\n     * by using the setProperty() in ExtendedProperties.\n     *\n     * @param prefix  the prefix to get a subset for\n     * @return a new independent ExtendedProperties\n     */\n    public ExtendedProperties subset(String prefix) {\n        ExtendedProperties c = new ExtendedProperties();\n        Iterator keys = getKeys();\n        boolean validSubset = false;\n\n        while (keys.hasNext()) {\n            Object key = keys.next();\n\n            if (key instanceof String && ((String) key).startsWith(prefix)) {\n                if (!validSubset) {\n                    validSubset = true;\n                }\n\n                /*\n                 * Check to make sure that c.subset(prefix) doesn't\n                 * blow up when there is only a single property\n                 * with the key prefix. This is not a useful\n                 * subset but it is a valid subset.\n                 */\n                String newKey = null;\n                if (((String) key).length() == prefix.length()) {\n                    newKey = prefix;\n                } else {\n                    newKey = ((String) key).substring(prefix.length() + 1);\n                }\n\n                /*\n                 *  use addPropertyDirect() - this will plug the data as \n                 *  is into the Map, but will also do the right thing\n                 *  re key accounting\n                 */\n                c.addPropertyDirect(newKey, get(key));\n            }\n        }\n\n        if (validSubset) {\n            return c;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Display the configuration for debugging purposes to System.out.\n     */\n    public void display() {\n        Iterator i = getKeys();\n\n        while (i.hasNext()) {\n            String key = (String) i.next();\n            Object value = get(key);\n            System.out.println(key + \" => \" + value);\n        }\n    }\n\n    /**\n     * Get a string associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated string.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a String.\n     */\n    public String getString(String key) {\n        return getString(key, null);\n    }\n\n    /**\n     * Get a string associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated string if key is found,\n     * default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a String.\n     */\n    public String getString(String key, String defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof String) {\n            return interpolate((String) value);\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return interpolate(defaults.getString(key, defaultValue));\n            } else {\n                return interpolate(defaultValue);\n            }\n        } else if (value instanceof List) {\n            return interpolate((String) ((List) value).get(0));\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a String object\");\n        }\n    }\n\n    /**\n     * Get a list of properties associated with the given\n     * configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated properties if key is found.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a String/List.\n     * @throws IllegalArgumentException if one of the tokens is\n     * malformed (does not contain an equals sign).\n     */\n    public Properties getProperties(String key) {\n        return getProperties(key, new Properties());\n    }\n\n    /**\n     * Get a list of properties associated with the given\n     * configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated properties if key is found.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a String/List.\n     * @throws IllegalArgumentException if one of the tokens is\n     * malformed (does not contain an equals sign).\n     */\n    public Properties getProperties(String key, Properties defaults) {\n        /*\n         * Grab an array of the tokens for this key.\n         */\n        String[] tokens = getStringArray(key);\n\n        // Each token is of the form 'key=value'.\n        Properties props = new Properties(defaults);\n        for (int i = 0; i < tokens.length; i++) {\n            String token = tokens[i];\n            int equalSign = token.indexOf('=');\n            if (equalSign > 0) {\n                String pkey = token.substring(0, equalSign).trim();\n                String pvalue = token.substring(equalSign + 1).trim();\n                props.put(pkey, pvalue);\n            } else {\n                throw new IllegalArgumentException('\\'' + token + \"' does not contain \" + \"an equals sign\");\n            }\n        }\n        return props;\n    }\n\n    /**\n     * Get an array of strings associated with the given configuration\n     * key.\n     *\n     * @param key The configuration key.\n     * @return The associated string array if key is found.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a String/List.\n     */\n    public String[] getStringArray(String key) {\n        Object value = get(key);\n\n        List values;\n        if (value instanceof String) {\n            values = new Vector(1);\n            values.add(value);\n            \n        } else if (value instanceof List) {\n            values = (List) value;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getStringArray(key);\n            } else {\n                return new String[0];\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a String/List object\");\n        }\n\n        String[] tokens = new String[values.size()];\n        for (int i = 0; i < tokens.length; i++) {\n            tokens[i] = (String) values.get(i);\n        }\n\n        return tokens;\n    }\n\n    /**\n     * Get a Vector of strings associated with the given configuration\n     * key.\n     *\n     * @param key The configuration key.\n     * @return The associated Vector.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Vector.\n     */\n    public Vector getVector(String key) {\n        return getVector(key, null);\n    }\n\n    /**\n     * Get a Vector of strings associated with the given configuration key.\n     * <p>\n     * The list is a copy of the internal data of this object, and as\n     * such you may alter it freely.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated Vector.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Vector.\n     */\n    public Vector getVector(String key, Vector defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof List) {\n            return new Vector((List) value);\n            \n        } else if (value instanceof String) {\n            Vector values = new Vector(1);\n            values.add(value);\n            super.put(key, values);\n            return values;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getVector(key, defaultValue);\n            } else {\n                return ((defaultValue == null) ? new Vector() : defaultValue);\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Vector object\");\n        }\n    }\n\n    /**\n     * Get a List of strings associated with the given configuration key.\n     * <p>\n     * The list is a copy of the internal data of this object, and as\n     * such you may alter it freely.\n     *\n     * @param key The configuration key.\n     * @return The associated List object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a List.\n     * @since Commons Collections 3.2\n     */\n    public List getList(String key) {\n        return getList(key, null);\n    }\n\n    /**\n     * Get a List of strings associated with the given configuration key.\n     * <p>\n     * The list is a copy of the internal data of this object, and as\n     * such you may alter it freely.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated List.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a List.\n     * @since Commons Collections 3.2\n     */\n    public List getList(String key, List defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof List) {\n            return new ArrayList((List) value);\n            \n        } else if (value instanceof String) {\n            List values = new ArrayList(1);\n            values.add(value);\n            super.put(key, values);\n            return values;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getList(key, defaultValue);\n            } else {\n                return ((defaultValue == null) ? new ArrayList() : defaultValue);\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a List object\");\n        }\n    }\n\n    /**\n     * Get a boolean associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated boolean.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Boolean.\n     */\n    public boolean getBoolean(String key) {\n        Boolean b = getBoolean(key, null);\n        if (b != null) {\n            return b.booleanValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a boolean associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated boolean.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Boolean.\n     */\n    public boolean getBoolean(String key, boolean defaultValue) {\n        return getBoolean(key, new Boolean(defaultValue)).booleanValue();\n    }\n\n    /**\n     * Get a boolean associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated boolean if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Boolean.\n     */\n    public Boolean getBoolean(String key, Boolean defaultValue) {\n\n        Object value = get(key);\n\n        if (value instanceof Boolean) {\n            return (Boolean) value;\n            \n        } else if (value instanceof String) {\n            String s = testBoolean((String) value);\n            Boolean b = new Boolean(s);\n            super.put(key, b);\n            return b;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getBoolean(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Boolean object\");\n        }\n    }\n\n    /**\n     * Test whether the string represent by value maps to a boolean\n     * value or not. We will allow <code>true</code>, <code>on</code>,\n     * and <code>yes</code> for a <code>true</code> boolean value, and\n     * <code>false</code>, <code>off</code>, and <code>no</code> for\n     * <code>false</code> boolean values.  Case of value to test for\n     * boolean status is ignored.\n     *\n     * @param value  the value to test for boolean state\n     * @return <code>true</code> or <code>false</code> if the supplied\n     * text maps to a boolean value, or <code>null</code> otherwise.\n     */\n    public String testBoolean(String value) {\n        String s = value.toLowerCase(Locale.ENGLISH);\n\n        if (s.equals(\"true\") || s.equals(\"on\") || s.equals(\"yes\")) {\n            return \"true\";\n        } else if (s.equals(\"false\") || s.equals(\"off\") || s.equals(\"no\")) {\n            return \"false\";\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Get a byte associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated byte.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Byte.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public byte getByte(String key) {\n        Byte b = getByte(key, null);\n        if (b != null) {\n            return b.byteValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \" doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a byte associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated byte.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Byte.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public byte getByte(String key, byte defaultValue) {\n        return getByte(key, new Byte(defaultValue)).byteValue();\n    }\n\n    /**\n     * Get a byte associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated byte if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Byte.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public Byte getByte(String key, Byte defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Byte) {\n            return (Byte) value;\n            \n        } else if (value instanceof String) {\n            Byte b = new Byte((String) value);\n            super.put(key, b);\n            return b;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getByte(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Byte object\");\n        }\n    }\n\n    /**\n     * Get a short associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated short.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Short.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public short getShort(String key) {\n        Short s = getShort(key, null);\n        if (s != null) {\n            return s.shortValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a short associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated short.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Short.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public short getShort(String key, short defaultValue) {\n        return getShort(key, new Short(defaultValue)).shortValue();\n    }\n\n    /**\n     * Get a short associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated short if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Short.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public Short getShort(String key, Short defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Short) {\n            return (Short) value;\n            \n        } else if (value instanceof String) {\n            Short s = new Short((String) value);\n            super.put(key, s);\n            return s;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getShort(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Short object\");\n        }\n    }\n\n    /**\n     * The purpose of this method is to get the configuration resource\n     * with the given name as an integer.\n     *\n     * @param name The resource name.\n     * @return The value of the resource as an integer.\n     */\n    public int getInt(String name) {\n        return getInteger(name);\n    }\n\n    /**\n     * The purpose of this method is to get the configuration resource\n     * with the given name as an integer, or a default value.\n     *\n     * @param name The resource name\n     * @param def The default value of the resource.\n     * @return The value of the resource as an integer.\n     */\n    public int getInt(String name, int def) {\n        return getInteger(name, def);\n    }\n\n    /**\n     * Get a int associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated int.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Integer.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public int getInteger(String key) {\n        Integer i = getInteger(key, null);\n        if (i != null) {\n            return i.intValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a int associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated int.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Integer.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public int getInteger(String key, int defaultValue) {\n        Integer i = getInteger(key, null);\n\n        if (i == null) {\n            return defaultValue;\n        }\n        return i.intValue();\n    }\n\n    /**\n     * Get a int associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated int if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Integer.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public Integer getInteger(String key, Integer defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Integer) {\n            return (Integer) value;\n            \n        } else if (value instanceof String) {\n            Integer i = new Integer((String) value);\n            super.put(key, i);\n            return i;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getInteger(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Integer object\");\n        }\n    }\n\n    /**\n     * Get a long associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated long.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Long.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public long getLong(String key) {\n        Long l = getLong(key, null);\n        if (l != null) {\n            return l.longValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a long associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated long.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Long.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public long getLong(String key, long defaultValue) {\n        return getLong(key, new Long(defaultValue)).longValue();\n    }\n\n    /**\n     * Get a long associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated long if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Long.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public Long getLong(String key, Long defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Long) {\n            return (Long) value;\n            \n        } else if (value instanceof String) {\n            Long l = new Long((String) value);\n            super.put(key, l);\n            return l;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getLong(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Long object\");\n        }\n    }\n\n    /**\n     * Get a float associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated float.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Float.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public float getFloat(String key) {\n        Float f = getFloat(key, null);\n        if (f != null) {\n            return f.floatValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a float associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated float.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Float.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public float getFloat(String key, float defaultValue) {\n        return getFloat(key, new Float(defaultValue)).floatValue();\n    }\n\n    /**\n     * Get a float associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated float if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Float.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public Float getFloat(String key, Float defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Float) {\n            return (Float) value;\n            \n        } else if (value instanceof String) {\n            Float f = new Float((String) value);\n            super.put(key, f);\n            return f;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getFloat(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Float object\");\n        }\n    }\n\n    /**\n     * Get a double associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @return The associated double.\n     * @throws NoSuchElementException is thrown if the key doesn't\n     * map to an existing object.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Double.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public double getDouble(String key) {\n        Double d = getDouble(key, null);\n        if (d != null) {\n            return d.doubleValue();\n        } else {\n            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n        }\n    }\n\n    /**\n     * Get a double associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated double.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Double.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public double getDouble(String key, double defaultValue) {\n        return getDouble(key, new Double(defaultValue)).doubleValue();\n    }\n\n    /**\n     * Get a double associated with the given configuration key.\n     *\n     * @param key The configuration key.\n     * @param defaultValue The default value.\n     * @return The associated double if key is found and has valid\n     * format, default value otherwise.\n     * @throws ClassCastException is thrown if the key maps to an\n     * object that is not a Double.\n     * @throws NumberFormatException is thrown if the value mapped\n     * by the key has not a valid number format.\n     */\n    public Double getDouble(String key, Double defaultValue) {\n        Object value = get(key);\n\n        if (value instanceof Double) {\n            return (Double) value;\n            \n        } else if (value instanceof String) {\n            Double d = new Double((String) value);\n            super.put(key, d);\n            return d;\n            \n        } else if (value == null) {\n            if (defaults != null) {\n                return defaults.getDouble(key, defaultValue);\n            } else {\n                return defaultValue;\n            }\n        } else {\n            throw new ClassCastException('\\'' + key + \"' doesn't map to a Double object\");\n        }\n    }\n\n    /**\n     * Convert a standard properties class into a configuration class.\n     * <p>\n     * NOTE: From Commons Collections 3.2 this method will pick up\n     * any default parent Properties of the specified input object.\n     * <p>\n     * As with java.util.Properties(Properties), any non-String \n     * values will not be passed on in the new ExtendedProperties \n     * object.\n     *\n     * @param props  the properties object to convert\n     * @return new ExtendedProperties created from props\n     */\n    public static ExtendedProperties convertProperties(Properties props) {\n        ExtendedProperties c = new ExtendedProperties();\n\n        for (Enumeration e = props.propertyNames(); e.hasMoreElements();) {\n            String s = (String) e.nextElement();\n            String value = props.getProperty(s);\n            if(value != null) {\n                c.setProperty(s, value);\n            }\n        }\n\n        return c;\n    }\n\n    /**\n     * Add a new property specified by the key to the \n     * ExtendedProperties.\n     *\n     * @param key specifying the property\n     * @param value for the property\n     * @return old value of the property\n     */\n    public Object put(Object key, Object value) {\n        String strKey = String.valueOf(key);\n        Object ret = getProperty(strKey);\n        addProperty(strKey, value);\n        return ret;\n    }\n\n    /**\n     * Add a map full of key/value pairs to the ExtendedProperties. \n     * If the added map is an ExtendedProperties class, then the \n     * order of the added properties is maintained. \n     *\n     * @param map full of key/value pair data\n     */\n    public void putAll(Map map) {\n        if (map instanceof ExtendedProperties) {\n            for (Iterator it = ((ExtendedProperties) map).getKeys(); it.hasNext(); ) {\n                Object key = it.next();\n                put(key, map.get(key));\n            }\n        } else {\n            for (Iterator it = map.entrySet().iterator(); it.hasNext(); ) {\n                Map.Entry entry = (Map.Entry) it.next();\n                put(entry.getKey(), entry.getValue());\n            }\n        }\n    }\n\n\n    /**\n     * Remove the property specified by the key from the \n     * ExtendedProperties.\n     *\n     * @param key specifying the property\n     * @return old value of the property\n     */\n    public Object remove(Object key) {\n        String strKey = String.valueOf(key);\n        Object ret = getProperty(strKey);\n        clearProperty(strKey);\n        return ret;\n    }\n\n}\n"}]}
{"project": "Collections", "bug_id": 14, "classes_modified": [{"class_name": "org.apache.commons.collections.map.CaseInsensitiveMap", "buggy_version": "/*\n *  Licensed to the Apache Software Foundation (ASF) under one or more\n *  contributor license agreements.  See the NOTICE file distributed with\n *  this work for additional information regarding copyright ownership.\n *  The ASF licenses this file to You under the Apache License, Version 2.0\n *  (the \"License\"); you may not use this file except in compliance with\n *  the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.apache.commons.collections.map;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.Map;\n\n/**\n * A case-insensitive <code>Map</code>.\n * <p>\n * Before keys are added to the map or compared to other existing keys, they are converted\n * to all lowercase in a locale-independent fashion by using information from the Unicode\n * data file.\n * <p>\n * Null keys are supported.  \n * <p>\n * The <code>keySet()</code> method returns all lowercase keys, or nulls.\n * <p>\n * Example:\n * <pre><code>\n *  Map map = new CaseInsensitiveMap();\n *  map.put(\"One\", \"One\");\n *  map.put(\"Two\", \"Two\");\n *  map.put(null, \"Three\");\n *  map.put(\"one\", \"Four\");\n * </code></pre>\n * creates a <code>CaseInsensitiveMap</code> with three entries.<br>\n * <code>map.get(null)</code> returns <code>\"Three\"</code> and <code>map.get(\"ONE\")</code>\n * returns <code>\"Four\".</code>  The <code>Set</code> returned by <code>keySet()</code>\n * equals <code>{\"one\", \"two\", null}.</code>\n * <p>\n * <strong>Note that CaseInsensitiveMap is not synchronized and is not thread-safe.</strong>\n * If you wish to use this map from multiple threads concurrently, you must use\n * appropriate synchronization. The simplest approach is to wrap this map\n * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw \n * exceptions when accessed by concurrent threads without synchronization.\n *\n * @since Commons Collections 3.0\n * @version $Revision$ $Date$\n *\n * @author Commons-Collections team\n */\npublic class CaseInsensitiveMap extends AbstractHashedMap implements Serializable, Cloneable {\n\n    /** Serialisation version */\n    private static final long serialVersionUID = -7074655917369299456L;\n\n    /**\n     * Constructs a new empty map with default size and load factor.\n     */\n    public CaseInsensitiveMap() {\n        super(DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_THRESHOLD);\n    }\n\n    /**\n     * Constructs a new, empty map with the specified initial capacity. \n     *\n     * @param initialCapacity  the initial capacity\n     * @throws IllegalArgumentException if the initial capacity is less than one\n     */\n    public CaseInsensitiveMap(int initialCapacity) {\n        super(initialCapacity);\n    }\n\n    /**\n     * Constructs a new, empty map with the specified initial capacity and\n     * load factor. \n     *\n     * @param initialCapacity  the initial capacity\n     * @param loadFactor  the load factor\n     * @throws IllegalArgumentException if the initial capacity is less than one\n     * @throws IllegalArgumentException if the load factor is less than zero\n     */\n    public CaseInsensitiveMap(int initialCapacity, float loadFactor) {\n        super(initialCapacity, loadFactor);\n    }\n\n    /**\n     * Constructor copying elements from another map.\n     * <p>\n     * Keys will be converted to lower case strings, which may cause\n     * some entries to be removed (if string representation of keys differ\n     * only by character case).\n     *\n     * @param map  the map to copy\n     * @throws NullPointerException if the map is null\n     */\n    public CaseInsensitiveMap(Map map) {\n        super(map);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Overrides convertKey() from {@link AbstractHashedMap} to convert keys to \n     * lower case.\n     * <p>\n     * Returns {@link AbstractHashedMap#NULL} if key is null.\n     * \n     * @param key  the key convert\n     * @return the converted key\n     */\n    protected Object convertKey(Object key) {\n        if (key != null) {\n            return key.toString().toLowerCase();\n        } else {\n            return AbstractHashedMap.NULL;\n        }\n    }   \n\n    //-----------------------------------------------------------------------\n    /**\n     * Clones the map without cloning the keys or values.\n     *\n     * @return a shallow clone\n     */\n    public Object clone() {\n        return super.clone();\n    }\n\n    /**\n     * Write the map out using a custom routine.\n     */\n    private void writeObject(ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        doWriteObject(out);\n    }\n\n    /**\n     * Read the map in using a custom routine.\n     */\n    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        doReadObject(in);\n    }\n \n}\n", "fixed_version": "/*\n *  Licensed to the Apache Software Foundation (ASF) under one or more\n *  contributor license agreements.  See the NOTICE file distributed with\n *  this work for additional information regarding copyright ownership.\n *  The ASF licenses this file to You under the Apache License, Version 2.0\n *  (the \"License\"); you may not use this file except in compliance with\n *  the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.apache.commons.collections.map;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.Map;\n\n/**\n * A case-insensitive <code>Map</code>.\n * <p>\n * Before keys are added to the map or compared to other existing keys, they are converted\n * to all lowercase in a locale-independent fashion by using information from the Unicode\n * data file.\n * <p>\n * Null keys are supported.  \n * <p>\n * The <code>keySet()</code> method returns all lowercase keys, or nulls.\n * <p>\n * Example:\n * <pre><code>\n *  Map map = new CaseInsensitiveMap();\n *  map.put(\"One\", \"One\");\n *  map.put(\"Two\", \"Two\");\n *  map.put(null, \"Three\");\n *  map.put(\"one\", \"Four\");\n * </code></pre>\n * creates a <code>CaseInsensitiveMap</code> with three entries.<br>\n * <code>map.get(null)</code> returns <code>\"Three\"</code> and <code>map.get(\"ONE\")</code>\n * returns <code>\"Four\".</code>  The <code>Set</code> returned by <code>keySet()</code>\n * equals <code>{\"one\", \"two\", null}.</code>\n * <p>\n * <strong>Note that CaseInsensitiveMap is not synchronized and is not thread-safe.</strong>\n * If you wish to use this map from multiple threads concurrently, you must use\n * appropriate synchronization. The simplest approach is to wrap this map\n * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw \n * exceptions when accessed by concurrent threads without synchronization.\n *\n * @since Commons Collections 3.0\n * @version $Revision$ $Date$\n *\n * @author Commons-Collections team\n */\npublic class CaseInsensitiveMap extends AbstractHashedMap implements Serializable, Cloneable {\n\n    /** Serialisation version */\n    private static final long serialVersionUID = -7074655917369299456L;\n\n    /**\n     * Constructs a new empty map with default size and load factor.\n     */\n    public CaseInsensitiveMap() {\n        super(DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_THRESHOLD);\n    }\n\n    /**\n     * Constructs a new, empty map with the specified initial capacity. \n     *\n     * @param initialCapacity  the initial capacity\n     * @throws IllegalArgumentException if the initial capacity is less than one\n     */\n    public CaseInsensitiveMap(int initialCapacity) {\n        super(initialCapacity);\n    }\n\n    /**\n     * Constructs a new, empty map with the specified initial capacity and\n     * load factor. \n     *\n     * @param initialCapacity  the initial capacity\n     * @param loadFactor  the load factor\n     * @throws IllegalArgumentException if the initial capacity is less than one\n     * @throws IllegalArgumentException if the load factor is less than zero\n     */\n    public CaseInsensitiveMap(int initialCapacity, float loadFactor) {\n        super(initialCapacity, loadFactor);\n    }\n\n    /**\n     * Constructor copying elements from another map.\n     * <p>\n     * Keys will be converted to lower case strings, which may cause\n     * some entries to be removed (if string representation of keys differ\n     * only by character case).\n     *\n     * @param map  the map to copy\n     * @throws NullPointerException if the map is null\n     */\n    public CaseInsensitiveMap(Map map) {\n        super(map);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Overrides convertKey() from {@link AbstractHashedMap} to convert keys to \n     * lower case.\n     * <p>\n     * Returns {@link AbstractHashedMap#NULL} if key is null.\n     * \n     * @param key  the key convert\n     * @return the converted key\n     */\n    protected Object convertKey(Object key) {\n        if (key != null) {\n            char[] chars = key.toString().toCharArray();\n            for (int i = chars.length - 1; i >= 0; i--) {\n                chars[i] = Character.toLowerCase(Character.toUpperCase(chars[i]));\n            }\n            return new String(chars);\n        } else {\n            return AbstractHashedMap.NULL;\n        }\n    }   \n\n    //-----------------------------------------------------------------------\n    /**\n     * Clones the map without cloning the keys or values.\n     *\n     * @return a shallow clone\n     */\n    public Object clone() {\n        return super.clone();\n    }\n\n    /**\n     * Write the map out using a custom routine.\n     */\n    private void writeObject(ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        doWriteObject(out);\n    }\n\n    /**\n     * Read the map in using a custom routine.\n     */\n    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        doReadObject(in);\n    }\n \n}\n"}]}
{"project": "Collections", "bug_id": 15, "classes_modified": [{"class_name": "org.apache.commons.collections.list.SetUniqueList", "buggy_version": "/*\n *  Licensed to the Apache Software Foundation (ASF) under one or more\n *  contributor license agreements.  See the NOTICE file distributed with\n *  this work for additional information regarding copyright ownership.\n *  The ASF licenses this file to You under the Apache License, Version 2.0\n *  (the \"License\"); you may not use this file except in compliance with\n *  the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.apache.commons.collections.list;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Set;\n\nimport org.apache.commons.collections.iterators.AbstractIteratorDecorator;\nimport org.apache.commons.collections.iterators.AbstractListIteratorDecorator;\nimport org.apache.commons.collections.set.UnmodifiableSet;\n\n/**\n * Decorates a <code>List</code> to ensure that no duplicates are present\n * much like a <code>Set</code>.\n * <p>\n * The <code>List</code> interface makes certain assumptions/requirements.\n * This implementation breaks these in certain ways, but this is merely the\n * result of rejecting duplicates.\n * Each violation is explained in the method, but it should not affect you.\n * Bear in mind that Sets require immutable objects to function correctly.\n * <p>\n * The {@link org.apache.commons.collections.set.ListOrderedSet ListOrderedSet}\n * class provides an alternative approach, by wrapping an existing Set and\n * retaining insertion order in the iterator.\n * <p>\n * This class is Serializable from Commons Collections 3.1.\n *\n * @since Commons Collections 3.0\n * @version $Revision$ $Date$\n * \n * @author Matthew Hawthorne\n * @author Stephen Colebourne\n * @author Tom Dunham\n */\npublic class SetUniqueList extends AbstractSerializableListDecorator {\n\n    /** Serialization version */\n    private static final long serialVersionUID = 7196982186153478694L;\n\n    /**\n     * Internal Set to maintain uniqueness.\n     */\n    protected final Set set;\n\n    /**\n     * Factory method to create a SetList using the supplied list to retain order.\n     * <p>\n     * If the list contains duplicates, these are removed (first indexed one kept).\n     * A <code>HashSet</code> is used for the set behaviour.\n     * \n     * @param list  the list to decorate, must not be null\n     * @throws IllegalArgumentException if list is null\n     */\n    public static SetUniqueList decorate(List list) {\n        if (list == null) {\n            throw new IllegalArgumentException(\"List must not be null\");\n        }\n        if (list.isEmpty()) {\n            return new SetUniqueList(list, new HashSet());\n        } else {\n            List temp = new ArrayList(list);\n            list.clear();\n            SetUniqueList sl = new SetUniqueList(list, new HashSet());\n            sl.addAll(temp);\n            return sl;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructor that wraps (not copies) the List and specifies the set to use.\n     * <p>\n     * The set and list must both be correctly initialised to the same elements.\n     * \n     * @param set  the set to decorate, must not be null\n     * @param list  the list to decorate, must not be null\n     * @throws IllegalArgumentException if set or list is null\n     */\n    protected SetUniqueList(List list, Set set) {\n        super(list);\n        if (set == null) {\n            throw new IllegalArgumentException(\"Set must not be null\");\n        }\n        this.set = set;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets an unmodifiable view as a Set.\n     * \n     * @return an unmodifiable set view\n     */\n    public Set asSet() {\n        return UnmodifiableSet.decorate(set);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Adds an element to the list if it is not already present.\n     * <p>\n     * <i>(Violation)</i>\n     * The <code>List</code> interface requires that this method returns\n     * <code>true</code> always. However this class may return <code>false</code>\n     * because of the <code>Set</code> behaviour.\n     * \n     * @param object the object to add\n     * @return true if object was added\n     */\n    public boolean add(Object object) {\n        // gets initial size\n        final int sizeBefore = size();\n\n        // adds element if unique\n        add(size(), object);\n\n        // compares sizes to detect if collection changed\n        return (sizeBefore != size());\n    }\n\n    /**\n     * Adds an element to a specific index in the list if it is not already present.\n     * <p>\n     * <i>(Violation)</i>\n     * The <code>List</code> interface makes the assumption that the element is\n     * always inserted. This may not happen with this implementation.\n     * \n     * @param index  the index to insert at\n     * @param object  the object to add\n     */\n    public void add(int index, Object object) {\n        // adds element if it is not contained already\n        if (set.contains(object) == false) {\n            super.add(index, object);\n            set.add(object);\n        }\n    }\n\n    /**\n     * Adds a collection of objects to the end of the list avoiding duplicates.\n     * <p>\n     * Only elements that are not already in this list will be added, and\n     * duplicates from the specified collection will be ignored.\n     * <p>\n     * <i>(Violation)</i>\n     * The <code>List</code> interface makes the assumption that the elements\n     * are always inserted. This may not happen with this implementation.\n     * \n     * @param coll  the collection to add in iterator order\n     * @return true if this collection changed\n     */\n    public boolean addAll(Collection coll) {\n        return addAll(size(), coll);\n    }\n\n    /**\n     * Adds a collection of objects a specific index in the list avoiding \n     * duplicates.\n     * <p>\n     * Only elements that are not already in this list will be added, and\n     * duplicates from the specified collection will be ignored.\n     * <p>\n     * <i>(Violation)</i>\n     * The <code>List</code> interface makes the assumption that the elements\n     * are always inserted. This may not happen with this implementation.\n     * \n     * @param index  the index to insert at\n     * @param coll  the collection to add in iterator order\n     * @return true if this collection changed\n     */\n    public boolean addAll(int index, Collection coll) {\n        // gets initial size\n        final int sizeBefore = size();\n\n        // adds all elements\n        for (final Iterator it = coll.iterator(); it.hasNext();) {\n            int sizeBeforeAddNext = size();\n            add(index, it.next());\n            // if it was inserted, then increase the target index\n            if (sizeBeforeAddNext != size()) {\n              index++;\n            }\n        }\n\n        // compares sizes to detect if collection changed\n        return sizeBefore != size();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Sets the value at the specified index avoiding duplicates.\n     * <p>\n     * The object is set into the specified index.\n     * Afterwards, any previous duplicate is removed\n     * If the object is not already in the list then a normal set occurs.\n     * If it is present, then the old version is removed.\n     * \n     * @param index  the index to insert at\n     * @param object  the object to set\n     * @return the previous object\n     */\n    public Object set(int index, Object object) {\n        int pos = indexOf(object);\n        Object removed = super.set(index, object);\n\n        if (pos == -1 || pos == index) {\n            // the object is already in the uniq list\n            // (and it hasn't been swapped with itself)\n            return removed;\n        }\n\n        super.remove(pos);\n        set.remove(removed);  // remove the item deleted by the set\n\n        return removed;  // return the item deleted by the set\n    }\n\n    public boolean remove(Object object) {\n        boolean result = super.remove(object);\n        set.remove(object);\n        return result;\n    }\n\n    public Object remove(int index) {\n        Object result = super.remove(index);\n        set.remove(result);\n        return result;\n    }\n\n    public boolean removeAll(Collection coll) {\n        boolean result = super.removeAll(coll);\n        set.removeAll(coll);\n        return result;\n    }\n\n    public boolean retainAll(Collection coll) {\n        boolean result = super.retainAll(coll);\n        set.retainAll(coll);\n        return result;\n    }\n\n    public void clear() {\n        super.clear();\n        set.clear();\n    }\n\n    public boolean contains(Object object) {\n        return set.contains(object);\n    }\n\n    public boolean containsAll(Collection coll) {\n        return set.containsAll(coll);\n    }\n\n    public Iterator iterator() {\n        return new SetListIterator(super.iterator(), set);\n    }\n\n    public ListIterator listIterator() {\n        return new SetListListIterator(super.listIterator(), set);\n    }\n\n    public ListIterator listIterator(int index) {\n        return new SetListListIterator(super.listIterator(index), set);\n    }\n\n    public List subList(int fromIndex, int toIndex) {\n        return new SetUniqueList(super.subList(fromIndex, toIndex), set);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Inner class iterator.\n     */\n    static class SetListIterator extends AbstractIteratorDecorator {\n        \n        protected final Set set;\n        protected Object last = null;\n        \n        protected SetListIterator(Iterator it, Set set) {\n            super(it);\n            this.set = set;\n        }\n        \n        public Object next() {\n            last = super.next();\n            return last;\n        }\n\n        public void remove() {\n            super.remove();\n            set.remove(last);\n            last = null;\n        }\n    }\n    \n    /**\n     * Inner class iterator.\n     */\n    static class SetListListIterator extends AbstractListIteratorDecorator {\n        \n        protected final Set set;\n        protected Object last = null;\n        \n        protected SetListListIterator(ListIterator it, Set set) {\n            super(it);\n            this.set = set;\n        }\n        \n        public Object next() {\n            last = super.next();\n            return last;\n        }\n\n        public Object previous() {\n            last = super.previous();\n            return last;\n        }\n\n        public void remove() {\n            super.remove();\n            set.remove(last);\n            last = null;\n        }\n\n        public void add(Object object) {\n            if (set.contains(object) == false) {\n                super.add(object);\n                set.add(object);\n            }\n        }\n        \n        public void set(Object object) {\n            throw new UnsupportedOperationException(\"ListIterator does not support set\");\n        }\n    }\n    \n}\n", "fixed_version": "/*\n *  Licensed to the Apache Software Foundation (ASF) under one or more\n *  contributor license agreements.  See the NOTICE file distributed with\n *  this work for additional information regarding copyright ownership.\n *  The ASF licenses this file to You under the Apache License, Version 2.0\n *  (the \"License\"); you may not use this file except in compliance with\n *  the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.apache.commons.collections.list;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Set;\n\nimport org.apache.commons.collections.iterators.AbstractIteratorDecorator;\nimport org.apache.commons.collections.iterators.AbstractListIteratorDecorator;\nimport org.apache.commons.collections.set.UnmodifiableSet;\n\n/**\n * Decorates a <code>List</code> to ensure that no duplicates are present\n * much like a <code>Set</code>.\n * <p>\n * The <code>List</code> interface makes certain assumptions/requirements.\n * This implementation breaks these in certain ways, but this is merely the\n * result of rejecting duplicates.\n * Each violation is explained in the method, but it should not affect you.\n * Bear in mind that Sets require immutable objects to function correctly.\n * <p>\n * The {@link org.apache.commons.collections.set.ListOrderedSet ListOrderedSet}\n * class provides an alternative approach, by wrapping an existing Set and\n * retaining insertion order in the iterator.\n * <p>\n * This class is Serializable from Commons Collections 3.1.\n *\n * @since Commons Collections 3.0\n * @version $Revision$ $Date$\n * \n * @author Matthew Hawthorne\n * @author Stephen Colebourne\n * @author Tom Dunham\n */\npublic class SetUniqueList extends AbstractSerializableListDecorator {\n\n    /** Serialization version */\n    private static final long serialVersionUID = 7196982186153478694L;\n\n    /**\n     * Internal Set to maintain uniqueness.\n     */\n    protected final Set set;\n\n    /**\n     * Factory method to create a SetList using the supplied list to retain order.\n     * <p>\n     * If the list contains duplicates, these are removed (first indexed one kept).\n     * A <code>HashSet</code> is used for the set behaviour.\n     * \n     * @param list  the list to decorate, must not be null\n     * @throws IllegalArgumentException if list is null\n     */\n    public static SetUniqueList decorate(List list) {\n        if (list == null) {\n            throw new IllegalArgumentException(\"List must not be null\");\n        }\n        if (list.isEmpty()) {\n            return new SetUniqueList(list, new HashSet());\n        } else {\n            List temp = new ArrayList(list);\n            list.clear();\n            SetUniqueList sl = new SetUniqueList(list, new HashSet());\n            sl.addAll(temp);\n            return sl;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructor that wraps (not copies) the List and specifies the set to use.\n     * <p>\n     * The set and list must both be correctly initialised to the same elements.\n     * \n     * @param set  the set to decorate, must not be null\n     * @param list  the list to decorate, must not be null\n     * @throws IllegalArgumentException if set or list is null\n     */\n    protected SetUniqueList(List list, Set set) {\n        super(list);\n        if (set == null) {\n            throw new IllegalArgumentException(\"Set must not be null\");\n        }\n        this.set = set;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets an unmodifiable view as a Set.\n     * \n     * @return an unmodifiable set view\n     */\n    public Set asSet() {\n        return UnmodifiableSet.decorate(set);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Adds an element to the list if it is not already present.\n     * <p>\n     * <i>(Violation)</i>\n     * The <code>List</code> interface requires that this method returns\n     * <code>true</code> always. However this class may return <code>false</code>\n     * because of the <code>Set</code> behaviour.\n     * \n     * @param object the object to add\n     * @return true if object was added\n     */\n    public boolean add(Object object) {\n        // gets initial size\n        final int sizeBefore = size();\n\n        // adds element if unique\n        add(size(), object);\n\n        // compares sizes to detect if collection changed\n        return (sizeBefore != size());\n    }\n\n    /**\n     * Adds an element to a specific index in the list if it is not already present.\n     * <p>\n     * <i>(Violation)</i>\n     * The <code>List</code> interface makes the assumption that the element is\n     * always inserted. This may not happen with this implementation.\n     * \n     * @param index  the index to insert at\n     * @param object  the object to add\n     */\n    public void add(int index, Object object) {\n        // adds element if it is not contained already\n        if (set.contains(object) == false) {\n            super.add(index, object);\n            set.add(object);\n        }\n    }\n\n    /**\n     * Adds a collection of objects to the end of the list avoiding duplicates.\n     * <p>\n     * Only elements that are not already in this list will be added, and\n     * duplicates from the specified collection will be ignored.\n     * <p>\n     * <i>(Violation)</i>\n     * The <code>List</code> interface makes the assumption that the elements\n     * are always inserted. This may not happen with this implementation.\n     * \n     * @param coll  the collection to add in iterator order\n     * @return true if this collection changed\n     */\n    public boolean addAll(Collection coll) {\n        return addAll(size(), coll);\n    }\n\n    /**\n     * Adds a collection of objects a specific index in the list avoiding \n     * duplicates.\n     * <p>\n     * Only elements that are not already in this list will be added, and\n     * duplicates from the specified collection will be ignored.\n     * <p>\n     * <i>(Violation)</i>\n     * The <code>List</code> interface makes the assumption that the elements\n     * are always inserted. This may not happen with this implementation.\n     * \n     * @param index  the index to insert at\n     * @param coll  the collection to add in iterator order\n     * @return true if this collection changed\n     */\n    public boolean addAll(int index, Collection coll) {\n        // gets initial size\n        final int sizeBefore = size();\n\n        // adds all elements\n        for (final Iterator it = coll.iterator(); it.hasNext();) {\n            int sizeBeforeAddNext = size();\n            add(index, it.next());\n            // if it was inserted, then increase the target index\n            if (sizeBeforeAddNext != size()) {\n              index++;\n            }\n        }\n\n        // compares sizes to detect if collection changed\n        return sizeBefore != size();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Sets the value at the specified index avoiding duplicates.\n     * <p>\n     * The object is set into the specified index.\n     * Afterwards, any previous duplicate is removed\n     * If the object is not already in the list then a normal set occurs.\n     * If it is present, then the old version is removed.\n     * \n     * @param index  the index to insert at\n     * @param object  the object to set\n     * @return the previous object\n     */\n    public Object set(int index, Object object) {\n        int pos = indexOf(object);\n        Object removed = super.set(index, object);\n\n        if (pos != -1 && pos != index) {\n            // the object is already in the uniq list\n            // (and it hasn't been swapped with itself)\n            super.remove(pos);  // remove the duplicate by index\n        }\n\n        set.add(object);      // add the new item to the unique set\n        set.remove(removed);  // remove the item deleted by the set\n\n        return removed;  // return the item deleted by the set\n    }\n\n    public boolean remove(Object object) {\n        boolean result = super.remove(object);\n        set.remove(object);\n        return result;\n    }\n\n    public Object remove(int index) {\n        Object result = super.remove(index);\n        set.remove(result);\n        return result;\n    }\n\n    public boolean removeAll(Collection coll) {\n        boolean result = super.removeAll(coll);\n        set.removeAll(coll);\n        return result;\n    }\n\n    public boolean retainAll(Collection coll) {\n        boolean result = super.retainAll(coll);\n        set.retainAll(coll);\n        return result;\n    }\n\n    public void clear() {\n        super.clear();\n        set.clear();\n    }\n\n    public boolean contains(Object object) {\n        return set.contains(object);\n    }\n\n    public boolean containsAll(Collection coll) {\n        return set.containsAll(coll);\n    }\n\n    public Iterator iterator() {\n        return new SetListIterator(super.iterator(), set);\n    }\n\n    public ListIterator listIterator() {\n        return new SetListListIterator(super.listIterator(), set);\n    }\n\n    public ListIterator listIterator(int index) {\n        return new SetListListIterator(super.listIterator(index), set);\n    }\n\n    public List subList(int fromIndex, int toIndex) {\n        return new SetUniqueList(super.subList(fromIndex, toIndex), set);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Inner class iterator.\n     */\n    static class SetListIterator extends AbstractIteratorDecorator {\n        \n        protected final Set set;\n        protected Object last = null;\n        \n        protected SetListIterator(Iterator it, Set set) {\n            super(it);\n            this.set = set;\n        }\n        \n        public Object next() {\n            last = super.next();\n            return last;\n        }\n\n        public void remove() {\n            super.remove();\n            set.remove(last);\n            last = null;\n        }\n    }\n    \n    /**\n     * Inner class iterator.\n     */\n    static class SetListListIterator extends AbstractListIteratorDecorator {\n        \n        protected final Set set;\n        protected Object last = null;\n        \n        protected SetListListIterator(ListIterator it, Set set) {\n            super(it);\n            this.set = set;\n        }\n        \n        public Object next() {\n            last = super.next();\n            return last;\n        }\n\n        public Object previous() {\n            last = super.previous();\n            return last;\n        }\n\n        public void remove() {\n            super.remove();\n            set.remove(last);\n            last = null;\n        }\n\n        public void add(Object object) {\n            if (set.contains(object) == false) {\n                super.add(object);\n                set.add(object);\n            }\n        }\n        \n        public void set(Object object) {\n            throw new UnsupportedOperationException(\"ListIterator does not support set\");\n        }\n    }\n    \n}\n"}]}
{"project": "Collections", "bug_id": 16, "classes_modified": [{"class_name": "org.apache.commons.collections.list.SetUniqueList", "buggy_version": "/*\n *  Licensed to the Apache Software Foundation (ASF) under one or more\n *  contributor license agreements.  See the NOTICE file distributed with\n *  this work for additional information regarding copyright ownership.\n *  The ASF licenses this file to You under the Apache License, Version 2.0\n *  (the \"License\"); you may not use this file except in compliance with\n *  the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.apache.commons.collections.list;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Set;\n\nimport org.apache.commons.collections.iterators.AbstractIteratorDecorator;\nimport org.apache.commons.collections.iterators.AbstractListIteratorDecorator;\nimport org.apache.commons.collections.set.UnmodifiableSet;\n\n/**\n * Decorates a <code>List</code> to ensure that no duplicates are present\n * much like a <code>Set</code>.\n * <p>\n * The <code>List</code> interface makes certain assumptions/requirements.\n * This implementation breaks these in certain ways, but this is merely the\n * result of rejecting duplicates.\n * Each violation is explained in the method, but it should not affect you.\n * Bear in mind that Sets require immutable objects to function correctly.\n * <p>\n * The {@link org.apache.commons.collections.set.ListOrderedSet ListOrderedSet}\n * class provides an alternative approach, by wrapping an existing Set and\n * retaining insertion order in the iterator.\n * <p>\n * This class is Serializable from Commons Collections 3.1.\n *\n * @since Commons Collections 3.0\n * @version $Revision$ $Date$\n * \n * @author Matthew Hawthorne\n * @author Stephen Colebourne\n * @author Tom Dunham\n */\npublic class SetUniqueList extends AbstractSerializableListDecorator {\n\n    /** Serialization version */\n    private static final long serialVersionUID = 7196982186153478694L;\n\n    /**\n     * Internal Set to maintain uniqueness.\n     */\n    protected final Set set;\n\n    /**\n     * Factory method to create a SetList using the supplied list to retain order.\n     * <p>\n     * If the list contains duplicates, these are removed (first indexed one kept).\n     * A <code>HashSet</code> is used for the set behaviour.\n     * \n     * @param list  the list to decorate, must not be null\n     * @throws IllegalArgumentException if list is null\n     */\n    public static SetUniqueList decorate(List list) {\n        if (list == null) {\n            throw new IllegalArgumentException(\"List must not be null\");\n        }\n        if (list.isEmpty()) {\n            return new SetUniqueList(list, new HashSet());\n        } else {\n            List temp = new ArrayList(list);\n            list.clear();\n            SetUniqueList sl = new SetUniqueList(list, new HashSet());\n            sl.addAll(temp);\n            return sl;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructor that wraps (not copies) the List and specifies the set to use.\n     * <p>\n     * The set and list must both be correctly initialised to the same elements.\n     * \n     * @param set  the set to decorate, must not be null\n     * @param list  the list to decorate, must not be null\n     * @throws IllegalArgumentException if set or list is null\n     */\n    protected SetUniqueList(List list, Set set) {\n        super(list);\n        if (set == null) {\n            throw new IllegalArgumentException(\"Set must not be null\");\n        }\n        this.set = set;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets an unmodifiable view as a Set.\n     * \n     * @return an unmodifiable set view\n     */\n    public Set asSet() {\n        return UnmodifiableSet.decorate(set);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Adds an element to the list if it is not already present.\n     * <p>\n     * <i>(Violation)</i>\n     * The <code>List</code> interface requires that this method returns\n     * <code>true</code> always. However this class may return <code>false</code>\n     * because of the <code>Set</code> behaviour.\n     * \n     * @param object the object to add\n     * @return true if object was added\n     */\n    public boolean add(Object object) {\n        // gets initial size\n        final int sizeBefore = size();\n\n        // adds element if unique\n        add(size(), object);\n\n        // compares sizes to detect if collection changed\n        return (sizeBefore != size());\n    }\n\n    /**\n     * Adds an element to a specific index in the list if it is not already present.\n     * <p>\n     * <i>(Violation)</i>\n     * The <code>List</code> interface makes the assumption that the element is\n     * always inserted. This may not happen with this implementation.\n     * \n     * @param index  the index to insert at\n     * @param object  the object to add\n     */\n    public void add(int index, Object object) {\n        // adds element if it is not contained already\n        if (set.contains(object) == false) {\n            super.add(index, object);\n            set.add(object);\n        }\n    }\n\n    /**\n     * Adds a collection of objects to the end of the list avoiding duplicates.\n     * <p>\n     * Only elements that are not already in this list will be added, and\n     * duplicates from the specified collection will be ignored.\n     * <p>\n     * <i>(Violation)</i>\n     * The <code>List</code> interface makes the assumption that the elements\n     * are always inserted. This may not happen with this implementation.\n     * \n     * @param coll  the collection to add in iterator order\n     * @return true if this collection changed\n     */\n    public boolean addAll(Collection coll) {\n        return addAll(size(), coll);\n    }\n\n    /**\n     * Adds a collection of objects a specific index in the list avoiding \n     * duplicates.\n     * <p>\n     * Only elements that are not already in this list will be added, and\n     * duplicates from the specified collection will be ignored.\n     * <p>\n     * <i>(Violation)</i>\n     * The <code>List</code> interface makes the assumption that the elements\n     * are always inserted. This may not happen with this implementation.\n     * \n     * @param index  the index to insert at\n     * @param coll  the collection to add in iterator order\n     * @return true if this collection changed\n     */\n    public boolean addAll(int index, Collection coll) {\n        // gets initial size\n        final int sizeBefore = size();\n\n        // adds all elements\n        for (final Iterator it = coll.iterator(); it.hasNext();) {\n            int sizeBeforeAddNext = size();\n            add(index, it.next());\n            // if it was inserted, then increase the target index\n            if (sizeBeforeAddNext != size()) {\n              index++;\n            }\n        }\n\n        // compares sizes to detect if collection changed\n        return sizeBefore != size();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Sets the value at the specified index avoiding duplicates.\n     * <p>\n     * The object is set into the specified index.\n     * Afterwards, any previous duplicate is removed\n     * If the object is not already in the list then a normal set occurs.\n     * If it is present, then the old version is removed.\n     * \n     * @param index  the index to insert at\n     * @param object  the object to set\n     * @return the previous object\n     */\n    public Object set(int index, Object object) {\n        int pos = indexOf(object);\n        Object removed = super.set(index, object);\n\n        if (pos != -1 && pos != index) {\n            // the object is already in the uniq list\n            // (and it hasn't been swapped with itself)\n            super.remove(pos);  // remove the duplicate by index\n        }\n\n        set.add(object);      // add the new item to the unique set\n        set.remove(removed);  // remove the item deleted by the set\n\n        return removed;  // return the item deleted by the set\n    }\n\n    public boolean remove(Object object) {\n        boolean result = super.remove(object);\n        set.remove(object);\n        return result;\n    }\n\n    public Object remove(int index) {\n        Object result = super.remove(index);\n        set.remove(result);\n        return result;\n    }\n\n    public boolean removeAll(Collection coll) {\n        boolean result = super.removeAll(coll);\n        set.removeAll(coll);\n        return result;\n    }\n\n    public boolean retainAll(Collection coll) {\n        boolean result = super.retainAll(coll);\n        set.retainAll(coll);\n        return result;\n    }\n\n    public void clear() {\n        super.clear();\n        set.clear();\n    }\n\n    public boolean contains(Object object) {\n        return set.contains(object);\n    }\n\n    public boolean containsAll(Collection coll) {\n        return set.containsAll(coll);\n    }\n\n    public Iterator iterator() {\n        return new SetListIterator(super.iterator(), set);\n    }\n\n    public ListIterator listIterator() {\n        return new SetListListIterator(super.listIterator(), set);\n    }\n\n    public ListIterator listIterator(int index) {\n        return new SetListListIterator(super.listIterator(index), set);\n    }\n\n    public List subList(int fromIndex, int toIndex) {\n        return new SetUniqueList(super.subList(fromIndex, toIndex), set);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Inner class iterator.\n     */\n    static class SetListIterator extends AbstractIteratorDecorator {\n        \n        protected final Set set;\n        protected Object last = null;\n        \n        protected SetListIterator(Iterator it, Set set) {\n            super(it);\n            this.set = set;\n        }\n        \n        public Object next() {\n            last = super.next();\n            return last;\n        }\n\n        public void remove() {\n            super.remove();\n            set.remove(last);\n            last = null;\n        }\n    }\n    \n    /**\n     * Inner class iterator.\n     */\n    static class SetListListIterator extends AbstractListIteratorDecorator {\n        \n        protected final Set set;\n        protected Object last = null;\n        \n        protected SetListListIterator(ListIterator it, Set set) {\n            super(it);\n            this.set = set;\n        }\n        \n        public Object next() {\n            last = super.next();\n            return last;\n        }\n\n        public Object previous() {\n            last = super.previous();\n            return last;\n        }\n\n        public void remove() {\n            super.remove();\n            set.remove(last);\n            last = null;\n        }\n\n        public void add(Object object) {\n            if (set.contains(object) == false) {\n                super.add(object);\n                set.add(object);\n            }\n        }\n        \n        public void set(Object object) {\n            throw new UnsupportedOperationException(\"ListIterator does not support set\");\n        }\n    }\n    \n}\n", "fixed_version": "/*\n *  Licensed to the Apache Software Foundation (ASF) under one or more\n *  contributor license agreements.  See the NOTICE file distributed with\n *  this work for additional information regarding copyright ownership.\n *  The ASF licenses this file to You under the Apache License, Version 2.0\n *  (the \"License\"); you may not use this file except in compliance with\n *  the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.apache.commons.collections.list;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Set;\n\nimport org.apache.commons.collections.iterators.AbstractIteratorDecorator;\nimport org.apache.commons.collections.iterators.AbstractListIteratorDecorator;\nimport org.apache.commons.collections.set.UnmodifiableSet;\n\n/**\n * Decorates a <code>List</code> to ensure that no duplicates are present\n * much like a <code>Set</code>.\n * <p>\n * The <code>List</code> interface makes certain assumptions/requirements.\n * This implementation breaks these in certain ways, but this is merely the\n * result of rejecting duplicates.\n * Each violation is explained in the method, but it should not affect you.\n * Bear in mind that Sets require immutable objects to function correctly.\n * <p>\n * The {@link org.apache.commons.collections.set.ListOrderedSet ListOrderedSet}\n * class provides an alternative approach, by wrapping an existing Set and\n * retaining insertion order in the iterator.\n * <p>\n * This class is Serializable from Commons Collections 3.1.\n *\n * @since Commons Collections 3.0\n * @version $Revision$ $Date$\n * \n * @author Matthew Hawthorne\n * @author Stephen Colebourne\n * @author Tom Dunham\n */\npublic class SetUniqueList extends AbstractSerializableListDecorator {\n\n    /** Serialization version */\n    private static final long serialVersionUID = 7196982186153478694L;\n\n    /**\n     * Internal Set to maintain uniqueness.\n     */\n    protected final Set set;\n\n    /**\n     * Factory method to create a SetList using the supplied list to retain order.\n     * <p>\n     * If the list contains duplicates, these are removed (first indexed one kept).\n     * A <code>HashSet</code> is used for the set behaviour.\n     * \n     * @param list  the list to decorate, must not be null\n     * @throws IllegalArgumentException if list is null\n     */\n    public static SetUniqueList decorate(List list) {\n        if (list == null) {\n            throw new IllegalArgumentException(\"List must not be null\");\n        }\n        if (list.isEmpty()) {\n            return new SetUniqueList(list, new HashSet());\n        } else {\n            List temp = new ArrayList(list);\n            list.clear();\n            SetUniqueList sl = new SetUniqueList(list, new HashSet());\n            sl.addAll(temp);\n            return sl;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructor that wraps (not copies) the List and specifies the set to use.\n     * <p>\n     * The set and list must both be correctly initialised to the same elements.\n     * \n     * @param set  the set to decorate, must not be null\n     * @param list  the list to decorate, must not be null\n     * @throws IllegalArgumentException if set or list is null\n     */\n    protected SetUniqueList(List list, Set set) {\n        super(list);\n        if (set == null) {\n            throw new IllegalArgumentException(\"Set must not be null\");\n        }\n        this.set = set;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets an unmodifiable view as a Set.\n     * \n     * @return an unmodifiable set view\n     */\n    public Set asSet() {\n        return UnmodifiableSet.decorate(set);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Adds an element to the list if it is not already present.\n     * <p>\n     * <i>(Violation)</i>\n     * The <code>List</code> interface requires that this method returns\n     * <code>true</code> always. However this class may return <code>false</code>\n     * because of the <code>Set</code> behaviour.\n     * \n     * @param object the object to add\n     * @return true if object was added\n     */\n    public boolean add(Object object) {\n        // gets initial size\n        final int sizeBefore = size();\n\n        // adds element if unique\n        add(size(), object);\n\n        // compares sizes to detect if collection changed\n        return (sizeBefore != size());\n    }\n\n    /**\n     * Adds an element to a specific index in the list if it is not already present.\n     * <p>\n     * <i>(Violation)</i>\n     * The <code>List</code> interface makes the assumption that the element is\n     * always inserted. This may not happen with this implementation.\n     * \n     * @param index  the index to insert at\n     * @param object  the object to add\n     */\n    public void add(int index, Object object) {\n        // adds element if it is not contained already\n        if (set.contains(object) == false) {\n            super.add(index, object);\n            set.add(object);\n        }\n    }\n\n    /**\n     * Adds a collection of objects to the end of the list avoiding duplicates.\n     * <p>\n     * Only elements that are not already in this list will be added, and\n     * duplicates from the specified collection will be ignored.\n     * <p>\n     * <i>(Violation)</i>\n     * The <code>List</code> interface makes the assumption that the elements\n     * are always inserted. This may not happen with this implementation.\n     * \n     * @param coll  the collection to add in iterator order\n     * @return true if this collection changed\n     */\n    public boolean addAll(Collection coll) {\n        return addAll(size(), coll);\n    }\n\n    /**\n     * Adds a collection of objects a specific index in the list avoiding \n     * duplicates.\n     * <p>\n     * Only elements that are not already in this list will be added, and\n     * duplicates from the specified collection will be ignored.\n     * <p>\n     * <i>(Violation)</i>\n     * The <code>List</code> interface makes the assumption that the elements\n     * are always inserted. This may not happen with this implementation.\n     * \n     * @param index  the index to insert at\n     * @param coll  the collection to add in iterator order\n     * @return true if this collection changed\n     */\n    public boolean addAll(int index, Collection coll) {\n        // gets initial size\n        final int sizeBefore = size();\n\n        // adds all elements\n        for (final Iterator it = coll.iterator(); it.hasNext();) {\n            int sizeBeforeAddNext = size();\n            add(index, it.next());\n            // if it was inserted, then increase the target index\n            if (sizeBeforeAddNext != size()) {\n              index++;\n            }\n        }\n\n        // compares sizes to detect if collection changed\n        return sizeBefore != size();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Sets the value at the specified index avoiding duplicates.\n     * <p>\n     * The object is set into the specified index.\n     * Afterwards, any previous duplicate is removed\n     * If the object is not already in the list then a normal set occurs.\n     * If it is present, then the old version is removed.\n     * \n     * @param index  the index to insert at\n     * @param object  the object to set\n     * @return the previous object\n     */\n    public Object set(int index, Object object) {\n        int pos = indexOf(object);\n        Object removed = super.set(index, object);\n\n        if (pos != -1 && pos != index) {\n            // the object is already in the uniq list\n            // (and it hasn't been swapped with itself)\n            super.remove(pos);  // remove the duplicate by index\n        }\n\n        set.add(object);      // add the new item to the unique set\n        set.remove(removed);  // remove the item deleted by the set\n\n        return removed;  // return the item deleted by the set\n    }\n\n    public boolean remove(Object object) {\n        boolean result = super.remove(object);\n        set.remove(object);\n        return result;\n    }\n\n    public Object remove(int index) {\n        Object result = super.remove(index);\n        set.remove(result);\n        return result;\n    }\n\n    public boolean removeAll(Collection coll) {\n        boolean result = super.removeAll(coll);\n        set.removeAll(coll);\n        return result;\n    }\n\n    public boolean retainAll(Collection coll) {\n        boolean result = super.retainAll(coll);\n        set.retainAll(coll);\n        return result;\n    }\n\n    public void clear() {\n        super.clear();\n        set.clear();\n    }\n\n    public boolean contains(Object object) {\n        return set.contains(object);\n    }\n\n    public boolean containsAll(Collection coll) {\n        return set.containsAll(coll);\n    }\n\n    public Iterator iterator() {\n        return new SetListIterator(super.iterator(), set);\n    }\n\n    public ListIterator listIterator() {\n        return new SetListListIterator(super.listIterator(), set);\n    }\n\n    public ListIterator listIterator(int index) {\n        return new SetListListIterator(super.listIterator(index), set);\n    }\n\n    public List subList(int fromIndex, int toIndex) {\n        List superSubList = super.subList(fromIndex, toIndex);\n        Set subSet = createSetBasedOnList(set, superSubList);\n        return new SetUniqueList(superSubList, subSet);\n    }\n\n    protected Set createSetBasedOnList(Set set, List list) {\n        Set subSet = null;\n        if(set.getClass().equals(HashSet.class)) {\n            subSet = new HashSet();\n        } else {\n            try {\n                subSet = (Set) set.getClass().newInstance();\n            } catch(InstantiationException ie) {\n                subSet = new HashSet();\n            } catch(IllegalAccessException iae) {\n                subSet = new HashSet();\n            }\n        }\n        subSet.addAll(list);\n        return subSet;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Inner class iterator.\n     */\n    static class SetListIterator extends AbstractIteratorDecorator {\n        \n        protected final Set set;\n        protected Object last = null;\n        \n        protected SetListIterator(Iterator it, Set set) {\n            super(it);\n            this.set = set;\n        }\n        \n        public Object next() {\n            last = super.next();\n            return last;\n        }\n\n        public void remove() {\n            super.remove();\n            set.remove(last);\n            last = null;\n        }\n    }\n    \n    /**\n     * Inner class iterator.\n     */\n    static class SetListListIterator extends AbstractListIteratorDecorator {\n        \n        protected final Set set;\n        protected Object last = null;\n        \n        protected SetListListIterator(ListIterator it, Set set) {\n            super(it);\n            this.set = set;\n        }\n        \n        public Object next() {\n            last = super.next();\n            return last;\n        }\n\n        public Object previous() {\n            last = super.previous();\n            return last;\n        }\n\n        public void remove() {\n            super.remove();\n            set.remove(last);\n            last = null;\n        }\n\n        public void add(Object object) {\n            if (set.contains(object) == false) {\n                super.add(object);\n                set.add(object);\n            }\n        }\n        \n        public void set(Object object) {\n            throw new UnsupportedOperationException(\"ListIterator does not support set\");\n        }\n    }\n    \n}\n"}]}
{"project": "Collections", "bug_id": 17, "classes_modified": [{"class_name": "org.apache.commons.collections.functors.EqualPredicate", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections.functors;\n\nimport static org.apache.commons.collections.functors.NullPredicate.nullPredicate;\n\nimport java.io.Serializable;\n\nimport org.apache.commons.collections.Predicate;\n\n/**\n * Predicate implementation that returns true if the input is the same object\n * as the one stored in this predicate by equals.\n *\n * @since 3.0\n * @version $Id$\n */\npublic final class EqualPredicate<T> implements Predicate<T>, Serializable {\n\n    /** Serial version UID */\n    private static final long serialVersionUID = 5633766978029907089L;\n\n    /** The value to compare to */\n    private final T iValue;\n    \n    /** The equator to use for comparison */\n    private final Equator<T> equator;\n\n    /**\n     * Factory to create the predicate.\n     * \n     * @param <T> the type that the predicate queries\n     * @param object  the object to compare to\n     * @return the predicate\n     * @throws IllegalArgumentException if the predicate is null\n     */\n    public static <T> Predicate<T> equalPredicate(T object) {\n        if (object == null) {\n            return nullPredicate();\n        }\n        return new EqualPredicate<T>(object);\n    }\n\n    /**\n     * Factory to create the identity predicate.\n     * \n     * @param <T> the type that the predicate queries\n     * @param object  the object to compare to\n     * @param equator  the equator to use for comparison\n     * @return the predicate\n     * @throws IllegalArgumentException if the predicate is null\n     * @since 4.0\n     */\n    public static <T> Predicate<T> equalPredicate(T object, Equator<T> equator) {\n        if (object == null) {\n            return nullPredicate();\n        }\n        return new EqualPredicate<T>(object, equator);\n    }\n\n    /**\n     * Constructor that performs no validation.\n     * Use <code>getInstance</code> if you want that.\n     * \n     * @param object  the object to compare to\n     */\n    public EqualPredicate(T object) {\n        // do not use the DefaultEquator to keep backwards compatibility\n        // the DefaultEquator returns also true if the two object references are equal\n        this(object, new DefaultEquator<T>());\n    }\n\n    /**\n     * Constructor that performs no validation.\n     * Use <code>getInstance</code> if you want that.\n     * \n     * @param object  the object to compare to\n     * @param equator  the equator to use for comparison\n     * @since 4.0\n     */\n    public EqualPredicate(T object, Equator<T> equator) {\n        super();\n        iValue = object;\n        this.equator = equator;\n    }\n\n    /**\n     * Evaluates the predicate returning true if the input equals the stored value.\n     * \n     * @param object  the input object\n     * @return true if input object equals stored value\n     */\n    public boolean evaluate(T object) {\n            return equator.equate(iValue, object);\n    }\n\n    /**\n     * Gets the value.\n     * \n     * @return the value\n     * @since 3.1\n     */\n    public Object getValue() {\n        return iValue;\n    }\n\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections.functors;\n\nimport static org.apache.commons.collections.functors.NullPredicate.nullPredicate;\n\nimport java.io.Serializable;\n\nimport org.apache.commons.collections.Predicate;\n\n/**\n * Predicate implementation that returns true if the input is the same object\n * as the one stored in this predicate by equals.\n *\n * @since 3.0\n * @version $Id$\n */\npublic final class EqualPredicate<T> implements Predicate<T>, Serializable {\n\n    /** Serial version UID */\n    private static final long serialVersionUID = 5633766978029907089L;\n\n    /** The value to compare to */\n    private final T iValue;\n    \n    /** The equator to use for comparison */\n    private final Equator<T> equator;\n\n    /**\n     * Factory to create the predicate.\n     * \n     * @param <T> the type that the predicate queries\n     * @param object  the object to compare to\n     * @return the predicate\n     * @throws IllegalArgumentException if the predicate is null\n     */\n    public static <T> Predicate<T> equalPredicate(T object) {\n        if (object == null) {\n            return nullPredicate();\n        }\n        return new EqualPredicate<T>(object);\n    }\n\n    /**\n     * Factory to create the identity predicate.\n     * \n     * @param <T> the type that the predicate queries\n     * @param object  the object to compare to\n     * @param equator  the equator to use for comparison\n     * @return the predicate\n     * @throws IllegalArgumentException if the predicate is null\n     * @since 4.0\n     */\n    public static <T> Predicate<T> equalPredicate(T object, Equator<T> equator) {\n        if (object == null) {\n            return nullPredicate();\n        }\n        return new EqualPredicate<T>(object, equator);\n    }\n\n    /**\n     * Constructor that performs no validation.\n     * Use <code>getInstance</code> if you want that.\n     * \n     * @param object  the object to compare to\n     */\n    public EqualPredicate(T object) {\n        // do not use the DefaultEquator to keep backwards compatibility\n        // the DefaultEquator returns also true if the two object references are equal\n        this(object, null);\n    }\n\n    /**\n     * Constructor that performs no validation.\n     * Use <code>getInstance</code> if you want that.\n     * \n     * @param object  the object to compare to\n     * @param equator  the equator to use for comparison\n     * @since 4.0\n     */\n    public EqualPredicate(T object, Equator<T> equator) {\n        super();\n        iValue = object;\n        this.equator = equator;\n    }\n\n    /**\n     * Evaluates the predicate returning true if the input equals the stored value.\n     * \n     * @param object  the input object\n     * @return true if input object equals stored value\n     */\n    public boolean evaluate(T object) {\n        if (equator != null) {\n            return equator.equate(iValue, object);\n        } else {\n            return iValue.equals(object);\n        }\n    }\n\n    /**\n     * Gets the value.\n     * \n     * @return the value\n     * @since 3.1\n     */\n    public Object getValue() {\n        return iValue;\n    }\n\n}\n"}]}
{"project": "Collections", "bug_id": 18, "classes_modified": [{"class_name": "org.apache.commons.collections.set.ListOrderedSet", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections.set;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Set;\n\nimport org.apache.commons.collections.OrderedIterator;\nimport org.apache.commons.collections.iterators.AbstractIteratorDecorator;\nimport org.apache.commons.collections.list.UnmodifiableList;\n\n/**\n * Decorates another <code>Set</code> to ensure that the order of addition is\n * retained and used by the iterator.\n * <p>\n * If an object is added to the set for a second time, it will remain in the\n * original position in the iteration. The order can be observed from the set\n * via the iterator or toArray methods.\n * <p>\n * The ListOrderedSet also has various useful direct methods. These include many\n * from <code>List</code>, such as <code>get(int)</code>,\n * <code>remove(int)</code> and <code>indexOf(int)</code>. An unmodifiable\n * <code>List</code> view of the set can be obtained via <code>asList()</code>.\n * <p>\n * This class cannot implement the <code>List</code> interface directly as\n * various interface methods (notably equals/hashCode) are incompatible with a\n * set.\n * <p>\n * This class is Serializable from Commons Collections 3.1.\n * \n * @since 3.0\n * @version $Id$\n */\npublic class ListOrderedSet<E>\n    extends AbstractSerializableSetDecorator<E>\n    implements Set<E> {\n\n    /** Serialization version */\n    private static final long serialVersionUID = -228664372470420141L;\n\n    /** Internal list to hold the sequence of objects */\n    protected final List<E> setOrder;\n\n    /**\n     * Factory method to create an ordered set specifying the list and set to\n     * use.\n     * <p>\n     * The list and set must both be empty.\n     * \n     * @param <E> the element type\n     * @param set the set to decorate, must be empty and not null\n     * @param list the list to decorate, must be empty and not null\n     * @return a new ordered set\n     * @throws IllegalArgumentException if set or list is null\n     * @throws IllegalArgumentException if either the set or list is not empty\n     * @since 3.1\n     */\n    public static <E> ListOrderedSet<E> listOrderedSet(Set<E> set, List<E> list) {\n        if (set == null) {\n            throw new IllegalArgumentException(\"Set must not be null\");\n        }\n        if (list == null) {\n            throw new IllegalArgumentException(\"List must not be null\");\n        }\n        if (set.size() > 0 || list.size() > 0) {\n            throw new IllegalArgumentException(\"Set and List must be empty\");\n        }\n        return new ListOrderedSet<E>(set, list);\n    }\n\n    /**\n     * Factory method to create an ordered set.\n     * <p>\n     * An <code>ArrayList</code> is used to retain order.\n     * \n     * @param <E> the element type\n     * @param set the set to decorate, must not be null\n     * @return a new ordered set\n     * @throws IllegalArgumentException if set is null\n     */\n    public static <E> ListOrderedSet<E> listOrderedSet(Set<E> set) {\n        return new ListOrderedSet<E>(set);\n    }\n\n    /**\n     * Factory method to create an ordered set using the supplied list to retain\n     * order.\n     * <p>\n     * A <code>HashSet</code> is used for the set behaviour.\n     * <p>\n     * NOTE: If the list contains duplicates, the duplicates are removed,\n     * altering the specified list.\n     * \n     * @param <E> the element type\n     * @param list the list to decorate, must not be null\n     * @return a new ordered set\n     * @throws IllegalArgumentException if list is null\n     */\n    public static <E> ListOrderedSet<E> listOrderedSet(List<E> list) {\n        if (list == null) {\n            throw new IllegalArgumentException(\"List must not be null\");\n        }\n        Set<E> set = new HashSet<E>(list);\n        list.retainAll(set);\n\n        return new ListOrderedSet<E>(set, list);\n    }\n\n    // -----------------------------------------------------------------------\n    /**\n     * Constructs a new empty <code>ListOrderedSet</code> using a\n     * <code>HashSet</code> and an <code>ArrayList</code> internally.\n     * \n     * @since 3.1\n     */\n    public ListOrderedSet() {\n        super(new HashSet<E>());\n        setOrder = new ArrayList<E>();\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     * \n     * @param set the set to decorate, must not be null\n     * @throws IllegalArgumentException if set is null\n     */\n    protected ListOrderedSet(Set<E> set) {\n        super(set);\n        setOrder = new ArrayList<E>(set);\n    }\n\n    /**\n     * Constructor that wraps (not copies) the Set and specifies the list to\n     * use.\n     * <p>\n     * The set and list must both be correctly initialised to the same elements.\n     * \n     * @param set the set to decorate, must not be null\n     * @param list the list to decorate, must not be null\n     * @throws IllegalArgumentException if set or list is null\n     */\n    protected ListOrderedSet(Set<E> set, List<E> list) {\n        super(set);\n        if (list == null) {\n            throw new IllegalArgumentException(\"List must not be null\");\n        }\n        setOrder = list;\n    }\n\n    // -----------------------------------------------------------------------\n    /**\n     * Gets an unmodifiable view of the order of the Set.\n     * \n     * @return an unmodifiable list view\n     */\n    public List<E> asList() {\n        return UnmodifiableList.unmodifiableList(setOrder);\n    }\n\n    // -----------------------------------------------------------------------\n    @Override\n    public void clear() {\n        collection.clear();\n        setOrder.clear();\n    }\n\n    @Override\n    public OrderedIterator<E> iterator() {\n        return new OrderedSetIterator<E>(setOrder.listIterator(), collection);\n    }\n\n    @Override\n    public boolean add(E object) {\n        if (collection.add(object)) {\n            setOrder.add(object);\n            return true;\n        }\n        return false;\n    }\n\n    @Override\n    public boolean addAll(Collection<? extends E> coll) {\n        boolean result = false;\n        for (E e : coll) {\n            result |= add(e);\n        }\n        return result;\n    }\n\n    @Override\n    public boolean remove(Object object) {\n        boolean result = collection.remove(object);\n        if (result) {\n            setOrder.remove(object);\n        }\n        return result;\n    }\n\n    @Override\n    public boolean removeAll(Collection<?> coll) {\n        boolean result = false;\n        for (Iterator<?> it = coll.iterator(); it.hasNext();) {\n            result |= remove(it.next());\n        }\n        return result;\n    }\n\n    @Override\n    public boolean retainAll(Collection<?> coll) {\n        boolean result = collection.retainAll(coll);\n        if (result == false) {\n            return false;\n        }\n        if (collection.size() == 0) {\n            setOrder.clear();\n        } else {\n            for (Iterator<E> it = setOrder.iterator(); it.hasNext();) {\n                if (!collection.contains(it.next())) {\n                    it.remove();\n                }\n            }\n        }\n        return result;\n    }\n\n    @Override\n    public Object[] toArray() {\n        return setOrder.toArray();\n    }\n\n    @Override\n    public <T> T[] toArray(T a[]) {\n        return setOrder.toArray(a);\n    }\n\n    // -----------------------------------------------------------------------\n    // Additional methods that comply to the {@link List} interface\n    // -----------------------------------------------------------------------\n\n    /**\n     * Returns the element at the specified position in this ordered set.\n     * \n     * @param index the position of the element in the ordered {@link Set}.\n     * @return the element at position {@code index}\n     * @see List#get(int)\n     */\n    public E get(int index) {\n        return setOrder.get(index);\n    }\n\n    /**\n     * Returns the index of the first occurrence of the specified element in\n     * ordered set.\n     * \n     * @param object the element to search for\n     * @return the index of the first occurrence of the object, or {@code -1} if\n     *         this ordered set does not contain this object\n     * @see List#indexOf(Object)\n     */\n    public int indexOf(Object object) {\n        return setOrder.indexOf(object);\n    }\n\n    /**\n     * Inserts the specified element at the specified position if it is not yet\n     * contained in this ordered set (optional operation). Shifts the element\n     * currently at this position and any subsequent elements to the right.\n     * \n     * @param index the index at which the element is to be inserted\n     * @param object the element to be inserted\n     * @see List#add(int, Object)\n     */\n    public void add(int index, E object) {\n        if (!contains(object)) {\n            collection.add(object);\n            setOrder.add(index, object);\n        }\n    }\n\n    /**\n     * Inserts all elements in the specified collection not yet contained in the\n     * ordered set at the specified position (optional operation). Shifts the\n     * element currently at the position and all subsequent elements to the\n     * right.\n     * \n     * @param index the position to insert the elements\n     * @param coll the collection containing the elements to be inserted\n     * @return {@code true} if this ordered set changed as a result of the call\n     * @see List#addAll(int, Collection)\n     */\n    public boolean addAll(int index, Collection<? extends E> coll) {\n        boolean changed = false;\n        // collect all elements to be added for performance reasons\n        final List<E> toAdd = new ArrayList<E>();\n        for (E e : coll) {\n            if (contains(e)) {\n                continue;\n            }\n            collection.add(e);\n            toAdd.add(e);\n            changed = true;\n        }\n\n        if (changed) {\n            setOrder.addAll(index, toAdd);\n        }\n\n        return changed;\n    }\n\n    /**\n     * Removes the element at the specified position from the ordered set.\n     * Shifts any subsequent elements to the left.\n     * \n     * @param index the index of the element to be removed\n     * @return the element that has been remove from the ordered set\n     * @see List#remove(int)\n     */\n    public Object remove(int index) {\n        Object obj = setOrder.remove(index);\n        remove(obj);\n        return obj;\n    }\n\n    /**\n     * Uses the underlying List's toString so that order is achieved. This means\n     * that the decorated Set's toString is not used, so any custom toStrings\n     * will be ignored.\n     * \n     * @return a string representation of the ordered set\n     */\n    // Fortunately List.toString and Set.toString look the same\n    @Override\n    public String toString() {\n        return setOrder.toString();\n    }\n\n    // -----------------------------------------------------------------------\n    /**\n     * Internal iterator handle remove.\n     */\n    static class OrderedSetIterator<E>\n        extends AbstractIteratorDecorator<E>\n        implements OrderedIterator<E> {\n\n        /** Object we iterate on */\n        protected final Collection<E> set;\n\n        /** Last object retrieved */\n        protected E last;\n\n        private OrderedSetIterator(ListIterator<E> iterator, Collection<E> set) {\n            super(iterator);\n            this.set = set;\n        }\n\n        @Override\n        public E next() {\n            last = iterator.next();\n            return last;\n        }\n\n        @Override\n        public void remove() {\n            set.remove(last);\n            iterator.remove();\n            last = null;\n        }\n\n        public boolean hasPrevious() {\n            return ((ListIterator<E>) iterator).hasPrevious();\n        }\n\n        public E previous() {\n            last = ((ListIterator<E>) iterator).previous();\n            return last;\n        }\n    }\n\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections.set;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Set;\n\nimport org.apache.commons.collections.OrderedIterator;\nimport org.apache.commons.collections.iterators.AbstractIteratorDecorator;\nimport org.apache.commons.collections.list.UnmodifiableList;\n\n/**\n * Decorates another <code>Set</code> to ensure that the order of addition is\n * retained and used by the iterator.\n * <p>\n * If an object is added to the set for a second time, it will remain in the\n * original position in the iteration. The order can be observed from the set\n * via the iterator or toArray methods.\n * <p>\n * The ListOrderedSet also has various useful direct methods. These include many\n * from <code>List</code>, such as <code>get(int)</code>,\n * <code>remove(int)</code> and <code>indexOf(int)</code>. An unmodifiable\n * <code>List</code> view of the set can be obtained via <code>asList()</code>.\n * <p>\n * This class cannot implement the <code>List</code> interface directly as\n * various interface methods (notably equals/hashCode) are incompatible with a\n * set.\n * <p>\n * This class is Serializable from Commons Collections 3.1.\n * \n * @since 3.0\n * @version $Id$\n */\npublic class ListOrderedSet<E>\n    extends AbstractSerializableSetDecorator<E>\n    implements Set<E> {\n\n    /** Serialization version */\n    private static final long serialVersionUID = -228664372470420141L;\n\n    /** Internal list to hold the sequence of objects */\n    protected final List<E> setOrder;\n\n    /**\n     * Factory method to create an ordered set specifying the list and set to\n     * use.\n     * <p>\n     * The list and set must both be empty.\n     * \n     * @param <E> the element type\n     * @param set the set to decorate, must be empty and not null\n     * @param list the list to decorate, must be empty and not null\n     * @return a new ordered set\n     * @throws IllegalArgumentException if set or list is null\n     * @throws IllegalArgumentException if either the set or list is not empty\n     * @since 3.1\n     */\n    public static <E> ListOrderedSet<E> listOrderedSet(Set<E> set, List<E> list) {\n        if (set == null) {\n            throw new IllegalArgumentException(\"Set must not be null\");\n        }\n        if (list == null) {\n            throw new IllegalArgumentException(\"List must not be null\");\n        }\n        if (set.size() > 0 || list.size() > 0) {\n            throw new IllegalArgumentException(\"Set and List must be empty\");\n        }\n        return new ListOrderedSet<E>(set, list);\n    }\n\n    /**\n     * Factory method to create an ordered set.\n     * <p>\n     * An <code>ArrayList</code> is used to retain order.\n     * \n     * @param <E> the element type\n     * @param set the set to decorate, must not be null\n     * @return a new ordered set\n     * @throws IllegalArgumentException if set is null\n     */\n    public static <E> ListOrderedSet<E> listOrderedSet(Set<E> set) {\n        return new ListOrderedSet<E>(set);\n    }\n\n    /**\n     * Factory method to create an ordered set using the supplied list to retain\n     * order.\n     * <p>\n     * A <code>HashSet</code> is used for the set behaviour.\n     * <p>\n     * NOTE: If the list contains duplicates, the duplicates are removed,\n     * altering the specified list.\n     * \n     * @param <E> the element type\n     * @param list the list to decorate, must not be null\n     * @return a new ordered set\n     * @throws IllegalArgumentException if list is null\n     */\n    public static <E> ListOrderedSet<E> listOrderedSet(List<E> list) {\n        if (list == null) {\n            throw new IllegalArgumentException(\"List must not be null\");\n        }\n        Set<E> set = new HashSet<E>(list);\n        list.retainAll(set);\n\n        return new ListOrderedSet<E>(set, list);\n    }\n\n    // -----------------------------------------------------------------------\n    /**\n     * Constructs a new empty <code>ListOrderedSet</code> using a\n     * <code>HashSet</code> and an <code>ArrayList</code> internally.\n     * \n     * @since 3.1\n     */\n    public ListOrderedSet() {\n        super(new HashSet<E>());\n        setOrder = new ArrayList<E>();\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     * \n     * @param set the set to decorate, must not be null\n     * @throws IllegalArgumentException if set is null\n     */\n    protected ListOrderedSet(Set<E> set) {\n        super(set);\n        setOrder = new ArrayList<E>(set);\n    }\n\n    /**\n     * Constructor that wraps (not copies) the Set and specifies the list to\n     * use.\n     * <p>\n     * The set and list must both be correctly initialised to the same elements.\n     * \n     * @param set the set to decorate, must not be null\n     * @param list the list to decorate, must not be null\n     * @throws IllegalArgumentException if set or list is null\n     */\n    protected ListOrderedSet(Set<E> set, List<E> list) {\n        super(set);\n        if (list == null) {\n            throw new IllegalArgumentException(\"List must not be null\");\n        }\n        setOrder = list;\n    }\n\n    // -----------------------------------------------------------------------\n    /**\n     * Gets an unmodifiable view of the order of the Set.\n     * \n     * @return an unmodifiable list view\n     */\n    public List<E> asList() {\n        return UnmodifiableList.unmodifiableList(setOrder);\n    }\n\n    // -----------------------------------------------------------------------\n    @Override\n    public void clear() {\n        collection.clear();\n        setOrder.clear();\n    }\n\n    @Override\n    public OrderedIterator<E> iterator() {\n        return new OrderedSetIterator<E>(setOrder.listIterator(), collection);\n    }\n\n    @Override\n    public boolean add(E object) {\n        if (collection.add(object)) {\n            setOrder.add(object);\n            return true;\n        }\n        return false;\n    }\n\n    @Override\n    public boolean addAll(Collection<? extends E> coll) {\n        boolean result = false;\n        for (E e : coll) {\n            result |= add(e);\n        }\n        return result;\n    }\n\n    @Override\n    public boolean remove(Object object) {\n        boolean result = collection.remove(object);\n        if (result) {\n            setOrder.remove(object);\n        }\n        return result;\n    }\n\n    @Override\n    public boolean removeAll(Collection<?> coll) {\n        boolean result = false;\n        for (Iterator<?> it = coll.iterator(); it.hasNext();) {\n            result |= remove(it.next());\n        }\n        return result;\n    }\n\n    @Override\n    public boolean retainAll(Collection<?> coll) {\n        Set<Object> collectionRetainAll = new HashSet<Object>();\n        for (Iterator<?> it = coll.iterator(); it.hasNext();) {\n            Object next = it.next();\n            if (collection.contains(next)) {\n                collectionRetainAll.add(next);\n            }\n        }\n        if (collectionRetainAll.size() == collection.size()) {\n            return false;\n        }\n        if (collectionRetainAll.size() == 0) {\n            clear();\n        } else {\n            for (Iterator<E> it = iterator(); it.hasNext();) {\n                if (!collectionRetainAll.contains(it.next())) {\n                    it.remove();\n                }\n            }\n        }\n        return true;\n    }\n\n    @Override\n    public Object[] toArray() {\n        return setOrder.toArray();\n    }\n\n    @Override\n    public <T> T[] toArray(T a[]) {\n        return setOrder.toArray(a);\n    }\n\n    // -----------------------------------------------------------------------\n    // Additional methods that comply to the {@link List} interface\n    // -----------------------------------------------------------------------\n\n    /**\n     * Returns the element at the specified position in this ordered set.\n     * \n     * @param index the position of the element in the ordered {@link Set}.\n     * @return the element at position {@code index}\n     * @see List#get(int)\n     */\n    public E get(int index) {\n        return setOrder.get(index);\n    }\n\n    /**\n     * Returns the index of the first occurrence of the specified element in\n     * ordered set.\n     * \n     * @param object the element to search for\n     * @return the index of the first occurrence of the object, or {@code -1} if\n     *         this ordered set does not contain this object\n     * @see List#indexOf(Object)\n     */\n    public int indexOf(Object object) {\n        return setOrder.indexOf(object);\n    }\n\n    /**\n     * Inserts the specified element at the specified position if it is not yet\n     * contained in this ordered set (optional operation). Shifts the element\n     * currently at this position and any subsequent elements to the right.\n     * \n     * @param index the index at which the element is to be inserted\n     * @param object the element to be inserted\n     * @see List#add(int, Object)\n     */\n    public void add(int index, E object) {\n        if (!contains(object)) {\n            collection.add(object);\n            setOrder.add(index, object);\n        }\n    }\n\n    /**\n     * Inserts all elements in the specified collection not yet contained in the\n     * ordered set at the specified position (optional operation). Shifts the\n     * element currently at the position and all subsequent elements to the\n     * right.\n     * \n     * @param index the position to insert the elements\n     * @param coll the collection containing the elements to be inserted\n     * @return {@code true} if this ordered set changed as a result of the call\n     * @see List#addAll(int, Collection)\n     */\n    public boolean addAll(int index, Collection<? extends E> coll) {\n        boolean changed = false;\n        // collect all elements to be added for performance reasons\n        final List<E> toAdd = new ArrayList<E>();\n        for (E e : coll) {\n            if (contains(e)) {\n                continue;\n            }\n            collection.add(e);\n            toAdd.add(e);\n            changed = true;\n        }\n\n        if (changed) {\n            setOrder.addAll(index, toAdd);\n        }\n\n        return changed;\n    }\n\n    /**\n     * Removes the element at the specified position from the ordered set.\n     * Shifts any subsequent elements to the left.\n     * \n     * @param index the index of the element to be removed\n     * @return the element that has been remove from the ordered set\n     * @see List#remove(int)\n     */\n    public Object remove(int index) {\n        Object obj = setOrder.remove(index);\n        remove(obj);\n        return obj;\n    }\n\n    /**\n     * Uses the underlying List's toString so that order is achieved. This means\n     * that the decorated Set's toString is not used, so any custom toStrings\n     * will be ignored.\n     * \n     * @return a string representation of the ordered set\n     */\n    // Fortunately List.toString and Set.toString look the same\n    @Override\n    public String toString() {\n        return setOrder.toString();\n    }\n\n    // -----------------------------------------------------------------------\n    /**\n     * Internal iterator handle remove.\n     */\n    static class OrderedSetIterator<E>\n        extends AbstractIteratorDecorator<E>\n        implements OrderedIterator<E> {\n\n        /** Object we iterate on */\n        protected final Collection<E> set;\n\n        /** Last object retrieved */\n        protected E last;\n\n        private OrderedSetIterator(ListIterator<E> iterator, Collection<E> set) {\n            super(iterator);\n            this.set = set;\n        }\n\n        @Override\n        public E next() {\n            last = iterator.next();\n            return last;\n        }\n\n        @Override\n        public void remove() {\n            set.remove(last);\n            iterator.remove();\n            last = null;\n        }\n\n        public boolean hasPrevious() {\n            return ((ListIterator<E>) iterator).hasPrevious();\n        }\n\n        public E previous() {\n            last = ((ListIterator<E>) iterator).previous();\n            return last;\n        }\n    }\n\n}\n"}]}
{"project": "Collections", "bug_id": 19, "classes_modified": [{"class_name": "org.apache.commons.collections.list.SetUniqueList", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections.list;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Set;\n\nimport org.apache.commons.collections.iterators.AbstractIteratorDecorator;\nimport org.apache.commons.collections.iterators.AbstractListIteratorDecorator;\nimport org.apache.commons.collections.set.UnmodifiableSet;\n\n/**\n * Decorates a <code>List</code> to ensure that no duplicates are present much\n * like a <code>Set</code>.\n * <p>\n * The <code>List</code> interface makes certain assumptions/requirements. This\n * implementation breaks these in certain ways, but this is merely the result of\n * rejecting duplicates. Each violation is explained in the method, but it\n * should not affect you. Bear in mind that Sets require immutable objects to\n * function correctly.\n * <p>\n * The {@link org.apache.commons.collections.set.ListOrderedSet ListOrderedSet}\n * class provides an alternative approach, by wrapping an existing Set and\n * retaining insertion order in the iterator.\n * <p>\n * This class is Serializable from Commons Collections 3.1.\n * \n * @since 3.0\n * @version $Id$\n */\npublic class SetUniqueList<E> extends AbstractSerializableListDecorator<E> {\n\n    /** Serialization version. */\n    private static final long serialVersionUID = 7196982186153478694L;\n\n    /** Internal Set to maintain uniqueness. */\n    protected final Set<E> set;\n\n    /**\n     * Factory method to create a SetList using the supplied list to retain\n     * order.\n     * <p>\n     * If the list contains duplicates, these are removed (first indexed one\n     * kept). A <code>HashSet</code> is used for the set behaviour.\n     * \n     * @param <E>\n     *            the element type\n     * @param list\n     *            the list to decorate, must not be null\n     * @return a new {@link SetUniqueList}\n     * @throws IllegalArgumentException\n     *             if list is null\n     */\n    public static <E> SetUniqueList<E> setUniqueList(final List<E> list) {\n        if (list == null) {\n            throw new IllegalArgumentException(\"List must not be null\");\n        }\n        if (list.isEmpty()) {\n            return new SetUniqueList<E>(list, new HashSet<E>());\n        }\n        final List<E> temp = new ArrayList<E>(list);\n        list.clear();\n        final SetUniqueList<E> sl = new SetUniqueList<E>(list, new HashSet<E>());\n        sl.addAll(temp);\n        return sl;\n    }\n\n    // -----------------------------------------------------------------------\n    /**\n     * Constructor that wraps (not copies) the List and specifies the set to\n     * use.\n     * <p>\n     * The set and list must both be correctly initialised to the same elements.\n     * \n     * @param set\n     *            the set to decorate, must not be null\n     * @param list\n     *            the list to decorate, must not be null\n     * @throws IllegalArgumentException\n     *             if set or list is null\n     */\n    protected SetUniqueList(final List<E> list, final Set<E> set) {\n        super(list);\n        if (set == null) {\n            throw new IllegalArgumentException(\"Set must not be null\");\n        }\n        this.set = set;\n    }\n\n    // -----------------------------------------------------------------------\n    /**\n     * Gets an unmodifiable view as a Set.\n     * \n     * @return an unmodifiable set view\n     */\n    public Set<E> asSet() {\n        return UnmodifiableSet.unmodifiableSet(set);\n    }\n\n    // -----------------------------------------------------------------------\n    /**\n     * Adds an element to the list if it is not already present.\n     * <p>\n     * <i>(Violation)</i> The <code>List</code> interface requires that this\n     * method returns <code>true</code> always. However this class may return\n     * <code>false</code> because of the <code>Set</code> behaviour.\n     * \n     * @param object\n     *            the object to add\n     * @return true if object was added\n     */\n    @Override\n    public boolean add(final E object) {\n        // gets initial size\n        final int sizeBefore = size();\n\n        // adds element if unique\n        add(size(), object);\n\n        // compares sizes to detect if collection changed\n        return sizeBefore != size();\n    }\n\n    /**\n     * Adds an element to a specific index in the list if it is not already\n     * present.\n     * <p>\n     * <i>(Violation)</i> The <code>List</code> interface makes the assumption\n     * that the element is always inserted. This may not happen with this\n     * implementation.\n     * \n     * @param index\n     *            the index to insert at\n     * @param object\n     *            the object to add\n     */\n    @Override\n    public void add(final int index, final E object) {\n        // adds element if it is not contained already\n        if (set.contains(object) == false) {\n            super.add(index, object);\n            set.add(object);\n        }\n    }\n\n    /**\n     * Adds a collection of objects to the end of the list avoiding duplicates.\n     * <p>\n     * Only elements that are not already in this list will be added, and\n     * duplicates from the specified collection will be ignored.\n     * <p>\n     * <i>(Violation)</i> The <code>List</code> interface makes the assumption\n     * that the elements are always inserted. This may not happen with this\n     * implementation.\n     * \n     * @param coll\n     *            the collection to add in iterator order\n     * @return true if this collection changed\n     */\n    @Override\n    public boolean addAll(final Collection<? extends E> coll) {\n        return addAll(size(), coll);\n    }\n\n    /**\n     * Adds a collection of objects a specific index in the list avoiding\n     * duplicates.\n     * <p>\n     * Only elements that are not already in this list will be added, and\n     * duplicates from the specified collection will be ignored.\n     * <p>\n     * <i>(Violation)</i> The <code>List</code> interface makes the assumption\n     * that the elements are always inserted. This may not happen with this\n     * implementation.\n     * \n     * @param index\n     *            the index to insert at\n     * @param coll\n     *            the collection to add in iterator order\n     * @return true if this collection changed\n     */\n    @Override\n    public boolean addAll(final int index, final Collection<? extends E> coll) {\n        final List<E> temp = new ArrayList<E>();\n        for (final E e : coll) {\n            if (set.add(e)) {\n                temp.add(e);\n            }\n        }\n        return super.addAll(index, temp);\n    }\n\n    // -----------------------------------------------------------------------\n    /**\n     * Sets the value at the specified index avoiding duplicates.\n     * <p>\n     * The object is set into the specified index. Afterwards, any previous\n     * duplicate is removed If the object is not already in the list then a\n     * normal set occurs. If it is present, then the old version is removed.\n     * \n     * @param index\n     *            the index to insert at\n     * @param object\n     *            the object to set\n     * @return the previous object\n     */\n    @Override\n    public E set(final int index, final E object) {\n        final int pos = indexOf(object);\n        final E removed = super.set(index, object);\n\n        if (pos != -1 && pos != index) {\n            // the object is already in the uniq list\n            // (and it hasn't been swapped with itself)\n            super.remove(pos); // remove the duplicate by index\n        }\n        set.add(object); \n        set.remove(removed);\n        return removed; // return the item deleted by the set\n    }\n\n    @Override\n    public boolean remove(final Object object) {\n        final boolean result = set.remove(object);\n        if (result) {\n            super.remove(object);\n        }\n        return result;\n    }\n\n    @Override\n    public E remove(final int index) {\n        final E result = super.remove(index);\n        set.remove(result);\n        return result;\n    }\n\n    @Override\n    public boolean removeAll(final Collection<?> coll) {\n        boolean result = false;\n        for (final Object name : coll) {\n            result |= remove(name);\n        }\n        return result;\n    }\n\n    @Override\n    public boolean retainAll(final Collection<?> coll) {\n        final Set<Object> setRetainAll = new HashSet<Object>();\n        for (final Object next : coll) {\n            if (set.contains(next)) {\n                setRetainAll.add(next);\n            }\n        }\n        if (setRetainAll.size() == set.size()) {\n            return false;\n        }\n        if (setRetainAll.size() == 0) {\n            clear();\n        } else {\n            for (final Iterator<E> it = iterator(); it.hasNext();) {\n                if (!setRetainAll.contains(it.next())) {\n                    it.remove();\n                }\n            }\n        }\n        return true;\n    }\n\n    @Override\n    public void clear() {\n        super.clear();\n        set.clear();\n    }\n\n    @Override\n    public boolean contains(final Object object) {\n        return set.contains(object);\n    }\n\n    @Override\n    public boolean containsAll(final Collection<?> coll) {\n        return set.containsAll(coll);\n    }\n\n    @Override\n    public Iterator<E> iterator() {\n        return new SetListIterator<E>(super.iterator(), set);\n    }\n\n    @Override\n    public ListIterator<E> listIterator() {\n        return new SetListListIterator<E>(super.listIterator(), set);\n    }\n\n    @Override\n    public ListIterator<E> listIterator(final int index) {\n        return new SetListListIterator<E>(super.listIterator(index), set);\n    }\n\n    @Override\n    public List<E> subList(final int fromIndex, final int toIndex) {\n        final List<E> superSubList = super.subList(fromIndex, toIndex);\n        final Set<E> subSet = createSetBasedOnList(set, superSubList);\n        return new SetUniqueList<E>(superSubList, subSet);\n    }\n\n    /**\n     * Create a new {@link Set} with the same type as the provided {@code set}\n     * and populate it with all elements of {@code list}.\n     * \n     * @param set\n     *            the {@link Set} to be used as return type, must not be null\n     * @param list\n     *            the {@link List} to populate the {@link Set}\n     * @return a new {@link Set} populated with all elements of the provided\n     *         {@link List}\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected Set<E> createSetBasedOnList(final Set<E> set, final List<E> list) {\n        Set<E> subSet;\n        if (set.getClass().equals(HashSet.class)) {\n            subSet = new HashSet<E>(list.size());\n        } else {\n            try {\n                subSet = set.getClass().newInstance();\n            } catch (final InstantiationException ie) {\n                subSet = new HashSet<E>();\n            } catch (final IllegalAccessException iae) {\n                subSet = new HashSet<E>();\n            }\n        }\n        subSet.addAll(list);\n        return subSet;\n    }\n\n    // -----------------------------------------------------------------------\n    /**\n     * Inner class iterator.\n     */\n    static class SetListIterator<E> extends AbstractIteratorDecorator<E> {\n\n        protected final Set<E> set;\n        protected E last = null;\n\n        protected SetListIterator(final Iterator<E> it, final Set<E> set) {\n            super(it);\n            this.set = set;\n        }\n\n        @Override\n        public E next() {\n            last = super.next();\n            return last;\n        }\n\n        @Override\n        public void remove() {\n            super.remove();\n            set.remove(last);\n            last = null;\n        }\n    }\n\n    /**\n     * Inner class iterator.\n     */\n    static class SetListListIterator<E> extends\n            AbstractListIteratorDecorator<E> {\n\n        protected final Set<E> set;\n        protected E last = null;\n\n        protected SetListListIterator(final ListIterator<E> it, final Set<E> set) {\n            super(it);\n            this.set = set;\n        }\n\n        @Override\n        public E next() {\n            last = super.next();\n            return last;\n        }\n\n        @Override\n        public E previous() {\n            last = super.previous();\n            return last;\n        }\n\n        @Override\n        public void remove() {\n            super.remove();\n            set.remove(last);\n            last = null;\n        }\n\n        @Override\n        public void add(final E object) {\n            if (set.contains(object) == false) {\n                super.add(object);\n                set.add(object);\n            }\n        }\n\n        @Override\n        public void set(final E object) {\n            throw new UnsupportedOperationException(\"ListIterator does not support set\");\n        }\n    }\n\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections.list;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Set;\n\nimport org.apache.commons.collections.iterators.AbstractIteratorDecorator;\nimport org.apache.commons.collections.iterators.AbstractListIteratorDecorator;\nimport org.apache.commons.collections.set.UnmodifiableSet;\n\n/**\n * Decorates a <code>List</code> to ensure that no duplicates are present much\n * like a <code>Set</code>.\n * <p>\n * The <code>List</code> interface makes certain assumptions/requirements. This\n * implementation breaks these in certain ways, but this is merely the result of\n * rejecting duplicates. Each violation is explained in the method, but it\n * should not affect you. Bear in mind that Sets require immutable objects to\n * function correctly.\n * <p>\n * The {@link org.apache.commons.collections.set.ListOrderedSet ListOrderedSet}\n * class provides an alternative approach, by wrapping an existing Set and\n * retaining insertion order in the iterator.\n * <p>\n * This class is Serializable from Commons Collections 3.1.\n * \n * @since 3.0\n * @version $Id$\n */\npublic class SetUniqueList<E> extends AbstractSerializableListDecorator<E> {\n\n    /** Serialization version. */\n    private static final long serialVersionUID = 7196982186153478694L;\n\n    /** Internal Set to maintain uniqueness. */\n    protected final Set<E> set;\n\n    /**\n     * Factory method to create a SetList using the supplied list to retain\n     * order.\n     * <p>\n     * If the list contains duplicates, these are removed (first indexed one\n     * kept). A <code>HashSet</code> is used for the set behaviour.\n     * \n     * @param <E>\n     *            the element type\n     * @param list\n     *            the list to decorate, must not be null\n     * @return a new {@link SetUniqueList}\n     * @throws IllegalArgumentException\n     *             if list is null\n     */\n    public static <E> SetUniqueList<E> setUniqueList(final List<E> list) {\n        if (list == null) {\n            throw new IllegalArgumentException(\"List must not be null\");\n        }\n        if (list.isEmpty()) {\n            return new SetUniqueList<E>(list, new HashSet<E>());\n        }\n        final List<E> temp = new ArrayList<E>(list);\n        list.clear();\n        final SetUniqueList<E> sl = new SetUniqueList<E>(list, new HashSet<E>());\n        sl.addAll(temp);\n        return sl;\n    }\n\n    // -----------------------------------------------------------------------\n    /**\n     * Constructor that wraps (not copies) the List and specifies the set to\n     * use.\n     * <p>\n     * The set and list must both be correctly initialised to the same elements.\n     * \n     * @param set\n     *            the set to decorate, must not be null\n     * @param list\n     *            the list to decorate, must not be null\n     * @throws IllegalArgumentException\n     *             if set or list is null\n     */\n    protected SetUniqueList(final List<E> list, final Set<E> set) {\n        super(list);\n        if (set == null) {\n            throw new IllegalArgumentException(\"Set must not be null\");\n        }\n        this.set = set;\n    }\n\n    // -----------------------------------------------------------------------\n    /**\n     * Gets an unmodifiable view as a Set.\n     * \n     * @return an unmodifiable set view\n     */\n    public Set<E> asSet() {\n        return UnmodifiableSet.unmodifiableSet(set);\n    }\n\n    // -----------------------------------------------------------------------\n    /**\n     * Adds an element to the list if it is not already present.\n     * <p>\n     * <i>(Violation)</i> The <code>List</code> interface requires that this\n     * method returns <code>true</code> always. However this class may return\n     * <code>false</code> because of the <code>Set</code> behaviour.\n     * \n     * @param object\n     *            the object to add\n     * @return true if object was added\n     */\n    @Override\n    public boolean add(final E object) {\n        // gets initial size\n        final int sizeBefore = size();\n\n        // adds element if unique\n        add(size(), object);\n\n        // compares sizes to detect if collection changed\n        return sizeBefore != size();\n    }\n\n    /**\n     * Adds an element to a specific index in the list if it is not already\n     * present.\n     * <p>\n     * <i>(Violation)</i> The <code>List</code> interface makes the assumption\n     * that the element is always inserted. This may not happen with this\n     * implementation.\n     * \n     * @param index\n     *            the index to insert at\n     * @param object\n     *            the object to add\n     */\n    @Override\n    public void add(final int index, final E object) {\n        // adds element if it is not contained already\n        if (set.contains(object) == false) {\n            super.add(index, object);\n            set.add(object);\n        }\n    }\n\n    /**\n     * Adds a collection of objects to the end of the list avoiding duplicates.\n     * <p>\n     * Only elements that are not already in this list will be added, and\n     * duplicates from the specified collection will be ignored.\n     * <p>\n     * <i>(Violation)</i> The <code>List</code> interface makes the assumption\n     * that the elements are always inserted. This may not happen with this\n     * implementation.\n     * \n     * @param coll\n     *            the collection to add in iterator order\n     * @return true if this collection changed\n     */\n    @Override\n    public boolean addAll(final Collection<? extends E> coll) {\n        return addAll(size(), coll);\n    }\n\n    /**\n     * Adds a collection of objects a specific index in the list avoiding\n     * duplicates.\n     * <p>\n     * Only elements that are not already in this list will be added, and\n     * duplicates from the specified collection will be ignored.\n     * <p>\n     * <i>(Violation)</i> The <code>List</code> interface makes the assumption\n     * that the elements are always inserted. This may not happen with this\n     * implementation.\n     * \n     * @param index\n     *            the index to insert at\n     * @param coll\n     *            the collection to add in iterator order\n     * @return true if this collection changed\n     */\n    @Override\n    public boolean addAll(final int index, final Collection<? extends E> coll) {\n        final List<E> temp = new ArrayList<E>();\n        for (final E e : coll) {\n            if (set.add(e)) {\n                temp.add(e);\n            }\n        }\n        return super.addAll(index, temp);\n    }\n\n    // -----------------------------------------------------------------------\n    /**\n     * Sets the value at the specified index avoiding duplicates.\n     * <p>\n     * The object is set into the specified index. Afterwards, any previous\n     * duplicate is removed If the object is not already in the list then a\n     * normal set occurs. If it is present, then the old version is removed.\n     * \n     * @param index\n     *            the index to insert at\n     * @param object\n     *            the object to set\n     * @return the previous object\n     */\n    @Override\n    public E set(final int index, final E object) {\n        final int pos = indexOf(object);\n        final E removed = super.set(index, object);\n\n        if (pos != -1 && pos != index) {\n            // the object is already in the uniq list\n            // (and it hasn't been swapped with itself)\n            super.remove(pos); // remove the duplicate by index\n            set.remove(removed); // remove the item deleted by the set\n        } else if (pos == -1) {\n            set.add(object); // add the new item to the unique set\n            set.remove(removed); // remove the item deleted by the set\n        }\n        \n        return removed; // return the item deleted by the set\n    }\n\n    @Override\n    public boolean remove(final Object object) {\n        final boolean result = set.remove(object);\n        if (result) {\n            super.remove(object);\n        }\n        return result;\n    }\n\n    @Override\n    public E remove(final int index) {\n        final E result = super.remove(index);\n        set.remove(result);\n        return result;\n    }\n\n    @Override\n    public boolean removeAll(final Collection<?> coll) {\n        boolean result = false;\n        for (final Object name : coll) {\n            result |= remove(name);\n        }\n        return result;\n    }\n\n    @Override\n    public boolean retainAll(final Collection<?> coll) {\n        final Set<Object> setRetainAll = new HashSet<Object>();\n        for (final Object next : coll) {\n            if (set.contains(next)) {\n                setRetainAll.add(next);\n            }\n        }\n        if (setRetainAll.size() == set.size()) {\n            return false;\n        }\n        if (setRetainAll.size() == 0) {\n            clear();\n        } else {\n            for (final Iterator<E> it = iterator(); it.hasNext();) {\n                if (!setRetainAll.contains(it.next())) {\n                    it.remove();\n                }\n            }\n        }\n        return true;\n    }\n\n    @Override\n    public void clear() {\n        super.clear();\n        set.clear();\n    }\n\n    @Override\n    public boolean contains(final Object object) {\n        return set.contains(object);\n    }\n\n    @Override\n    public boolean containsAll(final Collection<?> coll) {\n        return set.containsAll(coll);\n    }\n\n    @Override\n    public Iterator<E> iterator() {\n        return new SetListIterator<E>(super.iterator(), set);\n    }\n\n    @Override\n    public ListIterator<E> listIterator() {\n        return new SetListListIterator<E>(super.listIterator(), set);\n    }\n\n    @Override\n    public ListIterator<E> listIterator(final int index) {\n        return new SetListListIterator<E>(super.listIterator(index), set);\n    }\n\n    @Override\n    public List<E> subList(final int fromIndex, final int toIndex) {\n        final List<E> superSubList = super.subList(fromIndex, toIndex);\n        final Set<E> subSet = createSetBasedOnList(set, superSubList);\n        return new SetUniqueList<E>(superSubList, subSet);\n    }\n\n    /**\n     * Create a new {@link Set} with the same type as the provided {@code set}\n     * and populate it with all elements of {@code list}.\n     * \n     * @param set\n     *            the {@link Set} to be used as return type, must not be null\n     * @param list\n     *            the {@link List} to populate the {@link Set}\n     * @return a new {@link Set} populated with all elements of the provided\n     *         {@link List}\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected Set<E> createSetBasedOnList(final Set<E> set, final List<E> list) {\n        Set<E> subSet;\n        if (set.getClass().equals(HashSet.class)) {\n            subSet = new HashSet<E>(list.size());\n        } else {\n            try {\n                subSet = set.getClass().newInstance();\n            } catch (final InstantiationException ie) {\n                subSet = new HashSet<E>();\n            } catch (final IllegalAccessException iae) {\n                subSet = new HashSet<E>();\n            }\n        }\n        subSet.addAll(list);\n        return subSet;\n    }\n\n    // -----------------------------------------------------------------------\n    /**\n     * Inner class iterator.\n     */\n    static class SetListIterator<E> extends AbstractIteratorDecorator<E> {\n\n        protected final Set<E> set;\n        protected E last = null;\n\n        protected SetListIterator(final Iterator<E> it, final Set<E> set) {\n            super(it);\n            this.set = set;\n        }\n\n        @Override\n        public E next() {\n            last = super.next();\n            return last;\n        }\n\n        @Override\n        public void remove() {\n            super.remove();\n            set.remove(last);\n            last = null;\n        }\n    }\n\n    /**\n     * Inner class iterator.\n     */\n    static class SetListListIterator<E> extends\n            AbstractListIteratorDecorator<E> {\n\n        protected final Set<E> set;\n        protected E last = null;\n\n        protected SetListListIterator(final ListIterator<E> it, final Set<E> set) {\n            super(it);\n            this.set = set;\n        }\n\n        @Override\n        public E next() {\n            last = super.next();\n            return last;\n        }\n\n        @Override\n        public E previous() {\n            last = super.previous();\n            return last;\n        }\n\n        @Override\n        public void remove() {\n            super.remove();\n            set.remove(last);\n            last = null;\n        }\n\n        @Override\n        public void add(final E object) {\n            if (set.contains(object) == false) {\n                super.add(object);\n                set.add(object);\n            }\n        }\n\n        @Override\n        public void set(final E object) {\n            throw new UnsupportedOperationException(\"ListIterator does not support set\");\n        }\n    }\n\n}\n"}]}
{"project": "Collections", "bug_id": 20, "classes_modified": [{"class_name": "org.apache.commons.collections.list.TreeList", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections.list;\n\nimport java.util.AbstractList;\nimport java.util.Collection;\nimport java.util.ConcurrentModificationException;\nimport java.util.Iterator;\nimport java.util.ListIterator;\nimport java.util.NoSuchElementException;\n\nimport org.apache.commons.collections.OrderedIterator;\n\n/**\n * A <code>List</code> implementation that is optimised for fast insertions and\n * removals at any index in the list.\n * <p>\n * This list implementation utilises a tree structure internally to ensure that\n * all insertions and removals are O(log n). This provides much faster performance\n * than both an <code>ArrayList</code> and a <code>LinkedList</code> where elements\n * are inserted and removed repeatedly from anywhere in the list.\n * <p>\n * The following relative performance statistics are indicative of this class:\n * <pre>\n *              get  add  insert  iterate  remove\n * TreeList       3    5       1       2       1\n * ArrayList      1    1      40       1      40\n * LinkedList  5800    1     350       2     325\n * </pre>\n * <code>ArrayList</code> is a good general purpose list implementation.\n * It is faster than <code>TreeList</code> for most operations except inserting\n * and removing in the middle of the list. <code>ArrayList</code> also uses less\n * memory as <code>TreeList</code> uses one object per entry.\n * <p>\n * <code>LinkedList</code> is rarely a good choice of implementation.\n * <code>TreeList</code> is almost always a good replacement for it, although it\n * does use slightly more memory.\n *\n * @since 3.1\n * @version $Id$\n */\npublic class TreeList<E> extends AbstractList<E> {\n//    add; toArray; iterator; insert; get; indexOf; remove\n//    TreeList = 1260;7360;3080;  160;   170;3400;  170;\n//   ArrayList =  220;1480;1760; 6870;    50;1540; 7200;\n//  LinkedList =  270;7360;3350;55860;290720;2910;55200;\n\n    /** The root node in the AVL tree */\n    private AVLNode<E> root;\n\n    /** The current size of the list */\n    private int size;\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructs a new empty list.\n     */\n    public TreeList() {\n        super();\n    }\n\n    /**\n     * Constructs a new empty list that copies the specified list.\n     *\n     * @param coll  the collection to copy\n     * @throws NullPointerException if the collection is null\n     */\n    public TreeList(final Collection<E> coll) {\n        super();\n        addAll(coll);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the element at the specified index.\n     *\n     * @param index  the index to retrieve\n     * @return the element at the specified index\n     */\n    @Override\n    public E get(final int index) {\n        checkInterval(index, 0, size() - 1);\n        return root.get(index).getValue();\n    }\n\n    /**\n     * Gets the current size of the list.\n     *\n     * @return the current size\n     */\n    @Override\n    public int size() {\n        return size;\n    }\n\n    /**\n     * Gets an iterator over the list.\n     *\n     * @return an iterator over the list\n     */\n    @Override\n    public Iterator<E> iterator() {\n        // override to go 75% faster\n        return listIterator(0);\n    }\n\n    /**\n     * Gets a ListIterator over the list.\n     *\n     * @return the new iterator\n     */\n    @Override\n    public ListIterator<E> listIterator() {\n        // override to go 75% faster\n        return listIterator(0);\n    }\n\n    /**\n     * Gets a ListIterator over the list.\n     *\n     * @param fromIndex  the index to start from\n     * @return the new iterator\n     */\n    @Override\n    public ListIterator<E> listIterator(final int fromIndex) {\n        // override to go 75% faster\n        // cannot use EmptyIterator as iterator.add() must work\n        checkInterval(fromIndex, 0, size());\n        return new TreeListIterator<E>(this, fromIndex);\n    }\n\n    /**\n     * Searches for the index of an object in the list.\n     *\n     * @param object  the object to search\n     * @return the index of the object, -1 if not found\n     */\n    @Override\n    public int indexOf(final Object object) {\n        // override to go 75% faster\n        if (root == null) {\n            return -1;\n        }\n        return root.indexOf(object, root.relativePosition);\n    }\n\n    /**\n     * Searches for the presence of an object in the list.\n     *\n     * @param object  the object to check\n     * @return true if the object is found\n     */\n    @Override\n    public boolean contains(final Object object) {\n        return indexOf(object) >= 0;\n    }\n\n    /**\n     * Converts the list into an array.\n     *\n     * @return the list as an array\n     */\n    @Override\n    public Object[] toArray() {\n        // override to go 20% faster\n        final Object[] array = new Object[size()];\n        if (root != null) {\n            root.toArray(array, root.relativePosition);\n        }\n        return array;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Adds a new element to the list.\n     *\n     * @param index  the index to add before\n     * @param obj  the element to add\n     */\n    @Override\n    public void add(final int index, final E obj) {\n        modCount++;\n        checkInterval(index, 0, size());\n        if (root == null) {\n            root = new AVLNode<E>(index, obj, null, null);\n        } else {\n            root = root.insert(index, obj);\n        }\n        size++;\n    }\n\n    /**\n     * Sets the element at the specified index.\n     *\n     * @param index  the index to set\n     * @param obj  the object to store at the specified index\n     * @return the previous object at that index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    @Override\n    public E set(final int index, final E obj) {\n        checkInterval(index, 0, size() - 1);\n        final AVLNode<E> node = root.get(index);\n        final E result = node.value;\n        node.setValue(obj);\n        return result;\n    }\n\n    /**\n     * Removes the element at the specified index.\n     *\n     * @param index  the index to remove\n     * @return the previous object at that index\n     */\n    @Override\n    public E remove(final int index) {\n        modCount++;\n        checkInterval(index, 0, size() - 1);\n        final E result = get(index);\n        root = root.remove(index);\n        size--;\n        return result;\n    }\n\n    /**\n     * Clears the list, removing all entries.\n     */\n    @Override\n    public void clear() {\n        modCount++;\n        root = null;\n        size = 0;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks whether the index is valid.\n     *\n     * @param index  the index to check\n     * @param startIndex  the first allowed index\n     * @param endIndex  the last allowed index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    private void checkInterval(final int index, final int startIndex, final int endIndex) {\n        if (index < startIndex || index > endIndex) {\n            throw new IndexOutOfBoundsException(\"Invalid index:\" + index + \", size=\" + size());\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Implements an AVLNode which keeps the offset updated.\n     * <p>\n     * This node contains the real work.\n     * TreeList is just there to implement {@link java.util.List}.\n     * The nodes don't know the index of the object they are holding.  They\n     * do know however their position relative to their parent node.\n     * This allows to calculate the index of a node while traversing the tree.\n     * <p>\n     * The Faedelung calculation stores a flag for both the left and right child\n     * to indicate if they are a child (false) or a link as in linked list (true).\n     */\n    static class AVLNode<E> {\n        /** The left child node or the predecessor if {@link #leftIsPrevious}.*/\n        private AVLNode<E> left;\n        /** Flag indicating that left reference is not a subtree but the predecessor. */\n        private boolean leftIsPrevious;\n        /** The right child node or the successor if {@link #rightIsNext}. */\n        private AVLNode<E> right;\n        /** Flag indicating that right reference is not a subtree but the successor. */\n        private boolean rightIsNext;\n        /** How many levels of left/right are below this one. */\n        private int height;\n        /** The relative position, root holds absolute position. */\n        private int relativePosition;\n        /** The stored element. */\n        private E value;\n\n        /**\n         * Constructs a new node with a relative position.\n         *\n         * @param relativePosition  the relative position of the node\n         * @param obj  the value for the ndoe\n         * @param rightFollower the node with the value following this one\n         * @param leftFollower the node with the value leading this one\n         */\n        private AVLNode(final int relativePosition, final E obj,\n                        final AVLNode<E> rightFollower, final AVLNode<E> leftFollower) {\n            this.relativePosition = relativePosition;\n            value = obj;\n            rightIsNext = true;\n            leftIsPrevious = true;\n            right = rightFollower;\n            left = leftFollower;\n        }\n\n        /**\n         * Gets the value.\n         *\n         * @return the value of this node\n         */\n        E getValue() {\n            return value;\n        }\n\n        /**\n         * Sets the value.\n         *\n         * @param obj  the value to store\n         */\n        void setValue(final E obj) {\n            this.value = obj;\n        }\n\n        /**\n         * Locate the element with the given index relative to the\n         * offset of the parent of this node.\n         */\n        AVLNode<E> get(final int index) {\n            final int indexRelativeToMe = index - relativePosition;\n\n            if (indexRelativeToMe == 0) {\n                return this;\n            }\n\n            final AVLNode<E> nextNode = indexRelativeToMe < 0 ? getLeftSubTree() : getRightSubTree();\n            if (nextNode == null) {\n                return null;\n            }\n            return nextNode.get(indexRelativeToMe);\n        }\n\n        /**\n         * Locate the index that contains the specified object.\n         */\n        int indexOf(final Object object, final int index) {\n            if (getLeftSubTree() != null) {\n                final int result = left.indexOf(object, index + left.relativePosition);\n                if (result != -1) {\n                    return result;\n                }\n            }\n            if (value == null ? value == object : value.equals(object)) {\n                return index;\n            }\n            if (getRightSubTree() != null) {\n                return right.indexOf(object, index + right.relativePosition);\n            }\n            return -1;\n        }\n\n        /**\n         * Stores the node and its children into the array specified.\n         *\n         * @param array the array to be filled\n         * @param index the index of this node\n         */\n        void toArray(final Object[] array, final int index) {\n            array[index] = value;\n            if (getLeftSubTree() != null) {\n                left.toArray(array, index + left.relativePosition);\n            }\n            if (getRightSubTree() != null) {\n                right.toArray(array, index + right.relativePosition);\n            }\n        }\n\n        /**\n         * Gets the next node in the list after this one.\n         *\n         * @return the next node\n         */\n        AVLNode<E> next() {\n            if (rightIsNext || right == null) {\n                return right;\n            }\n            return right.min();\n        }\n\n        /**\n         * Gets the node in the list before this one.\n         *\n         * @return the previous node\n         */\n        AVLNode<E> previous() {\n            if (leftIsPrevious || left == null) {\n                return left;\n            }\n            return left.max();\n        }\n\n        /**\n         * Inserts a node at the position index.\n         *\n         * @param index is the index of the position relative to the position of\n         * the parent node.\n         * @param obj is the object to be stored in the position.\n         */\n        AVLNode<E> insert(final int index, final E obj) {\n            final int indexRelativeToMe = index - relativePosition;\n\n            if (indexRelativeToMe <= 0) {\n                return insertOnLeft(indexRelativeToMe, obj);\n            }\n            return insertOnRight(indexRelativeToMe, obj);\n        }\n\n        private AVLNode<E> insertOnLeft(final int indexRelativeToMe, final E obj) {\n            if (getLeftSubTree() == null) {\n                setLeft(new AVLNode<E>(-1, obj, this, left), null);\n            } else {\n                setLeft(left.insert(indexRelativeToMe, obj), null);\n            }\n\n            if (relativePosition >= 0) {\n                relativePosition++;\n            }\n            AVLNode<E> ret = balance();\n            recalcHeight();\n            return ret;\n        }\n\n        private AVLNode<E> insertOnRight(final int indexRelativeToMe, final E obj) {\n            if (getRightSubTree() == null) {\n                setRight(new AVLNode<E>(+1, obj, right, this), null);\n            } else {\n                setRight(right.insert(indexRelativeToMe, obj), null);\n            }\n            if (relativePosition < 0) {\n                relativePosition--;\n            }\n            AVLNode<E> ret = balance();\n            recalcHeight();\n            return ret;\n        }\n\n        //-----------------------------------------------------------------------\n        /**\n         * Gets the left node, returning null if its a faedelung.\n         */\n        private AVLNode<E> getLeftSubTree() {\n            return leftIsPrevious ? null : left;\n        }\n\n        /**\n         * Gets the right node, returning null if its a faedelung.\n         */\n        private AVLNode<E> getRightSubTree() {\n            return rightIsNext ? null : right;\n        }\n\n        /**\n         * Gets the rightmost child of this node.\n         *\n         * @return the rightmost child (greatest index)\n         */\n        private AVLNode<E> max() {\n            return getRightSubTree() == null ? this : right.max();\n        }\n\n        /**\n         * Gets the leftmost child of this node.\n         *\n         * @return the leftmost child (smallest index)\n         */\n        private AVLNode<E> min() {\n            return getLeftSubTree() == null ? this : left.min();\n        }\n\n        /**\n         * Removes the node at a given position.\n         *\n         * @param index is the index of the element to be removed relative to the position of\n         * the parent node of the current node.\n         */\n        AVLNode<E> remove(final int index) {\n            final int indexRelativeToMe = index - relativePosition;\n\n            if (indexRelativeToMe == 0) {\n                return removeSelf();\n            }\n            if (indexRelativeToMe > 0) {\n                setRight(right.remove(indexRelativeToMe), right.right);\n                if (relativePosition < 0) {\n                    relativePosition++;\n                }\n            } else {\n                setLeft(left.remove(indexRelativeToMe), left.left);\n                if (relativePosition > 0) {\n                    relativePosition--;\n                }\n            }\n            recalcHeight();\n            return balance();\n        }\n\n        private AVLNode<E> removeMax() {\n            if (getRightSubTree() == null) {\n                return removeSelf();\n            }\n            setRight(right.removeMax(), right.right);\n            if (relativePosition < 0) {\n                relativePosition++;\n            }\n            recalcHeight();\n            return balance();\n        }\n\n        private AVLNode<E> removeMin() {\n            if (getLeftSubTree() == null) {\n                return removeSelf();\n            }\n            setLeft(left.removeMin(), left.left);\n            if (relativePosition > 0) {\n                relativePosition--;\n            }\n            recalcHeight();\n            return balance();\n        }\n\n        /**\n         * Removes this node from the tree.\n         *\n         * @return the node that replaces this one in the parent\n         */\n        private AVLNode<E> removeSelf() {\n            if (getRightSubTree() == null && getLeftSubTree() == null) {\n                return null;\n            }\n            if (getRightSubTree() == null) {\n                if (relativePosition > 0) {\n                    left.relativePosition += relativePosition + (relativePosition > 0 ? 0 : 1);\n                }\n                left.max().setRight(null, right);\n                return left;\n            }\n            if (getLeftSubTree() == null) {\n                right.relativePosition += relativePosition - (relativePosition < 0 ? 0 : 1);\n                right.min().setLeft(null, left);\n                return right;\n            }\n\n            if (heightRightMinusLeft() > 0) {\n                // more on the right, so delete from the right\n                final AVLNode<E> rightMin = right.min();\n                value = rightMin.value;\n                if (leftIsPrevious) {\n                    left = rightMin.left;\n                }\n                right = right.removeMin();\n                if (relativePosition < 0) {\n                    relativePosition++;\n                }\n            } else {\n                // more on the left or equal, so delete from the left\n                final AVLNode<E> leftMax = left.max();\n                value = leftMax.value;\n                if (rightIsNext) {\n                    right = leftMax.right;\n                }\n                final AVLNode<E> leftPrevious = left.left;\n                left = left.removeMax();\n                if (left == null) {\n                    // special case where left that was deleted was a double link\n                    // only occurs when height difference is equal\n                    left = leftPrevious;\n                    leftIsPrevious = true;\n                }\n                if (relativePosition > 0) {\n                    relativePosition--;\n                }\n            }\n            recalcHeight();\n            return this;\n        }\n\n        //-----------------------------------------------------------------------\n        /**\n         * Balances according to the AVL algorithm.\n         */\n        private AVLNode<E> balance() {\n            switch (heightRightMinusLeft()) {\n                case 1 :\n                case 0 :\n                case -1 :\n                    return this;\n                case -2 :\n                    if (left.heightRightMinusLeft() > 0) {\n                        setLeft(left.rotateLeft(), null);\n                    }\n                    return rotateRight();\n                case 2 :\n                    if (right.heightRightMinusLeft() < 0) {\n                        setRight(right.rotateRight(), null);\n                    }\n                    return rotateLeft();\n                default :\n                    throw new RuntimeException(\"tree inconsistent!\");\n            }\n        }\n\n        /**\n         * Gets the relative position.\n         */\n        private int getOffset(final AVLNode<E> node) {\n            if (node == null) {\n                return 0;\n            }\n            return node.relativePosition;\n        }\n\n        /**\n         * Sets the relative position.\n         */\n        private int setOffset(final AVLNode<E> node, final int newOffest) {\n            if (node == null) {\n                return 0;\n            }\n            final int oldOffset = getOffset(node);\n            node.relativePosition = newOffest;\n            return oldOffset;\n        }\n\n        /**\n         * Sets the height by calculation.\n         */\n        private void recalcHeight() {\n            height = Math.max(\n                getLeftSubTree() == null ? -1 : getLeftSubTree().height,\n                getRightSubTree() == null ? -1 : getRightSubTree().height) + 1;\n        }\n\n        /**\n         * Returns the height of the node or -1 if the node is null.\n         */\n        private int getHeight(final AVLNode<E> node) {\n            return node == null ? -1 : node.height;\n        }\n\n        /**\n         * Returns the height difference right - left\n         */\n        private int heightRightMinusLeft() {\n            return getHeight(getRightSubTree()) - getHeight(getLeftSubTree());\n        }\n\n        private AVLNode<E> rotateLeft() {\n            final AVLNode<E> newTop = right; // can't be faedelung!\n            final AVLNode<E> movedNode = getRightSubTree().getLeftSubTree();\n\n            final int newTopPosition = relativePosition + getOffset(newTop);\n            final int myNewPosition = -newTop.relativePosition;\n            final int movedPosition = getOffset(newTop) + getOffset(movedNode);\n\n            setRight(movedNode, newTop);\n            newTop.setLeft(this, null);\n\n            setOffset(newTop, newTopPosition);\n            setOffset(this, myNewPosition);\n            setOffset(movedNode, movedPosition);\n            return newTop;\n        }\n\n        private AVLNode<E> rotateRight() {\n            final AVLNode<E> newTop = left; // can't be faedelung\n            final AVLNode<E> movedNode = getLeftSubTree().getRightSubTree();\n\n            final int newTopPosition = relativePosition + getOffset(newTop);\n            final int myNewPosition = -newTop.relativePosition;\n            final int movedPosition = getOffset(newTop) + getOffset(movedNode);\n\n            setLeft(movedNode, newTop);\n            newTop.setRight(this, null);\n\n            setOffset(newTop, newTopPosition);\n            setOffset(this, myNewPosition);\n            setOffset(movedNode, movedPosition);\n            return newTop;\n        }\n\n        /**\n         * Sets the left field to the node, or the previous node if that is null\n         *\n         * @param node  the new left subtree node\n         * @param previous  the previous node in the linked list\n         */\n        private void setLeft(final AVLNode<E> node, final AVLNode<E> previous) {\n            leftIsPrevious = node == null;\n            left = leftIsPrevious ? previous : node;\n            recalcHeight();\n        }\n\n        /**\n         * Sets the right field to the node, or the next node if that is null\n         *\n         * @param node  the new left subtree node\n         * @param next  the next node in the linked list\n         */\n        private void setRight(final AVLNode<E> node, final AVLNode<E> next) {\n            rightIsNext = node == null;\n            right = rightIsNext ? next : node;\n            recalcHeight();\n        }\n\n//      private void checkFaedelung() {\n//          AVLNode maxNode = left.max();\n//          if (!maxNode.rightIsFaedelung || maxNode.right != this) {\n//              throw new RuntimeException(maxNode + \" should right-faedel to \" + this);\n//          }\n//          AVLNode minNode = right.min();\n//          if (!minNode.leftIsFaedelung || minNode.left != this) {\n//              throw new RuntimeException(maxNode + \" should left-faedel to \" + this);\n//          }\n//      }\n//\n//        private int checkTreeDepth() {\n//            int hright = (getRightSubTree() == null ? -1 : getRightSubTree().checkTreeDepth());\n//            //          System.out.print(\"checkTreeDepth\");\n//            //          System.out.print(this);\n//            //          System.out.print(\" left: \");\n//            //          System.out.print(_left);\n//            //          System.out.print(\" right: \");\n//            //          System.out.println(_right);\n//\n//            int hleft = (left == null ? -1 : left.checkTreeDepth());\n//            if (height != Math.max(hright, hleft) + 1) {\n//                throw new RuntimeException(\n//                    \"height should be max\" + hleft + \",\" + hright + \" but is \" + height);\n//            }\n//            return height;\n//        }\n//\n//        private int checkLeftSubNode() {\n//            if (getLeftSubTree() == null) {\n//                return 0;\n//            }\n//            int count = 1 + left.checkRightSubNode();\n//            if (left.relativePosition != -count) {\n//                throw new RuntimeException();\n//            }\n//            return count + left.checkLeftSubNode();\n//        }\n//\n//        private int checkRightSubNode() {\n//            AVLNode right = getRightSubTree();\n//            if (right == null) {\n//                return 0;\n//            }\n//            int count = 1;\n//            count += right.checkLeftSubNode();\n//            if (right.relativePosition != count) {\n//                throw new RuntimeException();\n//            }\n//            return count + right.checkRightSubNode();\n//        }\n\n        /**\n         * Used for debugging.\n         */\n        @Override\n        public String toString() {\n            return new StringBuilder()\n                .append(\"AVLNode(\")\n                .append(relativePosition)\n                .append(',')\n                .append(left != null)\n                .append(',')\n                .append(value)\n                .append(',')\n                .append(getRightSubTree() != null)\n                .append(\", faedelung \")\n                .append(rightIsNext)\n                .append(\" )\")\n                .toString();\n        }\n    }\n\n    /**\n     * A list iterator over the linked list.\n     */\n    static class TreeListIterator<E> implements ListIterator<E>, OrderedIterator<E> {\n        /** The parent list */\n        protected final TreeList<E> parent;\n        /**\n         * Cache of the next node that will be returned by {@link #next()}.\n         */\n        protected AVLNode<E> next;\n        /**\n         * The index of the next node to be returned.\n         */\n        protected int nextIndex;\n        /**\n         * Cache of the last node that was returned by {@link #next()}\n         * or {@link #previous()}.\n         */\n        protected AVLNode<E> current;\n        /**\n         * The index of the last node that was returned.\n         */\n        protected int currentIndex;\n        /**\n         * The modification count that the list is expected to have. If the list\n         * doesn't have this count, then a\n         * {@link java.util.ConcurrentModificationException} may be thrown by\n         * the operations.\n         */\n        protected int expectedModCount;\n\n        /**\n         * Create a ListIterator for a list.\n         *\n         * @param parent  the parent list\n         * @param fromIndex  the index to start at\n         */\n        protected TreeListIterator(final TreeList<E> parent, final int fromIndex) throws IndexOutOfBoundsException {\n            super();\n            this.parent = parent;\n            this.expectedModCount = parent.modCount;\n            this.next = parent.root == null ? null : parent.root.get(fromIndex);\n            this.nextIndex = fromIndex;\n            this.currentIndex = -1;\n        }\n\n        /**\n         * Checks the modification count of the list is the value that this\n         * object expects.\n         *\n         * @throws ConcurrentModificationException If the list's modification\n         * count isn't the value that was expected.\n         */\n        protected void checkModCount() {\n            if (parent.modCount != expectedModCount) {\n                throw new ConcurrentModificationException();\n            }\n        }\n\n        public boolean hasNext() {\n            return nextIndex < parent.size();\n        }\n\n        public E next() {\n            checkModCount();\n            if (!hasNext()) {\n                throw new NoSuchElementException(\"No element at index \" + nextIndex + \".\");\n            }\n            if (next == null) {\n                next = parent.root.get(nextIndex);\n            }\n            final E value = next.getValue();\n            current = next;\n            currentIndex = nextIndex++;\n            next = next.next();\n            return value;\n        }\n\n        public boolean hasPrevious() {\n            return nextIndex > 0;\n        }\n\n        public E previous() {\n            checkModCount();\n            if (!hasPrevious()) {\n                throw new NoSuchElementException(\"Already at start of list.\");\n            }\n            if (next == null) {\n                next = parent.root.get(nextIndex - 1);\n            } else {\n                next = next.previous();\n            }\n            final E value = next.getValue();\n            current = next;\n            currentIndex = --nextIndex;\n            return value;\n        }\n\n        public int nextIndex() {\n            return nextIndex;\n        }\n\n        public int previousIndex() {\n            return nextIndex() - 1;\n        }\n\n        public void remove() {\n            checkModCount();\n            if (currentIndex == -1) {\n                throw new IllegalStateException();\n            }\n            if (nextIndex == currentIndex) {\n                next = next.next();\n                parent.remove(currentIndex);\n            } else {\n                // remove() following next()\n                parent.remove(currentIndex);\n                nextIndex--;\n            }\n            // the AVL node referenced by next may have become stale after a remove\n            // reset it now: will be retrieved by next call to next()/previous() via nextIndex\n            current = null;\n            currentIndex = -1;\n            expectedModCount++;\n        }\n\n        public void set(final E obj) {\n            checkModCount();\n            if (current == null) {\n                throw new IllegalStateException();\n            }\n            current.setValue(obj);\n        }\n\n        public void add(final E obj) {\n            checkModCount();\n            parent.add(nextIndex, obj);\n            current = null;\n            currentIndex = -1;\n            nextIndex++;\n            expectedModCount++;\n        }\n    }\n\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections.list;\n\nimport java.util.AbstractList;\nimport java.util.Collection;\nimport java.util.ConcurrentModificationException;\nimport java.util.Iterator;\nimport java.util.ListIterator;\nimport java.util.NoSuchElementException;\n\nimport org.apache.commons.collections.OrderedIterator;\n\n/**\n * A <code>List</code> implementation that is optimised for fast insertions and\n * removals at any index in the list.\n * <p>\n * This list implementation utilises a tree structure internally to ensure that\n * all insertions and removals are O(log n). This provides much faster performance\n * than both an <code>ArrayList</code> and a <code>LinkedList</code> where elements\n * are inserted and removed repeatedly from anywhere in the list.\n * <p>\n * The following relative performance statistics are indicative of this class:\n * <pre>\n *              get  add  insert  iterate  remove\n * TreeList       3    5       1       2       1\n * ArrayList      1    1      40       1      40\n * LinkedList  5800    1     350       2     325\n * </pre>\n * <code>ArrayList</code> is a good general purpose list implementation.\n * It is faster than <code>TreeList</code> for most operations except inserting\n * and removing in the middle of the list. <code>ArrayList</code> also uses less\n * memory as <code>TreeList</code> uses one object per entry.\n * <p>\n * <code>LinkedList</code> is rarely a good choice of implementation.\n * <code>TreeList</code> is almost always a good replacement for it, although it\n * does use slightly more memory.\n *\n * @since 3.1\n * @version $Id$\n */\npublic class TreeList<E> extends AbstractList<E> {\n//    add; toArray; iterator; insert; get; indexOf; remove\n//    TreeList = 1260;7360;3080;  160;   170;3400;  170;\n//   ArrayList =  220;1480;1760; 6870;    50;1540; 7200;\n//  LinkedList =  270;7360;3350;55860;290720;2910;55200;\n\n    /** The root node in the AVL tree */\n    private AVLNode<E> root;\n\n    /** The current size of the list */\n    private int size;\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructs a new empty list.\n     */\n    public TreeList() {\n        super();\n    }\n\n    /**\n     * Constructs a new empty list that copies the specified list.\n     *\n     * @param coll  the collection to copy\n     * @throws NullPointerException if the collection is null\n     */\n    public TreeList(final Collection<E> coll) {\n        super();\n        addAll(coll);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the element at the specified index.\n     *\n     * @param index  the index to retrieve\n     * @return the element at the specified index\n     */\n    @Override\n    public E get(final int index) {\n        checkInterval(index, 0, size() - 1);\n        return root.get(index).getValue();\n    }\n\n    /**\n     * Gets the current size of the list.\n     *\n     * @return the current size\n     */\n    @Override\n    public int size() {\n        return size;\n    }\n\n    /**\n     * Gets an iterator over the list.\n     *\n     * @return an iterator over the list\n     */\n    @Override\n    public Iterator<E> iterator() {\n        // override to go 75% faster\n        return listIterator(0);\n    }\n\n    /**\n     * Gets a ListIterator over the list.\n     *\n     * @return the new iterator\n     */\n    @Override\n    public ListIterator<E> listIterator() {\n        // override to go 75% faster\n        return listIterator(0);\n    }\n\n    /**\n     * Gets a ListIterator over the list.\n     *\n     * @param fromIndex  the index to start from\n     * @return the new iterator\n     */\n    @Override\n    public ListIterator<E> listIterator(final int fromIndex) {\n        // override to go 75% faster\n        // cannot use EmptyIterator as iterator.add() must work\n        checkInterval(fromIndex, 0, size());\n        return new TreeListIterator<E>(this, fromIndex);\n    }\n\n    /**\n     * Searches for the index of an object in the list.\n     *\n     * @param object  the object to search\n     * @return the index of the object, -1 if not found\n     */\n    @Override\n    public int indexOf(final Object object) {\n        // override to go 75% faster\n        if (root == null) {\n            return -1;\n        }\n        return root.indexOf(object, root.relativePosition);\n    }\n\n    /**\n     * Searches for the presence of an object in the list.\n     *\n     * @param object  the object to check\n     * @return true if the object is found\n     */\n    @Override\n    public boolean contains(final Object object) {\n        return indexOf(object) >= 0;\n    }\n\n    /**\n     * Converts the list into an array.\n     *\n     * @return the list as an array\n     */\n    @Override\n    public Object[] toArray() {\n        // override to go 20% faster\n        final Object[] array = new Object[size()];\n        if (root != null) {\n            root.toArray(array, root.relativePosition);\n        }\n        return array;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Adds a new element to the list.\n     *\n     * @param index  the index to add before\n     * @param obj  the element to add\n     */\n    @Override\n    public void add(final int index, final E obj) {\n        modCount++;\n        checkInterval(index, 0, size());\n        if (root == null) {\n            root = new AVLNode<E>(index, obj, null, null);\n        } else {\n            root = root.insert(index, obj);\n        }\n        size++;\n    }\n\n    /**\n     * Sets the element at the specified index.\n     *\n     * @param index  the index to set\n     * @param obj  the object to store at the specified index\n     * @return the previous object at that index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    @Override\n    public E set(final int index, final E obj) {\n        checkInterval(index, 0, size() - 1);\n        final AVLNode<E> node = root.get(index);\n        final E result = node.value;\n        node.setValue(obj);\n        return result;\n    }\n\n    /**\n     * Removes the element at the specified index.\n     *\n     * @param index  the index to remove\n     * @return the previous object at that index\n     */\n    @Override\n    public E remove(final int index) {\n        modCount++;\n        checkInterval(index, 0, size() - 1);\n        final E result = get(index);\n        root = root.remove(index);\n        size--;\n        return result;\n    }\n\n    /**\n     * Clears the list, removing all entries.\n     */\n    @Override\n    public void clear() {\n        modCount++;\n        root = null;\n        size = 0;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks whether the index is valid.\n     *\n     * @param index  the index to check\n     * @param startIndex  the first allowed index\n     * @param endIndex  the last allowed index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    private void checkInterval(final int index, final int startIndex, final int endIndex) {\n        if (index < startIndex || index > endIndex) {\n            throw new IndexOutOfBoundsException(\"Invalid index:\" + index + \", size=\" + size());\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Implements an AVLNode which keeps the offset updated.\n     * <p>\n     * This node contains the real work.\n     * TreeList is just there to implement {@link java.util.List}.\n     * The nodes don't know the index of the object they are holding.  They\n     * do know however their position relative to their parent node.\n     * This allows to calculate the index of a node while traversing the tree.\n     * <p>\n     * The Faedelung calculation stores a flag for both the left and right child\n     * to indicate if they are a child (false) or a link as in linked list (true).\n     */\n    static class AVLNode<E> {\n        /** The left child node or the predecessor if {@link #leftIsPrevious}.*/\n        private AVLNode<E> left;\n        /** Flag indicating that left reference is not a subtree but the predecessor. */\n        private boolean leftIsPrevious;\n        /** The right child node or the successor if {@link #rightIsNext}. */\n        private AVLNode<E> right;\n        /** Flag indicating that right reference is not a subtree but the successor. */\n        private boolean rightIsNext;\n        /** How many levels of left/right are below this one. */\n        private int height;\n        /** The relative position, root holds absolute position. */\n        private int relativePosition;\n        /** The stored element. */\n        private E value;\n\n        /**\n         * Constructs a new node with a relative position.\n         *\n         * @param relativePosition  the relative position of the node\n         * @param obj  the value for the ndoe\n         * @param rightFollower the node with the value following this one\n         * @param leftFollower the node with the value leading this one\n         */\n        private AVLNode(final int relativePosition, final E obj,\n                        final AVLNode<E> rightFollower, final AVLNode<E> leftFollower) {\n            this.relativePosition = relativePosition;\n            value = obj;\n            rightIsNext = true;\n            leftIsPrevious = true;\n            right = rightFollower;\n            left = leftFollower;\n        }\n\n        /**\n         * Gets the value.\n         *\n         * @return the value of this node\n         */\n        E getValue() {\n            return value;\n        }\n\n        /**\n         * Sets the value.\n         *\n         * @param obj  the value to store\n         */\n        void setValue(final E obj) {\n            this.value = obj;\n        }\n\n        /**\n         * Locate the element with the given index relative to the\n         * offset of the parent of this node.\n         */\n        AVLNode<E> get(final int index) {\n            final int indexRelativeToMe = index - relativePosition;\n\n            if (indexRelativeToMe == 0) {\n                return this;\n            }\n\n            final AVLNode<E> nextNode = indexRelativeToMe < 0 ? getLeftSubTree() : getRightSubTree();\n            if (nextNode == null) {\n                return null;\n            }\n            return nextNode.get(indexRelativeToMe);\n        }\n\n        /**\n         * Locate the index that contains the specified object.\n         */\n        int indexOf(final Object object, final int index) {\n            if (getLeftSubTree() != null) {\n                final int result = left.indexOf(object, index + left.relativePosition);\n                if (result != -1) {\n                    return result;\n                }\n            }\n            if (value == null ? value == object : value.equals(object)) {\n                return index;\n            }\n            if (getRightSubTree() != null) {\n                return right.indexOf(object, index + right.relativePosition);\n            }\n            return -1;\n        }\n\n        /**\n         * Stores the node and its children into the array specified.\n         *\n         * @param array the array to be filled\n         * @param index the index of this node\n         */\n        void toArray(final Object[] array, final int index) {\n            array[index] = value;\n            if (getLeftSubTree() != null) {\n                left.toArray(array, index + left.relativePosition);\n            }\n            if (getRightSubTree() != null) {\n                right.toArray(array, index + right.relativePosition);\n            }\n        }\n\n        /**\n         * Gets the next node in the list after this one.\n         *\n         * @return the next node\n         */\n        AVLNode<E> next() {\n            if (rightIsNext || right == null) {\n                return right;\n            }\n            return right.min();\n        }\n\n        /**\n         * Gets the node in the list before this one.\n         *\n         * @return the previous node\n         */\n        AVLNode<E> previous() {\n            if (leftIsPrevious || left == null) {\n                return left;\n            }\n            return left.max();\n        }\n\n        /**\n         * Inserts a node at the position index.\n         *\n         * @param index is the index of the position relative to the position of\n         * the parent node.\n         * @param obj is the object to be stored in the position.\n         */\n        AVLNode<E> insert(final int index, final E obj) {\n            final int indexRelativeToMe = index - relativePosition;\n\n            if (indexRelativeToMe <= 0) {\n                return insertOnLeft(indexRelativeToMe, obj);\n            }\n            return insertOnRight(indexRelativeToMe, obj);\n        }\n\n        private AVLNode<E> insertOnLeft(final int indexRelativeToMe, final E obj) {\n            if (getLeftSubTree() == null) {\n                setLeft(new AVLNode<E>(-1, obj, this, left), null);\n            } else {\n                setLeft(left.insert(indexRelativeToMe, obj), null);\n            }\n\n            if (relativePosition >= 0) {\n                relativePosition++;\n            }\n            AVLNode<E> ret = balance();\n            recalcHeight();\n            return ret;\n        }\n\n        private AVLNode<E> insertOnRight(final int indexRelativeToMe, final E obj) {\n            if (getRightSubTree() == null) {\n                setRight(new AVLNode<E>(+1, obj, right, this), null);\n            } else {\n                setRight(right.insert(indexRelativeToMe, obj), null);\n            }\n            if (relativePosition < 0) {\n                relativePosition--;\n            }\n            AVLNode<E> ret = balance();\n            recalcHeight();\n            return ret;\n        }\n\n        //-----------------------------------------------------------------------\n        /**\n         * Gets the left node, returning null if its a faedelung.\n         */\n        private AVLNode<E> getLeftSubTree() {\n            return leftIsPrevious ? null : left;\n        }\n\n        /**\n         * Gets the right node, returning null if its a faedelung.\n         */\n        private AVLNode<E> getRightSubTree() {\n            return rightIsNext ? null : right;\n        }\n\n        /**\n         * Gets the rightmost child of this node.\n         *\n         * @return the rightmost child (greatest index)\n         */\n        private AVLNode<E> max() {\n            return getRightSubTree() == null ? this : right.max();\n        }\n\n        /**\n         * Gets the leftmost child of this node.\n         *\n         * @return the leftmost child (smallest index)\n         */\n        private AVLNode<E> min() {\n            return getLeftSubTree() == null ? this : left.min();\n        }\n\n        /**\n         * Removes the node at a given position.\n         *\n         * @param index is the index of the element to be removed relative to the position of\n         * the parent node of the current node.\n         */\n        AVLNode<E> remove(final int index) {\n            final int indexRelativeToMe = index - relativePosition;\n\n            if (indexRelativeToMe == 0) {\n                return removeSelf();\n            }\n            if (indexRelativeToMe > 0) {\n                setRight(right.remove(indexRelativeToMe), right.right);\n                if (relativePosition < 0) {\n                    relativePosition++;\n                }\n            } else {\n                setLeft(left.remove(indexRelativeToMe), left.left);\n                if (relativePosition > 0) {\n                    relativePosition--;\n                }\n            }\n            recalcHeight();\n            return balance();\n        }\n\n        private AVLNode<E> removeMax() {\n            if (getRightSubTree() == null) {\n                return removeSelf();\n            }\n            setRight(right.removeMax(), right.right);\n            if (relativePosition < 0) {\n                relativePosition++;\n            }\n            recalcHeight();\n            return balance();\n        }\n\n        private AVLNode<E> removeMin() {\n            if (getLeftSubTree() == null) {\n                return removeSelf();\n            }\n            setLeft(left.removeMin(), left.left);\n            if (relativePosition > 0) {\n                relativePosition--;\n            }\n            recalcHeight();\n            return balance();\n        }\n\n        /**\n         * Removes this node from the tree.\n         *\n         * @return the node that replaces this one in the parent\n         */\n        private AVLNode<E> removeSelf() {\n            if (getRightSubTree() == null && getLeftSubTree() == null) {\n                return null;\n            }\n            if (getRightSubTree() == null) {\n                if (relativePosition > 0) {\n                    left.relativePosition += relativePosition + (relativePosition > 0 ? 0 : 1);\n                }\n                left.max().setRight(null, right);\n                return left;\n            }\n            if (getLeftSubTree() == null) {\n                right.relativePosition += relativePosition - (relativePosition < 0 ? 0 : 1);\n                right.min().setLeft(null, left);\n                return right;\n            }\n\n            if (heightRightMinusLeft() > 0) {\n                // more on the right, so delete from the right\n                final AVLNode<E> rightMin = right.min();\n                value = rightMin.value;\n                if (leftIsPrevious) {\n                    left = rightMin.left;\n                }\n                right = right.removeMin();\n                if (relativePosition < 0) {\n                    relativePosition++;\n                }\n            } else {\n                // more on the left or equal, so delete from the left\n                final AVLNode<E> leftMax = left.max();\n                value = leftMax.value;\n                if (rightIsNext) {\n                    right = leftMax.right;\n                }\n                final AVLNode<E> leftPrevious = left.left;\n                left = left.removeMax();\n                if (left == null) {\n                    // special case where left that was deleted was a double link\n                    // only occurs when height difference is equal\n                    left = leftPrevious;\n                    leftIsPrevious = true;\n                }\n                if (relativePosition > 0) {\n                    relativePosition--;\n                }\n            }\n            recalcHeight();\n            return this;\n        }\n\n        //-----------------------------------------------------------------------\n        /**\n         * Balances according to the AVL algorithm.\n         */\n        private AVLNode<E> balance() {\n            switch (heightRightMinusLeft()) {\n                case 1 :\n                case 0 :\n                case -1 :\n                    return this;\n                case -2 :\n                    if (left.heightRightMinusLeft() > 0) {\n                        setLeft(left.rotateLeft(), null);\n                    }\n                    return rotateRight();\n                case 2 :\n                    if (right.heightRightMinusLeft() < 0) {\n                        setRight(right.rotateRight(), null);\n                    }\n                    return rotateLeft();\n                default :\n                    throw new RuntimeException(\"tree inconsistent!\");\n            }\n        }\n\n        /**\n         * Gets the relative position.\n         */\n        private int getOffset(final AVLNode<E> node) {\n            if (node == null) {\n                return 0;\n            }\n            return node.relativePosition;\n        }\n\n        /**\n         * Sets the relative position.\n         */\n        private int setOffset(final AVLNode<E> node, final int newOffest) {\n            if (node == null) {\n                return 0;\n            }\n            final int oldOffset = getOffset(node);\n            node.relativePosition = newOffest;\n            return oldOffset;\n        }\n\n        /**\n         * Sets the height by calculation.\n         */\n        private void recalcHeight() {\n            height = Math.max(\n                getLeftSubTree() == null ? -1 : getLeftSubTree().height,\n                getRightSubTree() == null ? -1 : getRightSubTree().height) + 1;\n        }\n\n        /**\n         * Returns the height of the node or -1 if the node is null.\n         */\n        private int getHeight(final AVLNode<E> node) {\n            return node == null ? -1 : node.height;\n        }\n\n        /**\n         * Returns the height difference right - left\n         */\n        private int heightRightMinusLeft() {\n            return getHeight(getRightSubTree()) - getHeight(getLeftSubTree());\n        }\n\n        private AVLNode<E> rotateLeft() {\n            final AVLNode<E> newTop = right; // can't be faedelung!\n            final AVLNode<E> movedNode = getRightSubTree().getLeftSubTree();\n\n            final int newTopPosition = relativePosition + getOffset(newTop);\n            final int myNewPosition = -newTop.relativePosition;\n            final int movedPosition = getOffset(newTop) + getOffset(movedNode);\n\n            setRight(movedNode, newTop);\n            newTop.setLeft(this, null);\n\n            setOffset(newTop, newTopPosition);\n            setOffset(this, myNewPosition);\n            setOffset(movedNode, movedPosition);\n            return newTop;\n        }\n\n        private AVLNode<E> rotateRight() {\n            final AVLNode<E> newTop = left; // can't be faedelung\n            final AVLNode<E> movedNode = getLeftSubTree().getRightSubTree();\n\n            final int newTopPosition = relativePosition + getOffset(newTop);\n            final int myNewPosition = -newTop.relativePosition;\n            final int movedPosition = getOffset(newTop) + getOffset(movedNode);\n\n            setLeft(movedNode, newTop);\n            newTop.setRight(this, null);\n\n            setOffset(newTop, newTopPosition);\n            setOffset(this, myNewPosition);\n            setOffset(movedNode, movedPosition);\n            return newTop;\n        }\n\n        /**\n         * Sets the left field to the node, or the previous node if that is null\n         *\n         * @param node  the new left subtree node\n         * @param previous  the previous node in the linked list\n         */\n        private void setLeft(final AVLNode<E> node, final AVLNode<E> previous) {\n            leftIsPrevious = node == null;\n            left = leftIsPrevious ? previous : node;\n            recalcHeight();\n        }\n\n        /**\n         * Sets the right field to the node, or the next node if that is null\n         *\n         * @param node  the new left subtree node\n         * @param next  the next node in the linked list\n         */\n        private void setRight(final AVLNode<E> node, final AVLNode<E> next) {\n            rightIsNext = node == null;\n            right = rightIsNext ? next : node;\n            recalcHeight();\n        }\n\n//      private void checkFaedelung() {\n//          AVLNode maxNode = left.max();\n//          if (!maxNode.rightIsFaedelung || maxNode.right != this) {\n//              throw new RuntimeException(maxNode + \" should right-faedel to \" + this);\n//          }\n//          AVLNode minNode = right.min();\n//          if (!minNode.leftIsFaedelung || minNode.left != this) {\n//              throw new RuntimeException(maxNode + \" should left-faedel to \" + this);\n//          }\n//      }\n//\n//        private int checkTreeDepth() {\n//            int hright = (getRightSubTree() == null ? -1 : getRightSubTree().checkTreeDepth());\n//            //          System.out.print(\"checkTreeDepth\");\n//            //          System.out.print(this);\n//            //          System.out.print(\" left: \");\n//            //          System.out.print(_left);\n//            //          System.out.print(\" right: \");\n//            //          System.out.println(_right);\n//\n//            int hleft = (left == null ? -1 : left.checkTreeDepth());\n//            if (height != Math.max(hright, hleft) + 1) {\n//                throw new RuntimeException(\n//                    \"height should be max\" + hleft + \",\" + hright + \" but is \" + height);\n//            }\n//            return height;\n//        }\n//\n//        private int checkLeftSubNode() {\n//            if (getLeftSubTree() == null) {\n//                return 0;\n//            }\n//            int count = 1 + left.checkRightSubNode();\n//            if (left.relativePosition != -count) {\n//                throw new RuntimeException();\n//            }\n//            return count + left.checkLeftSubNode();\n//        }\n//\n//        private int checkRightSubNode() {\n//            AVLNode right = getRightSubTree();\n//            if (right == null) {\n//                return 0;\n//            }\n//            int count = 1;\n//            count += right.checkLeftSubNode();\n//            if (right.relativePosition != count) {\n//                throw new RuntimeException();\n//            }\n//            return count + right.checkRightSubNode();\n//        }\n\n        /**\n         * Used for debugging.\n         */\n        @Override\n        public String toString() {\n            return new StringBuilder()\n                .append(\"AVLNode(\")\n                .append(relativePosition)\n                .append(',')\n                .append(left != null)\n                .append(',')\n                .append(value)\n                .append(',')\n                .append(getRightSubTree() != null)\n                .append(\", faedelung \")\n                .append(rightIsNext)\n                .append(\" )\")\n                .toString();\n        }\n    }\n\n    /**\n     * A list iterator over the linked list.\n     */\n    static class TreeListIterator<E> implements ListIterator<E>, OrderedIterator<E> {\n        /** The parent list */\n        protected final TreeList<E> parent;\n        /**\n         * Cache of the next node that will be returned by {@link #next()}.\n         */\n        protected AVLNode<E> next;\n        /**\n         * The index of the next node to be returned.\n         */\n        protected int nextIndex;\n        /**\n         * Cache of the last node that was returned by {@link #next()}\n         * or {@link #previous()}.\n         */\n        protected AVLNode<E> current;\n        /**\n         * The index of the last node that was returned.\n         */\n        protected int currentIndex;\n        /**\n         * The modification count that the list is expected to have. If the list\n         * doesn't have this count, then a\n         * {@link java.util.ConcurrentModificationException} may be thrown by\n         * the operations.\n         */\n        protected int expectedModCount;\n\n        /**\n         * Create a ListIterator for a list.\n         *\n         * @param parent  the parent list\n         * @param fromIndex  the index to start at\n         */\n        protected TreeListIterator(final TreeList<E> parent, final int fromIndex) throws IndexOutOfBoundsException {\n            super();\n            this.parent = parent;\n            this.expectedModCount = parent.modCount;\n            this.next = parent.root == null ? null : parent.root.get(fromIndex);\n            this.nextIndex = fromIndex;\n            this.currentIndex = -1;\n        }\n\n        /**\n         * Checks the modification count of the list is the value that this\n         * object expects.\n         *\n         * @throws ConcurrentModificationException If the list's modification\n         * count isn't the value that was expected.\n         */\n        protected void checkModCount() {\n            if (parent.modCount != expectedModCount) {\n                throw new ConcurrentModificationException();\n            }\n        }\n\n        public boolean hasNext() {\n            return nextIndex < parent.size();\n        }\n\n        public E next() {\n            checkModCount();\n            if (!hasNext()) {\n                throw new NoSuchElementException(\"No element at index \" + nextIndex + \".\");\n            }\n            if (next == null) {\n                next = parent.root.get(nextIndex);\n            }\n            final E value = next.getValue();\n            current = next;\n            currentIndex = nextIndex++;\n            next = next.next();\n            return value;\n        }\n\n        public boolean hasPrevious() {\n            return nextIndex > 0;\n        }\n\n        public E previous() {\n            checkModCount();\n            if (!hasPrevious()) {\n                throw new NoSuchElementException(\"Already at start of list.\");\n            }\n            if (next == null) {\n                next = parent.root.get(nextIndex - 1);\n            } else {\n                next = next.previous();\n            }\n            final E value = next.getValue();\n            current = next;\n            currentIndex = --nextIndex;\n            return value;\n        }\n\n        public int nextIndex() {\n            return nextIndex;\n        }\n\n        public int previousIndex() {\n            return nextIndex() - 1;\n        }\n\n        public void remove() {\n            checkModCount();\n            if (currentIndex == -1) {\n                throw new IllegalStateException();\n            }\n            parent.remove(currentIndex);\n            if (nextIndex != currentIndex) {\n                // remove() following next()\n                nextIndex--;\n            }\n            // the AVL node referenced by next may have become stale after a remove\n            // reset it now: will be retrieved by next call to next()/previous() via nextIndex\n            next = null;\n            current = null;\n            currentIndex = -1;\n            expectedModCount++;\n        }\n\n        public void set(final E obj) {\n            checkModCount();\n            if (current == null) {\n                throw new IllegalStateException();\n            }\n            current.setValue(obj);\n        }\n\n        public void add(final E obj) {\n            checkModCount();\n            parent.add(nextIndex, obj);\n            current = null;\n            currentIndex = -1;\n            nextIndex++;\n            expectedModCount++;\n        }\n    }\n\n}\n"}]}
{"project": "Collections", "bug_id": 21, "classes_modified": [{"class_name": "org.apache.commons.collections4.list.SetUniqueList", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4.list;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Set;\n\nimport org.apache.commons.collections4.set.UnmodifiableSet;\nimport org.apache.commons.collections4.iterators.AbstractIteratorDecorator;\nimport org.apache.commons.collections4.iterators.AbstractListIteratorDecorator;\n\n/**\n * Decorates a <code>List</code> to ensure that no duplicates are present much\n * like a <code>Set</code>.\n * <p>\n * The <code>List</code> interface makes certain assumptions/requirements. This\n * implementation breaks these in certain ways, but this is merely the result of\n * rejecting duplicates. Each violation is explained in the method, but it\n * should not affect you. Bear in mind that Sets require immutable objects to\n * function correctly.\n * <p>\n * The {@link org.apache.commons.collections4.set.ListOrderedSet ListOrderedSet}\n * class provides an alternative approach, by wrapping an existing Set and\n * retaining insertion order in the iterator.\n * <p>\n * This class is Serializable from Commons Collections 3.1.\n * \n * @since 3.0\n * @version $Id$\n */\npublic class SetUniqueList<E> extends AbstractSerializableListDecorator<E> {\n\n    /** Serialization version. */\n    private static final long serialVersionUID = 7196982186153478694L;\n\n    /** Internal Set to maintain uniqueness. */\n    protected final Set<E> set;\n\n    /**\n     * Factory method to create a SetList using the supplied list to retain\n     * order.\n     * <p>\n     * If the list contains duplicates, these are removed (first indexed one\n     * kept). A <code>HashSet</code> is used for the set behaviour.\n     * \n     * @param <E>\n     *            the element type\n     * @param list\n     *            the list to decorate, must not be null\n     * @return a new {@link SetUniqueList}\n     * @throws IllegalArgumentException\n     *             if list is null\n     */\n    public static <E> SetUniqueList<E> setUniqueList(final List<E> list) {\n        if (list == null) {\n            throw new IllegalArgumentException(\"List must not be null\");\n        }\n        if (list.isEmpty()) {\n            return new SetUniqueList<E>(list, new HashSet<E>());\n        }\n        final List<E> temp = new ArrayList<E>(list);\n        list.clear();\n        final SetUniqueList<E> sl = new SetUniqueList<E>(list, new HashSet<E>());\n        sl.addAll(temp);\n        return sl;\n    }\n\n    // -----------------------------------------------------------------------\n    /**\n     * Constructor that wraps (not copies) the List and specifies the set to\n     * use.\n     * <p>\n     * The set and list must both be correctly initialised to the same elements.\n     * \n     * @param set\n     *            the set to decorate, must not be null\n     * @param list\n     *            the list to decorate, must not be null\n     * @throws IllegalArgumentException\n     *             if set or list is null\n     */\n    protected SetUniqueList(final List<E> list, final Set<E> set) {\n        super(list);\n        if (set == null) {\n            throw new IllegalArgumentException(\"Set must not be null\");\n        }\n        this.set = set;\n    }\n\n    // -----------------------------------------------------------------------\n    /**\n     * Gets an unmodifiable view as a Set.\n     * \n     * @return an unmodifiable set view\n     */\n    public Set<E> asSet() {\n        return UnmodifiableSet.unmodifiableSet(set);\n    }\n\n    // -----------------------------------------------------------------------\n    /**\n     * Adds an element to the list if it is not already present.\n     * <p>\n     * <i>(Violation)</i> The <code>List</code> interface requires that this\n     * method returns <code>true</code> always. However this class may return\n     * <code>false</code> because of the <code>Set</code> behaviour.\n     * \n     * @param object\n     *            the object to add\n     * @return true if object was added\n     */\n    @Override\n    public boolean add(final E object) {\n        // gets initial size\n        final int sizeBefore = size();\n\n        // adds element if unique\n        add(size(), object);\n\n        // compares sizes to detect if collection changed\n        return sizeBefore != size();\n    }\n\n    /**\n     * Adds an element to a specific index in the list if it is not already\n     * present.\n     * <p>\n     * <i>(Violation)</i> The <code>List</code> interface makes the assumption\n     * that the element is always inserted. This may not happen with this\n     * implementation.\n     * \n     * @param index\n     *            the index to insert at\n     * @param object\n     *            the object to add\n     */\n    @Override\n    public void add(final int index, final E object) {\n        // adds element if it is not contained already\n        if (set.contains(object) == false) {\n            super.add(index, object);\n            set.add(object);\n        }\n    }\n\n    /**\n     * Adds a collection of objects to the end of the list avoiding duplicates.\n     * <p>\n     * Only elements that are not already in this list will be added, and\n     * duplicates from the specified collection will be ignored.\n     * <p>\n     * <i>(Violation)</i> The <code>List</code> interface makes the assumption\n     * that the elements are always inserted. This may not happen with this\n     * implementation.\n     * \n     * @param coll\n     *            the collection to add in iterator order\n     * @return true if this collection changed\n     */\n    @Override\n    public boolean addAll(final Collection<? extends E> coll) {\n        return addAll(size(), coll);\n    }\n\n    /**\n     * Adds a collection of objects a specific index in the list avoiding\n     * duplicates.\n     * <p>\n     * Only elements that are not already in this list will be added, and\n     * duplicates from the specified collection will be ignored.\n     * <p>\n     * <i>(Violation)</i> The <code>List</code> interface makes the assumption\n     * that the elements are always inserted. This may not happen with this\n     * implementation.\n     * \n     * @param index\n     *            the index to insert at\n     * @param coll\n     *            the collection to add in iterator order\n     * @return true if this collection changed\n     */\n    @Override\n    public boolean addAll(final int index, final Collection<? extends E> coll) {\n        final List<E> temp = new ArrayList<E>();\n        for (final E e : coll) {\n            if (set.add(e)) {\n                temp.add(e);\n            }\n        }\n        return super.addAll(index, temp);\n    }\n\n    // -----------------------------------------------------------------------\n    /**\n     * Sets the value at the specified index avoiding duplicates.\n     * <p>\n     * The object is set into the specified index. Afterwards, any previous\n     * duplicate is removed. If the object is not already in the list then a\n     * normal set occurs. If it is present, then the old version is removed.\n     * \n     * @param index\n     *            the index to insert at\n     * @param object\n     *            the object to set\n     * @return the previous object\n     */\n    @Override\n    public E set(final int index, final E object) {\n        final int pos = indexOf(object);\n        final E removed = super.set(index, object);\n\n        if (pos != -1 && pos != index) {\n            // the object is already in the unique list\n            // (and it hasn't been swapped with itself)\n            super.remove(pos); // remove the duplicate by index\n        }\n\n        set.remove(removed); // remove the item deleted by the set\n        set.add(object); // add the new item to the unique set\n\n        return removed; // return the item deleted by the set\n    }\n\n    @Override\n    public boolean remove(final Object object) {\n        final boolean result = set.remove(object);\n        if (result) {\n            super.remove(object);\n        }\n        return result;\n    }\n\n    @Override\n    public E remove(final int index) {\n        final E result = super.remove(index);\n        set.remove(result);\n        return result;\n    }\n\n    @Override\n    public boolean removeAll(final Collection<?> coll) {\n        boolean result = false;\n        for (final Object name : coll) {\n            result |= remove(name);\n        }\n        return result;\n    }\n\n    @Override\n    public boolean retainAll(final Collection<?> coll) {\n        final Set<Object> setRetainAll = new HashSet<Object>();\n        for (final Object next : coll) {\n            if (set.contains(next)) {\n                setRetainAll.add(next);\n            }\n        }\n        if (setRetainAll.size() == set.size()) {\n            return false;\n        }\n        if (setRetainAll.size() == 0) {\n            clear();\n        } else {\n            for (final Iterator<E> it = iterator(); it.hasNext();) {\n                if (!setRetainAll.contains(it.next())) {\n                    it.remove();\n                }\n            }\n        }\n        return true;\n    }\n\n    @Override\n    public void clear() {\n        super.clear();\n        set.clear();\n    }\n\n    @Override\n    public boolean contains(final Object object) {\n        return set.contains(object);\n    }\n\n    @Override\n    public boolean containsAll(final Collection<?> coll) {\n        return set.containsAll(coll);\n    }\n\n    @Override\n    public Iterator<E> iterator() {\n        return new SetListIterator<E>(super.iterator(), set);\n    }\n\n    @Override\n    public ListIterator<E> listIterator() {\n        return new SetListListIterator<E>(super.listIterator(), set);\n    }\n\n    @Override\n    public ListIterator<E> listIterator(final int index) {\n        return new SetListListIterator<E>(super.listIterator(index), set);\n    }\n\n    /**\n     * {@inheritDoc}\n     * <p>\n     * NOTE: from 4.0, an unmodifiable list will be returned, as changes to the\n     * subList can invalidate the parent list. \n     */\n    @Override\n    public List<E> subList(final int fromIndex, final int toIndex) {\n        final List<E> superSubList = super.subList(fromIndex, toIndex);\n        final Set<E> subSet = createSetBasedOnList(set, superSubList);\n        return new SetUniqueList<E>(superSubList, subSet);\n    }\n\n    /**\n     * Create a new {@link Set} with the same type as the provided {@code set}\n     * and populate it with all elements of {@code list}.\n     * \n     * @param set\n     *            the {@link Set} to be used as return type, must not be null\n     * @param list\n     *            the {@link List} to populate the {@link Set}\n     * @return a new {@link Set} populated with all elements of the provided\n     *         {@link List}\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected Set<E> createSetBasedOnList(final Set<E> set, final List<E> list) {\n        Set<E> subSet;\n        if (set.getClass().equals(HashSet.class)) {\n            subSet = new HashSet<E>(list.size());\n        } else {\n            try {\n                subSet = set.getClass().newInstance();\n            } catch (final InstantiationException ie) {\n                subSet = new HashSet<E>();\n            } catch (final IllegalAccessException iae) {\n                subSet = new HashSet<E>();\n            }\n        }\n        subSet.addAll(list);\n        return subSet;\n    }\n\n    // -----------------------------------------------------------------------\n    /**\n     * Inner class iterator.\n     */\n    static class SetListIterator<E> extends AbstractIteratorDecorator<E> {\n\n        protected final Set<E> set;\n        protected E last = null;\n\n        protected SetListIterator(final Iterator<E> it, final Set<E> set) {\n            super(it);\n            this.set = set;\n        }\n\n        @Override\n        public E next() {\n            last = super.next();\n            return last;\n        }\n\n        @Override\n        public void remove() {\n            super.remove();\n            set.remove(last);\n            last = null;\n        }\n    }\n\n    /**\n     * Inner class iterator.\n     */\n    static class SetListListIterator<E> extends\n            AbstractListIteratorDecorator<E> {\n\n        protected final Set<E> set;\n        protected E last = null;\n\n        protected SetListListIterator(final ListIterator<E> it, final Set<E> set) {\n            super(it);\n            this.set = set;\n        }\n\n        @Override\n        public E next() {\n            last = super.next();\n            return last;\n        }\n\n        @Override\n        public E previous() {\n            last = super.previous();\n            return last;\n        }\n\n        @Override\n        public void remove() {\n            super.remove();\n            set.remove(last);\n            last = null;\n        }\n\n        @Override\n        public void add(final E object) {\n            if (set.contains(object) == false) {\n                super.add(object);\n                set.add(object);\n            }\n        }\n\n        @Override\n        public void set(final E object) {\n            throw new UnsupportedOperationException(\"ListIterator does not support set\");\n        }\n    }\n\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4.list;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Set;\n\nimport org.apache.commons.collections4.ListUtils;\nimport org.apache.commons.collections4.set.UnmodifiableSet;\nimport org.apache.commons.collections4.iterators.AbstractIteratorDecorator;\nimport org.apache.commons.collections4.iterators.AbstractListIteratorDecorator;\n\n/**\n * Decorates a <code>List</code> to ensure that no duplicates are present much\n * like a <code>Set</code>.\n * <p>\n * The <code>List</code> interface makes certain assumptions/requirements. This\n * implementation breaks these in certain ways, but this is merely the result of\n * rejecting duplicates. Each violation is explained in the method, but it\n * should not affect you. Bear in mind that Sets require immutable objects to\n * function correctly.\n * <p>\n * The {@link org.apache.commons.collections4.set.ListOrderedSet ListOrderedSet}\n * class provides an alternative approach, by wrapping an existing Set and\n * retaining insertion order in the iterator.\n * <p>\n * This class is Serializable from Commons Collections 3.1.\n * \n * @since 3.0\n * @version $Id$\n */\npublic class SetUniqueList<E> extends AbstractSerializableListDecorator<E> {\n\n    /** Serialization version. */\n    private static final long serialVersionUID = 7196982186153478694L;\n\n    /** Internal Set to maintain uniqueness. */\n    protected final Set<E> set;\n\n    /**\n     * Factory method to create a SetList using the supplied list to retain\n     * order.\n     * <p>\n     * If the list contains duplicates, these are removed (first indexed one\n     * kept). A <code>HashSet</code> is used for the set behaviour.\n     * \n     * @param <E>\n     *            the element type\n     * @param list\n     *            the list to decorate, must not be null\n     * @return a new {@link SetUniqueList}\n     * @throws IllegalArgumentException\n     *             if list is null\n     */\n    public static <E> SetUniqueList<E> setUniqueList(final List<E> list) {\n        if (list == null) {\n            throw new IllegalArgumentException(\"List must not be null\");\n        }\n        if (list.isEmpty()) {\n            return new SetUniqueList<E>(list, new HashSet<E>());\n        }\n        final List<E> temp = new ArrayList<E>(list);\n        list.clear();\n        final SetUniqueList<E> sl = new SetUniqueList<E>(list, new HashSet<E>());\n        sl.addAll(temp);\n        return sl;\n    }\n\n    // -----------------------------------------------------------------------\n    /**\n     * Constructor that wraps (not copies) the List and specifies the set to\n     * use.\n     * <p>\n     * The set and list must both be correctly initialised to the same elements.\n     * \n     * @param set\n     *            the set to decorate, must not be null\n     * @param list\n     *            the list to decorate, must not be null\n     * @throws IllegalArgumentException\n     *             if set or list is null\n     */\n    protected SetUniqueList(final List<E> list, final Set<E> set) {\n        super(list);\n        if (set == null) {\n            throw new IllegalArgumentException(\"Set must not be null\");\n        }\n        this.set = set;\n    }\n\n    // -----------------------------------------------------------------------\n    /**\n     * Gets an unmodifiable view as a Set.\n     * \n     * @return an unmodifiable set view\n     */\n    public Set<E> asSet() {\n        return UnmodifiableSet.unmodifiableSet(set);\n    }\n\n    // -----------------------------------------------------------------------\n    /**\n     * Adds an element to the list if it is not already present.\n     * <p>\n     * <i>(Violation)</i> The <code>List</code> interface requires that this\n     * method returns <code>true</code> always. However this class may return\n     * <code>false</code> because of the <code>Set</code> behaviour.\n     * \n     * @param object\n     *            the object to add\n     * @return true if object was added\n     */\n    @Override\n    public boolean add(final E object) {\n        // gets initial size\n        final int sizeBefore = size();\n\n        // adds element if unique\n        add(size(), object);\n\n        // compares sizes to detect if collection changed\n        return sizeBefore != size();\n    }\n\n    /**\n     * Adds an element to a specific index in the list if it is not already\n     * present.\n     * <p>\n     * <i>(Violation)</i> The <code>List</code> interface makes the assumption\n     * that the element is always inserted. This may not happen with this\n     * implementation.\n     * \n     * @param index\n     *            the index to insert at\n     * @param object\n     *            the object to add\n     */\n    @Override\n    public void add(final int index, final E object) {\n        // adds element if it is not contained already\n        if (set.contains(object) == false) {\n            super.add(index, object);\n            set.add(object);\n        }\n    }\n\n    /**\n     * Adds a collection of objects to the end of the list avoiding duplicates.\n     * <p>\n     * Only elements that are not already in this list will be added, and\n     * duplicates from the specified collection will be ignored.\n     * <p>\n     * <i>(Violation)</i> The <code>List</code> interface makes the assumption\n     * that the elements are always inserted. This may not happen with this\n     * implementation.\n     * \n     * @param coll\n     *            the collection to add in iterator order\n     * @return true if this collection changed\n     */\n    @Override\n    public boolean addAll(final Collection<? extends E> coll) {\n        return addAll(size(), coll);\n    }\n\n    /**\n     * Adds a collection of objects a specific index in the list avoiding\n     * duplicates.\n     * <p>\n     * Only elements that are not already in this list will be added, and\n     * duplicates from the specified collection will be ignored.\n     * <p>\n     * <i>(Violation)</i> The <code>List</code> interface makes the assumption\n     * that the elements are always inserted. This may not happen with this\n     * implementation.\n     * \n     * @param index\n     *            the index to insert at\n     * @param coll\n     *            the collection to add in iterator order\n     * @return true if this collection changed\n     */\n    @Override\n    public boolean addAll(final int index, final Collection<? extends E> coll) {\n        final List<E> temp = new ArrayList<E>();\n        for (final E e : coll) {\n            if (set.add(e)) {\n                temp.add(e);\n            }\n        }\n        return super.addAll(index, temp);\n    }\n\n    // -----------------------------------------------------------------------\n    /**\n     * Sets the value at the specified index avoiding duplicates.\n     * <p>\n     * The object is set into the specified index. Afterwards, any previous\n     * duplicate is removed. If the object is not already in the list then a\n     * normal set occurs. If it is present, then the old version is removed.\n     * \n     * @param index\n     *            the index to insert at\n     * @param object\n     *            the object to set\n     * @return the previous object\n     */\n    @Override\n    public E set(final int index, final E object) {\n        final int pos = indexOf(object);\n        final E removed = super.set(index, object);\n\n        if (pos != -1 && pos != index) {\n            // the object is already in the unique list\n            // (and it hasn't been swapped with itself)\n            super.remove(pos); // remove the duplicate by index\n        }\n\n        set.remove(removed); // remove the item deleted by the set\n        set.add(object); // add the new item to the unique set\n\n        return removed; // return the item deleted by the set\n    }\n\n    @Override\n    public boolean remove(final Object object) {\n        final boolean result = set.remove(object);\n        if (result) {\n            super.remove(object);\n        }\n        return result;\n    }\n\n    @Override\n    public E remove(final int index) {\n        final E result = super.remove(index);\n        set.remove(result);\n        return result;\n    }\n\n    @Override\n    public boolean removeAll(final Collection<?> coll) {\n        boolean result = false;\n        for (final Object name : coll) {\n            result |= remove(name);\n        }\n        return result;\n    }\n\n    @Override\n    public boolean retainAll(final Collection<?> coll) {\n        final Set<Object> setRetainAll = new HashSet<Object>();\n        for (final Object next : coll) {\n            if (set.contains(next)) {\n                setRetainAll.add(next);\n            }\n        }\n        if (setRetainAll.size() == set.size()) {\n            return false;\n        }\n        if (setRetainAll.size() == 0) {\n            clear();\n        } else {\n            for (final Iterator<E> it = iterator(); it.hasNext();) {\n                if (!setRetainAll.contains(it.next())) {\n                    it.remove();\n                }\n            }\n        }\n        return true;\n    }\n\n    @Override\n    public void clear() {\n        super.clear();\n        set.clear();\n    }\n\n    @Override\n    public boolean contains(final Object object) {\n        return set.contains(object);\n    }\n\n    @Override\n    public boolean containsAll(final Collection<?> coll) {\n        return set.containsAll(coll);\n    }\n\n    @Override\n    public Iterator<E> iterator() {\n        return new SetListIterator<E>(super.iterator(), set);\n    }\n\n    @Override\n    public ListIterator<E> listIterator() {\n        return new SetListListIterator<E>(super.listIterator(), set);\n    }\n\n    @Override\n    public ListIterator<E> listIterator(final int index) {\n        return new SetListListIterator<E>(super.listIterator(index), set);\n    }\n\n    /**\n     * {@inheritDoc}\n     * <p>\n     * NOTE: from 4.0, an unmodifiable list will be returned, as changes to the\n     * subList can invalidate the parent list. \n     */\n    @Override\n    public List<E> subList(final int fromIndex, final int toIndex) {\n        final List<E> superSubList = super.subList(fromIndex, toIndex);\n        final Set<E> subSet = createSetBasedOnList(set, superSubList);\n        return ListUtils.unmodifiableList(new SetUniqueList<E>(superSubList, subSet));\n    }\n\n    /**\n     * Create a new {@link Set} with the same type as the provided {@code set}\n     * and populate it with all elements of {@code list}.\n     * \n     * @param set\n     *            the {@link Set} to be used as return type, must not be null\n     * @param list\n     *            the {@link List} to populate the {@link Set}\n     * @return a new {@link Set} populated with all elements of the provided\n     *         {@link List}\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected Set<E> createSetBasedOnList(final Set<E> set, final List<E> list) {\n        Set<E> subSet;\n        if (set.getClass().equals(HashSet.class)) {\n            subSet = new HashSet<E>(list.size());\n        } else {\n            try {\n                subSet = set.getClass().newInstance();\n            } catch (final InstantiationException ie) {\n                subSet = new HashSet<E>();\n            } catch (final IllegalAccessException iae) {\n                subSet = new HashSet<E>();\n            }\n        }\n        subSet.addAll(list);\n        return subSet;\n    }\n\n    // -----------------------------------------------------------------------\n    /**\n     * Inner class iterator.\n     */\n    static class SetListIterator<E> extends AbstractIteratorDecorator<E> {\n\n        protected final Set<E> set;\n        protected E last = null;\n\n        protected SetListIterator(final Iterator<E> it, final Set<E> set) {\n            super(it);\n            this.set = set;\n        }\n\n        @Override\n        public E next() {\n            last = super.next();\n            return last;\n        }\n\n        @Override\n        public void remove() {\n            super.remove();\n            set.remove(last);\n            last = null;\n        }\n    }\n\n    /**\n     * Inner class iterator.\n     */\n    static class SetListListIterator<E> extends\n            AbstractListIteratorDecorator<E> {\n\n        protected final Set<E> set;\n        protected E last = null;\n\n        protected SetListListIterator(final ListIterator<E> it, final Set<E> set) {\n            super(it);\n            this.set = set;\n        }\n\n        @Override\n        public E next() {\n            last = super.next();\n            return last;\n        }\n\n        @Override\n        public E previous() {\n            last = super.previous();\n            return last;\n        }\n\n        @Override\n        public void remove() {\n            super.remove();\n            set.remove(last);\n            last = null;\n        }\n\n        @Override\n        public void add(final E object) {\n            if (set.contains(object) == false) {\n                super.add(object);\n                set.add(object);\n            }\n        }\n\n        @Override\n        public void set(final E object) {\n            throw new UnsupportedOperationException(\"ListIterator does not support set\");\n        }\n    }\n\n}\n"}]}
{"project": "Collections", "bug_id": 22, "classes_modified": [{"class_name": "org.apache.commons.collections4.map.ListOrderedMap", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4.map;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.AbstractList;\nimport java.util.AbstractSet;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Set;\n\nimport org.apache.commons.collections4.OrderedMap;\nimport org.apache.commons.collections4.OrderedMapIterator;\nimport org.apache.commons.collections4.ResettableIterator;\nimport org.apache.commons.collections4.iterators.AbstractUntypedIteratorDecorator;\nimport org.apache.commons.collections4.keyvalue.AbstractMapEntry;\nimport org.apache.commons.collections4.list.UnmodifiableList;\n\n/**\n * Decorates a <code>Map</code> to ensure that the order of addition is retained\n * using a <code>List</code> to maintain order.\n * <p>\n * The order will be used via the iterators and toArray methods on the views.\n * The order is also returned by the <code>MapIterator</code>.\n * The <code>orderedMapIterator()</code> method accesses an iterator that can\n * iterate both forwards and backwards through the map.\n * In addition, non-interface methods are provided to access the map by index.\n * <p>\n * If an object is added to the Map for a second time, it will remain in the\n * original position in the iteration.\n * <p>\n * <strong>Note that ListOrderedMap is not synchronized and is not thread-safe.</strong>\n * If you wish to use this map from multiple threads concurrently, you must use\n * appropriate synchronization. The simplest approach is to wrap this map\n * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw\n * exceptions when accessed by concurrent threads without synchronization.\n * <p>\n * <strong>Note that ListOrderedMap doesn't work with\n * {@link java.util.IdentityHashMap IdentityHashMap}, {@link CaseInsensitiveMap},\n * or similar maps that violate the general contract of {@link java.util.Map}.</strong>\n * The <code>ListOrderedMap</code> (or, more precisely, the underlying <code>List</code>)\n * is relying on {@link Object#equals(Object) equals()}. This is fine, as long as the\n * decorated <code>Map</code> is also based on {@link Object#equals(Object) equals()},\n * and {@link Object#hashCode() hashCode()}, which\n * {@link java.util.IdentityHashMap IdentityHashMap}, and\n * {@link CaseInsensitiveMap} don't: The former uses <code>==</code>, and\n * the latter uses {@link Object#equals(Object) equals()} on a lower-cased\n * key.\n * <p>\n * This class is {@link Serializable} starting with Commons Collections 3.1.\n *\n * @since 3.0\n * @version $Id$\n */\npublic class ListOrderedMap<K, V>\n        extends AbstractMapDecorator<K, V>\n        implements OrderedMap<K, V>, Serializable {\n\n    /** Serialization version */\n    private static final long serialVersionUID = 2728177751851003750L;\n\n    /** Internal list to hold the sequence of objects */\n    private final List<K> insertOrder = new ArrayList<K>();\n\n    /**\n     * Factory method to create an ordered map.\n     * <p>\n     * An <code>ArrayList</code> is used to retain order.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param map  the map to decorate, must not be null\n     * @return a new list ordered map\n     * @throws IllegalArgumentException if map is null\n     * @since 4.0\n     */\n    public static <K, V> ListOrderedMap<K, V> listOrderedMap(final Map<K, V> map) {\n        return new ListOrderedMap<K, V>(map);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructs a new empty <code>ListOrderedMap</code> that decorates\n     * a <code>HashMap</code>.\n     *\n     * @since 3.1\n     */\n    public ListOrderedMap() {\n        this(new HashMap<K, V>());\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param map  the map to decorate, must not be null\n     * @throws IllegalArgumentException if map is null\n     */\n    protected ListOrderedMap(final Map<K, V> map) {\n        super(map);\n        insertOrder.addAll(decorated().keySet());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Write the map out using a custom routine.\n     *\n     * @param out  the output stream\n     * @throws IOException\n     * @since 3.1\n     */\n    private void writeObject(final ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        out.writeObject(map);\n    }\n\n    /**\n     * Read the map in using a custom routine.\n     *\n     * @param in  the input stream\n     * @throws IOException\n     * @throws ClassNotFoundException\n     * @since 3.1\n     */\n    @SuppressWarnings(\"unchecked\") // (1) should only fail if input stream is incorrect\n    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        map = (Map<K, V>) in.readObject(); // (1)\n    }\n\n    // Implement OrderedMap\n    //-----------------------------------------------------------------------\n    @Override\n    public OrderedMapIterator<K, V> mapIterator() {\n        return new ListOrderedMapIterator<K, V>(this);\n    }\n\n    /**\n     * Gets the first key in this map by insert order.\n     *\n     * @return the first key currently in this map\n     * @throws NoSuchElementException if this map is empty\n     */\n    public K firstKey() {\n        if (size() == 0) {\n            throw new NoSuchElementException(\"Map is empty\");\n        }\n        return insertOrder.get(0);\n    }\n\n    /**\n     * Gets the last key in this map by insert order.\n     *\n     * @return the last key currently in this map\n     * @throws NoSuchElementException if this map is empty\n     */\n    public K lastKey() {\n        if (size() == 0) {\n            throw new NoSuchElementException(\"Map is empty\");\n        }\n        return insertOrder.get(size() - 1);\n    }\n\n    /**\n     * Gets the next key to the one specified using insert order.\n     * This method performs a list search to find the key and is O(n).\n     *\n     * @param key  the key to find previous for\n     * @return the next key, null if no match or at start\n     */\n    public K nextKey(final Object key) {\n        final int index = insertOrder.indexOf(key);\n        if (index >= 0 && index < size() - 1) {\n            return insertOrder.get(index + 1);\n        }\n        return null;\n    }\n\n    /**\n     * Gets the previous key to the one specified using insert order.\n     * This method performs a list search to find the key and is O(n).\n     *\n     * @param key  the key to find previous for\n     * @return the previous key, null if no match or at start\n     */\n    public K previousKey(final Object key) {\n        final int index = insertOrder.indexOf(key);\n        if (index > 0) {\n            return insertOrder.get(index - 1);\n        }\n        return null;\n    }\n\n    //-----------------------------------------------------------------------\n    @Override\n    public V put(final K key, final V value) {\n        if (decorated().containsKey(key)) {\n            // re-adding doesn't change order\n            return decorated().put(key, value);\n        } else {\n            // first add, so add to both map and list\n            final V result = decorated().put(key, value);\n            insertOrder.add(key);\n            return result;\n        }\n    }\n\n    @Override\n    public void putAll(final Map<? extends K, ? extends V> map) {\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            put(entry.getKey(), entry.getValue());\n        }\n    }\n\n    /**\n     * Puts the values contained in a supplied Map into the Map starting at\n     * the specified index.\n     *\n     * @param index the index in the Map to start at.\n     * @param map the Map containing the entries to be added.\n     */\n    public void putAll(int index, final Map<? extends K, ? extends V> map) {\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            final V old = put(index, entry.getKey(), entry.getValue());\n            if (old == null) {\n            // The return value of put is null if the key did not exist OR the value was null\n            // so it cannot be used to determine whether the key was added\n                // if no key was replaced, increment the index\n                index++;\n            } else {\n                // otherwise put the next item after the currently inserted key\n                index = indexOf(entry.getKey()) + 1;\n            }\n        }\n    }\n\n    @Override\n    public V remove(final Object key) {\n        V result = null;\n        if (decorated().containsKey(key)) {\n            result = decorated().remove(key);\n            insertOrder.remove(key);\n        }\n        return result;\n    }\n\n    @Override\n    public void clear() {\n        decorated().clear();\n        insertOrder.clear();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets a view over the keys in the map.\n     * <p>\n     * The Collection will be ordered by object insertion into the map.\n     *\n     * @see #keyList()\n     * @return the fully modifiable collection view over the keys\n     */\n    @Override\n    public Set<K> keySet() {\n        return new KeySetView<K>(this);\n    }\n\n    /**\n     * Gets a view over the keys in the map as a List.\n     * <p>\n     * The List will be ordered by object insertion into the map.\n     * The List is unmodifiable.\n     *\n     * @see #keySet()\n     * @return the unmodifiable list view over the keys\n     * @since 3.2\n     */\n    public List<K> keyList() {\n        return UnmodifiableList.unmodifiableList(insertOrder);\n    }\n\n    /**\n     * Gets a view over the values in the map.\n     * <p>\n     * The Collection will be ordered by object insertion into the map.\n     * <p>\n     * From Commons Collections 3.2, this Collection can be cast\n     * to a list, see {@link #valueList()}\n     *\n     * @see #valueList()\n     * @return the fully modifiable collection view over the values\n     */\n    @Override\n    public Collection<V> values() {\n        return new ValuesView<V>(this);\n    }\n\n    /**\n     * Gets a view over the values in the map as a List.\n     * <p>\n     * The List will be ordered by object insertion into the map.\n     * The List supports remove and set, but does not support add.\n     *\n     * @see #values()\n     * @return the partially modifiable list view over the values\n     * @since 3.2\n     */\n    public List<V> valueList() {\n        return new ValuesView<V>(this);\n    }\n\n    /**\n     * Gets a view over the entries in the map.\n     * <p>\n     * The Set will be ordered by object insertion into the map.\n     *\n     * @return the fully modifiable set view over the entries\n     */\n    @Override\n    public Set<Map.Entry<K, V>> entrySet() {\n        return new EntrySetView<K, V>(this, this.insertOrder);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns the Map as a string.\n     *\n     * @return the Map as a String\n     */\n    @Override\n    public String toString() {\n        if (isEmpty()) {\n            return \"{}\";\n        }\n        final StringBuilder buf = new StringBuilder();\n        buf.append('{');\n        boolean first = true;\n        for (final Map.Entry<K, V> entry : entrySet()) {\n            final K key = entry.getKey();\n            final V value = entry.getValue();\n            if (first) {\n                first = false;\n            } else {\n                buf.append(\", \");\n            }\n            buf.append(key == this ? \"(this Map)\" : key);\n            buf.append('=');\n            buf.append(value == this ? \"(this Map)\" : value);\n        }\n        buf.append('}');\n        return buf.toString();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the key at the specified index.\n     *\n     * @param index  the index to retrieve\n     * @return the key at the specified index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public K get(final int index) {\n        return insertOrder.get(index);\n    }\n\n    /**\n     * Gets the value at the specified index.\n     *\n     * @param index  the index to retrieve\n     * @return the key at the specified index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public V getValue(final int index) {\n        return get(insertOrder.get(index));\n    }\n\n    /**\n     * Gets the index of the specified key.\n     *\n     * @param key  the key to find the index of\n     * @return the index, or -1 if not found\n     */\n    public int indexOf(final Object key) {\n        return insertOrder.indexOf(key);\n    }\n\n    /**\n     * Sets the value at the specified index.\n     *\n     * @param index  the index of the value to set\n     * @param value  the new value to set\n     * @return the previous value at that index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     * @since 3.2\n     */\n    public V setValue(final int index, final V value) {\n        final K key = insertOrder.get(index);\n        return put(key, value);\n    }\n\n    /**\n     * Puts a key-value mapping into the map at the specified index.\n     * <p>\n     * If the map already contains the key, then the original mapping\n     * is removed and the new mapping added at the specified index.\n     * The remove may change the effect of the index. The index is\n     * always calculated relative to the original state of the map.\n     * <p>\n     * Thus the steps are: (1) remove the existing key-value mapping,\n     * then (2) insert the new key-value mapping at the position it\n     * would have been inserted had the remove not occurred.\n     *\n     * @param index  the index at which the mapping should be inserted\n     * @param key  the key\n     * @param value  the value\n     * @return the value previously mapped to the key\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * @since 3.2\n     */\n    public V put(int index, final K key, final V value) {\n        final Map<K, V> m = decorated();\n        if (m.containsKey(key)) {\n            final V result = m.remove(key);\n            final int pos = insertOrder.indexOf(key);\n            insertOrder.remove(pos);\n            if (pos < index) {\n                index--;\n            }\n            insertOrder.add(index, key);\n            m.put(key, value);\n            return result;\n        } else {\n            insertOrder.add(index, key);\n            m.put(key, value);\n            return null;\n        }\n    }\n\n    /**\n     * Removes the element at the specified index.\n     *\n     * @param index  the index of the object to remove\n     * @return the removed value, or <code>null</code> if none existed\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public V remove(final int index) {\n        return remove(get(index));\n    }\n\n    /**\n     * Gets an unmodifiable List view of the keys which changes as the map changes.\n     * <p>\n     * The returned list is unmodifiable because changes to the values of\n     * the list (using {@link java.util.ListIterator#set(Object)}) will\n     * effectively remove the value from the list and reinsert that value at\n     * the end of the list, which is an unexpected side effect of changing the\n     * value of a list.  This occurs because changing the key, changes when the\n     * mapping is added to the map and thus where it appears in the list.\n     * <p>\n     * An alternative to this method is to use the better named\n     * {@link #keyList()} or {@link #keySet()}.\n     *\n     * @see #keyList()\n     * @see #keySet()\n     * @return The ordered list of keys.\n     */\n    public List<K> asList() {\n        return keyList();\n    }\n\n    //-----------------------------------------------------------------------\n    static class ValuesView<V> extends AbstractList<V> {\n        private final ListOrderedMap<Object, V> parent;\n\n        @SuppressWarnings(\"unchecked\")\n        ValuesView(final ListOrderedMap<?, V> parent) {\n            super();\n            this.parent = (ListOrderedMap<Object, V>) parent;\n        }\n\n        @Override\n        public int size() {\n            return this.parent.size();\n        }\n\n        @Override\n        public boolean contains(final Object value) {\n            return this.parent.containsValue(value);\n        }\n\n        @Override\n        public void clear() {\n            this.parent.clear();\n        }\n\n        @Override\n        public Iterator<V> iterator() {\n            return new AbstractUntypedIteratorDecorator<Map.Entry<Object, V>, V>(parent.entrySet().iterator()) {\n                public V next() {\n                    return getIterator().next().getValue();\n                }\n            };\n        }\n\n        @Override\n        public V get(final int index) {\n            return this.parent.getValue(index);\n        }\n\n        @Override\n        public V set(final int index, final V value) {\n            return this.parent.setValue(index, value);\n        }\n\n        @Override\n        public V remove(final int index) {\n            return this.parent.remove(index);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    static class KeySetView<K> extends AbstractSet<K> {\n        private final ListOrderedMap<K, Object> parent;\n\n        @SuppressWarnings(\"unchecked\")\n        KeySetView(final ListOrderedMap<K, ?> parent) {\n            super();\n            this.parent = (ListOrderedMap<K, Object>) parent;\n        }\n\n        @Override\n        public int size() {\n            return this.parent.size();\n        }\n\n        @Override\n        public boolean contains(final Object value) {\n            return this.parent.containsKey(value);\n        }\n\n        @Override\n        public void clear() {\n            this.parent.clear();\n        }\n\n        @Override\n        public Iterator<K> iterator() {\n            return new AbstractUntypedIteratorDecorator<Map.Entry<K, Object>, K>(parent.entrySet().iterator()) {\n                public K next() {\n                    return getIterator().next().getKey();\n                }\n            };\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    static class EntrySetView<K, V> extends AbstractSet<Map.Entry<K, V>> {\n        private final ListOrderedMap<K, V> parent;\n        private final List<K> insertOrder;\n        private Set<Map.Entry<K, V>> entrySet;\n\n        public EntrySetView(final ListOrderedMap<K, V> parent, final List<K> insertOrder) {\n            super();\n            this.parent = parent;\n            this.insertOrder = insertOrder;\n        }\n\n        private Set<Map.Entry<K, V>> getEntrySet() {\n            if (entrySet == null) {\n                entrySet = parent.decorated().entrySet();\n            }\n            return entrySet;\n        }\n\n        @Override\n        public int size() {\n            return this.parent.size();\n        }\n        @Override\n        public boolean isEmpty() {\n            return this.parent.isEmpty();\n        }\n\n        @Override\n        public boolean contains(final Object obj) {\n            return getEntrySet().contains(obj);\n        }\n\n        @Override\n        public boolean containsAll(final Collection<?> coll) {\n            return getEntrySet().containsAll(coll);\n        }\n\n        @Override\n        @SuppressWarnings(\"unchecked\")\n        public boolean remove(final Object obj) {\n            if (obj instanceof Map.Entry == false) {\n                return false;\n            }\n            if (getEntrySet().contains(obj)) {\n                final Object key = ((Map.Entry<K, V>) obj).getKey();\n                parent.remove(key);\n                return true;\n            }\n            return false;\n        }\n\n        @Override\n        public void clear() {\n            this.parent.clear();\n        }\n\n        @Override\n        public boolean equals(final Object obj) {\n            if (obj == this) {\n                return true;\n            }\n            return getEntrySet().equals(obj);\n        }\n\n        @Override\n        public int hashCode() {\n            return getEntrySet().hashCode();\n        }\n\n        @Override\n        public String toString() {\n            return getEntrySet().toString();\n        }\n\n        @Override\n        public Iterator<Map.Entry<K, V>> iterator() {\n            return new ListOrderedIterator<K, V>(parent, insertOrder);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    static class ListOrderedIterator<K, V> extends AbstractUntypedIteratorDecorator<K, Map.Entry<K, V>> {\n        private final ListOrderedMap<K, V> parent;\n        private K last = null;\n\n        ListOrderedIterator(final ListOrderedMap<K, V> parent, final List<K> insertOrder) {\n            super(insertOrder.iterator());\n            this.parent = parent;\n        }\n\n        public Map.Entry<K, V> next() {\n            last = getIterator().next();\n            return new ListOrderedMapEntry<K, V>(parent, last);\n        }\n\n        @Override\n        public void remove() {\n            super.remove();\n            parent.decorated().remove(last);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    static class ListOrderedMapEntry<K, V> extends AbstractMapEntry<K, V> {\n        private final ListOrderedMap<K, V> parent;\n\n        ListOrderedMapEntry(final ListOrderedMap<K, V> parent, final K key) {\n            super(key, null);\n            this.parent = parent;\n        }\n\n        @Override\n        public V getValue() {\n            return parent.get(getKey());\n        }\n\n        @Override\n        public V setValue(final V value) {\n            return parent.decorated().put(getKey(), value);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    static class ListOrderedMapIterator<K, V> implements OrderedMapIterator<K, V>, ResettableIterator<K> {\n        private final ListOrderedMap<K, V> parent;\n        private ListIterator<K> iterator;\n        private K last = null;\n        private boolean readable = false;\n\n        ListOrderedMapIterator(final ListOrderedMap<K, V> parent) {\n            super();\n            this.parent = parent;\n            this.iterator = parent.insertOrder.listIterator();\n        }\n\n        public boolean hasNext() {\n            return iterator.hasNext();\n        }\n\n        public K next() {\n            last = iterator.next();\n            readable = true;\n            return last;\n        }\n\n        public boolean hasPrevious() {\n            return iterator.hasPrevious();\n        }\n\n        public K previous() {\n            last = iterator.previous();\n            readable = true;\n            return last;\n        }\n\n        public void remove() {\n            if (readable == false) {\n                throw new IllegalStateException(AbstractHashedMap.REMOVE_INVALID);\n            }\n            iterator.remove();\n            parent.map.remove(last);\n            readable = false;\n        }\n\n        public K getKey() {\n            if (readable == false) {\n                throw new IllegalStateException(AbstractHashedMap.GETKEY_INVALID);\n            }\n            return last;\n        }\n\n        public V getValue() {\n            if (readable == false) {\n                throw new IllegalStateException(AbstractHashedMap.GETVALUE_INVALID);\n            }\n            return parent.get(last);\n        }\n\n        public V setValue(final V value) {\n            if (readable == false) {\n                throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n            }\n            return parent.map.put(last, value);\n        }\n\n        public void reset() {\n            iterator = parent.insertOrder.listIterator();\n            last = null;\n            readable = false;\n        }\n\n        @Override\n        public String toString() {\n            if (readable == true) {\n                return \"Iterator[\" + getKey() + \"=\" + getValue() + \"]\";\n            }\n            return \"Iterator[]\";\n        }\n    }\n\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4.map;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.AbstractList;\nimport java.util.AbstractSet;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Set;\n\nimport org.apache.commons.collections4.OrderedMap;\nimport org.apache.commons.collections4.OrderedMapIterator;\nimport org.apache.commons.collections4.ResettableIterator;\nimport org.apache.commons.collections4.iterators.AbstractUntypedIteratorDecorator;\nimport org.apache.commons.collections4.keyvalue.AbstractMapEntry;\nimport org.apache.commons.collections4.list.UnmodifiableList;\n\n/**\n * Decorates a <code>Map</code> to ensure that the order of addition is retained\n * using a <code>List</code> to maintain order.\n * <p>\n * The order will be used via the iterators and toArray methods on the views.\n * The order is also returned by the <code>MapIterator</code>.\n * The <code>orderedMapIterator()</code> method accesses an iterator that can\n * iterate both forwards and backwards through the map.\n * In addition, non-interface methods are provided to access the map by index.\n * <p>\n * If an object is added to the Map for a second time, it will remain in the\n * original position in the iteration.\n * <p>\n * <strong>Note that ListOrderedMap is not synchronized and is not thread-safe.</strong>\n * If you wish to use this map from multiple threads concurrently, you must use\n * appropriate synchronization. The simplest approach is to wrap this map\n * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw\n * exceptions when accessed by concurrent threads without synchronization.\n * <p>\n * <strong>Note that ListOrderedMap doesn't work with\n * {@link java.util.IdentityHashMap IdentityHashMap}, {@link CaseInsensitiveMap},\n * or similar maps that violate the general contract of {@link java.util.Map}.</strong>\n * The <code>ListOrderedMap</code> (or, more precisely, the underlying <code>List</code>)\n * is relying on {@link Object#equals(Object) equals()}. This is fine, as long as the\n * decorated <code>Map</code> is also based on {@link Object#equals(Object) equals()},\n * and {@link Object#hashCode() hashCode()}, which\n * {@link java.util.IdentityHashMap IdentityHashMap}, and\n * {@link CaseInsensitiveMap} don't: The former uses <code>==</code>, and\n * the latter uses {@link Object#equals(Object) equals()} on a lower-cased\n * key.\n * <p>\n * This class is {@link Serializable} starting with Commons Collections 3.1.\n *\n * @since 3.0\n * @version $Id$\n */\npublic class ListOrderedMap<K, V>\n        extends AbstractMapDecorator<K, V>\n        implements OrderedMap<K, V>, Serializable {\n\n    /** Serialization version */\n    private static final long serialVersionUID = 2728177751851003750L;\n\n    /** Internal list to hold the sequence of objects */\n    private final List<K> insertOrder = new ArrayList<K>();\n\n    /**\n     * Factory method to create an ordered map.\n     * <p>\n     * An <code>ArrayList</code> is used to retain order.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param map  the map to decorate, must not be null\n     * @return a new list ordered map\n     * @throws IllegalArgumentException if map is null\n     * @since 4.0\n     */\n    public static <K, V> ListOrderedMap<K, V> listOrderedMap(final Map<K, V> map) {\n        return new ListOrderedMap<K, V>(map);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructs a new empty <code>ListOrderedMap</code> that decorates\n     * a <code>HashMap</code>.\n     *\n     * @since 3.1\n     */\n    public ListOrderedMap() {\n        this(new HashMap<K, V>());\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param map  the map to decorate, must not be null\n     * @throws IllegalArgumentException if map is null\n     */\n    protected ListOrderedMap(final Map<K, V> map) {\n        super(map);\n        insertOrder.addAll(decorated().keySet());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Write the map out using a custom routine.\n     *\n     * @param out  the output stream\n     * @throws IOException\n     * @since 3.1\n     */\n    private void writeObject(final ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        out.writeObject(map);\n    }\n\n    /**\n     * Read the map in using a custom routine.\n     *\n     * @param in  the input stream\n     * @throws IOException\n     * @throws ClassNotFoundException\n     * @since 3.1\n     */\n    @SuppressWarnings(\"unchecked\") // (1) should only fail if input stream is incorrect\n    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        map = (Map<K, V>) in.readObject(); // (1)\n    }\n\n    // Implement OrderedMap\n    //-----------------------------------------------------------------------\n    @Override\n    public OrderedMapIterator<K, V> mapIterator() {\n        return new ListOrderedMapIterator<K, V>(this);\n    }\n\n    /**\n     * Gets the first key in this map by insert order.\n     *\n     * @return the first key currently in this map\n     * @throws NoSuchElementException if this map is empty\n     */\n    public K firstKey() {\n        if (size() == 0) {\n            throw new NoSuchElementException(\"Map is empty\");\n        }\n        return insertOrder.get(0);\n    }\n\n    /**\n     * Gets the last key in this map by insert order.\n     *\n     * @return the last key currently in this map\n     * @throws NoSuchElementException if this map is empty\n     */\n    public K lastKey() {\n        if (size() == 0) {\n            throw new NoSuchElementException(\"Map is empty\");\n        }\n        return insertOrder.get(size() - 1);\n    }\n\n    /**\n     * Gets the next key to the one specified using insert order.\n     * This method performs a list search to find the key and is O(n).\n     *\n     * @param key  the key to find previous for\n     * @return the next key, null if no match or at start\n     */\n    public K nextKey(final Object key) {\n        final int index = insertOrder.indexOf(key);\n        if (index >= 0 && index < size() - 1) {\n            return insertOrder.get(index + 1);\n        }\n        return null;\n    }\n\n    /**\n     * Gets the previous key to the one specified using insert order.\n     * This method performs a list search to find the key and is O(n).\n     *\n     * @param key  the key to find previous for\n     * @return the previous key, null if no match or at start\n     */\n    public K previousKey(final Object key) {\n        final int index = insertOrder.indexOf(key);\n        if (index > 0) {\n            return insertOrder.get(index - 1);\n        }\n        return null;\n    }\n\n    //-----------------------------------------------------------------------\n    @Override\n    public V put(final K key, final V value) {\n        if (decorated().containsKey(key)) {\n            // re-adding doesn't change order\n            return decorated().put(key, value);\n        } else {\n            // first add, so add to both map and list\n            final V result = decorated().put(key, value);\n            insertOrder.add(key);\n            return result;\n        }\n    }\n\n    @Override\n    public void putAll(final Map<? extends K, ? extends V> map) {\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            put(entry.getKey(), entry.getValue());\n        }\n    }\n\n    /**\n     * Puts the values contained in a supplied Map into the Map starting at\n     * the specified index.\n     *\n     * @param index the index in the Map to start at.\n     * @param map the Map containing the entries to be added.\n     */\n    public void putAll(int index, final Map<? extends K, ? extends V> map) {\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            final K key = entry.getKey();\n            final boolean contains = containsKey(key);\n            // The return value of put is null if the key did not exist OR the value was null\n            // so it cannot be used to determine whether the key was added\n            put(index, entry.getKey(), entry.getValue());\n            if (!contains) {\n                // if no key was replaced, increment the index\n                index++;\n            } else {\n                // otherwise put the next item after the currently inserted key\n                index = indexOf(entry.getKey()) + 1;\n            }\n        }\n    }\n\n    @Override\n    public V remove(final Object key) {\n        V result = null;\n        if (decorated().containsKey(key)) {\n            result = decorated().remove(key);\n            insertOrder.remove(key);\n        }\n        return result;\n    }\n\n    @Override\n    public void clear() {\n        decorated().clear();\n        insertOrder.clear();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets a view over the keys in the map.\n     * <p>\n     * The Collection will be ordered by object insertion into the map.\n     *\n     * @see #keyList()\n     * @return the fully modifiable collection view over the keys\n     */\n    @Override\n    public Set<K> keySet() {\n        return new KeySetView<K>(this);\n    }\n\n    /**\n     * Gets a view over the keys in the map as a List.\n     * <p>\n     * The List will be ordered by object insertion into the map.\n     * The List is unmodifiable.\n     *\n     * @see #keySet()\n     * @return the unmodifiable list view over the keys\n     * @since 3.2\n     */\n    public List<K> keyList() {\n        return UnmodifiableList.unmodifiableList(insertOrder);\n    }\n\n    /**\n     * Gets a view over the values in the map.\n     * <p>\n     * The Collection will be ordered by object insertion into the map.\n     * <p>\n     * From Commons Collections 3.2, this Collection can be cast\n     * to a list, see {@link #valueList()}\n     *\n     * @see #valueList()\n     * @return the fully modifiable collection view over the values\n     */\n    @Override\n    public Collection<V> values() {\n        return new ValuesView<V>(this);\n    }\n\n    /**\n     * Gets a view over the values in the map as a List.\n     * <p>\n     * The List will be ordered by object insertion into the map.\n     * The List supports remove and set, but does not support add.\n     *\n     * @see #values()\n     * @return the partially modifiable list view over the values\n     * @since 3.2\n     */\n    public List<V> valueList() {\n        return new ValuesView<V>(this);\n    }\n\n    /**\n     * Gets a view over the entries in the map.\n     * <p>\n     * The Set will be ordered by object insertion into the map.\n     *\n     * @return the fully modifiable set view over the entries\n     */\n    @Override\n    public Set<Map.Entry<K, V>> entrySet() {\n        return new EntrySetView<K, V>(this, this.insertOrder);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns the Map as a string.\n     *\n     * @return the Map as a String\n     */\n    @Override\n    public String toString() {\n        if (isEmpty()) {\n            return \"{}\";\n        }\n        final StringBuilder buf = new StringBuilder();\n        buf.append('{');\n        boolean first = true;\n        for (final Map.Entry<K, V> entry : entrySet()) {\n            final K key = entry.getKey();\n            final V value = entry.getValue();\n            if (first) {\n                first = false;\n            } else {\n                buf.append(\", \");\n            }\n            buf.append(key == this ? \"(this Map)\" : key);\n            buf.append('=');\n            buf.append(value == this ? \"(this Map)\" : value);\n        }\n        buf.append('}');\n        return buf.toString();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the key at the specified index.\n     *\n     * @param index  the index to retrieve\n     * @return the key at the specified index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public K get(final int index) {\n        return insertOrder.get(index);\n    }\n\n    /**\n     * Gets the value at the specified index.\n     *\n     * @param index  the index to retrieve\n     * @return the key at the specified index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public V getValue(final int index) {\n        return get(insertOrder.get(index));\n    }\n\n    /**\n     * Gets the index of the specified key.\n     *\n     * @param key  the key to find the index of\n     * @return the index, or -1 if not found\n     */\n    public int indexOf(final Object key) {\n        return insertOrder.indexOf(key);\n    }\n\n    /**\n     * Sets the value at the specified index.\n     *\n     * @param index  the index of the value to set\n     * @param value  the new value to set\n     * @return the previous value at that index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     * @since 3.2\n     */\n    public V setValue(final int index, final V value) {\n        final K key = insertOrder.get(index);\n        return put(key, value);\n    }\n\n    /**\n     * Puts a key-value mapping into the map at the specified index.\n     * <p>\n     * If the map already contains the key, then the original mapping\n     * is removed and the new mapping added at the specified index.\n     * The remove may change the effect of the index. The index is\n     * always calculated relative to the original state of the map.\n     * <p>\n     * Thus the steps are: (1) remove the existing key-value mapping,\n     * then (2) insert the new key-value mapping at the position it\n     * would have been inserted had the remove not occurred.\n     *\n     * @param index  the index at which the mapping should be inserted\n     * @param key  the key\n     * @param value  the value\n     * @return the value previously mapped to the key\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * @since 3.2\n     */\n    public V put(int index, final K key, final V value) {\n        final Map<K, V> m = decorated();\n        if (m.containsKey(key)) {\n            final V result = m.remove(key);\n            final int pos = insertOrder.indexOf(key);\n            insertOrder.remove(pos);\n            if (pos < index) {\n                index--;\n            }\n            insertOrder.add(index, key);\n            m.put(key, value);\n            return result;\n        } else {\n            insertOrder.add(index, key);\n            m.put(key, value);\n            return null;\n        }\n    }\n\n    /**\n     * Removes the element at the specified index.\n     *\n     * @param index  the index of the object to remove\n     * @return the removed value, or <code>null</code> if none existed\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public V remove(final int index) {\n        return remove(get(index));\n    }\n\n    /**\n     * Gets an unmodifiable List view of the keys which changes as the map changes.\n     * <p>\n     * The returned list is unmodifiable because changes to the values of\n     * the list (using {@link java.util.ListIterator#set(Object)}) will\n     * effectively remove the value from the list and reinsert that value at\n     * the end of the list, which is an unexpected side effect of changing the\n     * value of a list.  This occurs because changing the key, changes when the\n     * mapping is added to the map and thus where it appears in the list.\n     * <p>\n     * An alternative to this method is to use the better named\n     * {@link #keyList()} or {@link #keySet()}.\n     *\n     * @see #keyList()\n     * @see #keySet()\n     * @return The ordered list of keys.\n     */\n    public List<K> asList() {\n        return keyList();\n    }\n\n    //-----------------------------------------------------------------------\n    static class ValuesView<V> extends AbstractList<V> {\n        private final ListOrderedMap<Object, V> parent;\n\n        @SuppressWarnings(\"unchecked\")\n        ValuesView(final ListOrderedMap<?, V> parent) {\n            super();\n            this.parent = (ListOrderedMap<Object, V>) parent;\n        }\n\n        @Override\n        public int size() {\n            return this.parent.size();\n        }\n\n        @Override\n        public boolean contains(final Object value) {\n            return this.parent.containsValue(value);\n        }\n\n        @Override\n        public void clear() {\n            this.parent.clear();\n        }\n\n        @Override\n        public Iterator<V> iterator() {\n            return new AbstractUntypedIteratorDecorator<Map.Entry<Object, V>, V>(parent.entrySet().iterator()) {\n                public V next() {\n                    return getIterator().next().getValue();\n                }\n            };\n        }\n\n        @Override\n        public V get(final int index) {\n            return this.parent.getValue(index);\n        }\n\n        @Override\n        public V set(final int index, final V value) {\n            return this.parent.setValue(index, value);\n        }\n\n        @Override\n        public V remove(final int index) {\n            return this.parent.remove(index);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    static class KeySetView<K> extends AbstractSet<K> {\n        private final ListOrderedMap<K, Object> parent;\n\n        @SuppressWarnings(\"unchecked\")\n        KeySetView(final ListOrderedMap<K, ?> parent) {\n            super();\n            this.parent = (ListOrderedMap<K, Object>) parent;\n        }\n\n        @Override\n        public int size() {\n            return this.parent.size();\n        }\n\n        @Override\n        public boolean contains(final Object value) {\n            return this.parent.containsKey(value);\n        }\n\n        @Override\n        public void clear() {\n            this.parent.clear();\n        }\n\n        @Override\n        public Iterator<K> iterator() {\n            return new AbstractUntypedIteratorDecorator<Map.Entry<K, Object>, K>(parent.entrySet().iterator()) {\n                public K next() {\n                    return getIterator().next().getKey();\n                }\n            };\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    static class EntrySetView<K, V> extends AbstractSet<Map.Entry<K, V>> {\n        private final ListOrderedMap<K, V> parent;\n        private final List<K> insertOrder;\n        private Set<Map.Entry<K, V>> entrySet;\n\n        public EntrySetView(final ListOrderedMap<K, V> parent, final List<K> insertOrder) {\n            super();\n            this.parent = parent;\n            this.insertOrder = insertOrder;\n        }\n\n        private Set<Map.Entry<K, V>> getEntrySet() {\n            if (entrySet == null) {\n                entrySet = parent.decorated().entrySet();\n            }\n            return entrySet;\n        }\n\n        @Override\n        public int size() {\n            return this.parent.size();\n        }\n        @Override\n        public boolean isEmpty() {\n            return this.parent.isEmpty();\n        }\n\n        @Override\n        public boolean contains(final Object obj) {\n            return getEntrySet().contains(obj);\n        }\n\n        @Override\n        public boolean containsAll(final Collection<?> coll) {\n            return getEntrySet().containsAll(coll);\n        }\n\n        @Override\n        @SuppressWarnings(\"unchecked\")\n        public boolean remove(final Object obj) {\n            if (obj instanceof Map.Entry == false) {\n                return false;\n            }\n            if (getEntrySet().contains(obj)) {\n                final Object key = ((Map.Entry<K, V>) obj).getKey();\n                parent.remove(key);\n                return true;\n            }\n            return false;\n        }\n\n        @Override\n        public void clear() {\n            this.parent.clear();\n        }\n\n        @Override\n        public boolean equals(final Object obj) {\n            if (obj == this) {\n                return true;\n            }\n            return getEntrySet().equals(obj);\n        }\n\n        @Override\n        public int hashCode() {\n            return getEntrySet().hashCode();\n        }\n\n        @Override\n        public String toString() {\n            return getEntrySet().toString();\n        }\n\n        @Override\n        public Iterator<Map.Entry<K, V>> iterator() {\n            return new ListOrderedIterator<K, V>(parent, insertOrder);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    static class ListOrderedIterator<K, V> extends AbstractUntypedIteratorDecorator<K, Map.Entry<K, V>> {\n        private final ListOrderedMap<K, V> parent;\n        private K last = null;\n\n        ListOrderedIterator(final ListOrderedMap<K, V> parent, final List<K> insertOrder) {\n            super(insertOrder.iterator());\n            this.parent = parent;\n        }\n\n        public Map.Entry<K, V> next() {\n            last = getIterator().next();\n            return new ListOrderedMapEntry<K, V>(parent, last);\n        }\n\n        @Override\n        public void remove() {\n            super.remove();\n            parent.decorated().remove(last);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    static class ListOrderedMapEntry<K, V> extends AbstractMapEntry<K, V> {\n        private final ListOrderedMap<K, V> parent;\n\n        ListOrderedMapEntry(final ListOrderedMap<K, V> parent, final K key) {\n            super(key, null);\n            this.parent = parent;\n        }\n\n        @Override\n        public V getValue() {\n            return parent.get(getKey());\n        }\n\n        @Override\n        public V setValue(final V value) {\n            return parent.decorated().put(getKey(), value);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    static class ListOrderedMapIterator<K, V> implements OrderedMapIterator<K, V>, ResettableIterator<K> {\n        private final ListOrderedMap<K, V> parent;\n        private ListIterator<K> iterator;\n        private K last = null;\n        private boolean readable = false;\n\n        ListOrderedMapIterator(final ListOrderedMap<K, V> parent) {\n            super();\n            this.parent = parent;\n            this.iterator = parent.insertOrder.listIterator();\n        }\n\n        public boolean hasNext() {\n            return iterator.hasNext();\n        }\n\n        public K next() {\n            last = iterator.next();\n            readable = true;\n            return last;\n        }\n\n        public boolean hasPrevious() {\n            return iterator.hasPrevious();\n        }\n\n        public K previous() {\n            last = iterator.previous();\n            readable = true;\n            return last;\n        }\n\n        public void remove() {\n            if (readable == false) {\n                throw new IllegalStateException(AbstractHashedMap.REMOVE_INVALID);\n            }\n            iterator.remove();\n            parent.map.remove(last);\n            readable = false;\n        }\n\n        public K getKey() {\n            if (readable == false) {\n                throw new IllegalStateException(AbstractHashedMap.GETKEY_INVALID);\n            }\n            return last;\n        }\n\n        public V getValue() {\n            if (readable == false) {\n                throw new IllegalStateException(AbstractHashedMap.GETVALUE_INVALID);\n            }\n            return parent.get(last);\n        }\n\n        public V setValue(final V value) {\n            if (readable == false) {\n                throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n            }\n            return parent.map.put(last, value);\n        }\n\n        public void reset() {\n            iterator = parent.insertOrder.listIterator();\n            last = null;\n            readable = false;\n        }\n\n        @Override\n        public String toString() {\n            if (readable == true) {\n                return \"Iterator[\" + getKey() + \"=\" + getValue() + \"]\";\n            }\n            return \"Iterator[]\";\n        }\n    }\n\n}\n"}]}
{"project": "Collections", "bug_id": 23, "classes_modified": [{"class_name": "org.apache.commons.collections4.trie.UnmodifiableTrie", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4.trie;\n\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.SortedMap;\n\nimport org.apache.commons.collections4.OrderedMapIterator;\nimport org.apache.commons.collections4.Trie;\nimport org.apache.commons.collections4.Unmodifiable;\nimport org.apache.commons.collections4.iterators.UnmodifiableOrderedMapIterator;\n\n/**\n * An unmodifiable {@link Trie}.\n *\n * @since 4.0\n * @version $Id$\n */\npublic class UnmodifiableTrie<K, V> implements Trie<K, V>, Serializable, Unmodifiable {\n\n    /** Serialization version */\n    private static final long serialVersionUID = -7156426030315945159L;\n\n    private final Trie<K, V> delegate;\n\n    /**\n     * Factory method to create a unmodifiable trie.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param trie  the trie to decorate, must not be null\n     * @return a new unmodifiable trie\n     * @throws IllegalArgumentException if trie is null\n     */\n    public static <K, V> UnmodifiableTrie<K, V> unmodifiableTrie(final Trie<K, ? extends V> trie) {\n        return new UnmodifiableTrie<K, V>(trie);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param trie  the trie to decorate, must not be null\n     * @throws IllegalArgumentException if trie is null\n     */\n    public UnmodifiableTrie(final Trie<K, ? extends V> trie) {\n        if (trie == null) {\n            throw new IllegalArgumentException(\"Trie must not be null\");\n        }\n        @SuppressWarnings(\"unchecked\") // safe to upcast\n        final Trie<K, V> tmpTrie = (Trie<K, V>) trie;\n        this.delegate = tmpTrie;\n    }\n\n    //-----------------------------------------------------------------------\n\n    public Set<Entry<K, V>> entrySet() {\n        return Collections.unmodifiableSet(delegate.entrySet());\n    }\n\n    public Set<K> keySet() {\n        return Collections.unmodifiableSet(delegate.keySet());\n    }\n\n    public Collection<V> values() {\n        return Collections.unmodifiableCollection(delegate.values());\n    }\n\n    public void clear() {\n        throw new UnsupportedOperationException();\n    }\n\n    public boolean containsKey(final Object key) {\n        return delegate.containsKey(key);\n    }\n\n    public boolean containsValue(final Object value) {\n        return delegate.containsValue(value);\n    }\n\n    public V get(final Object key) {\n        return delegate.get(key);\n    }\n\n    public boolean isEmpty() {\n        return delegate.isEmpty();\n    }\n\n    public V put(final K key, final V value) {\n        throw new UnsupportedOperationException();\n    }\n\n    public void putAll(final Map<? extends K, ? extends V> m) {\n        throw new UnsupportedOperationException();\n    }\n\n    public V remove(final Object key) {\n        throw new UnsupportedOperationException();\n    }\n\n    public int size() {\n        return delegate.size();\n    }\n\n    public K firstKey() {\n        return delegate.firstKey();\n    }\n\n    public SortedMap<K, V> headMap(final K toKey) {\n        return Collections.unmodifiableSortedMap(delegate.headMap(toKey));\n    }\n\n    public K lastKey() {\n        return delegate.lastKey();\n    }\n\n    public SortedMap<K, V> subMap(final K fromKey, final K toKey) {\n        return Collections.unmodifiableSortedMap(delegate.subMap(fromKey, toKey));\n    }\n\n    public SortedMap<K, V> tailMap(final K fromKey) {\n        return Collections.unmodifiableSortedMap(delegate.tailMap(fromKey));\n    }\n\n    public SortedMap<K, V> prefixMap(final K key) {\n        return Collections.unmodifiableSortedMap(delegate.prefixMap(key));\n    }\n\n    public Comparator<? super K> comparator() {\n        return delegate.comparator();\n    }\n\n    //-----------------------------------------------------------------------\n    public OrderedMapIterator<K, V> mapIterator() {\n        final OrderedMapIterator<K, V> it = delegate.mapIterator();\n        return UnmodifiableOrderedMapIterator.unmodifiableOrderedMapIterator(it);\n    }\n\n    public K nextKey(K key) {\n        return delegate.nextKey(key);\n    }\n\n    public K previousKey(K key) {\n        return delegate.previousKey(key);\n    }\n\n    //-----------------------------------------------------------------------\n    @Override\n    public int hashCode() {\n        return delegate.hashCode();\n    }\n\n    @Override\n    public boolean equals(final Object obj) {\n        return delegate.equals(obj);\n    }\n\n    @Override\n    public String toString() {\n        return delegate.toString();\n    }\n\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4.trie;\n\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.SortedMap;\n\nimport org.apache.commons.collections4.OrderedMapIterator;\nimport org.apache.commons.collections4.Trie;\nimport org.apache.commons.collections4.Unmodifiable;\nimport org.apache.commons.collections4.iterators.UnmodifiableOrderedMapIterator;\n\n/**\n * An unmodifiable {@link Trie}.\n *\n * @since 4.0\n * @version $Id$\n */\npublic class UnmodifiableTrie<K, V> implements Trie<K, V>, Serializable, Unmodifiable {\n\n    /** Serialization version */\n    private static final long serialVersionUID = -7156426030315945159L;\n\n    private final Trie<K, V> delegate;\n\n    /**\n     * Factory method to create a unmodifiable trie.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param trie  the trie to decorate, must not be null\n     * @return a new unmodifiable trie\n     * @throws IllegalArgumentException if trie is null\n     */\n    public static <K, V> Trie<K, V> unmodifiableTrie(final Trie<K, ? extends V> trie) {\n        if (trie instanceof Unmodifiable) {\n            @SuppressWarnings(\"unchecked\") // safe to upcast\n            final Trie<K, V> tmpTrie = (Trie<K, V>) trie;\n            return tmpTrie;\n        }\n        return new UnmodifiableTrie<K, V>(trie);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param trie  the trie to decorate, must not be null\n     * @throws IllegalArgumentException if trie is null\n     */\n    public UnmodifiableTrie(final Trie<K, ? extends V> trie) {\n        if (trie == null) {\n            throw new IllegalArgumentException(\"Trie must not be null\");\n        }\n        @SuppressWarnings(\"unchecked\") // safe to upcast\n        final Trie<K, V> tmpTrie = (Trie<K, V>) trie;\n        this.delegate = tmpTrie;\n    }\n\n    //-----------------------------------------------------------------------\n\n    public Set<Entry<K, V>> entrySet() {\n        return Collections.unmodifiableSet(delegate.entrySet());\n    }\n\n    public Set<K> keySet() {\n        return Collections.unmodifiableSet(delegate.keySet());\n    }\n\n    public Collection<V> values() {\n        return Collections.unmodifiableCollection(delegate.values());\n    }\n\n    public void clear() {\n        throw new UnsupportedOperationException();\n    }\n\n    public boolean containsKey(final Object key) {\n        return delegate.containsKey(key);\n    }\n\n    public boolean containsValue(final Object value) {\n        return delegate.containsValue(value);\n    }\n\n    public V get(final Object key) {\n        return delegate.get(key);\n    }\n\n    public boolean isEmpty() {\n        return delegate.isEmpty();\n    }\n\n    public V put(final K key, final V value) {\n        throw new UnsupportedOperationException();\n    }\n\n    public void putAll(final Map<? extends K, ? extends V> m) {\n        throw new UnsupportedOperationException();\n    }\n\n    public V remove(final Object key) {\n        throw new UnsupportedOperationException();\n    }\n\n    public int size() {\n        return delegate.size();\n    }\n\n    public K firstKey() {\n        return delegate.firstKey();\n    }\n\n    public SortedMap<K, V> headMap(final K toKey) {\n        return Collections.unmodifiableSortedMap(delegate.headMap(toKey));\n    }\n\n    public K lastKey() {\n        return delegate.lastKey();\n    }\n\n    public SortedMap<K, V> subMap(final K fromKey, final K toKey) {\n        return Collections.unmodifiableSortedMap(delegate.subMap(fromKey, toKey));\n    }\n\n    public SortedMap<K, V> tailMap(final K fromKey) {\n        return Collections.unmodifiableSortedMap(delegate.tailMap(fromKey));\n    }\n\n    public SortedMap<K, V> prefixMap(final K key) {\n        return Collections.unmodifiableSortedMap(delegate.prefixMap(key));\n    }\n\n    public Comparator<? super K> comparator() {\n        return delegate.comparator();\n    }\n\n    //-----------------------------------------------------------------------\n    public OrderedMapIterator<K, V> mapIterator() {\n        final OrderedMapIterator<K, V> it = delegate.mapIterator();\n        return UnmodifiableOrderedMapIterator.unmodifiableOrderedMapIterator(it);\n    }\n\n    public K nextKey(K key) {\n        return delegate.nextKey(key);\n    }\n\n    public K previousKey(K key) {\n        return delegate.previousKey(key);\n    }\n\n    //-----------------------------------------------------------------------\n    @Override\n    public int hashCode() {\n        return delegate.hashCode();\n    }\n\n    @Override\n    public boolean equals(final Object obj) {\n        return delegate.equals(obj);\n    }\n\n    @Override\n    public String toString() {\n        return delegate.toString();\n    }\n\n}\n"}]}
{"project": "Collections", "bug_id": 24, "classes_modified": [{"class_name": "org.apache.commons.collections4.collection.UnmodifiableBoundedCollection", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4.collection;\n\nimport java.util.Collection;\nimport java.util.Iterator;\n\nimport org.apache.commons.collections4.BoundedCollection;\nimport org.apache.commons.collections4.iterators.UnmodifiableIterator;\n\n/**\n * {@link UnmodifiableBoundedCollection} decorates another\n * {@link BoundedCollection} to ensure it can't be altered.\n * <p>\n * If a BoundedCollection is first wrapped in some other collection decorator,\n * such as synchronized or predicated, the BoundedCollection methods are no\n * longer accessible.\n * The factory on this class will attempt to retrieve the bounded nature by\n * examining the package scope variables.\n * <p>\n * This class is Serializable from Commons Collections 3.1.\n * <p>\n * Attempts to modify it will result in an UnsupportedOperationException.\n *\n * @since 3.0\n * @version $Id$\n */\npublic final class UnmodifiableBoundedCollection<E> extends AbstractCollectionDecorator<E>\n        implements BoundedCollection<E> {\n\n    /** Serialization version */\n    private static final long serialVersionUID = -7112672385450340330L;\n\n    /**\n     * Factory method to create an unmodifiable bounded collection.\n     *\n     * @param <E> the type of the elements in the collection\n     * @param coll  the <code>BoundedCollection</code> to decorate, must not be null\n     * @return a new unmodifiable bounded collection\n     * @throws IllegalArgumentException if {@code coll} is {@code null}\n     * @since 4.0\n     */\n    public static <E> BoundedCollection<E> unmodifiableBoundedCollection(final BoundedCollection<? extends E> coll) {\n        return new UnmodifiableBoundedCollection<E>(coll);\n    }\n\n    /**\n     * Factory method to create an unmodifiable bounded collection.\n     * <p>\n     * This method is capable of drilling down through up to 1000 other decorators\n     * to find a suitable BoundedCollection.\n     *\n     * @param <E> the type of the elements in the collection\n     * @param coll  the <code>BoundedCollection</code> to decorate, must not be null\n     * @return a new unmodifiable bounded collection\n     * @throws IllegalArgumentException if {@code coll} is {@code null}\n     * @since 4.0\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <E> BoundedCollection<E> unmodifiableBoundedCollection(Collection<? extends E> coll) {\n        if (coll == null) {\n            throw new IllegalArgumentException(\"The collection must not be null\");\n        }\n\n        // handle decorators\n        for (int i = 0; i < 1000; i++) {  // counter to prevent infinite looping\n            if (coll instanceof BoundedCollection) {\n                break;  // normal loop exit\n            }\n            if (coll instanceof AbstractCollectionDecorator) {\n                coll = ((AbstractCollectionDecorator<E>) coll).decorated();\n            } else if (coll instanceof SynchronizedCollection) {\n                coll = ((SynchronizedCollection<E>) coll).decorated();\n            }\n        }\n\n        if (coll instanceof BoundedCollection == false) {\n            throw new IllegalArgumentException(\"The collection is not a bounded collection\");\n        }\n        return new UnmodifiableBoundedCollection<E>((BoundedCollection<E>) coll);\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param coll  the collection to decorate, must not be null\n     * @throws IllegalArgumentException if coll is null\n     */\n    @SuppressWarnings(\"unchecked\") // safe to upcast\n    private UnmodifiableBoundedCollection(final BoundedCollection<? extends E> coll) {\n        super((BoundedCollection<E>) coll);\n    }\n\n    //-----------------------------------------------------------------------\n    @Override\n    public Iterator<E> iterator() {\n        return UnmodifiableIterator.unmodifiableIterator(decorated().iterator());\n    }\n\n    @Override\n    public boolean add(final E object) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public boolean addAll(final Collection<? extends E> coll) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public void clear() {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public boolean remove(final Object object) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public boolean removeAll(final Collection<?> coll) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public boolean retainAll(final Collection<?> coll) {\n        throw new UnsupportedOperationException();\n    }\n\n    //-----------------------------------------------------------------------\n    public boolean isFull() {\n        return decorated().isFull();\n    }\n\n    public int maxSize() {\n        return decorated().maxSize();\n    }\n\n    @Override\n    protected BoundedCollection<E> decorated() {\n        return (BoundedCollection<E>) super.decorated();\n    }\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4.collection;\n\nimport java.util.Collection;\nimport java.util.Iterator;\n\nimport org.apache.commons.collections4.BoundedCollection;\nimport org.apache.commons.collections4.Unmodifiable;\nimport org.apache.commons.collections4.iterators.UnmodifiableIterator;\n\n/**\n * {@link UnmodifiableBoundedCollection} decorates another\n * {@link BoundedCollection} to ensure it can't be altered.\n * <p>\n * If a BoundedCollection is first wrapped in some other collection decorator,\n * such as synchronized or predicated, the BoundedCollection methods are no\n * longer accessible.\n * The factory on this class will attempt to retrieve the bounded nature by\n * examining the package scope variables.\n * <p>\n * This class is Serializable from Commons Collections 3.1.\n * <p>\n * Attempts to modify it will result in an UnsupportedOperationException.\n *\n * @since 3.0\n * @version $Id$\n */\npublic final class UnmodifiableBoundedCollection<E> extends AbstractCollectionDecorator<E>\n        implements BoundedCollection<E>, Unmodifiable {\n\n    /** Serialization version */\n    private static final long serialVersionUID = -7112672385450340330L;\n\n    /**\n     * Factory method to create an unmodifiable bounded collection.\n     *\n     * @param <E> the type of the elements in the collection\n     * @param coll  the <code>BoundedCollection</code> to decorate, must not be null\n     * @return a new unmodifiable bounded collection\n     * @throws IllegalArgumentException if {@code coll} is {@code null}\n     * @since 4.0\n     */\n    public static <E> BoundedCollection<E> unmodifiableBoundedCollection(final BoundedCollection<? extends E> coll) {\n        if (coll instanceof Unmodifiable) {\n            @SuppressWarnings(\"unchecked\") // safe to upcast\n            final BoundedCollection<E> tmpColl = (BoundedCollection<E>) coll;\n            return tmpColl;\n        }\n        return new UnmodifiableBoundedCollection<E>(coll);\n    }\n\n    /**\n     * Factory method to create an unmodifiable bounded collection.\n     * <p>\n     * This method is capable of drilling down through up to 1000 other decorators\n     * to find a suitable BoundedCollection.\n     *\n     * @param <E> the type of the elements in the collection\n     * @param coll  the <code>BoundedCollection</code> to decorate, must not be null\n     * @return a new unmodifiable bounded collection\n     * @throws IllegalArgumentException if {@code coll} is {@code null}\n     * @since 4.0\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <E> BoundedCollection<E> unmodifiableBoundedCollection(Collection<? extends E> coll) {\n        if (coll == null) {\n            throw new IllegalArgumentException(\"The collection must not be null\");\n        }\n\n        // handle decorators\n        for (int i = 0; i < 1000; i++) {  // counter to prevent infinite looping\n            if (coll instanceof BoundedCollection) {\n                break;  // normal loop exit\n            }\n            if (coll instanceof AbstractCollectionDecorator) {\n                coll = ((AbstractCollectionDecorator<E>) coll).decorated();\n            } else if (coll instanceof SynchronizedCollection) {\n                coll = ((SynchronizedCollection<E>) coll).decorated();\n            }\n        }\n\n        if (coll instanceof BoundedCollection == false) {\n            throw new IllegalArgumentException(\"The collection is not a bounded collection\");\n        }\n        return new UnmodifiableBoundedCollection<E>((BoundedCollection<E>) coll);\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param coll  the collection to decorate, must not be null\n     * @throws IllegalArgumentException if coll is null\n     */\n    @SuppressWarnings(\"unchecked\") // safe to upcast\n    private UnmodifiableBoundedCollection(final BoundedCollection<? extends E> coll) {\n        super((BoundedCollection<E>) coll);\n    }\n\n    //-----------------------------------------------------------------------\n    @Override\n    public Iterator<E> iterator() {\n        return UnmodifiableIterator.unmodifiableIterator(decorated().iterator());\n    }\n\n    @Override\n    public boolean add(final E object) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public boolean addAll(final Collection<? extends E> coll) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public void clear() {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public boolean remove(final Object object) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public boolean removeAll(final Collection<?> coll) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public boolean retainAll(final Collection<?> coll) {\n        throw new UnsupportedOperationException();\n    }\n\n    //-----------------------------------------------------------------------\n    public boolean isFull() {\n        return decorated().isFull();\n    }\n\n    public int maxSize() {\n        return decorated().maxSize();\n    }\n\n    @Override\n    protected BoundedCollection<E> decorated() {\n        return (BoundedCollection<E>) super.decorated();\n    }\n}\n"}]}
{"project": "Collections", "bug_id": 25, "classes_modified": [{"class_name": "org.apache.commons.collections4.IteratorUtils", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport java.lang.reflect.Array;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.Dictionary;\nimport java.util.Enumeration;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Map;\n\nimport org.apache.commons.collections4.functors.EqualPredicate;\nimport org.apache.commons.collections4.iterators.ArrayIterator;\nimport org.apache.commons.collections4.iterators.ArrayListIterator;\nimport org.apache.commons.collections4.iterators.BoundedIterator;\nimport org.apache.commons.collections4.iterators.CollatingIterator;\nimport org.apache.commons.collections4.iterators.EmptyIterator;\nimport org.apache.commons.collections4.iterators.EmptyListIterator;\nimport org.apache.commons.collections4.iterators.EmptyMapIterator;\nimport org.apache.commons.collections4.iterators.EmptyOrderedIterator;\nimport org.apache.commons.collections4.iterators.EmptyOrderedMapIterator;\nimport org.apache.commons.collections4.iterators.EnumerationIterator;\nimport org.apache.commons.collections4.iterators.FilterIterator;\nimport org.apache.commons.collections4.iterators.FilterListIterator;\nimport org.apache.commons.collections4.iterators.IteratorChain;\nimport org.apache.commons.collections4.iterators.IteratorEnumeration;\nimport org.apache.commons.collections4.iterators.IteratorIterable;\nimport org.apache.commons.collections4.iterators.ListIteratorWrapper;\nimport org.apache.commons.collections4.iterators.LoopingIterator;\nimport org.apache.commons.collections4.iterators.LoopingListIterator;\nimport org.apache.commons.collections4.iterators.NodeListIterator;\nimport org.apache.commons.collections4.iterators.ObjectArrayIterator;\nimport org.apache.commons.collections4.iterators.ObjectArrayListIterator;\nimport org.apache.commons.collections4.iterators.ObjectGraphIterator;\nimport org.apache.commons.collections4.iterators.PeekingIterator;\nimport org.apache.commons.collections4.iterators.PushbackIterator;\nimport org.apache.commons.collections4.iterators.SingletonIterator;\nimport org.apache.commons.collections4.iterators.SingletonListIterator;\nimport org.apache.commons.collections4.iterators.SkippingIterator;\nimport org.apache.commons.collections4.iterators.TransformIterator;\nimport org.apache.commons.collections4.iterators.UnmodifiableIterator;\nimport org.apache.commons.collections4.iterators.UnmodifiableListIterator;\nimport org.apache.commons.collections4.iterators.UnmodifiableMapIterator;\nimport org.apache.commons.collections4.iterators.ZippingIterator;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\n/**\n * Provides static utility methods and decorators for {@link Iterator}\n * instances. The implementations are provided in the iterators subpackage.\n * <p>\n * WARNING: Due to human error certain binary incompatibilities were introduced\n * between Commons Collections 2.1 and 3.0. The class remained source and test\n * compatible, so if you can recompile all your classes and dependencies\n * everything is OK. Those methods which are binary incompatible are marked as\n * such, together with alternate solutions that are binary compatible\n * against versions 2.1.1 and 3.1.\n *\n * @since 2.1\n * @version $Id$\n */\npublic class IteratorUtils {\n    // validation is done in this class in certain cases because the\n    // public classes allow invalid states\n\n    /**\n     * An iterator over no elements.\n     * <p>\n     * WARNING: This constant is binary incompatible with Commons Collections 2.1 and 2.1.1.\n     * Use <code>EmptyIterator.INSTANCE</code> for compatibility with Commons Collections 2.1.1.\n     */\n    @SuppressWarnings(\"rawtypes\")\n    public static final ResettableIterator EMPTY_ITERATOR = EmptyIterator.RESETTABLE_INSTANCE;\n\n    /**\n     * A list iterator over no elements.\n     * <p>\n     * WARNING: This constant is binary incompatible with Commons Collections 2.1 and 2.1.1.\n     * Use <code>EmptyListIterator.INSTANCE</code> for compatibility with Commons Collections 2.1.1.\n     */\n    @SuppressWarnings(\"rawtypes\")\n    public static final ResettableListIterator EMPTY_LIST_ITERATOR = EmptyListIterator.RESETTABLE_INSTANCE;\n\n    /**\n     * An ordered iterator over no elements.\n     */\n    @SuppressWarnings(\"rawtypes\")\n    public static final OrderedIterator EMPTY_ORDERED_ITERATOR = EmptyOrderedIterator.INSTANCE;\n\n    /**\n     * A map iterator over no elements.\n     */\n    @SuppressWarnings(\"rawtypes\")\n    public static final MapIterator EMPTY_MAP_ITERATOR = EmptyMapIterator.INSTANCE;\n\n    /**\n     * An ordered map iterator over no elements.\n     */\n    @SuppressWarnings(\"rawtypes\")\n    public static final OrderedMapIterator EMPTY_ORDERED_MAP_ITERATOR = EmptyOrderedMapIterator.INSTANCE;\n\n    /**\n     * Default prefix used while converting an Iterator to its String representation.\n     */\n    private static final String DEFAULT_TOSTRING_PREFIX = \"[\";\n\n    /**\n     * Default suffix used while converting an Iterator to its String representation.\n     */\n    private static final String DEFAULT_TOSTRING_SUFFIX = \"]\";\n\n    /**\n     * Default delimiter used to delimit elements while converting an Iterator\n     * to its String representation.\n     */\n    private static final String DEFAULT_TOSTRING_DELIMITER = \", \";\n\n    /**\n     * IteratorUtils is not normally instantiated.\n     */\n    private IteratorUtils() {}\n\n    // Empty\n    //-----------------------------------------------------------------------\n    /**\n     * Gets an empty iterator.\n     * <p>\n     * This iterator is a valid iterator object that will iterate over\n     * nothing.\n     * <p>\n     * WARNING: This method is binary incompatible with Commons Collections 2.1 and 2.1.1.\n     * Use <code>EmptyIterator.INSTANCE</code> for compatibility with Commons Collections 2.1.1.\n     *\n     * @param <E>  the element type\n     * @return  an iterator over nothing\n     */\n    public static <E> ResettableIterator<E> emptyIterator() {\n        return EmptyIterator.<E>resettableEmptyIterator();\n    }\n\n    /**\n     * Gets an empty list iterator.\n     * <p>\n     * This iterator is a valid list iterator object that will iterate\n     * over nothing.\n     * <p>\n     * WARNING: This method is binary incompatible with Commons Collections 2.1 and 2.1.1.\n     * Use <code>EmptyListIterator.INSTANCE</code> for compatibility with Commons Collections 2.1.1.\n     *\n     * @param <E>  the element type\n     * @return  a list iterator over nothing\n     */\n    public static <E> ResettableListIterator<E> emptyListIterator() {\n        return EmptyListIterator.<E>resettableEmptyListIterator();\n    }\n\n    /**\n     * Gets an empty ordered iterator.\n     * <p>\n     * This iterator is a valid iterator object that will iterate\n     * over nothing.\n     *\n     * @param <E>  the element type\n     * @return  an ordered iterator over nothing\n     */\n    public static <E> OrderedIterator<E> emptyOrderedIterator() {\n        return EmptyOrderedIterator.<E>emptyOrderedIterator();\n    }\n\n    /**\n     * Gets an empty map iterator.\n     * <p>\n     * This iterator is a valid map iterator object that will iterate\n     * over nothing.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @return  a map iterator over nothing\n     */\n    public static <K, V> MapIterator<K, V> emptyMapIterator() {\n        return EmptyMapIterator.<K, V>emptyMapIterator();\n    }\n\n    /**\n     * Gets an empty ordered map iterator.\n     * <p>\n     * This iterator is a valid map iterator object that will iterate\n     * over nothing.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @return  a map iterator over nothing\n     */\n    public static <K, V> OrderedMapIterator<K, V> emptyOrderedMapIterator() {\n        return EmptyOrderedMapIterator.<K, V>emptyOrderedMapIterator();\n    }\n\n    // Singleton\n    //-----------------------------------------------------------------------\n    /**\n     * Gets a singleton iterator.\n     * <p>\n     * This iterator is a valid iterator object that will iterate over\n     * the specified object.\n     * <p>\n     * WARNING: This method is binary incompatible with Commons Collections 2.1 and 2.1.1.\n     * Use <code>new SingletonIterator(object)</code> for compatibility.\n     *\n     * @param <E>  the element type\n     * @param object  the single object over which to iterate\n     * @return  a singleton iterator over the object\n     */\n    public static <E> ResettableIterator<E> singletonIterator(final E object) {\n        return new SingletonIterator<E>(object);\n    }\n\n    /**\n     * Gets a singleton list iterator.\n     * <p>\n     * This iterator is a valid list iterator object that will iterate over\n     * the specified object.\n     *\n     * @param <E>  the element type\n     * @param object  the single object over which to iterate\n     * @return  a singleton list iterator over the object\n     */\n    public static <E> ListIterator<E> singletonListIterator(final E object) {\n        return new SingletonListIterator<E>(object);\n    }\n\n    // Arrays\n    //-----------------------------------------------------------------------\n    /**\n     * Gets an iterator over an object array.\n     * <p>\n     * WARNING: This method is binary incompatible with Commons Collections 2.1 and 2.1.1.\n     * Use <code>new ArrayIterator(array)</code> for compatibility.\n     *\n     * @param <E>  the element type\n     * @param array  the array over which to iterate\n     * @return  an iterator over the array\n     * @throws NullPointerException if array is null\n     */\n    public static <E> ResettableIterator<E> arrayIterator(final E... array) {\n        return new ObjectArrayIterator<E>(array);\n    }\n\n    /**\n     * Gets an iterator over an object or primitive array.\n     * <p>\n     * This method will handle primitive arrays as well as object arrays.\n     * The primitives will be wrapped in the appropriate wrapper class.\n     *\n     * @param <E>  the element type\n     * @param array  the array over which to iterate\n     * @return  an iterator over the array\n     * @throws IllegalArgumentException if the array is not an array\n     * @throws NullPointerException if array is null\n     */\n    public static <E> ResettableIterator<E> arrayIterator(final Object array) {\n        return new ArrayIterator<E>(array);\n    }\n\n    /**\n     * Gets an iterator over the end part of an object array.\n     * <p>\n     * WARNING: This method is binary incompatible with Commons Collections 2.1 and 2.1.1.\n     * Use <code>new ArrayIterator(array,start)</code> for compatibility.\n     *\n     * @param <E>  the element type\n     * @param array  the array over which to iterate\n     * @param start  the index to start iterating at\n     * @return an iterator over part of the array\n     * @throws IndexOutOfBoundsException if start is less than zero or greater\n     *   than the length of the array\n     * @throws NullPointerException if array is null\n     */\n    public static <E> ResettableIterator<E> arrayIterator(final E[] array, final int start) {\n        return new ObjectArrayIterator<E>(array, start);\n    }\n\n    /**\n     * Gets an iterator over the end part of an object or primitive array.\n     * <p>\n     * This method will handle primitive arrays as well as object arrays.\n     * The primitives will be wrapped in the appropriate wrapper class.\n     *\n     * @param <E>  the element type\n     * @param array  the array over which to iterate\n     * @param start  the index to start iterating at\n     * @return an iterator over part of the array\n     * @throws IllegalArgumentException if the array is not an array\n     * @throws IndexOutOfBoundsException if start is less than zero or greater\n     *   than the length of the array\n     * @throws NullPointerException if array is null\n     */\n    public static <E> ResettableIterator<E> arrayIterator(final Object array, final int start) {\n        return new ArrayIterator<E>(array, start);\n    }\n\n    /**\n     * Gets an iterator over part of an object array.\n     * <p>\n     * WARNING: This method is binary incompatible with Commons Collections 2.1 and 2.1.1.\n     * Use <code>new ArrayIterator(array,start,end)</code> for compatibility.\n     *\n     * @param <E>  the element type\n     * @param array  the array over which to iterate\n     * @param start  the index to start iterating at\n     * @param end  the index to finish iterating at\n     * @return an iterator over part of the array\n     * @throws IndexOutOfBoundsException if array bounds are invalid\n     * @throws IllegalArgumentException if end is before start\n     * @throws NullPointerException if array is null\n     */\n    public static <E> ResettableIterator<E> arrayIterator(final E[] array, final int start, final int end) {\n        return new ObjectArrayIterator<E>(array, start, end);\n    }\n\n    /**\n     * Gets an iterator over part of an object or primitive array.\n     * <p>\n     * This method will handle primitive arrays as well as object arrays.\n     * The primitives will be wrapped in the appropriate wrapper class.\n     *\n     * @param <E>  the element type\n     * @param array  the array over which to iterate\n     * @param start  the index to start iterating at\n     * @param end  the index to finish iterating at\n     * @return an iterator over part of the array\n     * @throws IllegalArgumentException if the array is not an array or end is before start\n     * @throws IndexOutOfBoundsException if array bounds are invalid\n     * @throws NullPointerException if array is null\n     */\n    public static <E> ResettableIterator<E> arrayIterator(final Object array, final int start, final int end) {\n        return new ArrayIterator<E>(array, start, end);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets a list iterator over an object array.\n     *\n     * @param <E>  the element type\n     * @param array  the array over which to iterate\n     * @return  a list iterator over the array\n     * @throws NullPointerException if array is null\n     */\n    public static <E> ResettableListIterator<E> arrayListIterator(final E... array) {\n        return new ObjectArrayListIterator<E>(array);\n    }\n\n    /**\n     * Gets a list iterator over an object or primitive array.\n     * <p>\n     * This method will handle primitive arrays as well as object arrays.\n     * The primitives will be wrapped in the appropriate wrapper class.\n     *\n     * @param <E>  the element type\n     * @param array  the array over which to iterate\n     * @return  a list iterator over the array\n     * @throws IllegalArgumentException if the array is not an array\n     * @throws NullPointerException if array is null\n     */\n    public static <E> ResettableListIterator<E> arrayListIterator(final Object array) {\n        return new ArrayListIterator<E>(array);\n    }\n\n    /**\n     * Gets a list iterator over the end part of an object array.\n     *\n     * @param <E>  the element type\n     * @param array  the array over which to iterate\n     * @param start  the index to start iterating at\n     * @return a list iterator over part of the array\n     * @throws IndexOutOfBoundsException if start is less than zero\n     * @throws NullPointerException if array is null\n     */\n    public static <E> ResettableListIterator<E> arrayListIterator(final E[] array, final int start) {\n        return new ObjectArrayListIterator<E>(array, start);\n    }\n\n    /**\n     * Gets a list iterator over the end part of an object or primitive array.\n     * <p>\n     * This method will handle primitive arrays as well as object arrays.\n     * The primitives will be wrapped in the appropriate wrapper class.\n     *\n     * @param <E>  the element type\n     * @param array  the array over which to iterate\n     * @param start  the index to start iterating at\n     * @return a list iterator over part of the array\n     * @throws IllegalArgumentException if the array is not an array\n     * @throws IndexOutOfBoundsException if start is less than zero\n     * @throws NullPointerException if array is null\n     */\n    public static <E> ResettableListIterator<E> arrayListIterator(final Object array, final int start) {\n        return new ArrayListIterator<E>(array, start);\n    }\n\n    /**\n     * Gets a list iterator over part of an object array.\n     *\n     * @param <E>  the element type\n     * @param array  the array over which to iterate\n     * @param start  the index to start iterating at\n     * @param end  the index to finish iterating at\n     * @return a list iterator over part of the array\n     * @throws IndexOutOfBoundsException if array bounds are invalid\n     * @throws IllegalArgumentException if end is before start\n     * @throws NullPointerException if array is null\n     */\n    public static <E> ResettableListIterator<E> arrayListIterator(final E[] array, final int start, final int end) {\n        return new ObjectArrayListIterator<E>(array, start, end);\n    }\n\n    /**\n     * Gets a list iterator over part of an object or primitive array.\n     * <p>\n     * This method will handle primitive arrays as well as object arrays.\n     * The primitives will be wrapped in the appropriate wrapper class.\n     *\n     * @param <E>  the element type\n     * @param array  the array over which to iterate\n     * @param start  the index to start iterating at\n     * @param end  the index to finish iterating at\n     * @return a list iterator over part of the array\n     * @throws IllegalArgumentException if the array is not an array or end is before start\n     * @throws IndexOutOfBoundsException if array bounds are invalid\n     * @throws NullPointerException if array is null\n     */\n    public static <E> ResettableListIterator<E> arrayListIterator(final Object array, final int start, final int end) {\n        return new ArrayListIterator<E>(array, start, end);\n    }\n\n    // Bounded\n    //-----------------------------------------------------------------------\n    /**\n     * Decorates the specified iterator to return at most the given number\n     * of elements.\n     *\n     * @param <E>  the element type\n     * @param iterator  the iterator to decorate\n     * @param max  the maximum number of elements returned by this iterator\n     * @return a new bounded iterator\n     * @throws IllegalArgumentException if the iterator is null or max is negative\n     * @since 4.1\n     */\n    public static <E> BoundedIterator<E> boundedIterator(final Iterator<? extends E> iterator, long max) {\n        return boundedIterator(iterator, 0, max);\n    }\n\n    /**\n     * Decorates the specified iterator to return at most the given number\n     * of elements, skipping all elements until the iterator reaches the\n     * position at {@code offset}.\n     * <p>\n     * The iterator is immediately advanced until it reaches the position at\n     * {@code offset}, incurring O(n) time.\n     *\n     * @param <E>  the element type\n     * @param iterator  the iterator to decorate\n     * @param offset  the index of the first element of the decorated iterator to return\n     * @param max  the maximum number of elements returned by this iterator\n     * @return a new bounded iterator\n     * @throws IllegalArgumentException if the iterator is null or either offset or max is negative\n     * @since 4.1\n     */\n    public static <E> BoundedIterator<E> boundedIterator(final Iterator<? extends E> iterator,\n                                                         long offset, long max) {\n        return new BoundedIterator<E>(iterator, offset, max);\n    }\n\n    // Unmodifiable\n    //-----------------------------------------------------------------------\n    /**\n     * Gets an immutable version of an {@link Iterator}. The returned object\n     * will always throw an {@link UnsupportedOperationException} for\n     * the {@link Iterator#remove} method.\n     *\n     * @param <E>  the element type\n     * @param iterator  the iterator to make immutable\n     * @return an immutable version of the iterator\n     */\n    public static <E> Iterator<E> unmodifiableIterator(final Iterator<E> iterator) {\n        return UnmodifiableIterator.unmodifiableIterator(iterator);\n    }\n\n    /**\n     * Gets an immutable version of a {@link ListIterator}. The returned object\n     * will always throw an {@link UnsupportedOperationException} for\n     * the {@link Iterator#remove}, {@link ListIterator#add} and\n     * {@link ListIterator#set} methods.\n     *\n     * @param <E>  the element type\n     * @param listIterator  the iterator to make immutable\n     * @return an immutable version of the iterator\n     */\n    public static <E> ListIterator<E> unmodifiableListIterator(final ListIterator<E> listIterator) {\n        return UnmodifiableListIterator.umodifiableListIterator(listIterator);\n    }\n\n    /**\n     * Gets an immutable version of a {@link MapIterator}. The returned object\n     * will always throw an {@link UnsupportedOperationException} for\n     * the {@link Iterator#remove}, {@link MapIterator#setValue(Object)} methods.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param mapIterator  the iterator to make immutable\n     * @return an immutable version of the iterator\n     */\n    public static <K, V> MapIterator<K, V> unmodifiableMapIterator(final MapIterator<K, V> mapIterator) {\n        return UnmodifiableMapIterator.unmodifiableMapIterator(mapIterator);\n    }\n\n    // Chained\n    //-----------------------------------------------------------------------\n\n    /**\n     * Gets an iterator that iterates through two {@link Iterator}s\n     * one after another.\n     *\n     * @param <E>  the element type\n     * @param iterator1  the first iterator to use, not null\n     * @param iterator2  the second iterator to use, not null\n     * @return a combination iterator over the iterators\n     * @throws NullPointerException if either iterator is null\n     */\n    public static <E> Iterator<E> chainedIterator(final Iterator<? extends E> iterator1,\n                                                  final Iterator<? extends E> iterator2) {\n        // keep a version with two iterators to avoid the following warning in client code (Java 5 & 6)\n        // \"A generic array of E is created for a varargs parameter\"\n        return new IteratorChain<E>(iterator1, iterator2);\n    }\n\n    /**\n     * Gets an iterator that iterates through an array of {@link Iterator}s\n     * one after another.\n     *\n     * @param <E>  the element type\n     * @param iterators  the iterators to use, not null or empty or contain nulls\n     * @return a combination iterator over the iterators\n     * @throws NullPointerException if iterators array is null or contains a null\n     */\n    public static <E> Iterator<E> chainedIterator(final Iterator<? extends E>... iterators) {\n        return new IteratorChain<E>(iterators);\n    }\n\n    /**\n     * Gets an iterator that iterates through a collections of {@link Iterator}s\n     * one after another.\n     *\n     * @param <E>  the element type\n     * @param iterators  the iterators to use, not null or empty or contain nulls\n     * @return a combination iterator over the iterators\n     * @throws NullPointerException if iterators collection is null or contains a null\n     * @throws ClassCastException if the iterators collection contains the wrong object type\n     */\n    public static <E> Iterator<E> chainedIterator(final Collection<Iterator<? extends E>> iterators) {\n        return new IteratorChain<E>(iterators);\n    }\n\n    // Collated\n    //-----------------------------------------------------------------------\n    /**\n     * Gets an iterator that provides an ordered iteration over the elements\n     * contained in a collection of ordered {@link Iterator}s.\n     * <p>\n     * Given two ordered {@link Iterator}s <code>A</code> and <code>B</code>,\n     * the {@link Iterator#next()} method will return the lesser of\n     * <code>A.next()</code> and <code>B.next()</code>.\n     * <p>\n     * The comparator is optional. If null is specified then natural order is used.\n     *\n     * @param <E>  the element type\n     * @param comparator  the comparator to use, may be null for natural order\n     * @param iterator1  the first iterators to use, not null\n     * @param iterator2  the first iterators to use, not null\n     * @return a combination iterator over the iterators\n     * @throws NullPointerException if either iterator is null\n     */\n    public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator,\n                                                   final Iterator<? extends E> iterator1,\n                                                   final Iterator<? extends E> iterator2) {\n        return new CollatingIterator<E>(comparator, iterator1, iterator2);\n    }\n\n    /**\n     * Gets an iterator that provides an ordered iteration over the elements\n     * contained in an array of {@link Iterator}s.\n     * <p>\n     * Given two ordered {@link Iterator}s <code>A</code> and <code>B</code>,\n     * the {@link Iterator#next()} method will return the lesser of\n     * <code>A.next()</code> and <code>B.next()</code> and so on.\n     * <p>\n     * The comparator is optional. If null is specified then natural order is used.\n     *\n     * @param <E>  the element type\n     * @param comparator  the comparator to use, may be null for natural order\n     * @param iterators  the iterators to use, not null or empty or contain nulls\n     * @return a combination iterator over the iterators\n     * @throws NullPointerException if iterators array is null or contains a null value\n     */\n    public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator,\n                                                   final Iterator<? extends E>... iterators) {\n        return new CollatingIterator<E>(comparator, iterators);\n    }\n\n    /**\n     * Gets an iterator that provides an ordered iteration over the elements\n     * contained in a collection of {@link Iterator}s.\n     * <p>\n     * Given two ordered {@link Iterator}s <code>A</code> and <code>B</code>,\n     * the {@link Iterator#next()} method will return the lesser of\n     * <code>A.next()</code> and <code>B.next()</code> and so on.\n     * <p>\n     * The comparator is optional. If null is specified then natural order is used.\n     *\n     * @param <E>  the element type\n     * @param comparator  the comparator to use, may be null for natural order\n     * @param iterators  the iterators to use, not null or empty or contain nulls\n     * @return a combination iterator over the iterators\n     * @throws NullPointerException if iterators collection is null or contains a null\n     * @throws ClassCastException if the iterators collection contains the wrong object type\n     */\n    public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator,\n                                                   final Collection<Iterator<? extends E>> iterators) {\n        return new CollatingIterator<E>(comparator, iterators);\n    }\n\n    // Object Graph\n    //-----------------------------------------------------------------------\n    /**\n     * Gets an iterator that operates over an object graph.\n     * <p>\n     * This iterator can extract multiple objects from a complex tree-like object graph.\n     * The iteration starts from a single root object.\n     * It uses a <code>Transformer</code> to extract the iterators and elements.\n     * Its main benefit is that no intermediate <code>List</code> is created.\n     * <p>\n     * For example, consider an object graph:\n     * <pre>\n     *                 |- Branch -- Leaf\n     *                 |         \\- Leaf\n     *         |- Tree |         /- Leaf\n     *         |       |- Branch -- Leaf\n     *  Forest |                 \\- Leaf\n     *         |       |- Branch -- Leaf\n     *         |       |         \\- Leaf\n     *         |- Tree |         /- Leaf\n     *                 |- Branch -- Leaf\n     *                 |- Branch -- Leaf</pre>\n     * The following <code>Transformer</code>, used in this class, will extract all\n     * the Leaf objects without creating a combined intermediate list:\n     * <pre>\n     * public Object transform(Object input) {\n     *   if (input instanceof Forest) {\n     *     return ((Forest) input).treeIterator();\n     *   }\n     *   if (input instanceof Tree) {\n     *     return ((Tree) input).branchIterator();\n     *   }\n     *   if (input instanceof Branch) {\n     *     return ((Branch) input).leafIterator();\n     *   }\n     *   if (input instanceof Leaf) {\n     *     return input;\n     *   }\n     *   throw new ClassCastException();\n     * }</pre>\n     * <p>\n     * Internally, iteration starts from the root object. When next is called,\n     * the transformer is called to examine the object. The transformer will return\n     * either an iterator or an object. If the object is an Iterator, the next element\n     * from that iterator is obtained and the process repeats. If the element is an object\n     * it is returned.\n     * <p>\n     * Under many circumstances, linking Iterators together in this manner is\n     * more efficient (and convenient) than using nested for loops to extract a list.\n     *\n     * @param <E>  the element type\n     * @param root  the root object to start iterating from, null results in an empty iterator\n     * @param transformer  the transformer to use, see above, null uses no effect transformer\n     * @return a new object graph iterator\n     * @since 3.1\n     */\n    public static <E> Iterator<E> objectGraphIterator(final E root,\n            final Transformer<? super E, ? extends E> transformer) {\n        return new ObjectGraphIterator<E>(root, transformer);\n    }\n\n    // Transformed\n    //-----------------------------------------------------------------------\n    /**\n     * Gets an iterator that transforms the elements of another iterator.\n     * <p>\n     * The transformation occurs during the next() method and the underlying\n     * iterator is unaffected by the transformation.\n     *\n     * @param <I>  the input type\n     * @param <O>  the output type\n     * @param iterator  the iterator to use, not null\n     * @param transform  the transform to use, not null\n     * @return a new transforming iterator\n     * @throws NullPointerException if either parameter is null\n     */\n    public static <I, O> Iterator<O> transformedIterator(final Iterator<? extends I> iterator,\n            final Transformer<? super I, ? extends O> transform) {\n\n        if (iterator == null) {\n            throw new NullPointerException(\"Iterator must not be null\");\n        }\n        if (transform == null) {\n            throw new NullPointerException(\"Transformer must not be null\");\n        }\n        return new TransformIterator<I, O>(iterator, transform);\n    }\n\n    // Filtered\n    //-----------------------------------------------------------------------\n    /**\n     * Gets an iterator that filters another iterator.\n     * <p>\n     * The returned iterator will only return objects that match the specified\n     * filtering predicate.\n     *\n     * @param <E>  the element type\n     * @param iterator  the iterator to use, not null\n     * @param predicate  the predicate to use as a filter, not null\n     * @return a new filtered iterator\n     * @throws NullPointerException if either parameter is null\n     */\n    public static <E> Iterator<E> filteredIterator(final Iterator<? extends E> iterator,\n                                                   final Predicate<? super E> predicate) {\n        if (iterator == null) {\n            throw new NullPointerException(\"Iterator must not be null\");\n        }\n        if (predicate == null) {\n            throw new NullPointerException(\"Predicate must not be null\");\n        }\n        return new FilterIterator<E>(iterator, predicate);\n    }\n\n    /**\n     * Gets a list iterator that filters another list iterator.\n     * <p>\n     * The returned iterator will only return objects that match the specified\n     * filtering predicate.\n     *\n     * @param <E>  the element type\n     * @param listIterator  the list iterator to use, not null\n     * @param predicate  the predicate to use as a filter, not null\n     * @return a new filtered iterator\n     * @throws NullPointerException if either parameter is null\n     */\n    public static <E> ListIterator<E> filteredListIterator(final ListIterator<? extends E> listIterator,\n            final Predicate<? super E> predicate) {\n\n        if (listIterator == null) {\n            throw new NullPointerException(\"ListIterator must not be null\");\n        }\n        if (predicate == null) {\n            throw new NullPointerException(\"Predicate must not be null\");\n        }\n        return new FilterListIterator<E>(listIterator, predicate);\n    }\n\n    // Looping\n    //-----------------------------------------------------------------------\n    /**\n     * Gets an iterator that loops continuously over the supplied collection.\n     * <p>\n     * The iterator will only stop looping if the remove method is called\n     * enough times to empty the collection, or if the collection is empty\n     * to start with.\n     *\n     * @param <E>  the element type\n     * @param coll  the collection to iterate over, not null\n     * @return a new looping iterator\n     * @throws NullPointerException if the collection is null\n     */\n    public static <E> ResettableIterator<E> loopingIterator(final Collection<? extends E> coll) {\n        if (coll == null) {\n            throw new NullPointerException(\"Collection must not be null\");\n        }\n        return new LoopingIterator<E>(coll);\n    }\n\n    /**\n     * Gets an iterator that loops continuously over the supplied list.\n     * <p>\n     * The iterator will only stop looping if the remove method is called\n     * enough times to empty the list, or if the list is empty to start with.\n     *\n     * @param <E>  the element type\n     * @param list  the list to iterate over, not null\n     * @return a new looping iterator\n     * @throws NullPointerException if the list is null\n     * @since 3.2\n     */\n    public static <E> ResettableListIterator<E> loopingListIterator(final List<E> list) {\n        if (list == null) {\n            throw new NullPointerException(\"List must not be null\");\n        }\n        return new LoopingListIterator<E>(list);\n    }\n\n    // org.w3c.dom.NodeList iterators\n    //-----------------------------------------------------------------------\n    /**\n     * Gets an {@link Iterator} that wraps the specified {@link NodeList}.\n     * The returned {@link Iterator} can be used for a single iteration.\n     *\n     * @param nodeList the node list to use, not null\n     * @return a new, single use {@link Iterator}\n     * @throws NullPointerException if nodeList is null\n     * @since 4.0\n     */\n    public static NodeListIterator nodeListIterator(final NodeList nodeList) {\n        if (nodeList == null) {\n            throw new NullPointerException(\"NodeList must not be null\");\n        }\n        return new NodeListIterator(nodeList);\n    }\n\n    /**\n     * Gets an {@link Iterator} that wraps the specified node's childNodes.\n     * The returned {@link Iterator} can be used for a single iteration.\n     * <p>\n     * Convenience method, allows easy iteration over NodeLists:\n     * <pre>\n     *   Iterator&lt;Node&gt; iterator = IteratorUtils.nodeListIterator(node);\n     *   for(Node childNode : IteratorUtils.asIterable(iterator)) {\n     *     ...\n     *   }\n     * </pre>\n     *\n     * @param node the node to use, not null\n     * @return a new, single use {@link Iterator}\n     * @throws NullPointerException if node is null\n     * @since 4.0\n     */\n    public static NodeListIterator nodeListIterator(final Node node) {\n        if (node == null) {\n            throw new NullPointerException(\"Node must not be null\");\n        }\n        return new NodeListIterator(node);\n    }\n\n    // Peeking\n    //-----------------------------------------------------------------------\n\n    /**\n     * Gets an iterator that supports one-element lookahead.\n     *\n     * @param <E>  the element type\n     * @param iterator  the iterator to decorate, not null\n     * @return a peeking iterator\n     * @throws NullPointerException if the iterator is null\n     * @since 4.0\n     */\n    public static <E> Iterator<E> peekingIterator(final Iterator<? extends E> iterator) {\n        return PeekingIterator.peekingIterator(iterator);\n    }\n\n    // Pushback\n    //-----------------------------------------------------------------------\n\n    /**\n     * Gets an iterator that supports pushback of elements.\n     *\n     * @param <E>  the element type\n     * @param iterator  the iterator to decorate, not null\n     * @return a pushback iterator\n     * @throws NullPointerException if the iterator is null\n     * @since 4.0\n     */\n    public static <E> Iterator<E> pushbackIterator(final Iterator<? extends E> iterator) {\n        return PushbackIterator.pushbackIterator(iterator);\n    }\n\n    // Skipping\n    //-----------------------------------------------------------------------\n    /**\n     * Decorates the specified iterator to skip the first N elements.\n     *\n     * @param <E>  the element type\n     * @param iterator  the iterator to decorate\n     * @param offset  the first number of elements to skip\n     * @return a new skipping iterator\n     * @throws IllegalArgumentException if the iterator is null or offset is negative\n     * @since 4.1\n     */\n    public static <E> SkippingIterator<E> skippingIterator(final Iterator<E> iterator, long offset) {\n        return new SkippingIterator<E>(iterator, offset);\n    }\n\n    // Zipping\n    //-----------------------------------------------------------------------\n    /**\n     * Returns an iterator that interleaves elements from the decorated iterators.\n     *\n     * @param <E>  the element type\n     * @param a  the first iterator to interleave\n     * @param b  the second iterator to interleave\n     * @return an iterator, interleaving the decorated iterators\n     * @throws IllegalArgumentException if any iterator is null\n     * @since 4.1\n     */\n    public static <E> ZippingIterator<E> zippingIterator(final Iterator<? extends E> a,\n                                                         final Iterator<? extends E> b) {\n        return new ZippingIterator<E>(a, b);\n    }\n\n    /**\n     * Returns an iterator that interleaves elements from the decorated iterators.\n     *\n     * @param <E>  the element type\n     * @param a  the first iterator to interleave\n     * @param b  the second iterator to interleave\n     * @param c  the third iterator to interleave\n     * @return an iterator, interleaving the decorated iterators\n     * @throws IllegalArgumentException if any iterator is null\n     * @since 4.1\n     */\n    public static <E> ZippingIterator<E> zippingIterator(final Iterator<? extends E> a,\n                                                         final Iterator<? extends E> b,\n                                                         final Iterator<? extends E> c) {\n        return new ZippingIterator<E>(a, b, c);\n    }\n\n    /**\n     * Returns an iterator that interleaves elements from the decorated iterators.\n     *\n     * @param <E>  the element type\n     * @param iterators  the array of iterators to interleave\n     * @return an iterator, interleaving the decorated iterators\n     * @throws IllegalArgumentException if any iterator is null\n     * @since 4.1\n     */\n    public static <E> ZippingIterator<E> zippingIterator(final Iterator<? extends E>... iterators) {\n        return new ZippingIterator<E>(iterators);\n    }\n\n    // Views\n    //-----------------------------------------------------------------------\n    /**\n     * Gets an iterator that provides an iterator view of the given enumeration.\n     *\n     * @param <E>  the element type\n     * @param enumeration  the enumeration to use\n     * @return a new iterator\n     */\n    public static <E> Iterator<E> asIterator(final Enumeration<? extends E> enumeration) {\n        if (enumeration == null) {\n            throw new NullPointerException(\"Enumeration must not be null\");\n        }\n        return new EnumerationIterator<E>(enumeration);\n    }\n\n    /**\n     * Gets an iterator that provides an iterator view of the given enumeration\n     * that will remove elements from the specified collection.\n     *\n     * @param <E>  the element type\n     * @param enumeration  the enumeration to use\n     * @param removeCollection  the collection to remove elements from\n     * @return a new iterator\n     */\n    public static <E> Iterator<E> asIterator(final Enumeration<? extends E> enumeration,\n                                             final Collection<? super E> removeCollection) {\n        if (enumeration == null) {\n            throw new NullPointerException(\"Enumeration must not be null\");\n        }\n        if (removeCollection == null) {\n            throw new NullPointerException(\"Collection must not be null\");\n        }\n        return new EnumerationIterator<E>(enumeration, removeCollection);\n    }\n\n    /**\n     * Gets an enumeration that wraps an iterator.\n     *\n     * @param <E>  the element type\n     * @param iterator  the iterator to use, not null\n     * @return a new enumeration\n     * @throws NullPointerException if iterator is null\n     */\n    public static <E> Enumeration<E> asEnumeration(final Iterator<? extends E> iterator) {\n        if (iterator == null) {\n            throw new NullPointerException(\"Iterator must not be null\");\n        }\n        return new IteratorEnumeration<E>(iterator);\n    }\n\n    /**\n     * Gets an {@link Iterable} that wraps an iterator.  The returned {@link Iterable} can be\n     * used for a single iteration.\n     *\n     * @param <E>  the element type\n     * @param iterator  the iterator to use, not null\n     * @return a new, single use {@link Iterable}\n     * @throws NullPointerException if iterator is null\n     */\n    public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator) {\n        if (iterator == null) {\n            throw new NullPointerException(\"Iterator must not be null\");\n        }\n        return new IteratorIterable<E>(iterator, false);\n    }\n\n    /**\n     * Gets an iterable that wraps an iterator.  The returned iterable can be\n     * used for multiple iterations.\n     *\n     * @param <E>  the element type\n     * @param iterator  the iterator to use, not null\n     * @return a new, multiple use iterable\n     * @throws NullPointerException if iterator is null\n     */\n    public static <E> Iterable<E> asMultipleUseIterable(final Iterator<? extends E> iterator) {\n        if (iterator == null) {\n            throw new NullPointerException(\"Iterator must not be null\");\n        }\n        return new IteratorIterable<E>(iterator, true);\n    }\n\n    /**\n     * Gets a list iterator based on a simple iterator.\n     * <p>\n     * As the wrapped Iterator is traversed, a LinkedList of its values is\n     * cached, permitting all required operations of ListIterator.\n     *\n     * @param <E>  the element type\n     * @param iterator  the iterator to use, not null\n     * @return a new iterator\n     * @throws NullPointerException if iterator parameter is null\n     */\n    public static <E> ListIterator<E> toListIterator(final Iterator<? extends E> iterator) {\n        if (iterator == null) {\n            throw new NullPointerException(\"Iterator must not be null\");\n        }\n        return new ListIteratorWrapper<E>(iterator);\n    }\n\n    /**\n     * Gets an array based on an iterator.\n     * <p>\n     * As the wrapped Iterator is traversed, an ArrayList of its values is\n     * created. At the end, this is converted to an array.\n     *\n     * @param iterator  the iterator to use, not null\n     * @return an array of the iterator contents\n     * @throws NullPointerException if iterator parameter is null\n     */\n    public static Object[] toArray(final Iterator<?> iterator) {\n        if (iterator == null) {\n            throw new NullPointerException(\"Iterator must not be null\");\n        }\n        final List<?> list = toList(iterator, 100);\n        return list.toArray();\n    }\n\n    /**\n     * Gets an array based on an iterator.\n     * <p>\n     * As the wrapped Iterator is traversed, an ArrayList of its values is\n     * created. At the end, this is converted to an array.\n     *\n     * @param <E>  the element type\n     * @param iterator  the iterator to use, not null\n     * @param arrayClass  the class of array to create\n     * @return an array of the iterator contents\n     * @throws NullPointerException if iterator parameter or arrayClass is null\n     * @throws ClassCastException if the arrayClass is invalid\n     */\n    public static <E> E[] toArray(final Iterator<? extends E> iterator, final Class<E> arrayClass) {\n        if (iterator == null) {\n            throw new NullPointerException(\"Iterator must not be null\");\n        }\n        if (arrayClass == null) {\n            throw new NullPointerException(\"Array class must not be null\");\n        }\n        final List<E> list = toList(iterator, 100);\n        @SuppressWarnings(\"unchecked\") // as per Javadoc, will throw CCE if class is wrong\n        final E[] array = (E[]) Array.newInstance(arrayClass, list.size());\n        return list.toArray(array);\n    }\n\n    /**\n     * Gets a list based on an iterator.\n     * <p>\n     * As the wrapped Iterator is traversed, an ArrayList of its values is\n     * created. At the end, the list is returned.\n     *\n     * @param <E>  the element type\n     * @param iterator  the iterator to use, not null\n     * @return a list of the iterator contents\n     * @throws NullPointerException if iterator parameter is null\n     */\n    public static <E> List<E> toList(final Iterator<? extends E> iterator) {\n        return toList(iterator, 10);\n    }\n\n    /**\n     * Gets a list based on an iterator.\n     * <p>\n     * As the wrapped Iterator is traversed, an ArrayList of its values is\n     * created. At the end, the list is returned.\n     *\n     * @param <E>  the element type\n     * @param iterator  the iterator to use, not null\n     * @param estimatedSize  the initial size of the ArrayList\n     * @return a list of the iterator contents\n     * @throws NullPointerException if iterator parameter is null\n     * @throws IllegalArgumentException if the size is less than 1\n     */\n    public static <E> List<E> toList(final Iterator<? extends E> iterator, final int estimatedSize) {\n        if (iterator == null) {\n            throw new NullPointerException(\"Iterator must not be null\");\n        }\n        if (estimatedSize < 1) {\n            throw new IllegalArgumentException(\"Estimated size must be greater than 0\");\n        }\n        final List<E> list = new ArrayList<E>(estimatedSize);\n        while (iterator.hasNext()) {\n            list.add(iterator.next());\n        }\n        return list;\n    }\n\n    /**\n     * Gets a suitable Iterator for the given object.\n     * <p>\n     * This method can handle objects as follows\n     * <ul>\n     * <li>null - empty iterator\n     * <li>Iterator - returned directly\n     * <li>Enumeration - wrapped\n     * <li>Collection - iterator from collection returned\n     * <li>Map - values iterator returned\n     * <li>Dictionary - values (elements) enumeration returned as iterator\n     * <li>array - iterator over array returned\n     * <li>object with iterator() public method accessed by reflection\n     * <li>object - singleton iterator\n     * <li>NodeList - iterator over the list\n     * <li>Node - iterator over the child nodes\n     * </ul>\n     *\n     * @param obj  the object to convert to an iterator\n     * @return a suitable iterator, never null\n     */\n    public static Iterator<?> getIterator(final Object obj) {\n        if (obj == null) {\n            return emptyIterator();\n        }\n        if (obj instanceof Iterator) {\n            return (Iterator<?>) obj;\n        }\n        if (obj instanceof Iterable) {\n            return ((Iterable<?>) obj).iterator();\n        }\n        if (obj instanceof Object[]) {\n            return new ObjectArrayIterator<Object>((Object[]) obj);\n        }\n        if (obj instanceof Enumeration) {\n            return new EnumerationIterator<Object>((Enumeration<?>) obj);\n        }\n        if (obj instanceof Map) {\n            return ((Map<?, ?>) obj).values().iterator();\n        }\n        if (obj instanceof NodeList) {\n            return new NodeListIterator((NodeList) obj);\n        }\n        if (obj instanceof Node) {\n            return new NodeListIterator((Node) obj);\n        }\n        if (obj instanceof Dictionary) {\n            return new EnumerationIterator<Object>(((Dictionary<?, ?>) obj).elements());\n        } else if (obj.getClass().isArray()) {\n            return new ArrayIterator<Object>(obj);\n        }\n        try {\n            final Method method = obj.getClass().getMethod(\"iterator\", (Class[]) null);\n            if (Iterator.class.isAssignableFrom(method.getReturnType())) {\n                final Iterator<?> it = (Iterator<?>) method.invoke(obj, (Object[]) null);\n                if (it != null) {\n                    return it;\n                }\n            }\n        } catch (final RuntimeException e) { // NOPMD\n            // ignore\n        } catch (final NoSuchMethodException e) { // NOPMD\n            // ignore\n        } catch (final IllegalAccessException e) { // NOPMD\n            // ignore\n        } catch (final InvocationTargetException e) { // NOPMD\n            // ignore\n        }\n        return singletonIterator(obj);\n    }\n\n    // Utility methods\n    //-----------------------------------------------------------------------\n\n    /**\n     * Applies the closure to each element of the provided iterator.\n     *\n     * @param <E>  the element type\n     * @param iterator  the iterator to use, may be null\n     * @param closure  the closure to apply to each element, may not be null\n     * @throws NullPointerException if closure is null\n     * @since 4.1\n     */\n    public static <E> void apply(final Iterator<E> iterator, final Closure<? super E> closure) {\n        if (closure == null) {\n            throw new NullPointerException(\"Closure must not be null\");\n        }\n\n        if (iterator != null) {\n            while (iterator.hasNext()) {\n                final E element = iterator.next();\n                closure.execute(element);\n            }\n        }\n    }\n\n    /**\n     * Finds the first element in the given iterator which matches the given predicate.\n     * <p>\n     * A <code>null</code> or empty iterator returns null.\n     *\n     * @param <E>  the element type\n     * @param iterator  the iterator to search, may be null\n     * @param predicate  the predicate to use, may not be null\n     * @return the first element of the iterator which matches the predicate or null if none could be found\n     * @throws NullPointerException if predicate is null\n     * @since 4.1\n     */\n    public static <E> E find(final Iterator<E> iterator, final Predicate<? super E> predicate) {\n        if (predicate == null) {\n            throw new NullPointerException(\"Predicate must not be null\");\n        }\n\n        if (iterator != null) {\n            while (iterator.hasNext()) {\n                final E element = iterator.next();\n                if (predicate.evaluate(element)) {\n                    return element;\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Answers true if a predicate is true for any element of the iterator.\n     * <p>\n     * A <code>null</code> or empty iterator returns false.\n     *\n     * @param <E>  the type of object the {@link Iterator} contains\n     * @param iterator  the {@link Iterator} to use, may be null\n     * @param predicate  the predicate to use, may not be null\n     * @return true if any element of the collection matches the predicate, false otherwise\n     * @throws NullPointerException if predicate is null\n     * @since 4.1\n     */\n    public static <E> boolean matchesAny(final Iterator<E> iterator, final Predicate<? super E> predicate) {\n        if (predicate == null) {\n            throw new NullPointerException(\"Predicate must not be null\");\n        }\n\n        if (iterator != null) {\n            while (iterator.hasNext()) {\n                final E element = iterator.next();\n                if (predicate.evaluate(element)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Answers true if a predicate is true for every element of an iterator.\n     * <p>\n     * A <code>null</code> or empty iterator returns true.\n     *\n     * @param <E>  the type of object the {@link Iterator} contains\n     * @param iterator  the {@link Iterator} to use, may be null\n     * @param predicate  the predicate to use, may not be null\n     * @return true if every element of the collection matches the predicate or if the\n     *   collection is empty, false otherwise\n     * @throws NullPointerException if predicate is null\n     * @since 4.1\n     */\n    public static <E> boolean matchesAll(final Iterator<E> iterator, final Predicate<? super E> predicate) {\n        if (predicate == null) {\n            throw new NullPointerException(\"Predicate must not be null\");\n        }\n\n        if (iterator != null) {\n            while (iterator.hasNext()) {\n                final E element = iterator.next();\n                if (!predicate.evaluate(element)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Checks if the given iterator is empty.\n     * <p>\n     * A <code>null</code> or empty iterator returns true.\n     *\n     * @param iterator  the {@link Iterator} to use, may be null\n     * @return true if the iterator is exhausted or null, false otherwise\n     * @since 4.1\n     */\n    public static boolean isEmpty(final Iterator<?> iterator) {\n        return iterator == null || !iterator.hasNext();\n    }\n\n    /**\n     * Checks if the object is contained in the given iterator.\n     * <p>\n     * A <code>null</code> or empty iterator returns false.\n     *\n     * @param <E>  the type of object the {@link Iterator} contains\n     * @param iterator  the iterator to check, may be null\n     * @param object  the object to check\n     * @return true if the object is contained in the iterator, false otherwise\n     * @since 4.1\n     */\n    public static <E> boolean contains(final Iterator<E> iterator, final Object object) {\n        return matchesAny(iterator, EqualPredicate.equalPredicate(object));\n    }\n\n    /**\n     * Returns the <code>index</code>-th value in {@link Iterator}, throwing\n     * <code>IndexOutOfBoundsException</code> if there is no such element.\n     * <p>\n     * The Iterator is advanced to <code>index</code> (or to the end, if\n     * <code>index</code> exceeds the number of entries) as a side effect of this method.\n     *\n     * @param <E>  the type of object in the {@link Iterator}\n     * @param iterator  the iterator to get a value from\n     * @param index  the index to get\n     * @return the object at the specified index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     * @throws IllegalArgumentException if the object type is invalid\n     * @since 4.1\n     */\n    public static <E> E get(final Iterator<E> iterator, final int index) {\n        int i = index;\n        CollectionUtils.checkIndexBounds(i);\n        while (iterator.hasNext()) {\n            i--;\n            if (i == -1) {\n                return iterator.next();\n            }\n            iterator.next();\n        }\n        throw new IndexOutOfBoundsException(\"Entry does not exist: \" + i);\n    }\n\n    /**\n     * Returns the number of elements contained in the given iterator.\n     * <p>\n     * A <code>null</code> or empty iterator returns {@code 0}.\n     *\n     * @param iterator  the iterator to check, may be null\n     * @return the number of elements contained in the iterator\n     * @since 4.1\n     */\n    public static int size(final Iterator<?> iterator) {\n        int size = 0;\n        if (iterator != null) {\n            while (iterator.hasNext()) {\n                iterator.next();\n                size++;\n            }\n        }\n        return size;\n    }\n\n    /**\n     * Returns a string representation of the elements of the specified iterator.\n     * <p>\n     * The string representation consists of a list of the iterator's elements,\n     * enclosed in square brackets ({@code \"[]\"}). Adjacent elements are separated\n     * by the characters {@code \", \"} (a comma followed by a space). Elements are\n     * converted to strings as by {@code String.valueOf(Object)}.\n     *\n     * @param <E>  the element type\n     * @param iterator  the iterator to convert to a string\n     * @return a string representation of {@code iterator}\n     * @since 4.1\n     */\n    public static <E> String toString(final Iterator<E> iterator) {\n        return toString(iterator, TransformerUtils.stringValueTransformer(),\n                        DEFAULT_TOSTRING_DELIMITER, DEFAULT_TOSTRING_PREFIX,\n                        DEFAULT_TOSTRING_SUFFIX);\n    }\n\n    /**\n     * Returns a string representation of the elements of the specified iterator.\n     * <p>\n     * The string representation consists of a list of the iterable's elements,\n     * enclosed in square brackets ({@code \"[]\"}). Adjacent elements are separated\n     * by the characters {@code \", \"} (a comma followed by a space). Elements are\n     * converted to strings as by using the provided {@code transformer}.\n     *\n     * @param <E>  the element type\n     * @param iterator  the iterator to convert to a string, may be null\n     * @param transformer  the transformer used to get a string representation of an element\n     * @return a string representation of {@code iterator}\n     * @throws NullPointerException if {@code transformer} is null\n     * @since 4.1\n     */\n    public static <E> String toString(final Iterator<E> iterator,\n                                      final Transformer<? super E, String> transformer) {\n        return toString(iterator, transformer, DEFAULT_TOSTRING_DELIMITER,\n                        DEFAULT_TOSTRING_PREFIX, DEFAULT_TOSTRING_SUFFIX);\n    }\n\n    /**\n     * Returns a string representation of the elements of the specified iterator.\n     * <p>\n     * The string representation consists of a list of the iterator's elements,\n     * enclosed by the provided {@code prefix} and {@code suffix}. Adjacent elements\n     * are separated by the provided {@code delimiter}. Elements are converted to\n     * strings as by using the provided {@code transformer}.\n     *\n     * @param <E>  the element type\n     * @param iterator  the iterator to convert to a string, may be null\n     * @param transformer  the transformer used to get a string representation of an element\n     * @param delimiter  the string to delimit elements\n     * @param prefix  the prefix, prepended to the string representation\n     * @param suffix  the suffix, appended to the string representation\n     * @return a string representation of {@code iterator}\n     * @throws NullPointerException if either transformer, delimiter, prefix or suffix is null\n     * @since 4.1\n     */\n    public static <E> String toString(final Iterator<E> iterator,\n                                      final Transformer<? super E, String> transformer,\n                                      final String delimiter,\n                                      final String prefix,\n                                      final String suffix) {\n        if (transformer == null) {\n            throw new NullPointerException(\"transformer may not be null\");\n        }\n        if (delimiter == null) {\n            throw new NullPointerException(\"delimiter may not be null\");\n        }\n        if (prefix == null) {\n            throw new NullPointerException(\"prefix may not be null\");\n        }\n        if (suffix == null) {\n            throw new NullPointerException(\"suffix may not be null\");\n        }\n        final StringBuilder stringBuilder = new StringBuilder(prefix);\n        if (iterator != null) {\n            while (iterator.hasNext()) {\n                final E element = iterator.next();\n                stringBuilder.append(transformer.transform(element));\n                stringBuilder.append(delimiter);\n            }\n            if(stringBuilder.length() > prefix.length()) {\n                stringBuilder.setLength(stringBuilder.length() - delimiter.length());\n            }\n        }\n        stringBuilder.append(suffix);\n        return stringBuilder.toString();\n    }\n\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4;\n\nimport java.lang.reflect.Array;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.Dictionary;\nimport java.util.Enumeration;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Map;\n\nimport org.apache.commons.collections4.functors.EqualPredicate;\nimport org.apache.commons.collections4.iterators.ArrayIterator;\nimport org.apache.commons.collections4.iterators.ArrayListIterator;\nimport org.apache.commons.collections4.iterators.BoundedIterator;\nimport org.apache.commons.collections4.iterators.CollatingIterator;\nimport org.apache.commons.collections4.iterators.EmptyIterator;\nimport org.apache.commons.collections4.iterators.EmptyListIterator;\nimport org.apache.commons.collections4.iterators.EmptyMapIterator;\nimport org.apache.commons.collections4.iterators.EmptyOrderedIterator;\nimport org.apache.commons.collections4.iterators.EmptyOrderedMapIterator;\nimport org.apache.commons.collections4.iterators.EnumerationIterator;\nimport org.apache.commons.collections4.iterators.FilterIterator;\nimport org.apache.commons.collections4.iterators.FilterListIterator;\nimport org.apache.commons.collections4.iterators.IteratorChain;\nimport org.apache.commons.collections4.iterators.IteratorEnumeration;\nimport org.apache.commons.collections4.iterators.IteratorIterable;\nimport org.apache.commons.collections4.iterators.ListIteratorWrapper;\nimport org.apache.commons.collections4.iterators.LoopingIterator;\nimport org.apache.commons.collections4.iterators.LoopingListIterator;\nimport org.apache.commons.collections4.iterators.NodeListIterator;\nimport org.apache.commons.collections4.iterators.ObjectArrayIterator;\nimport org.apache.commons.collections4.iterators.ObjectArrayListIterator;\nimport org.apache.commons.collections4.iterators.ObjectGraphIterator;\nimport org.apache.commons.collections4.iterators.PeekingIterator;\nimport org.apache.commons.collections4.iterators.PushbackIterator;\nimport org.apache.commons.collections4.iterators.SingletonIterator;\nimport org.apache.commons.collections4.iterators.SingletonListIterator;\nimport org.apache.commons.collections4.iterators.SkippingIterator;\nimport org.apache.commons.collections4.iterators.TransformIterator;\nimport org.apache.commons.collections4.iterators.UnmodifiableIterator;\nimport org.apache.commons.collections4.iterators.UnmodifiableListIterator;\nimport org.apache.commons.collections4.iterators.UnmodifiableMapIterator;\nimport org.apache.commons.collections4.iterators.ZippingIterator;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\n/**\n * Provides static utility methods and decorators for {@link Iterator}\n * instances. The implementations are provided in the iterators subpackage.\n * <p>\n * WARNING: Due to human error certain binary incompatibilities were introduced\n * between Commons Collections 2.1 and 3.0. The class remained source and test\n * compatible, so if you can recompile all your classes and dependencies\n * everything is OK. Those methods which are binary incompatible are marked as\n * such, together with alternate solutions that are binary compatible\n * against versions 2.1.1 and 3.1.\n *\n * @since 2.1\n * @version $Id$\n */\npublic class IteratorUtils {\n    // validation is done in this class in certain cases because the\n    // public classes allow invalid states\n\n    /**\n     * An iterator over no elements.\n     * <p>\n     * WARNING: This constant is binary incompatible with Commons Collections 2.1 and 2.1.1.\n     * Use <code>EmptyIterator.INSTANCE</code> for compatibility with Commons Collections 2.1.1.\n     */\n    @SuppressWarnings(\"rawtypes\")\n    public static final ResettableIterator EMPTY_ITERATOR = EmptyIterator.RESETTABLE_INSTANCE;\n\n    /**\n     * A list iterator over no elements.\n     * <p>\n     * WARNING: This constant is binary incompatible with Commons Collections 2.1 and 2.1.1.\n     * Use <code>EmptyListIterator.INSTANCE</code> for compatibility with Commons Collections 2.1.1.\n     */\n    @SuppressWarnings(\"rawtypes\")\n    public static final ResettableListIterator EMPTY_LIST_ITERATOR = EmptyListIterator.RESETTABLE_INSTANCE;\n\n    /**\n     * An ordered iterator over no elements.\n     */\n    @SuppressWarnings(\"rawtypes\")\n    public static final OrderedIterator EMPTY_ORDERED_ITERATOR = EmptyOrderedIterator.INSTANCE;\n\n    /**\n     * A map iterator over no elements.\n     */\n    @SuppressWarnings(\"rawtypes\")\n    public static final MapIterator EMPTY_MAP_ITERATOR = EmptyMapIterator.INSTANCE;\n\n    /**\n     * An ordered map iterator over no elements.\n     */\n    @SuppressWarnings(\"rawtypes\")\n    public static final OrderedMapIterator EMPTY_ORDERED_MAP_ITERATOR = EmptyOrderedMapIterator.INSTANCE;\n\n    /**\n     * Default prefix used while converting an Iterator to its String representation.\n     */\n    private static final String DEFAULT_TOSTRING_PREFIX = \"[\";\n\n    /**\n     * Default suffix used while converting an Iterator to its String representation.\n     */\n    private static final String DEFAULT_TOSTRING_SUFFIX = \"]\";\n\n    /**\n     * Default delimiter used to delimit elements while converting an Iterator\n     * to its String representation.\n     */\n    private static final String DEFAULT_TOSTRING_DELIMITER = \", \";\n\n    /**\n     * IteratorUtils is not normally instantiated.\n     */\n    private IteratorUtils() {}\n\n    // Empty\n    //-----------------------------------------------------------------------\n    /**\n     * Gets an empty iterator.\n     * <p>\n     * This iterator is a valid iterator object that will iterate over\n     * nothing.\n     * <p>\n     * WARNING: This method is binary incompatible with Commons Collections 2.1 and 2.1.1.\n     * Use <code>EmptyIterator.INSTANCE</code> for compatibility with Commons Collections 2.1.1.\n     *\n     * @param <E>  the element type\n     * @return  an iterator over nothing\n     */\n    public static <E> ResettableIterator<E> emptyIterator() {\n        return EmptyIterator.<E>resettableEmptyIterator();\n    }\n\n    /**\n     * Gets an empty list iterator.\n     * <p>\n     * This iterator is a valid list iterator object that will iterate\n     * over nothing.\n     * <p>\n     * WARNING: This method is binary incompatible with Commons Collections 2.1 and 2.1.1.\n     * Use <code>EmptyListIterator.INSTANCE</code> for compatibility with Commons Collections 2.1.1.\n     *\n     * @param <E>  the element type\n     * @return  a list iterator over nothing\n     */\n    public static <E> ResettableListIterator<E> emptyListIterator() {\n        return EmptyListIterator.<E>resettableEmptyListIterator();\n    }\n\n    /**\n     * Gets an empty ordered iterator.\n     * <p>\n     * This iterator is a valid iterator object that will iterate\n     * over nothing.\n     *\n     * @param <E>  the element type\n     * @return  an ordered iterator over nothing\n     */\n    public static <E> OrderedIterator<E> emptyOrderedIterator() {\n        return EmptyOrderedIterator.<E>emptyOrderedIterator();\n    }\n\n    /**\n     * Gets an empty map iterator.\n     * <p>\n     * This iterator is a valid map iterator object that will iterate\n     * over nothing.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @return  a map iterator over nothing\n     */\n    public static <K, V> MapIterator<K, V> emptyMapIterator() {\n        return EmptyMapIterator.<K, V>emptyMapIterator();\n    }\n\n    /**\n     * Gets an empty ordered map iterator.\n     * <p>\n     * This iterator is a valid map iterator object that will iterate\n     * over nothing.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @return  a map iterator over nothing\n     */\n    public static <K, V> OrderedMapIterator<K, V> emptyOrderedMapIterator() {\n        return EmptyOrderedMapIterator.<K, V>emptyOrderedMapIterator();\n    }\n\n    // Singleton\n    //-----------------------------------------------------------------------\n    /**\n     * Gets a singleton iterator.\n     * <p>\n     * This iterator is a valid iterator object that will iterate over\n     * the specified object.\n     * <p>\n     * WARNING: This method is binary incompatible with Commons Collections 2.1 and 2.1.1.\n     * Use <code>new SingletonIterator(object)</code> for compatibility.\n     *\n     * @param <E>  the element type\n     * @param object  the single object over which to iterate\n     * @return  a singleton iterator over the object\n     */\n    public static <E> ResettableIterator<E> singletonIterator(final E object) {\n        return new SingletonIterator<E>(object);\n    }\n\n    /**\n     * Gets a singleton list iterator.\n     * <p>\n     * This iterator is a valid list iterator object that will iterate over\n     * the specified object.\n     *\n     * @param <E>  the element type\n     * @param object  the single object over which to iterate\n     * @return  a singleton list iterator over the object\n     */\n    public static <E> ListIterator<E> singletonListIterator(final E object) {\n        return new SingletonListIterator<E>(object);\n    }\n\n    // Arrays\n    //-----------------------------------------------------------------------\n    /**\n     * Gets an iterator over an object array.\n     * <p>\n     * WARNING: This method is binary incompatible with Commons Collections 2.1 and 2.1.1.\n     * Use <code>new ArrayIterator(array)</code> for compatibility.\n     *\n     * @param <E>  the element type\n     * @param array  the array over which to iterate\n     * @return  an iterator over the array\n     * @throws NullPointerException if array is null\n     */\n    public static <E> ResettableIterator<E> arrayIterator(final E... array) {\n        return new ObjectArrayIterator<E>(array);\n    }\n\n    /**\n     * Gets an iterator over an object or primitive array.\n     * <p>\n     * This method will handle primitive arrays as well as object arrays.\n     * The primitives will be wrapped in the appropriate wrapper class.\n     *\n     * @param <E>  the element type\n     * @param array  the array over which to iterate\n     * @return  an iterator over the array\n     * @throws IllegalArgumentException if the array is not an array\n     * @throws NullPointerException if array is null\n     */\n    public static <E> ResettableIterator<E> arrayIterator(final Object array) {\n        return new ArrayIterator<E>(array);\n    }\n\n    /**\n     * Gets an iterator over the end part of an object array.\n     * <p>\n     * WARNING: This method is binary incompatible with Commons Collections 2.1 and 2.1.1.\n     * Use <code>new ArrayIterator(array,start)</code> for compatibility.\n     *\n     * @param <E>  the element type\n     * @param array  the array over which to iterate\n     * @param start  the index to start iterating at\n     * @return an iterator over part of the array\n     * @throws IndexOutOfBoundsException if start is less than zero or greater\n     *   than the length of the array\n     * @throws NullPointerException if array is null\n     */\n    public static <E> ResettableIterator<E> arrayIterator(final E[] array, final int start) {\n        return new ObjectArrayIterator<E>(array, start);\n    }\n\n    /**\n     * Gets an iterator over the end part of an object or primitive array.\n     * <p>\n     * This method will handle primitive arrays as well as object arrays.\n     * The primitives will be wrapped in the appropriate wrapper class.\n     *\n     * @param <E>  the element type\n     * @param array  the array over which to iterate\n     * @param start  the index to start iterating at\n     * @return an iterator over part of the array\n     * @throws IllegalArgumentException if the array is not an array\n     * @throws IndexOutOfBoundsException if start is less than zero or greater\n     *   than the length of the array\n     * @throws NullPointerException if array is null\n     */\n    public static <E> ResettableIterator<E> arrayIterator(final Object array, final int start) {\n        return new ArrayIterator<E>(array, start);\n    }\n\n    /**\n     * Gets an iterator over part of an object array.\n     * <p>\n     * WARNING: This method is binary incompatible with Commons Collections 2.1 and 2.1.1.\n     * Use <code>new ArrayIterator(array,start,end)</code> for compatibility.\n     *\n     * @param <E>  the element type\n     * @param array  the array over which to iterate\n     * @param start  the index to start iterating at\n     * @param end  the index to finish iterating at\n     * @return an iterator over part of the array\n     * @throws IndexOutOfBoundsException if array bounds are invalid\n     * @throws IllegalArgumentException if end is before start\n     * @throws NullPointerException if array is null\n     */\n    public static <E> ResettableIterator<E> arrayIterator(final E[] array, final int start, final int end) {\n        return new ObjectArrayIterator<E>(array, start, end);\n    }\n\n    /**\n     * Gets an iterator over part of an object or primitive array.\n     * <p>\n     * This method will handle primitive arrays as well as object arrays.\n     * The primitives will be wrapped in the appropriate wrapper class.\n     *\n     * @param <E>  the element type\n     * @param array  the array over which to iterate\n     * @param start  the index to start iterating at\n     * @param end  the index to finish iterating at\n     * @return an iterator over part of the array\n     * @throws IllegalArgumentException if the array is not an array or end is before start\n     * @throws IndexOutOfBoundsException if array bounds are invalid\n     * @throws NullPointerException if array is null\n     */\n    public static <E> ResettableIterator<E> arrayIterator(final Object array, final int start, final int end) {\n        return new ArrayIterator<E>(array, start, end);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets a list iterator over an object array.\n     *\n     * @param <E>  the element type\n     * @param array  the array over which to iterate\n     * @return  a list iterator over the array\n     * @throws NullPointerException if array is null\n     */\n    public static <E> ResettableListIterator<E> arrayListIterator(final E... array) {\n        return new ObjectArrayListIterator<E>(array);\n    }\n\n    /**\n     * Gets a list iterator over an object or primitive array.\n     * <p>\n     * This method will handle primitive arrays as well as object arrays.\n     * The primitives will be wrapped in the appropriate wrapper class.\n     *\n     * @param <E>  the element type\n     * @param array  the array over which to iterate\n     * @return  a list iterator over the array\n     * @throws IllegalArgumentException if the array is not an array\n     * @throws NullPointerException if array is null\n     */\n    public static <E> ResettableListIterator<E> arrayListIterator(final Object array) {\n        return new ArrayListIterator<E>(array);\n    }\n\n    /**\n     * Gets a list iterator over the end part of an object array.\n     *\n     * @param <E>  the element type\n     * @param array  the array over which to iterate\n     * @param start  the index to start iterating at\n     * @return a list iterator over part of the array\n     * @throws IndexOutOfBoundsException if start is less than zero\n     * @throws NullPointerException if array is null\n     */\n    public static <E> ResettableListIterator<E> arrayListIterator(final E[] array, final int start) {\n        return new ObjectArrayListIterator<E>(array, start);\n    }\n\n    /**\n     * Gets a list iterator over the end part of an object or primitive array.\n     * <p>\n     * This method will handle primitive arrays as well as object arrays.\n     * The primitives will be wrapped in the appropriate wrapper class.\n     *\n     * @param <E>  the element type\n     * @param array  the array over which to iterate\n     * @param start  the index to start iterating at\n     * @return a list iterator over part of the array\n     * @throws IllegalArgumentException if the array is not an array\n     * @throws IndexOutOfBoundsException if start is less than zero\n     * @throws NullPointerException if array is null\n     */\n    public static <E> ResettableListIterator<E> arrayListIterator(final Object array, final int start) {\n        return new ArrayListIterator<E>(array, start);\n    }\n\n    /**\n     * Gets a list iterator over part of an object array.\n     *\n     * @param <E>  the element type\n     * @param array  the array over which to iterate\n     * @param start  the index to start iterating at\n     * @param end  the index to finish iterating at\n     * @return a list iterator over part of the array\n     * @throws IndexOutOfBoundsException if array bounds are invalid\n     * @throws IllegalArgumentException if end is before start\n     * @throws NullPointerException if array is null\n     */\n    public static <E> ResettableListIterator<E> arrayListIterator(final E[] array, final int start, final int end) {\n        return new ObjectArrayListIterator<E>(array, start, end);\n    }\n\n    /**\n     * Gets a list iterator over part of an object or primitive array.\n     * <p>\n     * This method will handle primitive arrays as well as object arrays.\n     * The primitives will be wrapped in the appropriate wrapper class.\n     *\n     * @param <E>  the element type\n     * @param array  the array over which to iterate\n     * @param start  the index to start iterating at\n     * @param end  the index to finish iterating at\n     * @return a list iterator over part of the array\n     * @throws IllegalArgumentException if the array is not an array or end is before start\n     * @throws IndexOutOfBoundsException if array bounds are invalid\n     * @throws NullPointerException if array is null\n     */\n    public static <E> ResettableListIterator<E> arrayListIterator(final Object array, final int start, final int end) {\n        return new ArrayListIterator<E>(array, start, end);\n    }\n\n    // Bounded\n    //-----------------------------------------------------------------------\n    /**\n     * Decorates the specified iterator to return at most the given number\n     * of elements.\n     *\n     * @param <E>  the element type\n     * @param iterator  the iterator to decorate\n     * @param max  the maximum number of elements returned by this iterator\n     * @return a new bounded iterator\n     * @throws IllegalArgumentException if the iterator is null or max is negative\n     * @since 4.1\n     */\n    public static <E> BoundedIterator<E> boundedIterator(final Iterator<? extends E> iterator, long max) {\n        return boundedIterator(iterator, 0, max);\n    }\n\n    /**\n     * Decorates the specified iterator to return at most the given number\n     * of elements, skipping all elements until the iterator reaches the\n     * position at {@code offset}.\n     * <p>\n     * The iterator is immediately advanced until it reaches the position at\n     * {@code offset}, incurring O(n) time.\n     *\n     * @param <E>  the element type\n     * @param iterator  the iterator to decorate\n     * @param offset  the index of the first element of the decorated iterator to return\n     * @param max  the maximum number of elements returned by this iterator\n     * @return a new bounded iterator\n     * @throws IllegalArgumentException if the iterator is null or either offset or max is negative\n     * @since 4.1\n     */\n    public static <E> BoundedIterator<E> boundedIterator(final Iterator<? extends E> iterator,\n                                                         long offset, long max) {\n        return new BoundedIterator<E>(iterator, offset, max);\n    }\n\n    // Unmodifiable\n    //-----------------------------------------------------------------------\n    /**\n     * Gets an immutable version of an {@link Iterator}. The returned object\n     * will always throw an {@link UnsupportedOperationException} for\n     * the {@link Iterator#remove} method.\n     *\n     * @param <E>  the element type\n     * @param iterator  the iterator to make immutable\n     * @return an immutable version of the iterator\n     */\n    public static <E> Iterator<E> unmodifiableIterator(final Iterator<E> iterator) {\n        return UnmodifiableIterator.unmodifiableIterator(iterator);\n    }\n\n    /**\n     * Gets an immutable version of a {@link ListIterator}. The returned object\n     * will always throw an {@link UnsupportedOperationException} for\n     * the {@link Iterator#remove}, {@link ListIterator#add} and\n     * {@link ListIterator#set} methods.\n     *\n     * @param <E>  the element type\n     * @param listIterator  the iterator to make immutable\n     * @return an immutable version of the iterator\n     */\n    public static <E> ListIterator<E> unmodifiableListIterator(final ListIterator<E> listIterator) {\n        return UnmodifiableListIterator.umodifiableListIterator(listIterator);\n    }\n\n    /**\n     * Gets an immutable version of a {@link MapIterator}. The returned object\n     * will always throw an {@link UnsupportedOperationException} for\n     * the {@link Iterator#remove}, {@link MapIterator#setValue(Object)} methods.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param mapIterator  the iterator to make immutable\n     * @return an immutable version of the iterator\n     */\n    public static <K, V> MapIterator<K, V> unmodifiableMapIterator(final MapIterator<K, V> mapIterator) {\n        return UnmodifiableMapIterator.unmodifiableMapIterator(mapIterator);\n    }\n\n    // Chained\n    //-----------------------------------------------------------------------\n\n    /**\n     * Gets an iterator that iterates through two {@link Iterator}s\n     * one after another.\n     *\n     * @param <E>  the element type\n     * @param iterator1  the first iterator to use, not null\n     * @param iterator2  the second iterator to use, not null\n     * @return a combination iterator over the iterators\n     * @throws NullPointerException if either iterator is null\n     */\n    public static <E> Iterator<E> chainedIterator(final Iterator<? extends E> iterator1,\n                                                  final Iterator<? extends E> iterator2) {\n        // keep a version with two iterators to avoid the following warning in client code (Java 5 & 6)\n        // \"A generic array of E is created for a varargs parameter\"\n        return new IteratorChain<E>(iterator1, iterator2);\n    }\n\n    /**\n     * Gets an iterator that iterates through an array of {@link Iterator}s\n     * one after another.\n     *\n     * @param <E>  the element type\n     * @param iterators  the iterators to use, not null or empty or contain nulls\n     * @return a combination iterator over the iterators\n     * @throws NullPointerException if iterators array is null or contains a null\n     */\n    public static <E> Iterator<E> chainedIterator(final Iterator<? extends E>... iterators) {\n        return new IteratorChain<E>(iterators);\n    }\n\n    /**\n     * Gets an iterator that iterates through a collections of {@link Iterator}s\n     * one after another.\n     *\n     * @param <E>  the element type\n     * @param iterators  the iterators to use, not null or empty or contain nulls\n     * @return a combination iterator over the iterators\n     * @throws NullPointerException if iterators collection is null or contains a null\n     * @throws ClassCastException if the iterators collection contains the wrong object type\n     */\n    public static <E> Iterator<E> chainedIterator(final Collection<Iterator<? extends E>> iterators) {\n        return new IteratorChain<E>(iterators);\n    }\n\n    // Collated\n    //-----------------------------------------------------------------------\n    /**\n     * Gets an iterator that provides an ordered iteration over the elements\n     * contained in a collection of ordered {@link Iterator}s.\n     * <p>\n     * Given two ordered {@link Iterator}s <code>A</code> and <code>B</code>,\n     * the {@link Iterator#next()} method will return the lesser of\n     * <code>A.next()</code> and <code>B.next()</code>.\n     * <p>\n     * The comparator is optional. If null is specified then natural order is used.\n     *\n     * @param <E>  the element type\n     * @param comparator  the comparator to use, may be null for natural order\n     * @param iterator1  the first iterators to use, not null\n     * @param iterator2  the first iterators to use, not null\n     * @return a combination iterator over the iterators\n     * @throws NullPointerException if either iterator is null\n     */\n    public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator,\n                                                   final Iterator<? extends E> iterator1,\n                                                   final Iterator<? extends E> iterator2) {\n        @SuppressWarnings(\"unchecked\")\n        final Comparator<E> comp = comparator == null ? ComparatorUtils.NATURAL_COMPARATOR : comparator;\n        return new CollatingIterator<E>(comp, iterator1, iterator2);\n    }\n\n    /**\n     * Gets an iterator that provides an ordered iteration over the elements\n     * contained in an array of {@link Iterator}s.\n     * <p>\n     * Given two ordered {@link Iterator}s <code>A</code> and <code>B</code>,\n     * the {@link Iterator#next()} method will return the lesser of\n     * <code>A.next()</code> and <code>B.next()</code> and so on.\n     * <p>\n     * The comparator is optional. If null is specified then natural order is used.\n     *\n     * @param <E>  the element type\n     * @param comparator  the comparator to use, may be null for natural order\n     * @param iterators  the iterators to use, not null or empty or contain nulls\n     * @return a combination iterator over the iterators\n     * @throws NullPointerException if iterators array is null or contains a null value\n     */\n    public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator,\n                                                   final Iterator<? extends E>... iterators) {\n        @SuppressWarnings(\"unchecked\")\n        final Comparator<E> comp = comparator == null ? ComparatorUtils.NATURAL_COMPARATOR : comparator;\n        return new CollatingIterator<E>(comp, iterators);\n    }\n\n    /**\n     * Gets an iterator that provides an ordered iteration over the elements\n     * contained in a collection of {@link Iterator}s.\n     * <p>\n     * Given two ordered {@link Iterator}s <code>A</code> and <code>B</code>,\n     * the {@link Iterator#next()} method will return the lesser of\n     * <code>A.next()</code> and <code>B.next()</code> and so on.\n     * <p>\n     * The comparator is optional. If null is specified then natural order is used.\n     *\n     * @param <E>  the element type\n     * @param comparator  the comparator to use, may be null for natural order\n     * @param iterators  the iterators to use, not null or empty or contain nulls\n     * @return a combination iterator over the iterators\n     * @throws NullPointerException if iterators collection is null or contains a null\n     * @throws ClassCastException if the iterators collection contains the wrong object type\n     */\n    public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator,\n                                                   final Collection<Iterator<? extends E>> iterators) {\n        @SuppressWarnings(\"unchecked\")\n        final Comparator<E> comp = comparator == null ? ComparatorUtils.NATURAL_COMPARATOR : comparator;\n        return new CollatingIterator<E>(comp, iterators);\n    }\n\n    // Object Graph\n    //-----------------------------------------------------------------------\n    /**\n     * Gets an iterator that operates over an object graph.\n     * <p>\n     * This iterator can extract multiple objects from a complex tree-like object graph.\n     * The iteration starts from a single root object.\n     * It uses a <code>Transformer</code> to extract the iterators and elements.\n     * Its main benefit is that no intermediate <code>List</code> is created.\n     * <p>\n     * For example, consider an object graph:\n     * <pre>\n     *                 |- Branch -- Leaf\n     *                 |         \\- Leaf\n     *         |- Tree |         /- Leaf\n     *         |       |- Branch -- Leaf\n     *  Forest |                 \\- Leaf\n     *         |       |- Branch -- Leaf\n     *         |       |         \\- Leaf\n     *         |- Tree |         /- Leaf\n     *                 |- Branch -- Leaf\n     *                 |- Branch -- Leaf</pre>\n     * The following <code>Transformer</code>, used in this class, will extract all\n     * the Leaf objects without creating a combined intermediate list:\n     * <pre>\n     * public Object transform(Object input) {\n     *   if (input instanceof Forest) {\n     *     return ((Forest) input).treeIterator();\n     *   }\n     *   if (input instanceof Tree) {\n     *     return ((Tree) input).branchIterator();\n     *   }\n     *   if (input instanceof Branch) {\n     *     return ((Branch) input).leafIterator();\n     *   }\n     *   if (input instanceof Leaf) {\n     *     return input;\n     *   }\n     *   throw new ClassCastException();\n     * }</pre>\n     * <p>\n     * Internally, iteration starts from the root object. When next is called,\n     * the transformer is called to examine the object. The transformer will return\n     * either an iterator or an object. If the object is an Iterator, the next element\n     * from that iterator is obtained and the process repeats. If the element is an object\n     * it is returned.\n     * <p>\n     * Under many circumstances, linking Iterators together in this manner is\n     * more efficient (and convenient) than using nested for loops to extract a list.\n     *\n     * @param <E>  the element type\n     * @param root  the root object to start iterating from, null results in an empty iterator\n     * @param transformer  the transformer to use, see above, null uses no effect transformer\n     * @return a new object graph iterator\n     * @since 3.1\n     */\n    public static <E> Iterator<E> objectGraphIterator(final E root,\n            final Transformer<? super E, ? extends E> transformer) {\n        return new ObjectGraphIterator<E>(root, transformer);\n    }\n\n    // Transformed\n    //-----------------------------------------------------------------------\n    /**\n     * Gets an iterator that transforms the elements of another iterator.\n     * <p>\n     * The transformation occurs during the next() method and the underlying\n     * iterator is unaffected by the transformation.\n     *\n     * @param <I>  the input type\n     * @param <O>  the output type\n     * @param iterator  the iterator to use, not null\n     * @param transform  the transform to use, not null\n     * @return a new transforming iterator\n     * @throws NullPointerException if either parameter is null\n     */\n    public static <I, O> Iterator<O> transformedIterator(final Iterator<? extends I> iterator,\n            final Transformer<? super I, ? extends O> transform) {\n\n        if (iterator == null) {\n            throw new NullPointerException(\"Iterator must not be null\");\n        }\n        if (transform == null) {\n            throw new NullPointerException(\"Transformer must not be null\");\n        }\n        return new TransformIterator<I, O>(iterator, transform);\n    }\n\n    // Filtered\n    //-----------------------------------------------------------------------\n    /**\n     * Gets an iterator that filters another iterator.\n     * <p>\n     * The returned iterator will only return objects that match the specified\n     * filtering predicate.\n     *\n     * @param <E>  the element type\n     * @param iterator  the iterator to use, not null\n     * @param predicate  the predicate to use as a filter, not null\n     * @return a new filtered iterator\n     * @throws NullPointerException if either parameter is null\n     */\n    public static <E> Iterator<E> filteredIterator(final Iterator<? extends E> iterator,\n                                                   final Predicate<? super E> predicate) {\n        if (iterator == null) {\n            throw new NullPointerException(\"Iterator must not be null\");\n        }\n        if (predicate == null) {\n            throw new NullPointerException(\"Predicate must not be null\");\n        }\n        return new FilterIterator<E>(iterator, predicate);\n    }\n\n    /**\n     * Gets a list iterator that filters another list iterator.\n     * <p>\n     * The returned iterator will only return objects that match the specified\n     * filtering predicate.\n     *\n     * @param <E>  the element type\n     * @param listIterator  the list iterator to use, not null\n     * @param predicate  the predicate to use as a filter, not null\n     * @return a new filtered iterator\n     * @throws NullPointerException if either parameter is null\n     */\n    public static <E> ListIterator<E> filteredListIterator(final ListIterator<? extends E> listIterator,\n            final Predicate<? super E> predicate) {\n\n        if (listIterator == null) {\n            throw new NullPointerException(\"ListIterator must not be null\");\n        }\n        if (predicate == null) {\n            throw new NullPointerException(\"Predicate must not be null\");\n        }\n        return new FilterListIterator<E>(listIterator, predicate);\n    }\n\n    // Looping\n    //-----------------------------------------------------------------------\n    /**\n     * Gets an iterator that loops continuously over the supplied collection.\n     * <p>\n     * The iterator will only stop looping if the remove method is called\n     * enough times to empty the collection, or if the collection is empty\n     * to start with.\n     *\n     * @param <E>  the element type\n     * @param coll  the collection to iterate over, not null\n     * @return a new looping iterator\n     * @throws NullPointerException if the collection is null\n     */\n    public static <E> ResettableIterator<E> loopingIterator(final Collection<? extends E> coll) {\n        if (coll == null) {\n            throw new NullPointerException(\"Collection must not be null\");\n        }\n        return new LoopingIterator<E>(coll);\n    }\n\n    /**\n     * Gets an iterator that loops continuously over the supplied list.\n     * <p>\n     * The iterator will only stop looping if the remove method is called\n     * enough times to empty the list, or if the list is empty to start with.\n     *\n     * @param <E>  the element type\n     * @param list  the list to iterate over, not null\n     * @return a new looping iterator\n     * @throws NullPointerException if the list is null\n     * @since 3.2\n     */\n    public static <E> ResettableListIterator<E> loopingListIterator(final List<E> list) {\n        if (list == null) {\n            throw new NullPointerException(\"List must not be null\");\n        }\n        return new LoopingListIterator<E>(list);\n    }\n\n    // org.w3c.dom.NodeList iterators\n    //-----------------------------------------------------------------------\n    /**\n     * Gets an {@link Iterator} that wraps the specified {@link NodeList}.\n     * The returned {@link Iterator} can be used for a single iteration.\n     *\n     * @param nodeList the node list to use, not null\n     * @return a new, single use {@link Iterator}\n     * @throws NullPointerException if nodeList is null\n     * @since 4.0\n     */\n    public static NodeListIterator nodeListIterator(final NodeList nodeList) {\n        if (nodeList == null) {\n            throw new NullPointerException(\"NodeList must not be null\");\n        }\n        return new NodeListIterator(nodeList);\n    }\n\n    /**\n     * Gets an {@link Iterator} that wraps the specified node's childNodes.\n     * The returned {@link Iterator} can be used for a single iteration.\n     * <p>\n     * Convenience method, allows easy iteration over NodeLists:\n     * <pre>\n     *   Iterator&lt;Node&gt; iterator = IteratorUtils.nodeListIterator(node);\n     *   for(Node childNode : IteratorUtils.asIterable(iterator)) {\n     *     ...\n     *   }\n     * </pre>\n     *\n     * @param node the node to use, not null\n     * @return a new, single use {@link Iterator}\n     * @throws NullPointerException if node is null\n     * @since 4.0\n     */\n    public static NodeListIterator nodeListIterator(final Node node) {\n        if (node == null) {\n            throw new NullPointerException(\"Node must not be null\");\n        }\n        return new NodeListIterator(node);\n    }\n\n    // Peeking\n    //-----------------------------------------------------------------------\n\n    /**\n     * Gets an iterator that supports one-element lookahead.\n     *\n     * @param <E>  the element type\n     * @param iterator  the iterator to decorate, not null\n     * @return a peeking iterator\n     * @throws NullPointerException if the iterator is null\n     * @since 4.0\n     */\n    public static <E> Iterator<E> peekingIterator(final Iterator<? extends E> iterator) {\n        return PeekingIterator.peekingIterator(iterator);\n    }\n\n    // Pushback\n    //-----------------------------------------------------------------------\n\n    /**\n     * Gets an iterator that supports pushback of elements.\n     *\n     * @param <E>  the element type\n     * @param iterator  the iterator to decorate, not null\n     * @return a pushback iterator\n     * @throws NullPointerException if the iterator is null\n     * @since 4.0\n     */\n    public static <E> Iterator<E> pushbackIterator(final Iterator<? extends E> iterator) {\n        return PushbackIterator.pushbackIterator(iterator);\n    }\n\n    // Skipping\n    //-----------------------------------------------------------------------\n    /**\n     * Decorates the specified iterator to skip the first N elements.\n     *\n     * @param <E>  the element type\n     * @param iterator  the iterator to decorate\n     * @param offset  the first number of elements to skip\n     * @return a new skipping iterator\n     * @throws IllegalArgumentException if the iterator is null or offset is negative\n     * @since 4.1\n     */\n    public static <E> SkippingIterator<E> skippingIterator(final Iterator<E> iterator, long offset) {\n        return new SkippingIterator<E>(iterator, offset);\n    }\n\n    // Zipping\n    //-----------------------------------------------------------------------\n    /**\n     * Returns an iterator that interleaves elements from the decorated iterators.\n     *\n     * @param <E>  the element type\n     * @param a  the first iterator to interleave\n     * @param b  the second iterator to interleave\n     * @return an iterator, interleaving the decorated iterators\n     * @throws IllegalArgumentException if any iterator is null\n     * @since 4.1\n     */\n    public static <E> ZippingIterator<E> zippingIterator(final Iterator<? extends E> a,\n                                                         final Iterator<? extends E> b) {\n        return new ZippingIterator<E>(a, b);\n    }\n\n    /**\n     * Returns an iterator that interleaves elements from the decorated iterators.\n     *\n     * @param <E>  the element type\n     * @param a  the first iterator to interleave\n     * @param b  the second iterator to interleave\n     * @param c  the third iterator to interleave\n     * @return an iterator, interleaving the decorated iterators\n     * @throws IllegalArgumentException if any iterator is null\n     * @since 4.1\n     */\n    public static <E> ZippingIterator<E> zippingIterator(final Iterator<? extends E> a,\n                                                         final Iterator<? extends E> b,\n                                                         final Iterator<? extends E> c) {\n        return new ZippingIterator<E>(a, b, c);\n    }\n\n    /**\n     * Returns an iterator that interleaves elements from the decorated iterators.\n     *\n     * @param <E>  the element type\n     * @param iterators  the array of iterators to interleave\n     * @return an iterator, interleaving the decorated iterators\n     * @throws IllegalArgumentException if any iterator is null\n     * @since 4.1\n     */\n    public static <E> ZippingIterator<E> zippingIterator(final Iterator<? extends E>... iterators) {\n        return new ZippingIterator<E>(iterators);\n    }\n\n    // Views\n    //-----------------------------------------------------------------------\n    /**\n     * Gets an iterator that provides an iterator view of the given enumeration.\n     *\n     * @param <E>  the element type\n     * @param enumeration  the enumeration to use\n     * @return a new iterator\n     */\n    public static <E> Iterator<E> asIterator(final Enumeration<? extends E> enumeration) {\n        if (enumeration == null) {\n            throw new NullPointerException(\"Enumeration must not be null\");\n        }\n        return new EnumerationIterator<E>(enumeration);\n    }\n\n    /**\n     * Gets an iterator that provides an iterator view of the given enumeration\n     * that will remove elements from the specified collection.\n     *\n     * @param <E>  the element type\n     * @param enumeration  the enumeration to use\n     * @param removeCollection  the collection to remove elements from\n     * @return a new iterator\n     */\n    public static <E> Iterator<E> asIterator(final Enumeration<? extends E> enumeration,\n                                             final Collection<? super E> removeCollection) {\n        if (enumeration == null) {\n            throw new NullPointerException(\"Enumeration must not be null\");\n        }\n        if (removeCollection == null) {\n            throw new NullPointerException(\"Collection must not be null\");\n        }\n        return new EnumerationIterator<E>(enumeration, removeCollection);\n    }\n\n    /**\n     * Gets an enumeration that wraps an iterator.\n     *\n     * @param <E>  the element type\n     * @param iterator  the iterator to use, not null\n     * @return a new enumeration\n     * @throws NullPointerException if iterator is null\n     */\n    public static <E> Enumeration<E> asEnumeration(final Iterator<? extends E> iterator) {\n        if (iterator == null) {\n            throw new NullPointerException(\"Iterator must not be null\");\n        }\n        return new IteratorEnumeration<E>(iterator);\n    }\n\n    /**\n     * Gets an {@link Iterable} that wraps an iterator.  The returned {@link Iterable} can be\n     * used for a single iteration.\n     *\n     * @param <E>  the element type\n     * @param iterator  the iterator to use, not null\n     * @return a new, single use {@link Iterable}\n     * @throws NullPointerException if iterator is null\n     */\n    public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator) {\n        if (iterator == null) {\n            throw new NullPointerException(\"Iterator must not be null\");\n        }\n        return new IteratorIterable<E>(iterator, false);\n    }\n\n    /**\n     * Gets an iterable that wraps an iterator.  The returned iterable can be\n     * used for multiple iterations.\n     *\n     * @param <E>  the element type\n     * @param iterator  the iterator to use, not null\n     * @return a new, multiple use iterable\n     * @throws NullPointerException if iterator is null\n     */\n    public static <E> Iterable<E> asMultipleUseIterable(final Iterator<? extends E> iterator) {\n        if (iterator == null) {\n            throw new NullPointerException(\"Iterator must not be null\");\n        }\n        return new IteratorIterable<E>(iterator, true);\n    }\n\n    /**\n     * Gets a list iterator based on a simple iterator.\n     * <p>\n     * As the wrapped Iterator is traversed, a LinkedList of its values is\n     * cached, permitting all required operations of ListIterator.\n     *\n     * @param <E>  the element type\n     * @param iterator  the iterator to use, not null\n     * @return a new iterator\n     * @throws NullPointerException if iterator parameter is null\n     */\n    public static <E> ListIterator<E> toListIterator(final Iterator<? extends E> iterator) {\n        if (iterator == null) {\n            throw new NullPointerException(\"Iterator must not be null\");\n        }\n        return new ListIteratorWrapper<E>(iterator);\n    }\n\n    /**\n     * Gets an array based on an iterator.\n     * <p>\n     * As the wrapped Iterator is traversed, an ArrayList of its values is\n     * created. At the end, this is converted to an array.\n     *\n     * @param iterator  the iterator to use, not null\n     * @return an array of the iterator contents\n     * @throws NullPointerException if iterator parameter is null\n     */\n    public static Object[] toArray(final Iterator<?> iterator) {\n        if (iterator == null) {\n            throw new NullPointerException(\"Iterator must not be null\");\n        }\n        final List<?> list = toList(iterator, 100);\n        return list.toArray();\n    }\n\n    /**\n     * Gets an array based on an iterator.\n     * <p>\n     * As the wrapped Iterator is traversed, an ArrayList of its values is\n     * created. At the end, this is converted to an array.\n     *\n     * @param <E>  the element type\n     * @param iterator  the iterator to use, not null\n     * @param arrayClass  the class of array to create\n     * @return an array of the iterator contents\n     * @throws NullPointerException if iterator parameter or arrayClass is null\n     * @throws ClassCastException if the arrayClass is invalid\n     */\n    public static <E> E[] toArray(final Iterator<? extends E> iterator, final Class<E> arrayClass) {\n        if (iterator == null) {\n            throw new NullPointerException(\"Iterator must not be null\");\n        }\n        if (arrayClass == null) {\n            throw new NullPointerException(\"Array class must not be null\");\n        }\n        final List<E> list = toList(iterator, 100);\n        @SuppressWarnings(\"unchecked\") // as per Javadoc, will throw CCE if class is wrong\n        final E[] array = (E[]) Array.newInstance(arrayClass, list.size());\n        return list.toArray(array);\n    }\n\n    /**\n     * Gets a list based on an iterator.\n     * <p>\n     * As the wrapped Iterator is traversed, an ArrayList of its values is\n     * created. At the end, the list is returned.\n     *\n     * @param <E>  the element type\n     * @param iterator  the iterator to use, not null\n     * @return a list of the iterator contents\n     * @throws NullPointerException if iterator parameter is null\n     */\n    public static <E> List<E> toList(final Iterator<? extends E> iterator) {\n        return toList(iterator, 10);\n    }\n\n    /**\n     * Gets a list based on an iterator.\n     * <p>\n     * As the wrapped Iterator is traversed, an ArrayList of its values is\n     * created. At the end, the list is returned.\n     *\n     * @param <E>  the element type\n     * @param iterator  the iterator to use, not null\n     * @param estimatedSize  the initial size of the ArrayList\n     * @return a list of the iterator contents\n     * @throws NullPointerException if iterator parameter is null\n     * @throws IllegalArgumentException if the size is less than 1\n     */\n    public static <E> List<E> toList(final Iterator<? extends E> iterator, final int estimatedSize) {\n        if (iterator == null) {\n            throw new NullPointerException(\"Iterator must not be null\");\n        }\n        if (estimatedSize < 1) {\n            throw new IllegalArgumentException(\"Estimated size must be greater than 0\");\n        }\n        final List<E> list = new ArrayList<E>(estimatedSize);\n        while (iterator.hasNext()) {\n            list.add(iterator.next());\n        }\n        return list;\n    }\n\n    /**\n     * Gets a suitable Iterator for the given object.\n     * <p>\n     * This method can handle objects as follows\n     * <ul>\n     * <li>null - empty iterator\n     * <li>Iterator - returned directly\n     * <li>Enumeration - wrapped\n     * <li>Collection - iterator from collection returned\n     * <li>Map - values iterator returned\n     * <li>Dictionary - values (elements) enumeration returned as iterator\n     * <li>array - iterator over array returned\n     * <li>object with iterator() public method accessed by reflection\n     * <li>object - singleton iterator\n     * <li>NodeList - iterator over the list\n     * <li>Node - iterator over the child nodes\n     * </ul>\n     *\n     * @param obj  the object to convert to an iterator\n     * @return a suitable iterator, never null\n     */\n    public static Iterator<?> getIterator(final Object obj) {\n        if (obj == null) {\n            return emptyIterator();\n        }\n        if (obj instanceof Iterator) {\n            return (Iterator<?>) obj;\n        }\n        if (obj instanceof Iterable) {\n            return ((Iterable<?>) obj).iterator();\n        }\n        if (obj instanceof Object[]) {\n            return new ObjectArrayIterator<Object>((Object[]) obj);\n        }\n        if (obj instanceof Enumeration) {\n            return new EnumerationIterator<Object>((Enumeration<?>) obj);\n        }\n        if (obj instanceof Map) {\n            return ((Map<?, ?>) obj).values().iterator();\n        }\n        if (obj instanceof NodeList) {\n            return new NodeListIterator((NodeList) obj);\n        }\n        if (obj instanceof Node) {\n            return new NodeListIterator((Node) obj);\n        }\n        if (obj instanceof Dictionary) {\n            return new EnumerationIterator<Object>(((Dictionary<?, ?>) obj).elements());\n        } else if (obj.getClass().isArray()) {\n            return new ArrayIterator<Object>(obj);\n        }\n        try {\n            final Method method = obj.getClass().getMethod(\"iterator\", (Class[]) null);\n            if (Iterator.class.isAssignableFrom(method.getReturnType())) {\n                final Iterator<?> it = (Iterator<?>) method.invoke(obj, (Object[]) null);\n                if (it != null) {\n                    return it;\n                }\n            }\n        } catch (final RuntimeException e) { // NOPMD\n            // ignore\n        } catch (final NoSuchMethodException e) { // NOPMD\n            // ignore\n        } catch (final IllegalAccessException e) { // NOPMD\n            // ignore\n        } catch (final InvocationTargetException e) { // NOPMD\n            // ignore\n        }\n        return singletonIterator(obj);\n    }\n\n    // Utility methods\n    //-----------------------------------------------------------------------\n\n    /**\n     * Applies the closure to each element of the provided iterator.\n     *\n     * @param <E>  the element type\n     * @param iterator  the iterator to use, may be null\n     * @param closure  the closure to apply to each element, may not be null\n     * @throws NullPointerException if closure is null\n     * @since 4.1\n     */\n    public static <E> void apply(final Iterator<E> iterator, final Closure<? super E> closure) {\n        if (closure == null) {\n            throw new NullPointerException(\"Closure must not be null\");\n        }\n\n        if (iterator != null) {\n            while (iterator.hasNext()) {\n                final E element = iterator.next();\n                closure.execute(element);\n            }\n        }\n    }\n\n    /**\n     * Finds the first element in the given iterator which matches the given predicate.\n     * <p>\n     * A <code>null</code> or empty iterator returns null.\n     *\n     * @param <E>  the element type\n     * @param iterator  the iterator to search, may be null\n     * @param predicate  the predicate to use, may not be null\n     * @return the first element of the iterator which matches the predicate or null if none could be found\n     * @throws NullPointerException if predicate is null\n     * @since 4.1\n     */\n    public static <E> E find(final Iterator<E> iterator, final Predicate<? super E> predicate) {\n        if (predicate == null) {\n            throw new NullPointerException(\"Predicate must not be null\");\n        }\n\n        if (iterator != null) {\n            while (iterator.hasNext()) {\n                final E element = iterator.next();\n                if (predicate.evaluate(element)) {\n                    return element;\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Answers true if a predicate is true for any element of the iterator.\n     * <p>\n     * A <code>null</code> or empty iterator returns false.\n     *\n     * @param <E>  the type of object the {@link Iterator} contains\n     * @param iterator  the {@link Iterator} to use, may be null\n     * @param predicate  the predicate to use, may not be null\n     * @return true if any element of the collection matches the predicate, false otherwise\n     * @throws NullPointerException if predicate is null\n     * @since 4.1\n     */\n    public static <E> boolean matchesAny(final Iterator<E> iterator, final Predicate<? super E> predicate) {\n        if (predicate == null) {\n            throw new NullPointerException(\"Predicate must not be null\");\n        }\n\n        if (iterator != null) {\n            while (iterator.hasNext()) {\n                final E element = iterator.next();\n                if (predicate.evaluate(element)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Answers true if a predicate is true for every element of an iterator.\n     * <p>\n     * A <code>null</code> or empty iterator returns true.\n     *\n     * @param <E>  the type of object the {@link Iterator} contains\n     * @param iterator  the {@link Iterator} to use, may be null\n     * @param predicate  the predicate to use, may not be null\n     * @return true if every element of the collection matches the predicate or if the\n     *   collection is empty, false otherwise\n     * @throws NullPointerException if predicate is null\n     * @since 4.1\n     */\n    public static <E> boolean matchesAll(final Iterator<E> iterator, final Predicate<? super E> predicate) {\n        if (predicate == null) {\n            throw new NullPointerException(\"Predicate must not be null\");\n        }\n\n        if (iterator != null) {\n            while (iterator.hasNext()) {\n                final E element = iterator.next();\n                if (!predicate.evaluate(element)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Checks if the given iterator is empty.\n     * <p>\n     * A <code>null</code> or empty iterator returns true.\n     *\n     * @param iterator  the {@link Iterator} to use, may be null\n     * @return true if the iterator is exhausted or null, false otherwise\n     * @since 4.1\n     */\n    public static boolean isEmpty(final Iterator<?> iterator) {\n        return iterator == null || !iterator.hasNext();\n    }\n\n    /**\n     * Checks if the object is contained in the given iterator.\n     * <p>\n     * A <code>null</code> or empty iterator returns false.\n     *\n     * @param <E>  the type of object the {@link Iterator} contains\n     * @param iterator  the iterator to check, may be null\n     * @param object  the object to check\n     * @return true if the object is contained in the iterator, false otherwise\n     * @since 4.1\n     */\n    public static <E> boolean contains(final Iterator<E> iterator, final Object object) {\n        return matchesAny(iterator, EqualPredicate.equalPredicate(object));\n    }\n\n    /**\n     * Returns the <code>index</code>-th value in {@link Iterator}, throwing\n     * <code>IndexOutOfBoundsException</code> if there is no such element.\n     * <p>\n     * The Iterator is advanced to <code>index</code> (or to the end, if\n     * <code>index</code> exceeds the number of entries) as a side effect of this method.\n     *\n     * @param <E>  the type of object in the {@link Iterator}\n     * @param iterator  the iterator to get a value from\n     * @param index  the index to get\n     * @return the object at the specified index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     * @throws IllegalArgumentException if the object type is invalid\n     * @since 4.1\n     */\n    public static <E> E get(final Iterator<E> iterator, final int index) {\n        int i = index;\n        CollectionUtils.checkIndexBounds(i);\n        while (iterator.hasNext()) {\n            i--;\n            if (i == -1) {\n                return iterator.next();\n            }\n            iterator.next();\n        }\n        throw new IndexOutOfBoundsException(\"Entry does not exist: \" + i);\n    }\n\n    /**\n     * Returns the number of elements contained in the given iterator.\n     * <p>\n     * A <code>null</code> or empty iterator returns {@code 0}.\n     *\n     * @param iterator  the iterator to check, may be null\n     * @return the number of elements contained in the iterator\n     * @since 4.1\n     */\n    public static int size(final Iterator<?> iterator) {\n        int size = 0;\n        if (iterator != null) {\n            while (iterator.hasNext()) {\n                iterator.next();\n                size++;\n            }\n        }\n        return size;\n    }\n\n    /**\n     * Returns a string representation of the elements of the specified iterator.\n     * <p>\n     * The string representation consists of a list of the iterator's elements,\n     * enclosed in square brackets ({@code \"[]\"}). Adjacent elements are separated\n     * by the characters {@code \", \"} (a comma followed by a space). Elements are\n     * converted to strings as by {@code String.valueOf(Object)}.\n     *\n     * @param <E>  the element type\n     * @param iterator  the iterator to convert to a string\n     * @return a string representation of {@code iterator}\n     * @since 4.1\n     */\n    public static <E> String toString(final Iterator<E> iterator) {\n        return toString(iterator, TransformerUtils.stringValueTransformer(),\n                        DEFAULT_TOSTRING_DELIMITER, DEFAULT_TOSTRING_PREFIX,\n                        DEFAULT_TOSTRING_SUFFIX);\n    }\n\n    /**\n     * Returns a string representation of the elements of the specified iterator.\n     * <p>\n     * The string representation consists of a list of the iterable's elements,\n     * enclosed in square brackets ({@code \"[]\"}). Adjacent elements are separated\n     * by the characters {@code \", \"} (a comma followed by a space). Elements are\n     * converted to strings as by using the provided {@code transformer}.\n     *\n     * @param <E>  the element type\n     * @param iterator  the iterator to convert to a string, may be null\n     * @param transformer  the transformer used to get a string representation of an element\n     * @return a string representation of {@code iterator}\n     * @throws NullPointerException if {@code transformer} is null\n     * @since 4.1\n     */\n    public static <E> String toString(final Iterator<E> iterator,\n                                      final Transformer<? super E, String> transformer) {\n        return toString(iterator, transformer, DEFAULT_TOSTRING_DELIMITER,\n                        DEFAULT_TOSTRING_PREFIX, DEFAULT_TOSTRING_SUFFIX);\n    }\n\n    /**\n     * Returns a string representation of the elements of the specified iterator.\n     * <p>\n     * The string representation consists of a list of the iterator's elements,\n     * enclosed by the provided {@code prefix} and {@code suffix}. Adjacent elements\n     * are separated by the provided {@code delimiter}. Elements are converted to\n     * strings as by using the provided {@code transformer}.\n     *\n     * @param <E>  the element type\n     * @param iterator  the iterator to convert to a string, may be null\n     * @param transformer  the transformer used to get a string representation of an element\n     * @param delimiter  the string to delimit elements\n     * @param prefix  the prefix, prepended to the string representation\n     * @param suffix  the suffix, appended to the string representation\n     * @return a string representation of {@code iterator}\n     * @throws NullPointerException if either transformer, delimiter, prefix or suffix is null\n     * @since 4.1\n     */\n    public static <E> String toString(final Iterator<E> iterator,\n                                      final Transformer<? super E, String> transformer,\n                                      final String delimiter,\n                                      final String prefix,\n                                      final String suffix) {\n        if (transformer == null) {\n            throw new NullPointerException(\"transformer may not be null\");\n        }\n        if (delimiter == null) {\n            throw new NullPointerException(\"delimiter may not be null\");\n        }\n        if (prefix == null) {\n            throw new NullPointerException(\"prefix may not be null\");\n        }\n        if (suffix == null) {\n            throw new NullPointerException(\"suffix may not be null\");\n        }\n        final StringBuilder stringBuilder = new StringBuilder(prefix);\n        if (iterator != null) {\n            while (iterator.hasNext()) {\n                final E element = iterator.next();\n                stringBuilder.append(transformer.transform(element));\n                stringBuilder.append(delimiter);\n            }\n            if(stringBuilder.length() > prefix.length()) {\n                stringBuilder.setLength(stringBuilder.length() - delimiter.length());\n            }\n        }\n        stringBuilder.append(suffix);\n        return stringBuilder.toString();\n    }\n\n}\n"}]}
{"project": "Collections", "bug_id": 26, "classes_modified": [{"class_name": "org.apache.commons.collections4.keyvalue.MultiKey", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4.keyvalue;\n\nimport java.io.Serializable;\nimport java.util.Arrays;\n\n/**\n * A <code>MultiKey</code> allows multiple map keys to be merged together.\n * <p>\n * The purpose of this class is to avoid the need to write code to handle\n * maps of maps. An example might be the need to look up a file name by\n * key and locale. The typical solution might be nested maps. This class\n * can be used instead by creating an instance passing in the key and locale.\n * <p>\n * Example usage:\n * <pre>\n * // populate map with data mapping key+locale to localizedText\n * Map map = new HashMap();\n * MultiKey multiKey = new MultiKey(key, locale);\n * map.put(multiKey, localizedText);\n *\n * // later retrieve the localized text\n * MultiKey multiKey = new MultiKey(key, locale);\n * String localizedText = (String) map.get(multiKey);\n * </pre>\n *\n * @since 3.0\n * @version $Id$\n */\npublic class MultiKey<K> implements Serializable {\n    // This class could implement List, but that would confuse it's purpose\n\n    /** Serialisation version */\n    private static final long serialVersionUID = 4465448607415788805L;\n\n    /** The individual keys */\n    private final K[] keys;\n    /** The cached hashCode */\n    private transient int hashCode;\n\n    /**\n     * Constructor taking two keys.\n     * <p>\n     * The keys should be immutable\n     * If they are not then they must not be changed after adding to the MultiKey.\n     *\n     * @param key1  the first key\n     * @param key2  the second key\n     */\n    @SuppressWarnings(\"unchecked\")\n    public MultiKey(final K key1, final K key2) {\n        this((K[]) new Object[] { key1, key2 }, false);\n    }\n\n    /**\n     * Constructor taking three keys.\n     * <p>\n     * The keys should be immutable\n     * If they are not then they must not be changed after adding to the MultiKey.\n     *\n     * @param key1  the first key\n     * @param key2  the second key\n     * @param key3  the third key\n     */\n    @SuppressWarnings(\"unchecked\")\n    public MultiKey(final K key1, final K key2, final K key3) {\n        this((K[]) new Object[] {key1, key2, key3}, false);\n    }\n\n    /**\n     * Constructor taking four keys.\n     * <p>\n     * The keys should be immutable\n     * If they are not then they must not be changed after adding to the MultiKey.\n     *\n     * @param key1  the first key\n     * @param key2  the second key\n     * @param key3  the third key\n     * @param key4  the fourth key\n     */\n    @SuppressWarnings(\"unchecked\")\n    public MultiKey(final K key1, final K key2, final K key3, final K key4) {\n        this((K[]) new Object[] {key1, key2, key3, key4}, false);\n    }\n\n    /**\n     * Constructor taking five keys.\n     * <p>\n     * The keys should be immutable\n     * If they are not then they must not be changed after adding to the MultiKey.\n     *\n     * @param key1  the first key\n     * @param key2  the second key\n     * @param key3  the third key\n     * @param key4  the fourth key\n     * @param key5  the fifth key\n     */\n    @SuppressWarnings(\"unchecked\")\n    public MultiKey(final K key1, final K key2, final K key3, final K key4, final K key5) {\n        this((K[]) new Object[] {key1, key2, key3, key4, key5}, false);\n    }\n\n    /**\n     * Constructor taking an array of keys which is cloned.\n     * <p>\n     * The keys should be immutable\n     * If they are not then they must not be changed after adding to the MultiKey.\n     * <p>\n     * This is equivalent to <code>new MultiKey(keys, true)</code>.\n     *\n     * @param keys  the array of keys, not null\n     * @throws IllegalArgumentException if the key array is null\n     */\n    public MultiKey(final K[] keys) {\n        this(keys, true);\n    }\n\n    /**\n     * Constructor taking an array of keys, optionally choosing whether to clone.\n     * <p>\n     * <b>If the array is not cloned, then it must not be modified.</b>\n     * <p>\n     * This method is public for performance reasons only, to avoid a clone.\n     * The hashcode is calculated once here in this method.\n     * Therefore, changing the array passed in would not change the hashcode but\n     * would change the equals method, which is a bug.\n     * <p>\n     * This is the only fully safe usage of this constructor, as the object array\n     * is never made available in a variable:\n     * <pre>\n     * new MultiKey(new Object[] {...}, false);\n     * </pre>\n     * <p>\n     * The keys should be immutable\n     * If they are not then they must not be changed after adding to the MultiKey.\n     *\n     * @param keys  the array of keys, not null\n     * @param makeClone  true to clone the array, false to assign it\n     * @throws IllegalArgumentException if the key array is null\n     * @since 3.1\n     */\n    public MultiKey(final K[] keys, final boolean makeClone) {\n        super();\n        if (keys == null) {\n            throw new IllegalArgumentException(\"The array of keys must not be null\");\n        }\n        if (makeClone) {\n            this.keys = keys.clone();\n        } else {\n            this.keys = keys;\n        }\n\n        calculateHashCode(keys);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets a clone of the array of keys.\n     * <p>\n     * The keys should be immutable\n     * If they are not then they must not be changed.\n     *\n     * @return the individual keys\n     */\n    public K[] getKeys() {\n        return keys.clone();\n    }\n\n    /**\n     * Gets the key at the specified index.\n     * <p>\n     * The key should be immutable.\n     * If it is not then it must not be changed.\n     *\n     * @param index  the index to retrieve\n     * @return the key at the index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     * @since 3.1\n     */\n    public K getKey(final int index) {\n        return keys[index];\n    }\n\n    /**\n     * Gets the size of the list of keys.\n     *\n     * @return the size of the list of keys\n     * @since 3.1\n     */\n    public int size() {\n        return keys.length;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Compares this object to another.\n     * <p>\n     * To be equal, the other object must be a <code>MultiKey</code> with the\n     * same number of keys which are also equal.\n     *\n     * @param other  the other object to compare to\n     * @return true if equal\n     */\n    @Override\n    public boolean equals(final Object other) {\n        if (other == this) {\n            return true;\n        }\n        if (other instanceof MultiKey) {\n            final MultiKey<?> otherMulti = (MultiKey<?>) other;\n            return Arrays.equals(keys, otherMulti.keys);\n        }\n        return false;\n    }\n\n    /**\n     * Gets the combined hash code that is computed from all the keys.\n     * <p>\n     * This value is computed once and then cached, so elements should not\n     * change their hash codes once created (note that this is the same\n     * constraint that would be used if the individual keys elements were\n     * themselves {@link java.util.Map Map} keys.\n     *\n     * @return the hash code\n     */\n    @Override\n    public int hashCode() {\n        return hashCode;\n    }\n\n    /**\n     * Gets a debugging string version of the key.\n     *\n     * @return a debugging string\n     */\n    @Override\n    public String toString() {\n        return \"MultiKey\" + Arrays.toString(keys);\n    }\n\n    /**\n     * Calculate the hash code of the instance using the provided keys.\n     * @param keys the keys to calculate the hash code for\n     */\n    private void calculateHashCode(final Object[] keys)\n    {\n        int total = 0;\n        for (final Object key : keys) {\n            if (key != null) {\n                total ^= key.hashCode();\n            }\n        }\n        hashCode = total;\n    }\n\n    /**\n     * Recalculate the hash code after deserialization. The hash code of some\n     * keys might have change (hash codes based on the system hash code are\n     * only stable for the same process).\n     * @return the instance with recalculated hash code\n     */\n    private Object readResolve() {\n        calculateHashCode(keys);\n        return this;\n    }\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4.keyvalue;\n\nimport java.io.Serializable;\nimport java.util.Arrays;\n\n/**\n * A <code>MultiKey</code> allows multiple map keys to be merged together.\n * <p>\n * The purpose of this class is to avoid the need to write code to handle\n * maps of maps. An example might be the need to look up a file name by\n * key and locale. The typical solution might be nested maps. This class\n * can be used instead by creating an instance passing in the key and locale.\n * <p>\n * Example usage:\n * <pre>\n * // populate map with data mapping key+locale to localizedText\n * Map map = new HashMap();\n * MultiKey multiKey = new MultiKey(key, locale);\n * map.put(multiKey, localizedText);\n *\n * // later retrieve the localized text\n * MultiKey multiKey = new MultiKey(key, locale);\n * String localizedText = (String) map.get(multiKey);\n * </pre>\n *\n * @since 3.0\n * @version $Id$\n */\npublic class MultiKey<K> implements Serializable {\n    // This class could implement List, but that would confuse it's purpose\n\n    /** Serialisation version */\n    private static final long serialVersionUID = 4465448607415788805L;\n\n    /** The individual keys */\n    private final K[] keys;\n    /** The cached hashCode */\n    private transient int hashCode;\n\n    /**\n     * Constructor taking two keys.\n     * <p>\n     * The keys should be immutable\n     * If they are not then they must not be changed after adding to the MultiKey.\n     *\n     * @param key1  the first key\n     * @param key2  the second key\n     */\n    @SuppressWarnings(\"unchecked\")\n    public MultiKey(final K key1, final K key2) {\n        this((K[]) new Object[] { key1, key2 }, false);\n    }\n\n    /**\n     * Constructor taking three keys.\n     * <p>\n     * The keys should be immutable\n     * If they are not then they must not be changed after adding to the MultiKey.\n     *\n     * @param key1  the first key\n     * @param key2  the second key\n     * @param key3  the third key\n     */\n    @SuppressWarnings(\"unchecked\")\n    public MultiKey(final K key1, final K key2, final K key3) {\n        this((K[]) new Object[] {key1, key2, key3}, false);\n    }\n\n    /**\n     * Constructor taking four keys.\n     * <p>\n     * The keys should be immutable\n     * If they are not then they must not be changed after adding to the MultiKey.\n     *\n     * @param key1  the first key\n     * @param key2  the second key\n     * @param key3  the third key\n     * @param key4  the fourth key\n     */\n    @SuppressWarnings(\"unchecked\")\n    public MultiKey(final K key1, final K key2, final K key3, final K key4) {\n        this((K[]) new Object[] {key1, key2, key3, key4}, false);\n    }\n\n    /**\n     * Constructor taking five keys.\n     * <p>\n     * The keys should be immutable\n     * If they are not then they must not be changed after adding to the MultiKey.\n     *\n     * @param key1  the first key\n     * @param key2  the second key\n     * @param key3  the third key\n     * @param key4  the fourth key\n     * @param key5  the fifth key\n     */\n    @SuppressWarnings(\"unchecked\")\n    public MultiKey(final K key1, final K key2, final K key3, final K key4, final K key5) {\n        this((K[]) new Object[] {key1, key2, key3, key4, key5}, false);\n    }\n\n    /**\n     * Constructor taking an array of keys which is cloned.\n     * <p>\n     * The keys should be immutable\n     * If they are not then they must not be changed after adding to the MultiKey.\n     * <p>\n     * This is equivalent to <code>new MultiKey(keys, true)</code>.\n     *\n     * @param keys  the array of keys, not null\n     * @throws IllegalArgumentException if the key array is null\n     */\n    public MultiKey(final K[] keys) {\n        this(keys, true);\n    }\n\n    /**\n     * Constructor taking an array of keys, optionally choosing whether to clone.\n     * <p>\n     * <b>If the array is not cloned, then it must not be modified.</b>\n     * <p>\n     * This method is public for performance reasons only, to avoid a clone.\n     * The hashcode is calculated once here in this method.\n     * Therefore, changing the array passed in would not change the hashcode but\n     * would change the equals method, which is a bug.\n     * <p>\n     * This is the only fully safe usage of this constructor, as the object array\n     * is never made available in a variable:\n     * <pre>\n     * new MultiKey(new Object[] {...}, false);\n     * </pre>\n     * <p>\n     * The keys should be immutable\n     * If they are not then they must not be changed after adding to the MultiKey.\n     *\n     * @param keys  the array of keys, not null\n     * @param makeClone  true to clone the array, false to assign it\n     * @throws IllegalArgumentException if the key array is null\n     * @since 3.1\n     */\n    public MultiKey(final K[] keys, final boolean makeClone) {\n        super();\n        if (keys == null) {\n            throw new IllegalArgumentException(\"The array of keys must not be null\");\n        }\n        if (makeClone) {\n            this.keys = keys.clone();\n        } else {\n            this.keys = keys;\n        }\n\n        calculateHashCode(keys);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets a clone of the array of keys.\n     * <p>\n     * The keys should be immutable\n     * If they are not then they must not be changed.\n     *\n     * @return the individual keys\n     */\n    public K[] getKeys() {\n        return keys.clone();\n    }\n\n    /**\n     * Gets the key at the specified index.\n     * <p>\n     * The key should be immutable.\n     * If it is not then it must not be changed.\n     *\n     * @param index  the index to retrieve\n     * @return the key at the index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     * @since 3.1\n     */\n    public K getKey(final int index) {\n        return keys[index];\n    }\n\n    /**\n     * Gets the size of the list of keys.\n     *\n     * @return the size of the list of keys\n     * @since 3.1\n     */\n    public int size() {\n        return keys.length;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Compares this object to another.\n     * <p>\n     * To be equal, the other object must be a <code>MultiKey</code> with the\n     * same number of keys which are also equal.\n     *\n     * @param other  the other object to compare to\n     * @return true if equal\n     */\n    @Override\n    public boolean equals(final Object other) {\n        if (other == this) {\n            return true;\n        }\n        if (other instanceof MultiKey) {\n            final MultiKey<?> otherMulti = (MultiKey<?>) other;\n            return Arrays.equals(keys, otherMulti.keys);\n        }\n        return false;\n    }\n\n    /**\n     * Gets the combined hash code that is computed from all the keys.\n     * <p>\n     * This value is computed once and then cached, so elements should not\n     * change their hash codes once created (note that this is the same\n     * constraint that would be used if the individual keys elements were\n     * themselves {@link java.util.Map Map} keys.\n     *\n     * @return the hash code\n     */\n    @Override\n    public int hashCode() {\n        return hashCode;\n    }\n\n    /**\n     * Gets a debugging string version of the key.\n     *\n     * @return a debugging string\n     */\n    @Override\n    public String toString() {\n        return \"MultiKey\" + Arrays.toString(keys);\n    }\n\n    /**\n     * Calculate the hash code of the instance using the provided keys.\n     * @param keys the keys to calculate the hash code for\n     */\n    private void calculateHashCode(final Object[] keys)\n    {\n        int total = 0;\n        for (final Object key : keys) {\n            if (key != null) {\n                total ^= key.hashCode();\n            }\n        }\n        hashCode = total;\n    }\n\n    /**\n     * Recalculate the hash code after deserialization. The hash code of some\n     * keys might have change (hash codes based on the system hash code are\n     * only stable for the same process).\n     * @return the instance with recalculated hash code\n     */\n    protected Object readResolve() {\n        calculateHashCode(keys);\n        return this;\n    }\n}\n"}]}
{"project": "Collections", "bug_id": 27, "classes_modified": [{"class_name": "org.apache.commons.collections4.map.MultiValueMap", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4.map;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.AbstractCollection;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.apache.commons.collections4.CollectionUtils;\nimport org.apache.commons.collections4.Factory;\nimport org.apache.commons.collections4.FunctorException;\nimport org.apache.commons.collections4.MultiMap;\nimport org.apache.commons.collections4.Transformer;\nimport org.apache.commons.collections4.iterators.EmptyIterator;\nimport org.apache.commons.collections4.iterators.IteratorChain;\nimport org.apache.commons.collections4.iterators.LazyIteratorChain;\nimport org.apache.commons.collections4.iterators.TransformIterator;\n\n/**\n * A MultiValueMap decorates another map, allowing it to have\n * more than one value for a key.\n * <p>\n * A <code>MultiMap</code> is a Map with slightly different semantics.\n * Putting a value into the map will add the value to a Collection at that key.\n * Getting a value will return a Collection, holding all the values put to that key.\n * <p>\n * This implementation is a decorator, allowing any Map implementation\n * to be used as the base.\n * <p>\n * In addition, this implementation allows the type of collection used\n * for the values to be controlled. By default, an <code>ArrayList</code>\n * is used, however a <code>Class</code> to instantiate may be specified,\n * or a factory that returns a <code>Collection</code> instance.\n * <p>\n * <strong>Note that MultiValueMap is not synchronized and is not thread-safe.</strong>\n * If you wish to use this map from multiple threads concurrently, you must use\n * appropriate synchronization. This class may throw exceptions when accessed\n * by concurrent threads without synchronization.\n *\n * @since 3.2\n * @version $Id$\n * @deprecated since 4.1, use {@link org.apache.commons.collections4.MultiValuedMap MultiValuedMap} instead\n */\n@Deprecated\npublic class MultiValueMap<K, V> extends AbstractMapDecorator<K, Object> implements MultiMap<K, V>, Serializable {\n\n    /** Serialization version */\n    private static final long serialVersionUID = -2214159910087182007L;\n\n    /** The factory for creating value collections. */\n    private final Factory<? extends Collection<V>> collectionFactory;\n    /** The cached values. */\n    private transient Collection<V> valuesView;\n\n    /**\n     * Creates a map which wraps the given map and\n     * maps keys to ArrayLists.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param map  the map to wrap\n     * @return a new multi-value map\n     * @since 4.0\n     */\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public static <K, V> MultiValueMap<K, V> multiValueMap(final Map<K, ? super Collection<V>> map) {\n        return MultiValueMap.<K, V, ArrayList> multiValueMap((Map<K, ? super Collection>) map, ArrayList.class);\n    }\n\n    /**\n     * Creates a map which decorates the given <code>map</code> and\n     * maps keys to collections of type <code>collectionClass</code>.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param <C>  the collection class type\n     * @param map  the map to wrap\n     * @param collectionClass  the type of the collection class\n     * @return a new multi-value map\n     * @since 4.0\n     */\n    public static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(final Map<K, ? super C> map,\n                                                                                    final Class<C> collectionClass) {\n        return new MultiValueMap<K, V>(map, new ReflectionFactory<C>(collectionClass));\n    }\n\n    /**\n     * Creates a map which decorates the given <code>map</code> and\n     * creates the value collections using the supplied <code>collectionFactory</code>.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param <C>  the collection class type\n     * @param map  the map to decorate\n     * @param collectionFactory  the collection factory (must return a Collection object).\n     * @return a new multi-value map\n     * @since 4.0\n     */\n    public static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(final Map<K, ? super C> map,\n            final Factory<C> collectionFactory) {\n        return new MultiValueMap<K, V>(map, collectionFactory);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Creates a MultiValueMap based on a <code>HashMap</code> and\n     * storing the multiple values in an <code>ArrayList</code>.\n     */\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public MultiValueMap() {\n        this(new HashMap<K, V>(), new ReflectionFactory(ArrayList.class));\n    }\n\n    /**\n     * Creates a MultiValueMap which decorates the given <code>map</code> and\n     * creates the value collections using the supplied <code>collectionFactory</code>.\n     *\n     * @param <C>  the collection class type\n     * @param map  the map to decorate\n     * @param collectionFactory  the collection factory which must return a Collection instance\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected <C extends Collection<V>> MultiValueMap(final Map<K, ? super C> map,\n                                                      final Factory<C> collectionFactory) {\n        super((Map<K, Object>) map);\n        if (collectionFactory == null) {\n            throw new IllegalArgumentException(\"The factory must not be null\");\n        }\n        this.collectionFactory = collectionFactory;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Write the map out using a custom routine.\n     *\n     * @param out  the output stream\n     * @throws IOException\n     * @since 4.0\n     */\n    private void writeObject(final ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        out.writeObject(map);\n    }\n\n    /**\n     * Read the map in using a custom routine.\n     *\n     * @param in  the input stream\n     * @throws IOException\n     * @throws ClassNotFoundException\n     * @since 4.0\n     */\n    @SuppressWarnings(\"unchecked\") // (1) should only fail if input stream is incorrect\n    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        map = (Map<K, Object>) in.readObject(); // (1)\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Clear the map.\n     */\n    @Override\n    public void clear() {\n        // If you believe that you have GC issues here, try uncommenting this code\n//        Set pairs = getMap().entrySet();\n//        Iterator pairsIterator = pairs.iterator();\n//        while (pairsIterator.hasNext()) {\n//            Map.Entry keyValuePair = (Map.Entry) pairsIterator.next();\n//            Collection coll = (Collection) keyValuePair.getValue();\n//            coll.clear();\n//        }\n        decorated().clear();\n    }\n\n    /**\n     * Removes a specific value from map.\n     * <p>\n     * The item is removed from the collection mapped to the specified key.\n     * Other values attached to that key are unaffected.\n     * <p>\n     * If the last value for a key is removed, <code>null</code> will be returned\n     * from a subsequent <code>get(key)</code>.\n     *\n     * @param key  the key to remove from\n     * @param value the value to remove\n     * @return {@code true} if the mapping was removed, {@code false} otherwise\n     */\n    @Override\n    public boolean removeMapping(final Object key, final Object value) {\n        final Collection<V> valuesForKey = getCollection(key);\n        if (valuesForKey == null) {\n            return false;\n        }\n        final boolean removed = valuesForKey.remove(value);\n        if (removed == false) {\n            return false;\n        }\n        if (valuesForKey.isEmpty()) {\n            remove(key);\n        }\n        return true;\n    }\n\n    /**\n     * Checks whether the map contains the value specified.\n     * <p>\n     * This checks all collections against all keys for the value, and thus could be slow.\n     *\n     * @param value  the value to search for\n     * @return true if the map contains the value\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public boolean containsValue(final Object value) {\n        final Set<Map.Entry<K, Object>> pairs = decorated().entrySet();\n        if (pairs != null) {\n            for (final Map.Entry<K, Object> entry : pairs) {\n                if (((Collection<V>) entry.getValue()).contains(value)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Adds the value to the collection associated with the specified key.\n     * <p>\n     * Unlike a normal <code>Map</code> the previous value is not replaced.\n     * Instead the new value is added to the collection stored against the key.\n     *\n     * @param key  the key to store against\n     * @param value  the value to add to the collection at the key\n     * @return the value added if the map changed and null if the map did not change\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public Object put(final K key, final Object value) {\n        boolean result = false;\n        Collection<V> coll = getCollection(key);\n        if (coll == null) {\n            coll = createCollection(1);  // might produce a non-empty collection\n            coll.add((V) value);\n            if (coll.size() > 0) {\n                // only add if non-zero size to maintain class state\n                decorated().put(key, coll);\n                result = true;  // map definitely changed\n            }\n        } else {\n            result = coll.add((V) value);\n        }\n        return result ? value : null;\n    }\n\n    /**\n     * Override superclass to ensure that MultiMap instances are\n     * correctly handled.\n     * <p>\n     * If you call this method with a normal map, each entry is\n     * added using <code>put(Object,Object)</code>.\n     * If you call this method with a multi map, each entry is\n     * added using <code>putAll(Object,Collection)</code>.\n     *\n     * @param map  the map to copy (either a normal or multi map)\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public void putAll(final Map<? extends K, ?> map) {\n        if (map instanceof MultiMap) {\n            for (final Map.Entry<? extends K, Object> entry : ((MultiMap<? extends K, V>) map).entrySet()) {\n                putAll(entry.getKey(), (Collection<V>) entry.getValue());\n            }\n        } else {\n            for (final Map.Entry<? extends K, ?> entry : map.entrySet()) {\n                put(entry.getKey(), entry.getValue());\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     * <p>\n     * NOTE: the returned Entry objects will contain as value a {@link Collection}\n     * of all values that are mapped to the given key. To get a \"flattened\" version\n     * of all mappings contained in this map, use {@link #iterator()}.\n     *\n     * @see #iterator()\n     */\n    @Override\n    public Set<Entry<K, Object>> entrySet() {\n        return super.entrySet();\n    }\n\n    /**\n     * Gets a collection containing all the values in the map.\n     * <p>\n     * This returns a collection containing the combination of values from all keys.\n     *\n     * @return a collection view of the values contained in this map\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public Collection<Object> values() {\n        final Collection<V> vs = valuesView;\n        return (Collection<Object>) (vs != null ? vs : (valuesView = new Values()));\n    }\n\n    /**\n     * Checks whether the collection at the specified key contains the value.\n     *\n     * @param key  the key to search for\n     * @param value  the value to search for\n     * @return true if the map contains the value\n     */\n    public boolean containsValue(final Object key, final Object value) {\n        final Collection<V> coll = getCollection(key);\n        if (coll == null) {\n            return false;\n        }\n        return coll.contains(value);\n    }\n\n    /**\n     * Gets the collection mapped to the specified key.\n     * This method is a convenience method to typecast the result of <code>get(key)</code>.\n     *\n     * @param key  the key to retrieve\n     * @return the collection mapped to the key, null if no mapping\n     */\n    @SuppressWarnings(\"unchecked\")\n    public Collection<V> getCollection(final Object key) {\n        return (Collection<V>) decorated().get(key);\n    }\n\n    /**\n     * Gets the size of the collection mapped to the specified key.\n     *\n     * @param key  the key to get size for\n     * @return the size of the collection at the key, zero if key not in map\n     */\n    public int size(final Object key) {\n        final Collection<V> coll = getCollection(key);\n        if (coll == null) {\n            return 0;\n        }\n        return coll.size();\n    }\n\n    /**\n     * Adds a collection of values to the collection associated with\n     * the specified key.\n     *\n     * @param key  the key to store against\n     * @param values  the values to add to the collection at the key, null ignored\n     * @return true if this map changed\n     */\n    public boolean putAll(final K key, final Collection<V> values) {\n        if (values == null || values.size() == 0) {\n            return false;\n        }\n        boolean result = false;\n        Collection<V> coll = getCollection(key);\n        if (coll == null) {\n            coll = createCollection(values.size());  // might produce a non-empty collection\n            coll.addAll(values);\n            if (coll.size() > 0) {\n                // only add if non-zero size to maintain class state\n                decorated().put(key, coll);\n                result = true;  // map definitely changed\n            }\n        } else {\n            result = coll.addAll(values);\n        }\n        return result;\n    }\n\n    /**\n     * Gets an iterator for the collection mapped to the specified key.\n     *\n     * @param key  the key to get an iterator for\n     * @return the iterator of the collection at the key, empty iterator if key not in map\n     */\n    public Iterator<V> iterator(final Object key) {\n        if (!containsKey(key)) {\n            return EmptyIterator.<V>emptyIterator();\n        }\n        return new ValuesIterator(key);\n    }\n\n    /**\n     * Gets an iterator for all mappings stored in this {@link MultiValueMap}.\n     * <p>\n     * The iterator will return multiple Entry objects with the same key\n     * if there are multiple values mapped to this key.\n     * <p>\n     * NOTE: calling {@link java.util.Map.Entry#setValue(Object)} on any of the returned\n     * elements will result in a {@link UnsupportedOperationException}.\n     *\n     * @return the iterator of all mappings in this map\n     * @since 4.0\n     */\n    public Iterator<Entry<K, V>> iterator() {\n        final Collection<K> allKeys = new ArrayList<K>(keySet());\n        final Iterator<K> keyIterator = allKeys.iterator();\n\n        return new LazyIteratorChain<Entry<K, V>>() {\n            @Override\n            protected Iterator<? extends Entry<K, V>> nextIterator(int count) {\n                if ( ! keyIterator.hasNext() ) {\n                    return null;\n                }\n                final K key = keyIterator.next();\n                final Transformer<V, Entry<K, V>> transformer = new Transformer<V, Entry<K, V>>() {\n                    @Override\n                    public Entry<K, V> transform(final V input) {\n                        return new Entry<K, V>() {\n                            @Override\n                            public K getKey() {\n                                return key;\n                            }\n                            @Override\n                            public V getValue() {\n                                return input;\n                            }\n                            @Override\n                            public V setValue(V value) {\n                                throw new UnsupportedOperationException();\n                            }\n                        };\n                    }\n                };\n                return new TransformIterator<V, Entry<K, V>>(new ValuesIterator(key), transformer);\n            }\n        };\n    }\n\n    /**\n     * Gets the total size of the map by counting all the values.\n     *\n     * @return the total size of the map counting all values\n     */\n    public int totalSize() {\n        int total = 0;\n        for (final Object v : decorated().values()) {\n            total += CollectionUtils.size(v);\n        }\n        return total;\n    }\n\n    /**\n     * Creates a new instance of the map value Collection container\n     * using the factory.\n     * <p>\n     * This method can be overridden to perform your own processing\n     * instead of using the factory.\n     *\n     * @param size  the collection size that is about to be added\n     * @return the new collection\n     */\n    protected Collection<V> createCollection(final int size) {\n        return collectionFactory.create();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Inner class that provides the values view.\n     */\n    private class Values extends AbstractCollection<V> {\n        @Override\n        public Iterator<V> iterator() {\n            final IteratorChain<V> chain = new IteratorChain<V>();\n            for (final K k : keySet()) {\n                chain.addIterator(new ValuesIterator(k));\n            }\n            return chain;\n        }\n\n        @Override\n        public int size() {\n            return totalSize();\n        }\n\n        @Override\n        public void clear() {\n            MultiValueMap.this.clear();\n        }\n    }\n\n    /**\n     * Inner class that provides the values iterator.\n     */\n    private class ValuesIterator implements Iterator<V> {\n        private final Object key;\n        private final Collection<V> values;\n        private final Iterator<V> iterator;\n\n        public ValuesIterator(final Object key) {\n            this.key = key;\n            this.values = getCollection(key);\n            this.iterator = values.iterator();\n        }\n\n        @Override\n        public void remove() {\n            iterator.remove();\n            if (values.isEmpty()) {\n                MultiValueMap.this.remove(key);\n            }\n        }\n\n        @Override\n        public boolean hasNext() {\n            return iterator.hasNext();\n        }\n\n        @Override\n        public V next() {\n            return iterator.next();\n        }\n    }\n\n    /**\n     * Inner class that provides a simple reflection factory.\n     */\n    private static class ReflectionFactory<T extends Collection<?>> implements Factory<T>, Serializable {\n\n        /** Serialization version */\n        private static final long serialVersionUID = 2986114157496788874L;\n\n        private final Class<T> clazz;\n\n        public ReflectionFactory(final Class<T> clazz) {\n            this.clazz = clazz;\n        }\n\n        @Override\n        public T create() {\n            try {\n                return clazz.newInstance();\n            } catch (final Exception ex) {\n                throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex);\n            }\n        }\n\n    }\n\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4.map;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.AbstractCollection;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.apache.commons.collections4.CollectionUtils;\nimport org.apache.commons.collections4.Factory;\nimport org.apache.commons.collections4.FunctorException;\nimport org.apache.commons.collections4.MultiMap;\nimport org.apache.commons.collections4.Transformer;\nimport org.apache.commons.collections4.iterators.EmptyIterator;\nimport org.apache.commons.collections4.iterators.IteratorChain;\nimport org.apache.commons.collections4.iterators.LazyIteratorChain;\nimport org.apache.commons.collections4.iterators.TransformIterator;\n\n/**\n * A MultiValueMap decorates another map, allowing it to have\n * more than one value for a key.\n * <p>\n * A <code>MultiMap</code> is a Map with slightly different semantics.\n * Putting a value into the map will add the value to a Collection at that key.\n * Getting a value will return a Collection, holding all the values put to that key.\n * <p>\n * This implementation is a decorator, allowing any Map implementation\n * to be used as the base.\n * <p>\n * In addition, this implementation allows the type of collection used\n * for the values to be controlled. By default, an <code>ArrayList</code>\n * is used, however a <code>Class</code> to instantiate may be specified,\n * or a factory that returns a <code>Collection</code> instance.\n * <p>\n * <strong>Note that MultiValueMap is not synchronized and is not thread-safe.</strong>\n * If you wish to use this map from multiple threads concurrently, you must use\n * appropriate synchronization. This class may throw exceptions when accessed\n * by concurrent threads without synchronization.\n *\n * @since 3.2\n * @version $Id$\n * @deprecated since 4.1, use {@link org.apache.commons.collections4.MultiValuedMap MultiValuedMap} instead\n */\n@Deprecated\npublic class MultiValueMap<K, V> extends AbstractMapDecorator<K, Object> implements MultiMap<K, V>, Serializable {\n\n    /** Serialization version */\n    private static final long serialVersionUID = -2214159910087182007L;\n\n    /** The factory for creating value collections. */\n    private final Factory<? extends Collection<V>> collectionFactory;\n    /** The cached values. */\n    private transient Collection<V> valuesView;\n\n    /**\n     * Creates a map which wraps the given map and\n     * maps keys to ArrayLists.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param map  the map to wrap\n     * @return a new multi-value map\n     * @since 4.0\n     */\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public static <K, V> MultiValueMap<K, V> multiValueMap(final Map<K, ? super Collection<V>> map) {\n        return MultiValueMap.<K, V, ArrayList> multiValueMap((Map<K, ? super Collection>) map, ArrayList.class);\n    }\n\n    /**\n     * Creates a map which decorates the given <code>map</code> and\n     * maps keys to collections of type <code>collectionClass</code>.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param <C>  the collection class type\n     * @param map  the map to wrap\n     * @param collectionClass  the type of the collection class\n     * @return a new multi-value map\n     * @since 4.0\n     */\n    public static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(final Map<K, ? super C> map,\n                                                                                    final Class<C> collectionClass) {\n        return new MultiValueMap<K, V>(map, new ReflectionFactory<C>(collectionClass));\n    }\n\n    /**\n     * Creates a map which decorates the given <code>map</code> and\n     * creates the value collections using the supplied <code>collectionFactory</code>.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param <C>  the collection class type\n     * @param map  the map to decorate\n     * @param collectionFactory  the collection factory (must return a Collection object).\n     * @return a new multi-value map\n     * @since 4.0\n     */\n    public static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(final Map<K, ? super C> map,\n            final Factory<C> collectionFactory) {\n        return new MultiValueMap<K, V>(map, collectionFactory);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Creates a MultiValueMap based on a <code>HashMap</code> and\n     * storing the multiple values in an <code>ArrayList</code>.\n     */\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public MultiValueMap() {\n        this(new HashMap<K, V>(), new ReflectionFactory(ArrayList.class));\n    }\n\n    /**\n     * Creates a MultiValueMap which decorates the given <code>map</code> and\n     * creates the value collections using the supplied <code>collectionFactory</code>.\n     *\n     * @param <C>  the collection class type\n     * @param map  the map to decorate\n     * @param collectionFactory  the collection factory which must return a Collection instance\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected <C extends Collection<V>> MultiValueMap(final Map<K, ? super C> map,\n                                                      final Factory<C> collectionFactory) {\n        super((Map<K, Object>) map);\n        if (collectionFactory == null) {\n            throw new IllegalArgumentException(\"The factory must not be null\");\n        }\n        this.collectionFactory = collectionFactory;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Write the map out using a custom routine.\n     *\n     * @param out  the output stream\n     * @throws IOException\n     * @since 4.0\n     */\n    private void writeObject(final ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        out.writeObject(map);\n    }\n\n    /**\n     * Read the map in using a custom routine.\n     *\n     * @param in  the input stream\n     * @throws IOException\n     * @throws ClassNotFoundException\n     * @since 4.0\n     */\n    @SuppressWarnings(\"unchecked\") // (1) should only fail if input stream is incorrect\n    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        map = (Map<K, Object>) in.readObject(); // (1)\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Clear the map.\n     */\n    @Override\n    public void clear() {\n        // If you believe that you have GC issues here, try uncommenting this code\n//        Set pairs = getMap().entrySet();\n//        Iterator pairsIterator = pairs.iterator();\n//        while (pairsIterator.hasNext()) {\n//            Map.Entry keyValuePair = (Map.Entry) pairsIterator.next();\n//            Collection coll = (Collection) keyValuePair.getValue();\n//            coll.clear();\n//        }\n        decorated().clear();\n    }\n\n    /**\n     * Removes a specific value from map.\n     * <p>\n     * The item is removed from the collection mapped to the specified key.\n     * Other values attached to that key are unaffected.\n     * <p>\n     * If the last value for a key is removed, <code>null</code> will be returned\n     * from a subsequent <code>get(key)</code>.\n     *\n     * @param key  the key to remove from\n     * @param value the value to remove\n     * @return {@code true} if the mapping was removed, {@code false} otherwise\n     */\n    @Override\n    public boolean removeMapping(final Object key, final Object value) {\n        final Collection<V> valuesForKey = getCollection(key);\n        if (valuesForKey == null) {\n            return false;\n        }\n        final boolean removed = valuesForKey.remove(value);\n        if (removed == false) {\n            return false;\n        }\n        if (valuesForKey.isEmpty()) {\n            remove(key);\n        }\n        return true;\n    }\n\n    /**\n     * Checks whether the map contains the value specified.\n     * <p>\n     * This checks all collections against all keys for the value, and thus could be slow.\n     *\n     * @param value  the value to search for\n     * @return true if the map contains the value\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public boolean containsValue(final Object value) {\n        final Set<Map.Entry<K, Object>> pairs = decorated().entrySet();\n        if (pairs != null) {\n            for (final Map.Entry<K, Object> entry : pairs) {\n                if (((Collection<V>) entry.getValue()).contains(value)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Adds the value to the collection associated with the specified key.\n     * <p>\n     * Unlike a normal <code>Map</code> the previous value is not replaced.\n     * Instead the new value is added to the collection stored against the key.\n     *\n     * @param key  the key to store against\n     * @param value  the value to add to the collection at the key\n     * @return the value added if the map changed and null if the map did not change\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public Object put(final K key, final Object value) {\n        boolean result = false;\n        Collection<V> coll = getCollection(key);\n        if (coll == null) {\n            coll = createCollection(1);  // might produce a non-empty collection\n            coll.add((V) value);\n            if (coll.size() > 0) {\n                // only add if non-zero size to maintain class state\n                decorated().put(key, coll);\n                result = true;  // map definitely changed\n            }\n        } else {\n            result = coll.add((V) value);\n        }\n        return result ? value : null;\n    }\n\n    /**\n     * Override superclass to ensure that MultiMap instances are\n     * correctly handled.\n     * <p>\n     * If you call this method with a normal map, each entry is\n     * added using <code>put(Object,Object)</code>.\n     * If you call this method with a multi map, each entry is\n     * added using <code>putAll(Object,Collection)</code>.\n     *\n     * @param map  the map to copy (either a normal or multi map)\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public void putAll(final Map<? extends K, ?> map) {\n        if (map instanceof MultiMap) {\n            for (final Map.Entry<? extends K, Object> entry : ((MultiMap<? extends K, V>) map).entrySet()) {\n                putAll(entry.getKey(), (Collection<V>) entry.getValue());\n            }\n        } else {\n            for (final Map.Entry<? extends K, ?> entry : map.entrySet()) {\n                put(entry.getKey(), entry.getValue());\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     * <p>\n     * NOTE: the returned Entry objects will contain as value a {@link Collection}\n     * of all values that are mapped to the given key. To get a \"flattened\" version\n     * of all mappings contained in this map, use {@link #iterator()}.\n     *\n     * @see #iterator()\n     */\n    @Override\n    public Set<Entry<K, Object>> entrySet() {\n        return super.entrySet();\n    }\n\n    /**\n     * Gets a collection containing all the values in the map.\n     * <p>\n     * This returns a collection containing the combination of values from all keys.\n     *\n     * @return a collection view of the values contained in this map\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public Collection<Object> values() {\n        final Collection<V> vs = valuesView;\n        return (Collection<Object>) (vs != null ? vs : (valuesView = new Values()));\n    }\n\n    /**\n     * Checks whether the collection at the specified key contains the value.\n     *\n     * @param key  the key to search for\n     * @param value  the value to search for\n     * @return true if the map contains the value\n     */\n    public boolean containsValue(final Object key, final Object value) {\n        final Collection<V> coll = getCollection(key);\n        if (coll == null) {\n            return false;\n        }\n        return coll.contains(value);\n    }\n\n    /**\n     * Gets the collection mapped to the specified key.\n     * This method is a convenience method to typecast the result of <code>get(key)</code>.\n     *\n     * @param key  the key to retrieve\n     * @return the collection mapped to the key, null if no mapping\n     */\n    @SuppressWarnings(\"unchecked\")\n    public Collection<V> getCollection(final Object key) {\n        return (Collection<V>) decorated().get(key);\n    }\n\n    /**\n     * Gets the size of the collection mapped to the specified key.\n     *\n     * @param key  the key to get size for\n     * @return the size of the collection at the key, zero if key not in map\n     */\n    public int size(final Object key) {\n        final Collection<V> coll = getCollection(key);\n        if (coll == null) {\n            return 0;\n        }\n        return coll.size();\n    }\n\n    /**\n     * Adds a collection of values to the collection associated with\n     * the specified key.\n     *\n     * @param key  the key to store against\n     * @param values  the values to add to the collection at the key, null ignored\n     * @return true if this map changed\n     */\n    public boolean putAll(final K key, final Collection<V> values) {\n        if (values == null || values.size() == 0) {\n            return false;\n        }\n        boolean result = false;\n        Collection<V> coll = getCollection(key);\n        if (coll == null) {\n            coll = createCollection(values.size());  // might produce a non-empty collection\n            coll.addAll(values);\n            if (coll.size() > 0) {\n                // only add if non-zero size to maintain class state\n                decorated().put(key, coll);\n                result = true;  // map definitely changed\n            }\n        } else {\n            result = coll.addAll(values);\n        }\n        return result;\n    }\n\n    /**\n     * Gets an iterator for the collection mapped to the specified key.\n     *\n     * @param key  the key to get an iterator for\n     * @return the iterator of the collection at the key, empty iterator if key not in map\n     */\n    public Iterator<V> iterator(final Object key) {\n        if (!containsKey(key)) {\n            return EmptyIterator.<V>emptyIterator();\n        }\n        return new ValuesIterator(key);\n    }\n\n    /**\n     * Gets an iterator for all mappings stored in this {@link MultiValueMap}.\n     * <p>\n     * The iterator will return multiple Entry objects with the same key\n     * if there are multiple values mapped to this key.\n     * <p>\n     * NOTE: calling {@link java.util.Map.Entry#setValue(Object)} on any of the returned\n     * elements will result in a {@link UnsupportedOperationException}.\n     *\n     * @return the iterator of all mappings in this map\n     * @since 4.0\n     */\n    public Iterator<Entry<K, V>> iterator() {\n        final Collection<K> allKeys = new ArrayList<K>(keySet());\n        final Iterator<K> keyIterator = allKeys.iterator();\n\n        return new LazyIteratorChain<Entry<K, V>>() {\n            @Override\n            protected Iterator<? extends Entry<K, V>> nextIterator(int count) {\n                if ( ! keyIterator.hasNext() ) {\n                    return null;\n                }\n                final K key = keyIterator.next();\n                final Transformer<V, Entry<K, V>> transformer = new Transformer<V, Entry<K, V>>() {\n                    @Override\n                    public Entry<K, V> transform(final V input) {\n                        return new Entry<K, V>() {\n                            @Override\n                            public K getKey() {\n                                return key;\n                            }\n                            @Override\n                            public V getValue() {\n                                return input;\n                            }\n                            @Override\n                            public V setValue(V value) {\n                                throw new UnsupportedOperationException();\n                            }\n                        };\n                    }\n                };\n                return new TransformIterator<V, Entry<K, V>>(new ValuesIterator(key), transformer);\n            }\n        };\n    }\n\n    /**\n     * Gets the total size of the map by counting all the values.\n     *\n     * @return the total size of the map counting all values\n     */\n    public int totalSize() {\n        int total = 0;\n        for (final Object v : decorated().values()) {\n            total += CollectionUtils.size(v);\n        }\n        return total;\n    }\n\n    /**\n     * Creates a new instance of the map value Collection container\n     * using the factory.\n     * <p>\n     * This method can be overridden to perform your own processing\n     * instead of using the factory.\n     *\n     * @param size  the collection size that is about to be added\n     * @return the new collection\n     */\n    protected Collection<V> createCollection(final int size) {\n        return collectionFactory.create();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Inner class that provides the values view.\n     */\n    private class Values extends AbstractCollection<V> {\n        @Override\n        public Iterator<V> iterator() {\n            final IteratorChain<V> chain = new IteratorChain<V>();\n            for (final K k : keySet()) {\n                chain.addIterator(new ValuesIterator(k));\n            }\n            return chain;\n        }\n\n        @Override\n        public int size() {\n            return totalSize();\n        }\n\n        @Override\n        public void clear() {\n            MultiValueMap.this.clear();\n        }\n    }\n\n    /**\n     * Inner class that provides the values iterator.\n     */\n    private class ValuesIterator implements Iterator<V> {\n        private final Object key;\n        private final Collection<V> values;\n        private final Iterator<V> iterator;\n\n        public ValuesIterator(final Object key) {\n            this.key = key;\n            this.values = getCollection(key);\n            this.iterator = values.iterator();\n        }\n\n        @Override\n        public void remove() {\n            iterator.remove();\n            if (values.isEmpty()) {\n                MultiValueMap.this.remove(key);\n            }\n        }\n\n        @Override\n        public boolean hasNext() {\n            return iterator.hasNext();\n        }\n\n        @Override\n        public V next() {\n            return iterator.next();\n        }\n    }\n\n    /**\n     * Inner class that provides a simple reflection factory.\n     */\n    private static class ReflectionFactory<T extends Collection<?>> implements Factory<T>, Serializable {\n\n        /** Serialization version */\n        private static final long serialVersionUID = 2986114157496788874L;\n\n        private final Class<T> clazz;\n\n        public ReflectionFactory(final Class<T> clazz) {\n            this.clazz = clazz;\n        }\n\n        @Override\n        public T create() {\n            try {\n                return clazz.newInstance();\n            } catch (final Exception ex) {\n                throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex);\n            }\n        }\n\n        private void readObject(ObjectInputStream is) throws IOException, ClassNotFoundException {\n            is.defaultReadObject();\n            // ensure that the de-serialized class is a Collection, COLLECTIONS-580\n            if (clazz != null && !Collection.class.isAssignableFrom(clazz)) {\n                throw new UnsupportedOperationException();\n            }\n        }\n    }\n\n}\n"}]}
{"project": "Collections", "bug_id": 28, "classes_modified": [{"class_name": "org.apache.commons.collections4.trie.AbstractPatriciaTrie", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4.trie;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.util.AbstractCollection;\nimport java.util.AbstractMap;\nimport java.util.AbstractSet;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.ConcurrentModificationException;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Set;\nimport java.util.SortedMap;\n\nimport org.apache.commons.collections4.OrderedMapIterator;\n\n/**\n * This class implements the base PATRICIA algorithm and everything that\n * is related to the {@link Map} interface.\n *\n * @since 4.0\n * @version $Id$\n */\nabstract class AbstractPatriciaTrie<K, V> extends AbstractBitwiseTrie<K, V> {\n\n    private static final long serialVersionUID = 5155253417231339498L;\n\n    /** The root node of the {@link Trie}. */\n    private transient TrieEntry<K, V> root = new TrieEntry<K, V>(null, null, -1);\n\n    /**\n     * Each of these fields are initialized to contain an instance of the\n     * appropriate view the first time this view is requested. The views are\n     * stateless, so there's no reason to create more than one of each.\n     */\n    private transient volatile Set<K> keySet;\n    private transient volatile Collection<V> values;\n    private transient volatile Set<Map.Entry<K,V>> entrySet;\n\n    /** The current size of the {@link Trie}. */\n    private transient int size = 0;\n\n    /**\n     * The number of times this {@link Trie} has been modified.\n     * It's used to detect concurrent modifications and fail-fast the {@link Iterator}s.\n     */\n    protected transient int modCount = 0;\n\n    protected AbstractPatriciaTrie(final KeyAnalyzer<? super K> keyAnalyzer) {\n        super(keyAnalyzer);\n    }\n\n    /**\n     * Constructs a new {@link org.apache.commons.collections4.Trie Trie} using the given\n     * {@link KeyAnalyzer} and initializes the {@link org.apache.commons.collections4.Trie Trie}\n     * with the values from the provided {@link Map}.\n     */\n    protected AbstractPatriciaTrie(final KeyAnalyzer<? super K> keyAnalyzer,\n                                   final Map<? extends K, ? extends V> map) {\n        super(keyAnalyzer);\n        putAll(map);\n    }\n\n    //-----------------------------------------------------------------------\n    @Override\n    public void clear() {\n        root.key = null;\n        root.bitIndex = -1;\n        root.value = null;\n\n        root.parent = null;\n        root.left = root;\n        root.right = null;\n        root.predecessor = root;\n\n        size = 0;\n        incrementModCount();\n    }\n\n    @Override\n    public int size() {\n        return size;\n    }\n\n    /**\n     * A helper method to increment the {@link Trie} size and the modification counter.\n     */\n    void incrementSize() {\n        size++;\n        incrementModCount();\n    }\n\n    /**\n     * A helper method to decrement the {@link Trie} size and increment the modification counter.\n     */\n    void decrementSize() {\n        size--;\n        incrementModCount();\n    }\n\n    /**\n     * A helper method to increment the modification counter.\n     */\n    private void incrementModCount() {\n        ++modCount;\n    }\n\n    @Override\n    public V put(final K key, final V value) {\n        if (key == null) {\n            throw new NullPointerException(\"Key cannot be null\");\n        }\n\n        final int lengthInBits = lengthInBits(key);\n\n        // The only place to store a key with a length\n        // of zero bits is the root node\n        if (lengthInBits == 0) {\n            if (root.isEmpty()) {\n                incrementSize();\n            } else {\n                incrementModCount();\n            }\n            return root.setKeyValue(key, value);\n        }\n\n        final TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);\n        if (compareKeys(key, found.key)) {\n            if (found.isEmpty()) { // <- must be the root\n                incrementSize();\n            } else {\n                incrementModCount();\n            }\n            return found.setKeyValue(key, value);\n        }\n\n        final int bitIndex = bitIndex(key, found.key);\n        if (!KeyAnalyzer.isOutOfBoundsIndex(bitIndex)) {\n            if (KeyAnalyzer.isValidBitIndex(bitIndex)) { // in 99.999...9% the case\n                /* NEW KEY+VALUE TUPLE */\n                final TrieEntry<K, V> t = new TrieEntry<K, V>(key, value, bitIndex);\n                addEntry(t, lengthInBits);\n                incrementSize();\n                return null;\n            } else if (KeyAnalyzer.isNullBitKey(bitIndex)) {\n                // A bits of the Key are zero. The only place to\n                // store such a Key is the root Node!\n\n                /* NULL BIT KEY */\n                if (root.isEmpty()) {\n                    incrementSize();\n                } else {\n                    incrementModCount();\n                }\n                return root.setKeyValue(key, value);\n\n            } else if (KeyAnalyzer.isEqualBitKey(bitIndex)) {\n                // This is a very special and rare case.\n\n                /* REPLACE OLD KEY+VALUE */\n                if (found != root) {\n                    incrementModCount();\n                    return found.setKeyValue(key, value);\n                }\n            }\n        }\n\n        throw new IllegalArgumentException(\"Failed to put: \" + key + \" -> \" + value + \", \" + bitIndex);\n    }\n\n    /**\n     * Adds the given {@link TrieEntry} to the {@link Trie}.\n     */\n    TrieEntry<K, V> addEntry(final TrieEntry<K, V> entry, final int lengthInBits) {\n        TrieEntry<K, V> current = root.left;\n        TrieEntry<K, V> path = root;\n        while(true) {\n            if (current.bitIndex >= entry.bitIndex\n                    || current.bitIndex <= path.bitIndex) {\n                entry.predecessor = entry;\n\n                if (!isBitSet(entry.key, entry.bitIndex, lengthInBits)) {\n                    entry.left = entry;\n                    entry.right = current;\n                } else {\n                    entry.left = current;\n                    entry.right = entry;\n                }\n\n                entry.parent = path;\n                if (current.bitIndex >= entry.bitIndex) {\n                    current.parent = entry;\n                }\n\n                // if we inserted an uplink, set the predecessor on it\n                if (current.bitIndex <= path.bitIndex) {\n                    current.predecessor = entry;\n                }\n\n                if (path == root || !isBitSet(entry.key, path.bitIndex, lengthInBits)) {\n                    path.left = entry;\n                } else {\n                    path.right = entry;\n                }\n\n                return entry;\n            }\n\n            path = current;\n\n            if (!isBitSet(entry.key, current.bitIndex, lengthInBits)) {\n                current = current.left;\n            } else {\n                current = current.right;\n            }\n        }\n    }\n\n    @Override\n    public V get(final Object k) {\n        final TrieEntry<K, V> entry = getEntry(k);\n        return entry != null ? entry.getValue() : null;\n    }\n\n    /**\n     * Returns the entry associated with the specified key in the\n     * PatriciaTrieBase.  Returns null if the map contains no mapping\n     * for this key.\n     * <p>\n     * This may throw ClassCastException if the object is not of type K.\n     */\n    TrieEntry<K,V> getEntry(final Object k) {\n        final K key = castKey(k);\n        if (key == null) {\n            return null;\n        }\n\n        final int lengthInBits = lengthInBits(key);\n        final TrieEntry<K,V> entry = getNearestEntryForKey(key, lengthInBits);\n        return !entry.isEmpty() && compareKeys(key, entry.key) ? entry : null;\n    }\n\n    /**\n     * Returns the {@link Entry} whose key is closest in a bitwise XOR\n     * metric to the given key. This is NOT lexicographic closeness.\n     * For example, given the keys:\n     *\n     * <ol>\n     * <li>D = 1000100\n     * <li>H = 1001000\n     * <li>L = 1001100\n     * </ol>\n     *\n     * If the {@link Trie} contained 'H' and 'L', a lookup of 'D' would\n     * return 'L', because the XOR distance between D &amp; L is smaller\n     * than the XOR distance between D &amp; H.\n     *\n     * @param key  the key to use in the search\n     * @return the {@link Entry} whose key is closest in a bitwise XOR metric\n     *   to the provided key\n     */\n    public Map.Entry<K, V> select(final K key) {\n        final int lengthInBits = lengthInBits(key);\n        final Reference<Map.Entry<K, V>> reference = new Reference<Map.Entry<K,V>>();\n        if (!selectR(root.left, -1, key, lengthInBits, reference)) {\n            return reference.get();\n        }\n        return null;\n    }\n\n    /**\n     * Returns the key that is closest in a bitwise XOR metric to the\n     * provided key. This is NOT lexicographic closeness!\n     *\n     * For example, given the keys:\n     *\n     * <ol>\n     * <li>D = 1000100\n     * <li>H = 1001000\n     * <li>L = 1001100\n     * </ol>\n     *\n     * If the {@link Trie} contained 'H' and 'L', a lookup of 'D' would\n     * return 'L', because the XOR distance between D &amp; L is smaller\n     * than the XOR distance between D &amp; H.\n     *\n     * @param key  the key to use in the search\n     * @return the key that is closest in a bitwise XOR metric to the provided key\n     */\n    public K selectKey(final K key) {\n        final Map.Entry<K, V> entry = select(key);\n        if (entry == null) {\n            return null;\n        }\n        return entry.getKey();\n    }\n\n    /**\n     * Returns the value whose key is closest in a bitwise XOR metric to\n     * the provided key. This is NOT lexicographic closeness!\n     *\n     * For example, given the keys:\n     *\n     * <ol>\n     * <li>D = 1000100\n     * <li>H = 1001000\n     * <li>L = 1001100\n     * </ol>\n     *\n     * If the {@link Trie} contained 'H' and 'L', a lookup of 'D' would\n     * return 'L', because the XOR distance between D &amp; L is smaller\n     * than the XOR distance between D &amp; H.\n     *\n     * @param key  the key to use in the search\n     * @return the value whose key is closest in a bitwise XOR metric\n     * to the provided key\n     */\n    public V selectValue(final K key) {\n        final Map.Entry<K, V> entry = select(key);\n        if (entry == null) {\n            return null;\n        }\n        return entry.getValue();\n    }\n\n    /**\n     * This is equivalent to the other {@link #selectR(TrieEntry, int, Object, int, Cursor, Reference)}\n     * method but without its overhead because we're selecting only one best matching Entry from the {@link Trie}.\n     */\n    private boolean selectR(final TrieEntry<K, V> h, final int bitIndex,\n                            final K key, final int lengthInBits,\n                            final Reference<Map.Entry<K, V>> reference) {\n\n        if (h.bitIndex <= bitIndex) {\n            // If we hit the root Node and it is empty\n            // we have to look for an alternative best\n            // matching node.\n            if (!h.isEmpty()) {\n                reference.set(h);\n                return false;\n            }\n            return true;\n        }\n\n        if (!isBitSet(key, h.bitIndex, lengthInBits)) {\n            if (selectR(h.left, h.bitIndex, key, lengthInBits, reference)) {\n                return selectR(h.right, h.bitIndex, key, lengthInBits, reference);\n            }\n        } else {\n            if (selectR(h.right, h.bitIndex, key, lengthInBits, reference)) {\n                return selectR(h.left, h.bitIndex, key, lengthInBits, reference);\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public boolean containsKey(final Object k) {\n        if (k == null) {\n            return false;\n        }\n\n        final K key = castKey(k);\n        final int lengthInBits = lengthInBits(key);\n        final TrieEntry<K, V> entry = getNearestEntryForKey(key, lengthInBits);\n        return !entry.isEmpty() && compareKeys(key, entry.key);\n    }\n\n    @Override\n    public Set<Map.Entry<K,V>> entrySet() {\n        if (entrySet == null) {\n            entrySet = new EntrySet();\n        }\n        return entrySet;\n    }\n\n    @Override\n    public Set<K> keySet() {\n        if (keySet == null) {\n            keySet = new KeySet();\n        }\n        return keySet;\n    }\n\n    @Override\n    public Collection<V> values() {\n        if (values == null) {\n            values = new Values();\n        }\n        return values;\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * @throws ClassCastException if provided key is of an incompatible type\n     */\n    @Override\n    public V remove(final Object k) {\n        if (k == null) {\n            return null;\n        }\n\n        final K key = castKey(k);\n        final int lengthInBits = lengthInBits(key);\n        TrieEntry<K, V> current = root.left;\n        TrieEntry<K, V> path = root;\n        while (true) {\n            if (current.bitIndex <= path.bitIndex) {\n                if (!current.isEmpty() && compareKeys(key, current.key)) {\n                    return removeEntry(current);\n                }\n                return null;\n            }\n\n            path = current;\n\n            if (!isBitSet(key, current.bitIndex, lengthInBits)) {\n                current = current.left;\n            } else {\n                current = current.right;\n            }\n        }\n    }\n\n    /**\n     * Returns the nearest entry for a given key.  This is useful\n     * for finding knowing if a given key exists (and finding the value\n     * for it), or for inserting the key.\n     *\n     * The actual get implementation. This is very similar to\n     * selectR but with the exception that it might return the\n     * root Entry even if it's empty.\n     */\n    TrieEntry<K, V> getNearestEntryForKey(final K key, final int lengthInBits) {\n        TrieEntry<K, V> current = root.left;\n        TrieEntry<K, V> path = root;\n        while(true) {\n            if (current.bitIndex <= path.bitIndex) {\n                return current;\n            }\n\n            path = current;\n            if (!isBitSet(key, current.bitIndex, lengthInBits)) {\n                current = current.left;\n            } else {\n                current = current.right;\n            }\n        }\n    }\n\n    /**\n     * Removes a single entry from the {@link Trie}.\n     *\n     * If we found a Key (Entry h) then figure out if it's\n     * an internal (hard to remove) or external Entry (easy\n     * to remove)\n     */\n    V removeEntry(final TrieEntry<K, V> h) {\n        if (h != root) {\n            if (h.isInternalNode()) {\n                removeInternalEntry(h);\n            } else {\n                removeExternalEntry(h);\n            }\n        }\n\n        decrementSize();\n        return h.setKeyValue(null, null);\n    }\n\n    /**\n     * Removes an external entry from the {@link Trie}.\n     *\n     * If it's an external Entry then just remove it.\n     * This is very easy and straight forward.\n     */\n    private void removeExternalEntry(final TrieEntry<K, V> h) {\n        if (h == root) {\n            throw new IllegalArgumentException(\"Cannot delete root Entry!\");\n        } else if (!h.isExternalNode()) {\n            throw new IllegalArgumentException(h + \" is not an external Entry!\");\n        }\n\n        final TrieEntry<K, V> parent = h.parent;\n        final TrieEntry<K, V> child = h.left == h ? h.right : h.left;\n\n        if (parent.left == h) {\n            parent.left = child;\n        } else {\n            parent.right = child;\n        }\n\n        // either the parent is changing, or the predecessor is changing.\n        if (child.bitIndex > parent.bitIndex) {\n            child.parent = parent;\n        } else {\n            child.predecessor = parent;\n        }\n\n    }\n\n    /**\n     * Removes an internal entry from the {@link Trie}.\n     *\n     * If it's an internal Entry then \"good luck\" with understanding\n     * this code. The Idea is essentially that Entry p takes Entry h's\n     * place in the trie which requires some re-wiring.\n     */\n    private void removeInternalEntry(final TrieEntry<K, V> h) {\n        if (h == root) {\n            throw new IllegalArgumentException(\"Cannot delete root Entry!\");\n        } else if (!h.isInternalNode()) {\n            throw new IllegalArgumentException(h + \" is not an internal Entry!\");\n        }\n\n        final TrieEntry<K, V> p = h.predecessor;\n\n        // Set P's bitIndex\n        p.bitIndex = h.bitIndex;\n\n        // Fix P's parent, predecessor and child Nodes\n        {\n            final TrieEntry<K, V> parent = p.parent;\n            final TrieEntry<K, V> child = p.left == h ? p.right : p.left;\n\n            // if it was looping to itself previously,\n            // it will now be pointed from it's parent\n            // (if we aren't removing it's parent --\n            //  in that case, it remains looping to itself).\n            // otherwise, it will continue to have the same\n            // predecessor.\n            if (p.predecessor == p && p.parent != h) {\n                p.predecessor = p.parent;\n            }\n\n            if (parent.left == p) {\n                parent.left = child;\n            } else {\n                parent.right = child;\n            }\n\n            if (child.bitIndex > parent.bitIndex) {\n                child.parent = parent;\n            }\n        }\n\n        // Fix H's parent and child Nodes\n        {\n            // If H is a parent of its left and right child\n            // then change them to P\n            if (h.left.parent == h) {\n                h.left.parent = p;\n            }\n\n            if (h.right.parent == h) {\n                h.right.parent = p;\n            }\n\n            // Change H's parent\n            if (h.parent.left == h) {\n                h.parent.left = p;\n            } else {\n                h.parent.right = p;\n            }\n        }\n\n        // Copy the remaining fields from H to P\n        //p.bitIndex = h.bitIndex;\n        p.parent = h.parent;\n        p.left = h.left;\n        p.right = h.right;\n\n        // Make sure that if h was pointing to any uplinks,\n        // p now points to them.\n        if (isValidUplink(p.left, p)) {\n            p.left.predecessor = p;\n        }\n\n        if (isValidUplink(p.right, p)) {\n            p.right.predecessor = p;\n        }\n    }\n\n    /**\n     * Returns the entry lexicographically after the given entry.\n     * If the given entry is null, returns the first node.\n     */\n    TrieEntry<K, V> nextEntry(final TrieEntry<K, V> node) {\n        if (node == null) {\n            return firstEntry();\n        }\n        return nextEntryImpl(node.predecessor, node, null);\n    }\n\n    /**\n     * Scans for the next node, starting at the specified point, and using 'previous'\n     * as a hint that the last node we returned was 'previous' (so we know not to return\n     * it again).  If 'tree' is non-null, this will limit the search to the given tree.\n     *\n     * The basic premise is that each iteration can follow the following steps:\n     *\n     * 1) Scan all the way to the left.\n     *   a) If we already started from this node last time, proceed to Step 2.\n     *   b) If a valid uplink is found, use it.\n     *   c) If the result is an empty node (root not set), break the scan.\n     *   d) If we already returned the left node, break the scan.\n     *\n     * 2) Check the right.\n     *   a) If we already returned the right node, proceed to Step 3.\n     *   b) If it is a valid uplink, use it.\n     *   c) Do Step 1 from the right node.\n     *\n     * 3) Back up through the parents until we encounter find a parent\n     *    that we're not the right child of.\n     *\n     * 4) If there's no right child of that parent, the iteration is finished.\n     *    Otherwise continue to Step 5.\n     *\n     * 5) Check to see if the right child is a valid uplink.\n     *    a) If we already returned that child, proceed to Step 6.\n     *       Otherwise, use it.\n     *\n     * 6) If the right child of the parent is the parent itself, we've\n     *    already found & returned the end of the Trie, so exit.\n     *\n     * 7) Do Step 1 on the parent's right child.\n     */\n    TrieEntry<K, V> nextEntryImpl(final TrieEntry<K, V> start,\n            final TrieEntry<K, V> previous, final TrieEntry<K, V> tree) {\n\n        TrieEntry<K, V> current = start;\n\n        // Only look at the left if this was a recursive or\n        // the first check, otherwise we know we've already looked\n        // at the left.\n        if (previous == null || start != previous.predecessor) {\n            while (!current.left.isEmpty()) {\n                // stop traversing if we've already\n                // returned the left of this node.\n                if (previous == current.left) {\n                    break;\n                }\n\n                if (isValidUplink(current.left, current)) {\n                    return current.left;\n                }\n\n                current = current.left;\n            }\n        }\n\n        // If there's no data at all, exit.\n        if (current.isEmpty()) {\n            return null;\n        }\n\n        // If we've already returned the left,\n        // and the immediate right is null,\n        // there's only one entry in the Trie\n        // which is stored at the root.\n        //\n        //  / (\"\")   <-- root\n        //  \\_/  \\\n        //       null <-- 'current'\n        //\n        if (current.right == null) {\n            return null;\n        }\n\n        // If nothing valid on the left, try the right.\n        if (previous != current.right) {\n            // See if it immediately is valid.\n            if (isValidUplink(current.right, current)) {\n                return current.right;\n            }\n\n            // Must search on the right's side if it wasn't initially valid.\n            return nextEntryImpl(current.right, previous, tree);\n        }\n\n        // Neither left nor right are valid, find the first parent\n        // whose child did not come from the right & traverse it.\n        while (current == current.parent.right) {\n            // If we're going to traverse to above the subtree, stop.\n            if (current == tree) {\n                return null;\n            }\n\n            current = current.parent;\n        }\n\n        // If we're on the top of the subtree, we can't go any higher.\n        if (current == tree) {\n            return null;\n        }\n\n        // If there's no right, the parent must be root, so we're done.\n        if (current.parent.right == null) {\n            return null;\n        }\n\n        // If the parent's right points to itself, we've found one.\n        if (previous != current.parent.right\n                && isValidUplink(current.parent.right, current.parent)) {\n            return current.parent.right;\n        }\n\n        // If the parent's right is itself, there can't be any more nodes.\n        if (current.parent.right == current.parent) {\n            return null;\n        }\n\n        // We need to traverse down the parent's right's path.\n        return nextEntryImpl(current.parent.right, previous, tree);\n    }\n\n    /**\n     * Returns the first entry the {@link Trie} is storing.\n     * <p>\n     * This is implemented by going always to the left until\n     * we encounter a valid uplink. That uplink is the first key.\n     */\n    TrieEntry<K, V> firstEntry() {\n        // if Trie is empty, no first node.\n        if (isEmpty()) {\n            return null;\n        }\n\n        return followLeft(root);\n    }\n\n    /**\n     * Goes left through the tree until it finds a valid node.\n     */\n    TrieEntry<K, V> followLeft(TrieEntry<K, V> node) {\n        while(true) {\n            TrieEntry<K, V> child = node.left;\n            // if we hit root and it didn't have a node, go right instead.\n            if (child.isEmpty()) {\n                child = node.right;\n            }\n\n            if (child.bitIndex <= node.bitIndex) {\n                return child;\n            }\n\n            node = child;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n\n    @Override\n    public Comparator<? super K> comparator() {\n        return getKeyAnalyzer();\n    }\n\n    @Override\n    public K firstKey() {\n        if (size() == 0) {\n            throw new NoSuchElementException();\n        }\n        return firstEntry().getKey();\n    }\n\n    @Override\n    public K lastKey() {\n        final TrieEntry<K, V> entry = lastEntry();\n        if (entry != null) {\n            return entry.getKey();\n        }\n        throw new NoSuchElementException();\n    }\n\n    @Override\n    public K nextKey(final K key) {\n        if (key == null) {\n            throw new NullPointerException();\n        }\n        final TrieEntry<K, V> entry = getEntry(key);\n        if (entry != null) {\n            final TrieEntry<K, V> nextEntry = nextEntry(entry);\n            return nextEntry != null ? nextEntry.getKey() : null;\n        }\n        return null;\n    }\n\n    @Override\n    public K previousKey(final K key) {\n        if (key == null) {\n            throw new NullPointerException();\n        }\n        final TrieEntry<K, V> entry = getEntry(key);\n        if (entry != null) {\n            final TrieEntry<K, V> prevEntry = previousEntry(entry);\n            return prevEntry != null ? prevEntry.getKey() : null;\n        }\n        return null;\n    }\n\n    @Override\n    public OrderedMapIterator<K, V> mapIterator() {\n        return new TrieMapIterator();\n    }\n\n    @Override\n    public SortedMap<K, V> prefixMap(final K key) {\n        return getPrefixMapByBits(key, 0, lengthInBits(key));\n    }\n\n    /**\n     * Returns a view of this {@link Trie} of all elements that are prefixed\n     * by the number of bits in the given Key.\n     * <p>\n     * The view that this returns is optimized to have a very efficient\n     * {@link Iterator}. The {@link SortedMap#firstKey()},\n     * {@link SortedMap#lastKey()} &amp; {@link Map#size()} methods must\n     * iterate over all possible values in order to determine the results.\n     * This information is cached until the PATRICIA {@link Trie} changes.\n     * All other methods (except {@link Iterator}) must compare the given\n     * key to the prefix to ensure that it is within the range of the view.\n     * The {@link Iterator}'s remove method must also relocate the subtree\n     * that contains the prefixes if the entry holding the subtree is\n     * removed or changes. Changing the subtree takes O(K) time.\n     *\n     * @param key  the key to use in the search\n     * @param offsetInBits  the prefix offset\n     * @param lengthInBits  the number of significant prefix bits\n     * @return a {@link SortedMap} view of this {@link Trie} with all elements whose\n     *   key is prefixed by the search key\n     */\n    private SortedMap<K, V> getPrefixMapByBits(final K key, final int offsetInBits, final int lengthInBits) {\n\n        final int offsetLength = offsetInBits + lengthInBits;\n        if (offsetLength > lengthInBits(key)) {\n            throw new IllegalArgumentException(offsetInBits + \" + \"\n                    + lengthInBits + \" > \" + lengthInBits(key));\n        }\n\n        if (offsetLength == 0) {\n            return this;\n        }\n\n        return new PrefixRangeMap(key, offsetInBits, lengthInBits);\n    }\n\n    @Override\n    public SortedMap<K, V> headMap(final K toKey) {\n        return new RangeEntryMap(null, toKey);\n    }\n\n    @Override\n    public SortedMap<K, V> subMap(final K fromKey, final K toKey) {\n        return new RangeEntryMap(fromKey, toKey);\n    }\n\n    @Override\n    public SortedMap<K, V> tailMap(final K fromKey) {\n        return new RangeEntryMap(fromKey, null);\n    }\n\n    /**\n     * Returns an entry strictly higher than the given key,\n     * or null if no such entry exists.\n     */\n    TrieEntry<K,V> higherEntry(final K key) {\n        // TODO: Cleanup so that we don't actually have to add/remove from the\n        //       tree.  (We do it here because there are other well-defined\n        //       functions to perform the search.)\n        final int lengthInBits = lengthInBits(key);\n\n        if (lengthInBits == 0) {\n            if (!root.isEmpty()) {\n                // If data in root, and more after -- return it.\n                if (size() > 1) {\n                    return nextEntry(root);\n                }\n                // If no more after, no higher entry.\n                return null;\n            }\n            // Root is empty & we want something after empty, return first.\n            return firstEntry();\n        }\n\n        final TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);\n        if (compareKeys(key, found.key)) {\n            return nextEntry(found);\n        }\n\n        final int bitIndex = bitIndex(key, found.key);\n        if (KeyAnalyzer.isValidBitIndex(bitIndex)) {\n            final TrieEntry<K, V> added = new TrieEntry<K, V>(key, null, bitIndex);\n            addEntry(added, lengthInBits);\n            incrementSize(); // must increment because remove will decrement\n            final TrieEntry<K, V> ceil = nextEntry(added);\n            removeEntry(added);\n            modCount -= 2; // we didn't really modify it.\n            return ceil;\n        } else if (KeyAnalyzer.isNullBitKey(bitIndex)) {\n            if (!root.isEmpty()) {\n                return firstEntry();\n            } else if (size() > 1) {\n                return nextEntry(firstEntry());\n            } else {\n                return null;\n            }\n        } else if (KeyAnalyzer.isEqualBitKey(bitIndex)) {\n            return nextEntry(found);\n        }\n\n        // we should have exited above.\n        throw new IllegalStateException(\"invalid lookup: \" + key);\n    }\n\n    /**\n     * Returns a key-value mapping associated with the least key greater\n     * than or equal to the given key, or null if there is no such key.\n     */\n    TrieEntry<K,V> ceilingEntry(final K key) {\n        // Basically:\n        // Follow the steps of adding an entry, but instead...\n        //\n        // - If we ever encounter a situation where we found an equal\n        //   key, we return it immediately.\n        //\n        // - If we hit an empty root, return the first iterable item.\n        //\n        // - If we have to add a new item, we temporarily add it,\n        //   find the successor to it, then remove the added item.\n        //\n        // These steps ensure that the returned value is either the\n        // entry for the key itself, or the first entry directly after\n        // the key.\n\n        // TODO: Cleanup so that we don't actually have to add/remove from the\n        //       tree.  (We do it here because there are other well-defined\n        //       functions to perform the search.)\n        final int lengthInBits = lengthInBits(key);\n\n        if (lengthInBits == 0) {\n            if (!root.isEmpty()) {\n                return root;\n            }\n            return firstEntry();\n        }\n\n        final TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);\n        if (compareKeys(key, found.key)) {\n            return found;\n        }\n\n        final int bitIndex = bitIndex(key, found.key);\n        if (KeyAnalyzer.isValidBitIndex(bitIndex)) {\n            final TrieEntry<K, V> added = new TrieEntry<K, V>(key, null, bitIndex);\n            addEntry(added, lengthInBits);\n            incrementSize(); // must increment because remove will decrement\n            final TrieEntry<K, V> ceil = nextEntry(added);\n            removeEntry(added);\n            modCount -= 2; // we didn't really modify it.\n            return ceil;\n        } else if (KeyAnalyzer.isNullBitKey(bitIndex)) {\n            if (!root.isEmpty()) {\n                return root;\n            }\n            return firstEntry();\n        } else if (KeyAnalyzer.isEqualBitKey(bitIndex)) {\n            return found;\n        }\n\n        // we should have exited above.\n        throw new IllegalStateException(\"invalid lookup: \" + key);\n    }\n\n    /**\n     * Returns a key-value mapping associated with the greatest key\n     * strictly less than the given key, or null if there is no such key.\n     */\n    TrieEntry<K,V> lowerEntry(final K key) {\n        // Basically:\n        // Follow the steps of adding an entry, but instead...\n        //\n        // - If we ever encounter a situation where we found an equal\n        //   key, we return it's previousEntry immediately.\n        //\n        // - If we hit root (empty or not), return null.\n        //\n        // - If we have to add a new item, we temporarily add it,\n        //   find the previousEntry to it, then remove the added item.\n        //\n        // These steps ensure that the returned value is always just before\n        // the key or null (if there was nothing before it).\n\n        // TODO: Cleanup so that we don't actually have to add/remove from the\n        //       tree.  (We do it here because there are other well-defined\n        //       functions to perform the search.)\n        final int lengthInBits = lengthInBits(key);\n\n        if (lengthInBits == 0) {\n            return null; // there can never be anything before root.\n        }\n\n        final TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);\n        if (compareKeys(key, found.key)) {\n            return previousEntry(found);\n        }\n\n        final int bitIndex = bitIndex(key, found.key);\n        if (KeyAnalyzer.isValidBitIndex(bitIndex)) {\n            final TrieEntry<K, V> added = new TrieEntry<K, V>(key, null, bitIndex);\n            addEntry(added, lengthInBits);\n            incrementSize(); // must increment because remove will decrement\n            final TrieEntry<K, V> prior = previousEntry(added);\n            removeEntry(added);\n            modCount -= 2; // we didn't really modify it.\n            return prior;\n        } else if (KeyAnalyzer.isNullBitKey(bitIndex)) {\n            return null;\n        } else if (KeyAnalyzer.isEqualBitKey(bitIndex)) {\n            return previousEntry(found);\n        }\n\n        // we should have exited above.\n        throw new IllegalStateException(\"invalid lookup: \" + key);\n    }\n\n    /**\n     * Returns a key-value mapping associated with the greatest key\n     * less than or equal to the given key, or null if there is no such key.\n     */\n    TrieEntry<K,V> floorEntry(final K key) {\n        // TODO: Cleanup so that we don't actually have to add/remove from the\n        //       tree.  (We do it here because there are other well-defined\n        //       functions to perform the search.)\n        final int lengthInBits = lengthInBits(key);\n\n        if (lengthInBits == 0) {\n            if (!root.isEmpty()) {\n                return root;\n            }\n            return null;\n        }\n\n        final TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);\n        if (compareKeys(key, found.key)) {\n            return found;\n        }\n\n        final int bitIndex = bitIndex(key, found.key);\n        if (KeyAnalyzer.isValidBitIndex(bitIndex)) {\n            final TrieEntry<K, V> added = new TrieEntry<K, V>(key, null, bitIndex);\n            addEntry(added, lengthInBits);\n            incrementSize(); // must increment because remove will decrement\n            final TrieEntry<K, V> floor = previousEntry(added);\n            removeEntry(added);\n            modCount -= 2; // we didn't really modify it.\n            return floor;\n        } else if (KeyAnalyzer.isNullBitKey(bitIndex)) {\n            if (!root.isEmpty()) {\n                return root;\n            }\n            return null;\n        } else if (KeyAnalyzer.isEqualBitKey(bitIndex)) {\n            return found;\n        }\n\n        // we should have exited above.\n        throw new IllegalStateException(\"invalid lookup: \" + key);\n    }\n\n    /**\n     * Finds the subtree that contains the prefix.\n     *\n     * This is very similar to getR but with the difference that\n     * we stop the lookup if h.bitIndex > lengthInBits.\n     */\n    TrieEntry<K, V> subtree(final K prefix, final int offsetInBits, final int lengthInBits) {\n        TrieEntry<K, V> current = root.left;\n        TrieEntry<K, V> path = root;\n        while(true) {\n            if (current.bitIndex <= path.bitIndex || lengthInBits <= current.bitIndex) {\n                break;\n            }\n\n            path = current;\n            if (!isBitSet(prefix, offsetInBits + current.bitIndex, offsetInBits + lengthInBits)) {\n                current = current.left;\n            } else {\n                current = current.right;\n            }\n        }\n\n        // Make sure the entry is valid for a subtree.\n        final TrieEntry<K, V> entry = current.isEmpty() ? path : current;\n\n        // If entry is root, it can't be empty.\n        if (entry.isEmpty()) {\n            return null;\n        }\n\n        final int endIndexInBits = offsetInBits + lengthInBits;\n\n        // if root && length of root is less than length of lookup,\n        // there's nothing.\n        // (this prevents returning the whole subtree if root has an empty\n        //  string and we want to lookup things with \"\\0\")\n        if (entry == root && lengthInBits(entry.getKey()) < endIndexInBits) {\n            return null;\n        }\n\n        // Found key's length-th bit differs from our key\n        // which means it cannot be the prefix...\n        if (isBitSet(prefix, endIndexInBits - 1, endIndexInBits)\n                != isBitSet(entry.key, lengthInBits - 1, lengthInBits(entry.key))) {\n            return null;\n        }\n\n        // ... or there are less than 'length' equal bits\n        final int bitIndex = getKeyAnalyzer().bitIndex(prefix, offsetInBits, lengthInBits,\n                                                       entry.key, 0, lengthInBits(entry.getKey()));\n\n        if (bitIndex >= 0 && bitIndex < lengthInBits) {\n            return null;\n        }\n\n        return entry;\n    }\n\n    /**\n     * Returns the last entry the {@link Trie} is storing.\n     *\n     * <p>This is implemented by going always to the right until\n     * we encounter a valid uplink. That uplink is the last key.\n     */\n    TrieEntry<K, V> lastEntry() {\n        return followRight(root.left);\n    }\n\n    /**\n     * Traverses down the right path until it finds an uplink.\n     */\n    TrieEntry<K, V> followRight(TrieEntry<K, V> node) {\n        // if Trie is empty, no last entry.\n        if (node.right == null) {\n            return null;\n        }\n\n        // Go as far right as possible, until we encounter an uplink.\n        while (node.right.bitIndex > node.bitIndex) {\n            node = node.right;\n        }\n\n        return node.right;\n    }\n\n    /**\n     * Returns the node lexicographically before the given node (or null if none).\n     *\n     * This follows four simple branches:\n     *  - If the uplink that returned us was a right uplink:\n     *      - If predecessor's left is a valid uplink from predecessor, return it.\n     *      - Else, follow the right path from the predecessor's left.\n     *  - If the uplink that returned us was a left uplink:\n     *      - Loop back through parents until we encounter a node where\n     *        node != node.parent.left.\n     *          - If node.parent.left is uplink from node.parent:\n     *              - If node.parent.left is not root, return it.\n     *              - If it is root & root isEmpty, return null.\n     *              - If it is root & root !isEmpty, return root.\n     *          - If node.parent.left is not uplink from node.parent:\n     *              - Follow right path for first right child from node.parent.left\n     *\n     * @param start  the start entry\n     */\n    TrieEntry<K, V> previousEntry(final TrieEntry<K, V> start) {\n        if (start.predecessor == null) {\n            throw new IllegalArgumentException(\"must have come from somewhere!\");\n        }\n\n        if (start.predecessor.right == start) {\n            if (isValidUplink(start.predecessor.left, start.predecessor)) {\n                return start.predecessor.left;\n            }\n            return followRight(start.predecessor.left);\n        }\n        TrieEntry<K, V> node = start.predecessor;\n        while (node.parent != null && node == node.parent.left) {\n            node = node.parent;\n        }\n\n        if (node.parent == null) { // can be null if we're looking up root.\n            return null;\n        }\n\n        if (isValidUplink(node.parent.left, node.parent)) {\n            if (node.parent.left == root) {\n                if (root.isEmpty()) {\n                    return null;\n                }\n                return root;\n\n            }\n            return node.parent.left;\n        }\n        return followRight(node.parent.left);\n    }\n\n    /**\n     * Returns the entry lexicographically after the given entry.\n     * If the given entry is null, returns the first node.\n     *\n     * This will traverse only within the subtree.  If the given node\n     * is not within the subtree, this will have undefined results.\n     */\n    TrieEntry<K, V> nextEntryInSubtree(final TrieEntry<K, V> node,\n            final TrieEntry<K, V> parentOfSubtree) {\n        if (node == null) {\n            return firstEntry();\n        }\n        return nextEntryImpl(node.predecessor, node, parentOfSubtree);\n    }\n\n    /**\n     * Returns true if 'next' is a valid uplink coming from 'from'.\n     */\n    static boolean isValidUplink(final TrieEntry<?, ?> next, final TrieEntry<?, ?> from) {\n        return next != null && next.bitIndex <= from.bitIndex && !next.isEmpty();\n    }\n\n    /**\n     * A {@link Reference} allows us to return something through a Method's\n     * argument list. An alternative would be to an Array with a length of\n     * one (1) but that leads to compiler warnings. Computationally and memory\n     * wise there's no difference (except for the need to load the\n     * {@link Reference} Class but that happens only once).\n     */\n    private static class Reference<E> {\n\n        private E item;\n\n        public void set(final E item) {\n            this.item = item;\n        }\n\n        public E get() {\n            return item;\n        }\n    }\n\n    /**\n     *  A {@link Trie} is a set of {@link TrieEntry} nodes.\n     */\n    protected static class TrieEntry<K,V> extends BasicEntry<K, V> {\n\n        private static final long serialVersionUID = 4596023148184140013L;\n\n        /** The index this entry is comparing. */\n        protected int bitIndex;\n\n        /** The parent of this entry. */\n        protected TrieEntry<K,V> parent;\n\n        /** The left child of this entry. */\n        protected TrieEntry<K,V> left;\n\n        /** The right child of this entry. */\n        protected TrieEntry<K,V> right;\n\n        /** The entry who uplinks to this entry. */\n        protected TrieEntry<K,V> predecessor;\n\n        public TrieEntry(final K key, final V value, final int bitIndex) {\n            super(key, value);\n\n            this.bitIndex = bitIndex;\n\n            this.parent = null;\n            this.left = this;\n            this.right = null;\n            this.predecessor = this;\n        }\n\n        /**\n         * Whether or not the entry is storing a key.\n         * Only the root can potentially be empty, all other\n         * nodes must have a key.\n         */\n        public boolean isEmpty() {\n            return key == null;\n        }\n\n        /**\n         * Neither the left nor right child is a loopback.\n         */\n        public boolean isInternalNode() {\n            return left != this && right != this;\n        }\n\n        /**\n         * Either the left or right child is a loopback.\n         */\n        public boolean isExternalNode() {\n            return !isInternalNode();\n        }\n\n        @Override\n        public String toString() {\n            final StringBuilder buffer = new StringBuilder();\n\n            if (bitIndex == -1) {\n                buffer.append(\"RootEntry(\");\n            } else {\n                buffer.append(\"Entry(\");\n            }\n\n            buffer.append(\"key=\").append(getKey()).append(\" [\").append(bitIndex).append(\"], \");\n            buffer.append(\"value=\").append(getValue()).append(\", \");\n            //buffer.append(\"bitIndex=\").append(bitIndex).append(\", \");\n\n            if (parent != null) {\n                if (parent.bitIndex == -1) {\n                    buffer.append(\"parent=\").append(\"ROOT\");\n                } else {\n                    buffer.append(\"parent=\").append(parent.getKey()).append(\" [\").append(parent.bitIndex).append(\"]\");\n                }\n            } else {\n                buffer.append(\"parent=\").append(\"null\");\n            }\n            buffer.append(\", \");\n\n            if (left != null) {\n                if (left.bitIndex == -1) {\n                    buffer.append(\"left=\").append(\"ROOT\");\n                } else {\n                    buffer.append(\"left=\").append(left.getKey()).append(\" [\").append(left.bitIndex).append(\"]\");\n                }\n            } else {\n                buffer.append(\"left=\").append(\"null\");\n            }\n            buffer.append(\", \");\n\n            if (right != null) {\n                if (right.bitIndex == -1) {\n                    buffer.append(\"right=\").append(\"ROOT\");\n                } else {\n                    buffer.append(\"right=\").append(right.getKey()).append(\" [\").append(right.bitIndex).append(\"]\");\n                }\n            } else {\n                buffer.append(\"right=\").append(\"null\");\n            }\n            buffer.append(\", \");\n\n            if (predecessor != null) {\n                if(predecessor.bitIndex == -1) {\n                    buffer.append(\"predecessor=\").append(\"ROOT\");\n                } else {\n                    buffer.append(\"predecessor=\").append(predecessor.getKey()).append(\" [\").\n                           append(predecessor.bitIndex).append(\"]\");\n                }\n            }\n\n            buffer.append(\")\");\n            return buffer.toString();\n        }\n    }\n\n\n    /**\n     * This is a entry set view of the {@link Trie} as returned by {@link Map#entrySet()}.\n     */\n    private class EntrySet extends AbstractSet<Map.Entry<K,V>> {\n\n        @Override\n        public Iterator<Map.Entry<K,V>> iterator() {\n            return new EntryIterator();\n        }\n\n        @Override\n        public boolean contains(final Object o) {\n            if (!(o instanceof Map.Entry)) {\n                return false;\n            }\n\n            final TrieEntry<K,V> candidate = getEntry(((Map.Entry<?, ?>)o).getKey());\n            return candidate != null && candidate.equals(o);\n        }\n\n        @Override\n        public boolean remove(final Object obj) {\n            if (obj instanceof Map.Entry == false) {\n                return false;\n            }\n            if (contains(obj) == false) {\n                return false;\n            }\n            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n            AbstractPatriciaTrie.this.remove(entry.getKey());\n            return true;\n        }\n\n        @Override\n        public int size() {\n            return AbstractPatriciaTrie.this.size();\n        }\n\n        @Override\n        public void clear() {\n            AbstractPatriciaTrie.this.clear();\n        }\n\n        /**\n         * An {@link Iterator} that returns {@link Entry} Objects.\n         */\n        private class EntryIterator extends TrieIterator<Map.Entry<K,V>> {\n            @Override\n            public Map.Entry<K,V> next() {\n                return nextEntry();\n            }\n        }\n    }\n\n    /**\n     * This is a key set view of the {@link Trie} as returned by {@link Map#keySet()}.\n     */\n    private class KeySet extends AbstractSet<K> {\n\n        @Override\n        public Iterator<K> iterator() {\n            return new KeyIterator();\n        }\n\n        @Override\n        public int size() {\n            return AbstractPatriciaTrie.this.size();\n        }\n\n        @Override\n        public boolean contains(final Object o) {\n            return containsKey(o);\n        }\n\n        @Override\n        public boolean remove(final Object o) {\n            final int size = size();\n            AbstractPatriciaTrie.this.remove(o);\n            return size != size();\n        }\n\n        @Override\n        public void clear() {\n            AbstractPatriciaTrie.this.clear();\n        }\n\n        /**\n         * An {@link Iterator} that returns Key Objects.\n         */\n        private class KeyIterator extends TrieIterator<K> {\n            @Override\n            public K next() {\n                return nextEntry().getKey();\n            }\n        }\n    }\n\n    /**\n     * This is a value view of the {@link Trie} as returned by {@link Map#values()}.\n     */\n    private class Values extends AbstractCollection<V> {\n\n        @Override\n        public Iterator<V> iterator() {\n            return new ValueIterator();\n        }\n\n        @Override\n        public int size() {\n            return AbstractPatriciaTrie.this.size();\n        }\n\n        @Override\n        public boolean contains(final Object o) {\n            return containsValue(o);\n        }\n\n        @Override\n        public void clear() {\n            AbstractPatriciaTrie.this.clear();\n        }\n\n        @Override\n        public boolean remove(final Object o) {\n            for (final Iterator<V> it = iterator(); it.hasNext(); ) {\n                final V value = it.next();\n                if (compare(value, o)) {\n                    it.remove();\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        /**\n         * An {@link Iterator} that returns Value Objects.\n         */\n        private class ValueIterator extends TrieIterator<V> {\n            @Override\n            public V next() {\n                return nextEntry().getValue();\n            }\n        }\n    }\n\n    /**\n     * An iterator for the entries.\n     */\n    abstract class TrieIterator<E> implements Iterator<E> {\n\n        /** For fast-fail. */\n        protected int expectedModCount = AbstractPatriciaTrie.this.modCount;\n\n        protected TrieEntry<K, V> next; // the next node to return\n        protected TrieEntry<K, V> current; // the current entry we're on\n\n        /**\n         * Starts iteration from the root.\n         */\n        protected TrieIterator() {\n            next = AbstractPatriciaTrie.this.nextEntry(null);\n        }\n\n        /**\n         * Starts iteration at the given entry.\n         */\n        protected TrieIterator(final TrieEntry<K, V> firstEntry) {\n            next = firstEntry;\n        }\n\n        /**\n         * Returns the next {@link TrieEntry}.\n         */\n        protected TrieEntry<K,V> nextEntry() {\n            if (expectedModCount != AbstractPatriciaTrie.this.modCount) {\n                throw new ConcurrentModificationException();\n            }\n\n            final TrieEntry<K,V> e = next;\n            if (e == null) {\n                throw new NoSuchElementException();\n            }\n\n            next = findNext(e);\n            current = e;\n            return e;\n        }\n\n        /**\n         * @see PatriciaTrie#nextEntry(TrieEntry)\n         */\n        protected TrieEntry<K, V> findNext(final TrieEntry<K, V> prior) {\n            return AbstractPatriciaTrie.this.nextEntry(prior);\n        }\n\n        @Override\n        public boolean hasNext() {\n            return next != null;\n        }\n\n        @Override\n        public void remove() {\n            if (current == null) {\n                throw new IllegalStateException();\n            }\n\n            if (expectedModCount != AbstractPatriciaTrie.this.modCount) {\n                throw new ConcurrentModificationException();\n            }\n\n            final TrieEntry<K, V> node = current;\n            current = null;\n            AbstractPatriciaTrie.this.removeEntry(node);\n\n            expectedModCount = AbstractPatriciaTrie.this.modCount;\n        }\n    }\n\n    /**\n     * An {@link OrderedMapIterator} for a {@link Trie}.\n     */\n    private class TrieMapIterator extends TrieIterator<K> implements OrderedMapIterator<K, V> {\n\n        protected TrieEntry<K, V> previous; // the previous node to return\n\n        @Override\n        public K next() {\n            return nextEntry().getKey();\n        }\n\n        @Override\n        public K getKey() {\n            if (current == null) {\n                throw new IllegalStateException();\n            }\n            return current.getKey();\n        }\n\n        @Override\n        public V getValue() {\n            if (current == null) {\n                throw new IllegalStateException();\n            }\n            return current.getValue();\n        }\n\n        @Override\n        public V setValue(final V value) {\n            if (current == null) {\n                throw new IllegalStateException();\n            }\n            return current.setValue(value);\n        }\n\n        @Override\n        public boolean hasPrevious() {\n            return previous != null;\n        }\n\n        @Override\n        public K previous() {\n            return previousEntry().getKey();\n        }\n\n        @Override\n        protected TrieEntry<K, V> nextEntry() {\n            final TrieEntry<K, V> nextEntry = super.nextEntry();\n            previous = nextEntry;\n            return nextEntry;\n        }\n\n        protected TrieEntry<K,V> previousEntry() {\n            if (expectedModCount != AbstractPatriciaTrie.this.modCount) {\n                throw new ConcurrentModificationException();\n            }\n\n            final TrieEntry<K,V> e = previous;\n            if (e == null) {\n                throw new NoSuchElementException();\n            }\n\n            previous = AbstractPatriciaTrie.this.previousEntry(e);\n            next = current;\n            current = e;\n            return current;\n        }\n\n    }\n\n    /**\n     * A range view of the {@link Trie}.\n     */\n    private abstract class RangeMap extends AbstractMap<K, V>\n            implements SortedMap<K, V> {\n\n        /** The {@link #entrySet()} view. */\n        private transient volatile Set<Map.Entry<K, V>> entrySet;\n\n        /**\n         * Creates and returns an {@link #entrySet()} view of the {@link RangeMap}.\n         */\n        protected abstract Set<Map.Entry<K, V>> createEntrySet();\n\n        /**\n         * Returns the FROM Key.\n         */\n        protected abstract K getFromKey();\n\n        /**\n         * Whether or not the {@link #getFromKey()} is in the range.\n         */\n        protected abstract boolean isFromInclusive();\n\n        /**\n         * Returns the TO Key.\n         */\n        protected abstract K getToKey();\n\n        /**\n         * Whether or not the {@link #getToKey()} is in the range.\n         */\n        protected abstract boolean isToInclusive();\n\n        @Override\n        public Comparator<? super K> comparator() {\n            return AbstractPatriciaTrie.this.comparator();\n        }\n\n        @Override\n        public boolean containsKey(final Object key) {\n            if (!inRange(castKey(key))) {\n                return false;\n            }\n\n            return AbstractPatriciaTrie.this.containsKey(key);\n        }\n\n        @Override\n        public V remove(final Object key) {\n            if (!inRange(castKey(key))) {\n                return null;\n            }\n\n            return AbstractPatriciaTrie.this.remove(key);\n        }\n\n        @Override\n        public V get(final Object key) {\n            if (!inRange(castKey(key))) {\n                return null;\n            }\n\n            return AbstractPatriciaTrie.this.get(key);\n        }\n\n        @Override\n        public V put(final K key, final V value) {\n            if (!inRange(key)) {\n                throw new IllegalArgumentException(\"Key is out of range: \" + key);\n            }\n            return AbstractPatriciaTrie.this.put(key, value);\n        }\n\n        @Override\n        public Set<Map.Entry<K, V>> entrySet() {\n            if (entrySet == null) {\n                entrySet = createEntrySet();\n            }\n            return entrySet;\n        }\n\n        @Override\n        public SortedMap<K, V> subMap(final K fromKey, final K toKey) {\n            if (!inRange2(fromKey)) {\n                throw new IllegalArgumentException(\"FromKey is out of range: \" + fromKey);\n            }\n\n            if (!inRange2(toKey)) {\n                throw new IllegalArgumentException(\"ToKey is out of range: \" + toKey);\n            }\n\n            return createRangeMap(fromKey, isFromInclusive(), toKey, isToInclusive());\n        }\n\n        @Override\n        public SortedMap<K, V> headMap(final K toKey) {\n            if (!inRange2(toKey)) {\n                throw new IllegalArgumentException(\"ToKey is out of range: \" + toKey);\n            }\n            return createRangeMap(getFromKey(), isFromInclusive(), toKey, isToInclusive());\n        }\n\n        @Override\n        public SortedMap<K, V> tailMap(final K fromKey) {\n            if (!inRange2(fromKey)) {\n                throw new IllegalArgumentException(\"FromKey is out of range: \" + fromKey);\n            }\n            return createRangeMap(fromKey, isFromInclusive(), getToKey(), isToInclusive());\n        }\n\n        /**\n         * Returns true if the provided key is greater than TO and less than FROM.\n         */\n        protected boolean inRange(final K key) {\n            final K fromKey = getFromKey();\n            final K toKey = getToKey();\n\n            return (fromKey == null || inFromRange(key, false)) && (toKey == null || inToRange(key, false));\n        }\n\n        /**\n         * This form allows the high endpoint (as well as all legit keys).\n         */\n        protected boolean inRange2(final K key) {\n            final K fromKey = getFromKey();\n            final K toKey = getToKey();\n\n            return (fromKey == null || inFromRange(key, false)) && (toKey == null || inToRange(key, true));\n        }\n\n        /**\n         * Returns true if the provided key is in the FROM range of the {@link RangeMap}.\n         */\n        protected boolean inFromRange(final K key, final boolean forceInclusive) {\n            final K fromKey = getFromKey();\n            final boolean fromInclusive = isFromInclusive();\n\n            final int ret = getKeyAnalyzer().compare(key, fromKey);\n            if (fromInclusive || forceInclusive) {\n                return ret >= 0;\n            }\n            return ret > 0;\n        }\n\n        /**\n         * Returns true if the provided key is in the TO range of the {@link RangeMap}.\n         */\n        protected boolean inToRange(final K key, final boolean forceInclusive) {\n            final K toKey = getToKey();\n            final boolean toInclusive = isToInclusive();\n\n            final int ret = getKeyAnalyzer().compare(key, toKey);\n            if (toInclusive || forceInclusive) {\n                return ret <= 0;\n            }\n            return ret < 0;\n        }\n\n        /**\n         * Creates and returns a sub-range view of the current {@link RangeMap}.\n         */\n        protected abstract SortedMap<K, V> createRangeMap(K fromKey, boolean fromInclusive,\n                                                          K toKey, boolean toInclusive);\n    }\n\n   /**\n    * A {@link RangeMap} that deals with {@link Entry}s.\n    */\n   private class RangeEntryMap extends RangeMap {\n\n       /** The key to start from, null if the beginning. */\n       private final K fromKey;\n\n       /** The key to end at, null if till the end. */\n       private final K toKey;\n\n       /** Whether or not the 'from' is inclusive. */\n       private final boolean fromInclusive;\n\n       /** Whether or not the 'to' is inclusive. */\n       private final boolean toInclusive;\n\n       /**\n        * Creates a {@link RangeEntryMap} with the fromKey included and\n        * the toKey excluded from the range.\n        */\n       protected RangeEntryMap(final K fromKey, final K toKey) {\n           this(fromKey, true, toKey, false);\n       }\n\n       /**\n        * Creates a {@link RangeEntryMap}.\n        */\n       protected RangeEntryMap(final K fromKey, final boolean fromInclusive,\n                               final K toKey, final boolean toInclusive) {\n\n           if (fromKey == null && toKey == null) {\n               throw new IllegalArgumentException(\"must have a from or to!\");\n           }\n\n           if (fromKey != null && toKey != null && getKeyAnalyzer().compare(fromKey, toKey) > 0) {\n               throw new IllegalArgumentException(\"fromKey > toKey\");\n           }\n\n           this.fromKey = fromKey;\n           this.fromInclusive = fromInclusive;\n           this.toKey = toKey;\n           this.toInclusive = toInclusive;\n       }\n\n       @Override\n    public K firstKey() {\n           Map.Entry<K,V> e = null;\n           if (fromKey == null) {\n               e = firstEntry();\n           } else {\n               if (fromInclusive) {\n                   e = ceilingEntry(fromKey);\n               } else {\n                   e = higherEntry(fromKey);\n               }\n           }\n\n           final K first = e != null ? e.getKey() : null;\n           if (e == null || toKey != null && !inToRange(first, false)) {\n               throw new NoSuchElementException();\n           }\n           return first;\n       }\n\n       @Override\n    public K lastKey() {\n           Map.Entry<K,V> e;\n           if (toKey == null) {\n               e = lastEntry();\n           } else {\n               if (toInclusive) {\n                   e = floorEntry(toKey);\n               } else {\n                   e = lowerEntry(toKey);\n               }\n           }\n\n           final K last = e != null ? e.getKey() : null;\n           if (e == null || fromKey != null && !inFromRange(last, false)) {\n               throw new NoSuchElementException();\n           }\n           return last;\n       }\n\n       @Override\n       protected Set<Entry<K, V>> createEntrySet() {\n           return new RangeEntrySet(this);\n       }\n\n       @Override\n       public K getFromKey() {\n           return fromKey;\n       }\n\n       @Override\n       public K getToKey() {\n           return toKey;\n       }\n\n       @Override\n       public boolean isFromInclusive() {\n           return fromInclusive;\n       }\n\n       @Override\n       public boolean isToInclusive() {\n           return toInclusive;\n       }\n\n       @Override\n       protected SortedMap<K, V> createRangeMap(final K fromKey, final boolean fromInclusive,\n                                                final K toKey, final boolean toInclusive) {\n           return new RangeEntryMap(fromKey, fromInclusive, toKey, toInclusive);\n       }\n   }\n\n    /**\n     * A {@link Set} view of a {@link RangeMap}.\n     */\n    private class RangeEntrySet extends AbstractSet<Map.Entry<K, V>> {\n\n        private final RangeMap delegate;\n\n        private transient int size = -1;\n\n        private transient int expectedModCount;\n\n        /**\n         * Creates a {@link RangeEntrySet}.\n         */\n        public RangeEntrySet(final RangeMap delegate) {\n            if (delegate == null) {\n                throw new NullPointerException(\"delegate\");\n            }\n\n            this.delegate = delegate;\n        }\n\n        @Override\n        public Iterator<Map.Entry<K, V>> iterator() {\n            final K fromKey = delegate.getFromKey();\n            final K toKey = delegate.getToKey();\n\n            TrieEntry<K, V> first = null;\n            if (fromKey == null) {\n                first = firstEntry();\n            } else {\n                first = ceilingEntry(fromKey);\n            }\n\n            TrieEntry<K, V> last = null;\n            if (toKey != null) {\n                last = ceilingEntry(toKey);\n            }\n\n            return new EntryIterator(first, last);\n        }\n\n        @Override\n        public int size() {\n            if (size == -1 || expectedModCount != AbstractPatriciaTrie.this.modCount) {\n                size = 0;\n\n                for (final Iterator<?> it = iterator(); it.hasNext(); it.next()) {\n                    ++size;\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n            return size;\n        }\n\n        @Override\n        public boolean isEmpty() {\n            return !iterator().hasNext();\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        @Override\n        public boolean contains(final Object o) {\n            if (!(o instanceof Map.Entry)) {\n                return false;\n            }\n\n            final Map.Entry<K, V> entry = (Map.Entry<K, V>) o;\n            final K key = entry.getKey();\n            if (!delegate.inRange(key)) {\n                return false;\n            }\n\n            final TrieEntry<K, V> node = getEntry(key);\n            return node != null && compare(node.getValue(), entry.getValue());\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        @Override\n        public boolean remove(final Object o) {\n            if (!(o instanceof Map.Entry)) {\n                return false;\n            }\n\n            final Map.Entry<K, V> entry = (Map.Entry<K, V>) o;\n            final K key = entry.getKey();\n            if (!delegate.inRange(key)) {\n                return false;\n            }\n\n            final TrieEntry<K, V> node = getEntry(key);\n            if (node != null && compare(node.getValue(), entry.getValue())) {\n                removeEntry(node);\n                return true;\n            }\n            return false;\n        }\n\n        /**\n         * An {@link Iterator} for {@link RangeEntrySet}s.\n         */\n        private final class EntryIterator extends TrieIterator<Map.Entry<K,V>> {\n\n            private final K excludedKey;\n\n            /**\n             * Creates a {@link EntryIterator}.\n             */\n            private EntryIterator(final TrieEntry<K,V> first, final TrieEntry<K,V> last) {\n                super(first);\n                this.excludedKey = last != null ? last.getKey() : null;\n            }\n\n            @Override\n            public boolean hasNext() {\n                return next != null && !compare(next.key, excludedKey);\n            }\n\n            @Override\n            public Map.Entry<K,V> next() {\n                if (next == null || compare(next.key, excludedKey)) {\n                    throw new NoSuchElementException();\n                }\n                return nextEntry();\n            }\n        }\n    }\n\n    /**\n     * A submap used for prefix views over the {@link Trie}.\n     */\n    private class PrefixRangeMap extends RangeMap {\n\n        private final K prefix;\n\n        private final int offsetInBits;\n\n        private final int lengthInBits;\n\n        private K fromKey = null;\n\n        private K toKey = null;\n\n        private transient int expectedModCount = 0;\n\n        private int size = -1;\n\n        /**\n         * Creates a {@link PrefixRangeMap}.\n         */\n        private PrefixRangeMap(final K prefix, final int offsetInBits, final int lengthInBits) {\n            this.prefix = prefix;\n            this.offsetInBits = offsetInBits;\n            this.lengthInBits = lengthInBits;\n        }\n\n        /**\n         * This method does two things. It determines the FROM\n         * and TO range of the {@link PrefixRangeMap} and the number\n         * of elements in the range. This method must be called every\n         * time the {@link Trie} has changed.\n         */\n        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\n                if (it.hasNext()) {\n                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }\n\n        @Override\n        public K firstKey() {\n            fixup();\n\n            Map.Entry<K,V> e = null;\n            if (fromKey == null) {\n                e = firstEntry();\n            } else {\n                e = higherEntry(fromKey);\n            }\n\n            final K first = e != null ? e.getKey() : null;\n            if (e == null || !getKeyAnalyzer().isPrefix(prefix, offsetInBits, lengthInBits, first)) {\n                throw new NoSuchElementException();\n            }\n\n            return first;\n        }\n\n        @Override\n        public K lastKey() {\n            fixup();\n\n            Map.Entry<K,V> e = null;\n            if (toKey == null) {\n                e = lastEntry();\n            } else {\n                e = lowerEntry(toKey);\n            }\n\n            final K last = e != null ? e.getKey() : null;\n            if (e == null || !getKeyAnalyzer().isPrefix(prefix, offsetInBits, lengthInBits, last)) {\n                throw new NoSuchElementException();\n            }\n\n            return last;\n        }\n\n        /**\n         * Returns true if this {@link PrefixRangeMap}'s key is a prefix of the provided key.\n         */\n        @Override\n        protected boolean inRange(final K key) {\n            return getKeyAnalyzer().isPrefix(prefix, offsetInBits, lengthInBits, key);\n        }\n\n        /**\n         * Same as {@link #inRange(Object)}.\n         */\n        @Override\n        protected boolean inRange2(final K key) {\n            return inRange(key);\n        }\n\n        /**\n         * Returns true if the provided Key is in the FROM range of the {@link PrefixRangeMap}.\n         */\n        @Override\n        protected boolean inFromRange(final K key, final boolean forceInclusive) {\n            return getKeyAnalyzer().isPrefix(prefix, offsetInBits, lengthInBits, key);\n        }\n\n        /**\n         * Returns true if the provided Key is in the TO range of the {@link PrefixRangeMap}.\n         */\n        @Override\n        protected boolean inToRange(final K key, final boolean forceInclusive) {\n            return getKeyAnalyzer().isPrefix(prefix, offsetInBits, lengthInBits, key);\n        }\n\n        @Override\n        protected Set<Map.Entry<K, V>> createEntrySet() {\n            return new PrefixRangeEntrySet(this);\n        }\n\n        @Override\n        public K getFromKey() {\n            return fromKey;\n        }\n\n        @Override\n        public K getToKey() {\n            return toKey;\n        }\n\n        @Override\n        public boolean isFromInclusive() {\n            return false;\n        }\n\n        @Override\n        public boolean isToInclusive() {\n            return false;\n        }\n\n        @Override\n        protected SortedMap<K, V> createRangeMap(final K fromKey, final boolean fromInclusive,\n                                                 final K toKey, final boolean toInclusive) {\n            return new RangeEntryMap(fromKey, fromInclusive, toKey, toInclusive);\n        }\n\n    }\n\n    /**\n     * A prefix {@link RangeEntrySet} view of the {@link Trie}.\n     */\n    private final class PrefixRangeEntrySet extends RangeEntrySet {\n\n        private final PrefixRangeMap delegate;\n\n        private TrieEntry<K, V> prefixStart;\n\n        private int expectedModCount = 0;\n\n        /**\n         * Creates a {@link PrefixRangeEntrySet}.\n         */\n        public PrefixRangeEntrySet(final PrefixRangeMap delegate) {\n            super(delegate);\n            this.delegate = delegate;\n        }\n\n        @Override\n        public int size() {\n            return delegate.fixup();\n        }\n\n        @Override\n        public Iterator<Map.Entry<K,V>> iterator() {\n            if (AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                prefixStart = subtree(delegate.prefix, delegate.offsetInBits, delegate.lengthInBits);\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            if (prefixStart == null) {\n                final Set<Map.Entry<K,V>> empty = Collections.emptySet();\n                return empty.iterator();\n            } else if (delegate.lengthInBits > prefixStart.bitIndex) {\n                return new SingletonIterator(prefixStart);\n            } else {\n                return new EntryIterator(prefixStart, delegate.prefix, delegate.offsetInBits, delegate.lengthInBits);\n            }\n        }\n\n        /**\n         * An {@link Iterator} that holds a single {@link TrieEntry}.\n         */\n        private final class SingletonIterator implements Iterator<Map.Entry<K, V>> {\n\n            private final TrieEntry<K, V> entry;\n\n            private int hit = 0;\n\n            public SingletonIterator(final TrieEntry<K, V> entry) {\n                this.entry = entry;\n            }\n\n            @Override\n            public boolean hasNext() {\n                return hit == 0;\n            }\n\n            @Override\n            public Map.Entry<K, V> next() {\n                if (hit != 0) {\n                    throw new NoSuchElementException();\n                }\n\n                ++hit;\n                return entry;\n            }\n\n            @Override\n            public void remove() {\n                if (hit != 1) {\n                    throw new IllegalStateException();\n                }\n\n                ++hit;\n                AbstractPatriciaTrie.this.removeEntry(entry);\n            }\n        }\n\n        /**\n         * An {@link Iterator} for iterating over a prefix search.\n         */\n        private final class EntryIterator extends TrieIterator<Map.Entry<K, V>> {\n\n            // values to reset the subtree if we remove it.\n            private final K prefix;\n            private final int offset;\n            private final int lengthInBits;\n            private boolean lastOne;\n\n            private TrieEntry<K, V> subtree; // the subtree to search within\n\n            /**\n             * Starts iteration at the given entry & search only\n             * within the given subtree.\n             */\n            EntryIterator(final TrieEntry<K, V> startScan, final K prefix,\n                    final int offset, final int lengthInBits) {\n                subtree = startScan;\n                next = AbstractPatriciaTrie.this.followLeft(startScan);\n                this.prefix = prefix;\n                this.offset = offset;\n                this.lengthInBits = lengthInBits;\n            }\n\n            @Override\n            public Map.Entry<K,V> next() {\n                final Map.Entry<K, V> entry = nextEntry();\n                if (lastOne) {\n                    next = null;\n                }\n                return entry;\n            }\n\n            @Override\n            protected TrieEntry<K, V> findNext(final TrieEntry<K, V> prior) {\n                return AbstractPatriciaTrie.this.nextEntryInSubtree(prior, subtree);\n            }\n\n            @Override\n            public void remove() {\n                // If the current entry we're removing is the subtree\n                // then we need to find a new subtree parent.\n                boolean needsFixing = false;\n                final int bitIdx = subtree.bitIndex;\n                if (current == subtree) {\n                    needsFixing = true;\n                }\n\n                super.remove();\n\n                // If the subtree changed its bitIndex or we\n                // removed the old subtree, get a new one.\n                if (bitIdx != subtree.bitIndex || needsFixing) {\n                    subtree = subtree(prefix, offset, lengthInBits);\n                }\n\n                // If the subtree's bitIndex is less than the\n                // length of our prefix, it's the last item\n                // in the prefix tree.\n                if (lengthInBits >= subtree.bitIndex) {\n                    lastOne = true;\n                }\n            }\n        }\n    }\n\n    //-----------------------------------------------------------------------\n\n    /**\n     * Reads the content of the stream.\n     */\n    @SuppressWarnings(\"unchecked\") // This will fail at runtime if the stream is incorrect\n    private void readObject(final ObjectInputStream stream) throws IOException, ClassNotFoundException{\n        stream.defaultReadObject();\n        root = new TrieEntry<K, V>(null, null, -1);\n        int size = stream.readInt();\n        for(int i = 0; i < size; i++){\n            K k = (K) stream.readObject();\n            V v = (V) stream.readObject();\n            put(k, v);\n        }\n    }\n\n    /**\n     * Writes the content to the stream for serialization.\n     */\n    private void writeObject(final ObjectOutputStream stream) throws IOException{\n        stream.defaultWriteObject();\n        stream.writeInt(this.size());\n        for (final Entry<K, V> entry : entrySet()) {\n            stream.writeObject(entry.getKey());\n            stream.writeObject(entry.getValue());\n        }\n    }\n\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.collections4.trie;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.util.AbstractCollection;\nimport java.util.AbstractMap;\nimport java.util.AbstractSet;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.ConcurrentModificationException;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Set;\nimport java.util.SortedMap;\n\nimport org.apache.commons.collections4.OrderedMapIterator;\n\n/**\n * This class implements the base PATRICIA algorithm and everything that\n * is related to the {@link Map} interface.\n *\n * @since 4.0\n * @version $Id$\n */\nabstract class AbstractPatriciaTrie<K, V> extends AbstractBitwiseTrie<K, V> {\n\n    private static final long serialVersionUID = 5155253417231339498L;\n\n    /** The root node of the {@link Trie}. */\n    private transient TrieEntry<K, V> root = new TrieEntry<K, V>(null, null, -1);\n\n    /**\n     * Each of these fields are initialized to contain an instance of the\n     * appropriate view the first time this view is requested. The views are\n     * stateless, so there's no reason to create more than one of each.\n     */\n    private transient volatile Set<K> keySet;\n    private transient volatile Collection<V> values;\n    private transient volatile Set<Map.Entry<K,V>> entrySet;\n\n    /** The current size of the {@link Trie}. */\n    private transient int size = 0;\n\n    /**\n     * The number of times this {@link Trie} has been modified.\n     * It's used to detect concurrent modifications and fail-fast the {@link Iterator}s.\n     */\n    protected transient int modCount = 0;\n\n    protected AbstractPatriciaTrie(final KeyAnalyzer<? super K> keyAnalyzer) {\n        super(keyAnalyzer);\n    }\n\n    /**\n     * Constructs a new {@link org.apache.commons.collections4.Trie Trie} using the given\n     * {@link KeyAnalyzer} and initializes the {@link org.apache.commons.collections4.Trie Trie}\n     * with the values from the provided {@link Map}.\n     */\n    protected AbstractPatriciaTrie(final KeyAnalyzer<? super K> keyAnalyzer,\n                                   final Map<? extends K, ? extends V> map) {\n        super(keyAnalyzer);\n        putAll(map);\n    }\n\n    //-----------------------------------------------------------------------\n    @Override\n    public void clear() {\n        root.key = null;\n        root.bitIndex = -1;\n        root.value = null;\n\n        root.parent = null;\n        root.left = root;\n        root.right = null;\n        root.predecessor = root;\n\n        size = 0;\n        incrementModCount();\n    }\n\n    @Override\n    public int size() {\n        return size;\n    }\n\n    /**\n     * A helper method to increment the {@link Trie} size and the modification counter.\n     */\n    void incrementSize() {\n        size++;\n        incrementModCount();\n    }\n\n    /**\n     * A helper method to decrement the {@link Trie} size and increment the modification counter.\n     */\n    void decrementSize() {\n        size--;\n        incrementModCount();\n    }\n\n    /**\n     * A helper method to increment the modification counter.\n     */\n    private void incrementModCount() {\n        ++modCount;\n    }\n\n    @Override\n    public V put(final K key, final V value) {\n        if (key == null) {\n            throw new NullPointerException(\"Key cannot be null\");\n        }\n\n        final int lengthInBits = lengthInBits(key);\n\n        // The only place to store a key with a length\n        // of zero bits is the root node\n        if (lengthInBits == 0) {\n            if (root.isEmpty()) {\n                incrementSize();\n            } else {\n                incrementModCount();\n            }\n            return root.setKeyValue(key, value);\n        }\n\n        final TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);\n        if (compareKeys(key, found.key)) {\n            if (found.isEmpty()) { // <- must be the root\n                incrementSize();\n            } else {\n                incrementModCount();\n            }\n            return found.setKeyValue(key, value);\n        }\n\n        final int bitIndex = bitIndex(key, found.key);\n        if (!KeyAnalyzer.isOutOfBoundsIndex(bitIndex)) {\n            if (KeyAnalyzer.isValidBitIndex(bitIndex)) { // in 99.999...9% the case\n                /* NEW KEY+VALUE TUPLE */\n                final TrieEntry<K, V> t = new TrieEntry<K, V>(key, value, bitIndex);\n                addEntry(t, lengthInBits);\n                incrementSize();\n                return null;\n            } else if (KeyAnalyzer.isNullBitKey(bitIndex)) {\n                // A bits of the Key are zero. The only place to\n                // store such a Key is the root Node!\n\n                /* NULL BIT KEY */\n                if (root.isEmpty()) {\n                    incrementSize();\n                } else {\n                    incrementModCount();\n                }\n                return root.setKeyValue(key, value);\n\n            } else if (KeyAnalyzer.isEqualBitKey(bitIndex)) {\n                // This is a very special and rare case.\n\n                /* REPLACE OLD KEY+VALUE */\n                if (found != root) {\n                    incrementModCount();\n                    return found.setKeyValue(key, value);\n                }\n            }\n        }\n\n        throw new IllegalArgumentException(\"Failed to put: \" + key + \" -> \" + value + \", \" + bitIndex);\n    }\n\n    /**\n     * Adds the given {@link TrieEntry} to the {@link Trie}.\n     */\n    TrieEntry<K, V> addEntry(final TrieEntry<K, V> entry, final int lengthInBits) {\n        TrieEntry<K, V> current = root.left;\n        TrieEntry<K, V> path = root;\n        while(true) {\n            if (current.bitIndex >= entry.bitIndex\n                    || current.bitIndex <= path.bitIndex) {\n                entry.predecessor = entry;\n\n                if (!isBitSet(entry.key, entry.bitIndex, lengthInBits)) {\n                    entry.left = entry;\n                    entry.right = current;\n                } else {\n                    entry.left = current;\n                    entry.right = entry;\n                }\n\n                entry.parent = path;\n                if (current.bitIndex >= entry.bitIndex) {\n                    current.parent = entry;\n                }\n\n                // if we inserted an uplink, set the predecessor on it\n                if (current.bitIndex <= path.bitIndex) {\n                    current.predecessor = entry;\n                }\n\n                if (path == root || !isBitSet(entry.key, path.bitIndex, lengthInBits)) {\n                    path.left = entry;\n                } else {\n                    path.right = entry;\n                }\n\n                return entry;\n            }\n\n            path = current;\n\n            if (!isBitSet(entry.key, current.bitIndex, lengthInBits)) {\n                current = current.left;\n            } else {\n                current = current.right;\n            }\n        }\n    }\n\n    @Override\n    public V get(final Object k) {\n        final TrieEntry<K, V> entry = getEntry(k);\n        return entry != null ? entry.getValue() : null;\n    }\n\n    /**\n     * Returns the entry associated with the specified key in the\n     * PatriciaTrieBase.  Returns null if the map contains no mapping\n     * for this key.\n     * <p>\n     * This may throw ClassCastException if the object is not of type K.\n     */\n    TrieEntry<K,V> getEntry(final Object k) {\n        final K key = castKey(k);\n        if (key == null) {\n            return null;\n        }\n\n        final int lengthInBits = lengthInBits(key);\n        final TrieEntry<K,V> entry = getNearestEntryForKey(key, lengthInBits);\n        return !entry.isEmpty() && compareKeys(key, entry.key) ? entry : null;\n    }\n\n    /**\n     * Returns the {@link Entry} whose key is closest in a bitwise XOR\n     * metric to the given key. This is NOT lexicographic closeness.\n     * For example, given the keys:\n     *\n     * <ol>\n     * <li>D = 1000100\n     * <li>H = 1001000\n     * <li>L = 1001100\n     * </ol>\n     *\n     * If the {@link Trie} contained 'H' and 'L', a lookup of 'D' would\n     * return 'L', because the XOR distance between D &amp; L is smaller\n     * than the XOR distance between D &amp; H.\n     *\n     * @param key  the key to use in the search\n     * @return the {@link Entry} whose key is closest in a bitwise XOR metric\n     *   to the provided key\n     */\n    public Map.Entry<K, V> select(final K key) {\n        final int lengthInBits = lengthInBits(key);\n        final Reference<Map.Entry<K, V>> reference = new Reference<Map.Entry<K,V>>();\n        if (!selectR(root.left, -1, key, lengthInBits, reference)) {\n            return reference.get();\n        }\n        return null;\n    }\n\n    /**\n     * Returns the key that is closest in a bitwise XOR metric to the\n     * provided key. This is NOT lexicographic closeness!\n     *\n     * For example, given the keys:\n     *\n     * <ol>\n     * <li>D = 1000100\n     * <li>H = 1001000\n     * <li>L = 1001100\n     * </ol>\n     *\n     * If the {@link Trie} contained 'H' and 'L', a lookup of 'D' would\n     * return 'L', because the XOR distance between D &amp; L is smaller\n     * than the XOR distance between D &amp; H.\n     *\n     * @param key  the key to use in the search\n     * @return the key that is closest in a bitwise XOR metric to the provided key\n     */\n    public K selectKey(final K key) {\n        final Map.Entry<K, V> entry = select(key);\n        if (entry == null) {\n            return null;\n        }\n        return entry.getKey();\n    }\n\n    /**\n     * Returns the value whose key is closest in a bitwise XOR metric to\n     * the provided key. This is NOT lexicographic closeness!\n     *\n     * For example, given the keys:\n     *\n     * <ol>\n     * <li>D = 1000100\n     * <li>H = 1001000\n     * <li>L = 1001100\n     * </ol>\n     *\n     * If the {@link Trie} contained 'H' and 'L', a lookup of 'D' would\n     * return 'L', because the XOR distance between D &amp; L is smaller\n     * than the XOR distance between D &amp; H.\n     *\n     * @param key  the key to use in the search\n     * @return the value whose key is closest in a bitwise XOR metric\n     * to the provided key\n     */\n    public V selectValue(final K key) {\n        final Map.Entry<K, V> entry = select(key);\n        if (entry == null) {\n            return null;\n        }\n        return entry.getValue();\n    }\n\n    /**\n     * This is equivalent to the other {@link #selectR(TrieEntry, int, Object, int, Cursor, Reference)}\n     * method but without its overhead because we're selecting only one best matching Entry from the {@link Trie}.\n     */\n    private boolean selectR(final TrieEntry<K, V> h, final int bitIndex,\n                            final K key, final int lengthInBits,\n                            final Reference<Map.Entry<K, V>> reference) {\n\n        if (h.bitIndex <= bitIndex) {\n            // If we hit the root Node and it is empty\n            // we have to look for an alternative best\n            // matching node.\n            if (!h.isEmpty()) {\n                reference.set(h);\n                return false;\n            }\n            return true;\n        }\n\n        if (!isBitSet(key, h.bitIndex, lengthInBits)) {\n            if (selectR(h.left, h.bitIndex, key, lengthInBits, reference)) {\n                return selectR(h.right, h.bitIndex, key, lengthInBits, reference);\n            }\n        } else {\n            if (selectR(h.right, h.bitIndex, key, lengthInBits, reference)) {\n                return selectR(h.left, h.bitIndex, key, lengthInBits, reference);\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public boolean containsKey(final Object k) {\n        if (k == null) {\n            return false;\n        }\n\n        final K key = castKey(k);\n        final int lengthInBits = lengthInBits(key);\n        final TrieEntry<K, V> entry = getNearestEntryForKey(key, lengthInBits);\n        return !entry.isEmpty() && compareKeys(key, entry.key);\n    }\n\n    @Override\n    public Set<Map.Entry<K,V>> entrySet() {\n        if (entrySet == null) {\n            entrySet = new EntrySet();\n        }\n        return entrySet;\n    }\n\n    @Override\n    public Set<K> keySet() {\n        if (keySet == null) {\n            keySet = new KeySet();\n        }\n        return keySet;\n    }\n\n    @Override\n    public Collection<V> values() {\n        if (values == null) {\n            values = new Values();\n        }\n        return values;\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * @throws ClassCastException if provided key is of an incompatible type\n     */\n    @Override\n    public V remove(final Object k) {\n        if (k == null) {\n            return null;\n        }\n\n        final K key = castKey(k);\n        final int lengthInBits = lengthInBits(key);\n        TrieEntry<K, V> current = root.left;\n        TrieEntry<K, V> path = root;\n        while (true) {\n            if (current.bitIndex <= path.bitIndex) {\n                if (!current.isEmpty() && compareKeys(key, current.key)) {\n                    return removeEntry(current);\n                }\n                return null;\n            }\n\n            path = current;\n\n            if (!isBitSet(key, current.bitIndex, lengthInBits)) {\n                current = current.left;\n            } else {\n                current = current.right;\n            }\n        }\n    }\n\n    /**\n     * Returns the nearest entry for a given key.  This is useful\n     * for finding knowing if a given key exists (and finding the value\n     * for it), or for inserting the key.\n     *\n     * The actual get implementation. This is very similar to\n     * selectR but with the exception that it might return the\n     * root Entry even if it's empty.\n     */\n    TrieEntry<K, V> getNearestEntryForKey(final K key, final int lengthInBits) {\n        TrieEntry<K, V> current = root.left;\n        TrieEntry<K, V> path = root;\n        while(true) {\n            if (current.bitIndex <= path.bitIndex) {\n                return current;\n            }\n\n            path = current;\n            if (!isBitSet(key, current.bitIndex, lengthInBits)) {\n                current = current.left;\n            } else {\n                current = current.right;\n            }\n        }\n    }\n\n    /**\n     * Removes a single entry from the {@link Trie}.\n     *\n     * If we found a Key (Entry h) then figure out if it's\n     * an internal (hard to remove) or external Entry (easy\n     * to remove)\n     */\n    V removeEntry(final TrieEntry<K, V> h) {\n        if (h != root) {\n            if (h.isInternalNode()) {\n                removeInternalEntry(h);\n            } else {\n                removeExternalEntry(h);\n            }\n        }\n\n        decrementSize();\n        return h.setKeyValue(null, null);\n    }\n\n    /**\n     * Removes an external entry from the {@link Trie}.\n     *\n     * If it's an external Entry then just remove it.\n     * This is very easy and straight forward.\n     */\n    private void removeExternalEntry(final TrieEntry<K, V> h) {\n        if (h == root) {\n            throw new IllegalArgumentException(\"Cannot delete root Entry!\");\n        } else if (!h.isExternalNode()) {\n            throw new IllegalArgumentException(h + \" is not an external Entry!\");\n        }\n\n        final TrieEntry<K, V> parent = h.parent;\n        final TrieEntry<K, V> child = h.left == h ? h.right : h.left;\n\n        if (parent.left == h) {\n            parent.left = child;\n        } else {\n            parent.right = child;\n        }\n\n        // either the parent is changing, or the predecessor is changing.\n        if (child.bitIndex > parent.bitIndex) {\n            child.parent = parent;\n        } else {\n            child.predecessor = parent;\n        }\n\n    }\n\n    /**\n     * Removes an internal entry from the {@link Trie}.\n     *\n     * If it's an internal Entry then \"good luck\" with understanding\n     * this code. The Idea is essentially that Entry p takes Entry h's\n     * place in the trie which requires some re-wiring.\n     */\n    private void removeInternalEntry(final TrieEntry<K, V> h) {\n        if (h == root) {\n            throw new IllegalArgumentException(\"Cannot delete root Entry!\");\n        } else if (!h.isInternalNode()) {\n            throw new IllegalArgumentException(h + \" is not an internal Entry!\");\n        }\n\n        final TrieEntry<K, V> p = h.predecessor;\n\n        // Set P's bitIndex\n        p.bitIndex = h.bitIndex;\n\n        // Fix P's parent, predecessor and child Nodes\n        {\n            final TrieEntry<K, V> parent = p.parent;\n            final TrieEntry<K, V> child = p.left == h ? p.right : p.left;\n\n            // if it was looping to itself previously,\n            // it will now be pointed from it's parent\n            // (if we aren't removing it's parent --\n            //  in that case, it remains looping to itself).\n            // otherwise, it will continue to have the same\n            // predecessor.\n            if (p.predecessor == p && p.parent != h) {\n                p.predecessor = p.parent;\n            }\n\n            if (parent.left == p) {\n                parent.left = child;\n            } else {\n                parent.right = child;\n            }\n\n            if (child.bitIndex > parent.bitIndex) {\n                child.parent = parent;\n            }\n        }\n\n        // Fix H's parent and child Nodes\n        {\n            // If H is a parent of its left and right child\n            // then change them to P\n            if (h.left.parent == h) {\n                h.left.parent = p;\n            }\n\n            if (h.right.parent == h) {\n                h.right.parent = p;\n            }\n\n            // Change H's parent\n            if (h.parent.left == h) {\n                h.parent.left = p;\n            } else {\n                h.parent.right = p;\n            }\n        }\n\n        // Copy the remaining fields from H to P\n        //p.bitIndex = h.bitIndex;\n        p.parent = h.parent;\n        p.left = h.left;\n        p.right = h.right;\n\n        // Make sure that if h was pointing to any uplinks,\n        // p now points to them.\n        if (isValidUplink(p.left, p)) {\n            p.left.predecessor = p;\n        }\n\n        if (isValidUplink(p.right, p)) {\n            p.right.predecessor = p;\n        }\n    }\n\n    /**\n     * Returns the entry lexicographically after the given entry.\n     * If the given entry is null, returns the first node.\n     */\n    TrieEntry<K, V> nextEntry(final TrieEntry<K, V> node) {\n        if (node == null) {\n            return firstEntry();\n        }\n        return nextEntryImpl(node.predecessor, node, null);\n    }\n\n    /**\n     * Scans for the next node, starting at the specified point, and using 'previous'\n     * as a hint that the last node we returned was 'previous' (so we know not to return\n     * it again).  If 'tree' is non-null, this will limit the search to the given tree.\n     *\n     * The basic premise is that each iteration can follow the following steps:\n     *\n     * 1) Scan all the way to the left.\n     *   a) If we already started from this node last time, proceed to Step 2.\n     *   b) If a valid uplink is found, use it.\n     *   c) If the result is an empty node (root not set), break the scan.\n     *   d) If we already returned the left node, break the scan.\n     *\n     * 2) Check the right.\n     *   a) If we already returned the right node, proceed to Step 3.\n     *   b) If it is a valid uplink, use it.\n     *   c) Do Step 1 from the right node.\n     *\n     * 3) Back up through the parents until we encounter find a parent\n     *    that we're not the right child of.\n     *\n     * 4) If there's no right child of that parent, the iteration is finished.\n     *    Otherwise continue to Step 5.\n     *\n     * 5) Check to see if the right child is a valid uplink.\n     *    a) If we already returned that child, proceed to Step 6.\n     *       Otherwise, use it.\n     *\n     * 6) If the right child of the parent is the parent itself, we've\n     *    already found & returned the end of the Trie, so exit.\n     *\n     * 7) Do Step 1 on the parent's right child.\n     */\n    TrieEntry<K, V> nextEntryImpl(final TrieEntry<K, V> start,\n            final TrieEntry<K, V> previous, final TrieEntry<K, V> tree) {\n\n        TrieEntry<K, V> current = start;\n\n        // Only look at the left if this was a recursive or\n        // the first check, otherwise we know we've already looked\n        // at the left.\n        if (previous == null || start != previous.predecessor) {\n            while (!current.left.isEmpty()) {\n                // stop traversing if we've already\n                // returned the left of this node.\n                if (previous == current.left) {\n                    break;\n                }\n\n                if (isValidUplink(current.left, current)) {\n                    return current.left;\n                }\n\n                current = current.left;\n            }\n        }\n\n        // If there's no data at all, exit.\n        if (current.isEmpty()) {\n            return null;\n        }\n\n        // If we've already returned the left,\n        // and the immediate right is null,\n        // there's only one entry in the Trie\n        // which is stored at the root.\n        //\n        //  / (\"\")   <-- root\n        //  \\_/  \\\n        //       null <-- 'current'\n        //\n        if (current.right == null) {\n            return null;\n        }\n\n        // If nothing valid on the left, try the right.\n        if (previous != current.right) {\n            // See if it immediately is valid.\n            if (isValidUplink(current.right, current)) {\n                return current.right;\n            }\n\n            // Must search on the right's side if it wasn't initially valid.\n            return nextEntryImpl(current.right, previous, tree);\n        }\n\n        // Neither left nor right are valid, find the first parent\n        // whose child did not come from the right & traverse it.\n        while (current == current.parent.right) {\n            // If we're going to traverse to above the subtree, stop.\n            if (current == tree) {\n                return null;\n            }\n\n            current = current.parent;\n        }\n\n        // If we're on the top of the subtree, we can't go any higher.\n        if (current == tree) {\n            return null;\n        }\n\n        // If there's no right, the parent must be root, so we're done.\n        if (current.parent.right == null) {\n            return null;\n        }\n\n        // If the parent's right points to itself, we've found one.\n        if (previous != current.parent.right\n                && isValidUplink(current.parent.right, current.parent)) {\n            return current.parent.right;\n        }\n\n        // If the parent's right is itself, there can't be any more nodes.\n        if (current.parent.right == current.parent) {\n            return null;\n        }\n\n        // We need to traverse down the parent's right's path.\n        return nextEntryImpl(current.parent.right, previous, tree);\n    }\n\n    /**\n     * Returns the first entry the {@link Trie} is storing.\n     * <p>\n     * This is implemented by going always to the left until\n     * we encounter a valid uplink. That uplink is the first key.\n     */\n    TrieEntry<K, V> firstEntry() {\n        // if Trie is empty, no first node.\n        if (isEmpty()) {\n            return null;\n        }\n\n        return followLeft(root);\n    }\n\n    /**\n     * Goes left through the tree until it finds a valid node.\n     */\n    TrieEntry<K, V> followLeft(TrieEntry<K, V> node) {\n        while(true) {\n            TrieEntry<K, V> child = node.left;\n            // if we hit root and it didn't have a node, go right instead.\n            if (child.isEmpty()) {\n                child = node.right;\n            }\n\n            if (child.bitIndex <= node.bitIndex) {\n                return child;\n            }\n\n            node = child;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n\n    @Override\n    public Comparator<? super K> comparator() {\n        return getKeyAnalyzer();\n    }\n\n    @Override\n    public K firstKey() {\n        if (size() == 0) {\n            throw new NoSuchElementException();\n        }\n        return firstEntry().getKey();\n    }\n\n    @Override\n    public K lastKey() {\n        final TrieEntry<K, V> entry = lastEntry();\n        if (entry != null) {\n            return entry.getKey();\n        }\n        throw new NoSuchElementException();\n    }\n\n    @Override\n    public K nextKey(final K key) {\n        if (key == null) {\n            throw new NullPointerException();\n        }\n        final TrieEntry<K, V> entry = getEntry(key);\n        if (entry != null) {\n            final TrieEntry<K, V> nextEntry = nextEntry(entry);\n            return nextEntry != null ? nextEntry.getKey() : null;\n        }\n        return null;\n    }\n\n    @Override\n    public K previousKey(final K key) {\n        if (key == null) {\n            throw new NullPointerException();\n        }\n        final TrieEntry<K, V> entry = getEntry(key);\n        if (entry != null) {\n            final TrieEntry<K, V> prevEntry = previousEntry(entry);\n            return prevEntry != null ? prevEntry.getKey() : null;\n        }\n        return null;\n    }\n\n    @Override\n    public OrderedMapIterator<K, V> mapIterator() {\n        return new TrieMapIterator();\n    }\n\n    @Override\n    public SortedMap<K, V> prefixMap(final K key) {\n        return getPrefixMapByBits(key, 0, lengthInBits(key));\n    }\n\n    /**\n     * Returns a view of this {@link Trie} of all elements that are prefixed\n     * by the number of bits in the given Key.\n     * <p>\n     * The view that this returns is optimized to have a very efficient\n     * {@link Iterator}. The {@link SortedMap#firstKey()},\n     * {@link SortedMap#lastKey()} &amp; {@link Map#size()} methods must\n     * iterate over all possible values in order to determine the results.\n     * This information is cached until the PATRICIA {@link Trie} changes.\n     * All other methods (except {@link Iterator}) must compare the given\n     * key to the prefix to ensure that it is within the range of the view.\n     * The {@link Iterator}'s remove method must also relocate the subtree\n     * that contains the prefixes if the entry holding the subtree is\n     * removed or changes. Changing the subtree takes O(K) time.\n     *\n     * @param key  the key to use in the search\n     * @param offsetInBits  the prefix offset\n     * @param lengthInBits  the number of significant prefix bits\n     * @return a {@link SortedMap} view of this {@link Trie} with all elements whose\n     *   key is prefixed by the search key\n     */\n    private SortedMap<K, V> getPrefixMapByBits(final K key, final int offsetInBits, final int lengthInBits) {\n\n        final int offsetLength = offsetInBits + lengthInBits;\n        if (offsetLength > lengthInBits(key)) {\n            throw new IllegalArgumentException(offsetInBits + \" + \"\n                    + lengthInBits + \" > \" + lengthInBits(key));\n        }\n\n        if (offsetLength == 0) {\n            return this;\n        }\n\n        return new PrefixRangeMap(key, offsetInBits, lengthInBits);\n    }\n\n    @Override\n    public SortedMap<K, V> headMap(final K toKey) {\n        return new RangeEntryMap(null, toKey);\n    }\n\n    @Override\n    public SortedMap<K, V> subMap(final K fromKey, final K toKey) {\n        return new RangeEntryMap(fromKey, toKey);\n    }\n\n    @Override\n    public SortedMap<K, V> tailMap(final K fromKey) {\n        return new RangeEntryMap(fromKey, null);\n    }\n\n    /**\n     * Returns an entry strictly higher than the given key,\n     * or null if no such entry exists.\n     */\n    TrieEntry<K,V> higherEntry(final K key) {\n        // TODO: Cleanup so that we don't actually have to add/remove from the\n        //       tree.  (We do it here because there are other well-defined\n        //       functions to perform the search.)\n        final int lengthInBits = lengthInBits(key);\n\n        if (lengthInBits == 0) {\n            if (!root.isEmpty()) {\n                // If data in root, and more after -- return it.\n                if (size() > 1) {\n                    return nextEntry(root);\n                }\n                // If no more after, no higher entry.\n                return null;\n            }\n            // Root is empty & we want something after empty, return first.\n            return firstEntry();\n        }\n\n        final TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);\n        if (compareKeys(key, found.key)) {\n            return nextEntry(found);\n        }\n\n        final int bitIndex = bitIndex(key, found.key);\n        if (KeyAnalyzer.isValidBitIndex(bitIndex)) {\n            final TrieEntry<K, V> added = new TrieEntry<K, V>(key, null, bitIndex);\n            addEntry(added, lengthInBits);\n            incrementSize(); // must increment because remove will decrement\n            final TrieEntry<K, V> ceil = nextEntry(added);\n            removeEntry(added);\n            modCount -= 2; // we didn't really modify it.\n            return ceil;\n        } else if (KeyAnalyzer.isNullBitKey(bitIndex)) {\n            if (!root.isEmpty()) {\n                return firstEntry();\n            } else if (size() > 1) {\n                return nextEntry(firstEntry());\n            } else {\n                return null;\n            }\n        } else if (KeyAnalyzer.isEqualBitKey(bitIndex)) {\n            return nextEntry(found);\n        }\n\n        // we should have exited above.\n        throw new IllegalStateException(\"invalid lookup: \" + key);\n    }\n\n    /**\n     * Returns a key-value mapping associated with the least key greater\n     * than or equal to the given key, or null if there is no such key.\n     */\n    TrieEntry<K,V> ceilingEntry(final K key) {\n        // Basically:\n        // Follow the steps of adding an entry, but instead...\n        //\n        // - If we ever encounter a situation where we found an equal\n        //   key, we return it immediately.\n        //\n        // - If we hit an empty root, return the first iterable item.\n        //\n        // - If we have to add a new item, we temporarily add it,\n        //   find the successor to it, then remove the added item.\n        //\n        // These steps ensure that the returned value is either the\n        // entry for the key itself, or the first entry directly after\n        // the key.\n\n        // TODO: Cleanup so that we don't actually have to add/remove from the\n        //       tree.  (We do it here because there are other well-defined\n        //       functions to perform the search.)\n        final int lengthInBits = lengthInBits(key);\n\n        if (lengthInBits == 0) {\n            if (!root.isEmpty()) {\n                return root;\n            }\n            return firstEntry();\n        }\n\n        final TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);\n        if (compareKeys(key, found.key)) {\n            return found;\n        }\n\n        final int bitIndex = bitIndex(key, found.key);\n        if (KeyAnalyzer.isValidBitIndex(bitIndex)) {\n            final TrieEntry<K, V> added = new TrieEntry<K, V>(key, null, bitIndex);\n            addEntry(added, lengthInBits);\n            incrementSize(); // must increment because remove will decrement\n            final TrieEntry<K, V> ceil = nextEntry(added);\n            removeEntry(added);\n            modCount -= 2; // we didn't really modify it.\n            return ceil;\n        } else if (KeyAnalyzer.isNullBitKey(bitIndex)) {\n            if (!root.isEmpty()) {\n                return root;\n            }\n            return firstEntry();\n        } else if (KeyAnalyzer.isEqualBitKey(bitIndex)) {\n            return found;\n        }\n\n        // we should have exited above.\n        throw new IllegalStateException(\"invalid lookup: \" + key);\n    }\n\n    /**\n     * Returns a key-value mapping associated with the greatest key\n     * strictly less than the given key, or null if there is no such key.\n     */\n    TrieEntry<K,V> lowerEntry(final K key) {\n        // Basically:\n        // Follow the steps of adding an entry, but instead...\n        //\n        // - If we ever encounter a situation where we found an equal\n        //   key, we return it's previousEntry immediately.\n        //\n        // - If we hit root (empty or not), return null.\n        //\n        // - If we have to add a new item, we temporarily add it,\n        //   find the previousEntry to it, then remove the added item.\n        //\n        // These steps ensure that the returned value is always just before\n        // the key or null (if there was nothing before it).\n\n        // TODO: Cleanup so that we don't actually have to add/remove from the\n        //       tree.  (We do it here because there are other well-defined\n        //       functions to perform the search.)\n        final int lengthInBits = lengthInBits(key);\n\n        if (lengthInBits == 0) {\n            return null; // there can never be anything before root.\n        }\n\n        final TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);\n        if (compareKeys(key, found.key)) {\n            return previousEntry(found);\n        }\n\n        final int bitIndex = bitIndex(key, found.key);\n        if (KeyAnalyzer.isValidBitIndex(bitIndex)) {\n            final TrieEntry<K, V> added = new TrieEntry<K, V>(key, null, bitIndex);\n            addEntry(added, lengthInBits);\n            incrementSize(); // must increment because remove will decrement\n            final TrieEntry<K, V> prior = previousEntry(added);\n            removeEntry(added);\n            modCount -= 2; // we didn't really modify it.\n            return prior;\n        } else if (KeyAnalyzer.isNullBitKey(bitIndex)) {\n            return null;\n        } else if (KeyAnalyzer.isEqualBitKey(bitIndex)) {\n            return previousEntry(found);\n        }\n\n        // we should have exited above.\n        throw new IllegalStateException(\"invalid lookup: \" + key);\n    }\n\n    /**\n     * Returns a key-value mapping associated with the greatest key\n     * less than or equal to the given key, or null if there is no such key.\n     */\n    TrieEntry<K,V> floorEntry(final K key) {\n        // TODO: Cleanup so that we don't actually have to add/remove from the\n        //       tree.  (We do it here because there are other well-defined\n        //       functions to perform the search.)\n        final int lengthInBits = lengthInBits(key);\n\n        if (lengthInBits == 0) {\n            if (!root.isEmpty()) {\n                return root;\n            }\n            return null;\n        }\n\n        final TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);\n        if (compareKeys(key, found.key)) {\n            return found;\n        }\n\n        final int bitIndex = bitIndex(key, found.key);\n        if (KeyAnalyzer.isValidBitIndex(bitIndex)) {\n            final TrieEntry<K, V> added = new TrieEntry<K, V>(key, null, bitIndex);\n            addEntry(added, lengthInBits);\n            incrementSize(); // must increment because remove will decrement\n            final TrieEntry<K, V> floor = previousEntry(added);\n            removeEntry(added);\n            modCount -= 2; // we didn't really modify it.\n            return floor;\n        } else if (KeyAnalyzer.isNullBitKey(bitIndex)) {\n            if (!root.isEmpty()) {\n                return root;\n            }\n            return null;\n        } else if (KeyAnalyzer.isEqualBitKey(bitIndex)) {\n            return found;\n        }\n\n        // we should have exited above.\n        throw new IllegalStateException(\"invalid lookup: \" + key);\n    }\n\n    /**\n     * Finds the subtree that contains the prefix.\n     *\n     * This is very similar to getR but with the difference that\n     * we stop the lookup if h.bitIndex > lengthInBits.\n     */\n    TrieEntry<K, V> subtree(final K prefix, final int offsetInBits, final int lengthInBits) {\n        TrieEntry<K, V> current = root.left;\n        TrieEntry<K, V> path = root;\n        while(true) {\n            if (current.bitIndex <= path.bitIndex || lengthInBits <= current.bitIndex) {\n                break;\n            }\n\n            path = current;\n            if (!isBitSet(prefix, offsetInBits + current.bitIndex, offsetInBits + lengthInBits)) {\n                current = current.left;\n            } else {\n                current = current.right;\n            }\n        }\n\n        // Make sure the entry is valid for a subtree.\n        final TrieEntry<K, V> entry = current.isEmpty() ? path : current;\n\n        // If entry is root, it can't be empty.\n        if (entry.isEmpty()) {\n            return null;\n        }\n\n        final int endIndexInBits = offsetInBits + lengthInBits;\n\n        // if root && length of root is less than length of lookup,\n        // there's nothing.\n        // (this prevents returning the whole subtree if root has an empty\n        //  string and we want to lookup things with \"\\0\")\n        if (entry == root && lengthInBits(entry.getKey()) < endIndexInBits) {\n            return null;\n        }\n\n        // Found key's length-th bit differs from our key\n        // which means it cannot be the prefix...\n        if (isBitSet(prefix, endIndexInBits - 1, endIndexInBits)\n                != isBitSet(entry.key, lengthInBits - 1, lengthInBits(entry.key))) {\n            return null;\n        }\n\n        // ... or there are less than 'length' equal bits\n        final int bitIndex = getKeyAnalyzer().bitIndex(prefix, offsetInBits, lengthInBits,\n                                                       entry.key, 0, lengthInBits(entry.getKey()));\n\n        if (bitIndex >= 0 && bitIndex < lengthInBits) {\n            return null;\n        }\n\n        return entry;\n    }\n\n    /**\n     * Returns the last entry the {@link Trie} is storing.\n     *\n     * <p>This is implemented by going always to the right until\n     * we encounter a valid uplink. That uplink is the last key.\n     */\n    TrieEntry<K, V> lastEntry() {\n        return followRight(root.left);\n    }\n\n    /**\n     * Traverses down the right path until it finds an uplink.\n     */\n    TrieEntry<K, V> followRight(TrieEntry<K, V> node) {\n        // if Trie is empty, no last entry.\n        if (node.right == null) {\n            return null;\n        }\n\n        // Go as far right as possible, until we encounter an uplink.\n        while (node.right.bitIndex > node.bitIndex) {\n            node = node.right;\n        }\n\n        return node.right;\n    }\n\n    /**\n     * Returns the node lexicographically before the given node (or null if none).\n     *\n     * This follows four simple branches:\n     *  - If the uplink that returned us was a right uplink:\n     *      - If predecessor's left is a valid uplink from predecessor, return it.\n     *      - Else, follow the right path from the predecessor's left.\n     *  - If the uplink that returned us was a left uplink:\n     *      - Loop back through parents until we encounter a node where\n     *        node != node.parent.left.\n     *          - If node.parent.left is uplink from node.parent:\n     *              - If node.parent.left is not root, return it.\n     *              - If it is root & root isEmpty, return null.\n     *              - If it is root & root !isEmpty, return root.\n     *          - If node.parent.left is not uplink from node.parent:\n     *              - Follow right path for first right child from node.parent.left\n     *\n     * @param start  the start entry\n     */\n    TrieEntry<K, V> previousEntry(final TrieEntry<K, V> start) {\n        if (start.predecessor == null) {\n            throw new IllegalArgumentException(\"must have come from somewhere!\");\n        }\n\n        if (start.predecessor.right == start) {\n            if (isValidUplink(start.predecessor.left, start.predecessor)) {\n                return start.predecessor.left;\n            }\n            return followRight(start.predecessor.left);\n        }\n        TrieEntry<K, V> node = start.predecessor;\n        while (node.parent != null && node == node.parent.left) {\n            node = node.parent;\n        }\n\n        if (node.parent == null) { // can be null if we're looking up root.\n            return null;\n        }\n\n        if (isValidUplink(node.parent.left, node.parent)) {\n            if (node.parent.left == root) {\n                if (root.isEmpty()) {\n                    return null;\n                }\n                return root;\n\n            }\n            return node.parent.left;\n        }\n        return followRight(node.parent.left);\n    }\n\n    /**\n     * Returns the entry lexicographically after the given entry.\n     * If the given entry is null, returns the first node.\n     *\n     * This will traverse only within the subtree.  If the given node\n     * is not within the subtree, this will have undefined results.\n     */\n    TrieEntry<K, V> nextEntryInSubtree(final TrieEntry<K, V> node,\n            final TrieEntry<K, V> parentOfSubtree) {\n        if (node == null) {\n            return firstEntry();\n        }\n        return nextEntryImpl(node.predecessor, node, parentOfSubtree);\n    }\n\n    /**\n     * Returns true if 'next' is a valid uplink coming from 'from'.\n     */\n    static boolean isValidUplink(final TrieEntry<?, ?> next, final TrieEntry<?, ?> from) {\n        return next != null && next.bitIndex <= from.bitIndex && !next.isEmpty();\n    }\n\n    /**\n     * A {@link Reference} allows us to return something through a Method's\n     * argument list. An alternative would be to an Array with a length of\n     * one (1) but that leads to compiler warnings. Computationally and memory\n     * wise there's no difference (except for the need to load the\n     * {@link Reference} Class but that happens only once).\n     */\n    private static class Reference<E> {\n\n        private E item;\n\n        public void set(final E item) {\n            this.item = item;\n        }\n\n        public E get() {\n            return item;\n        }\n    }\n\n    /**\n     *  A {@link Trie} is a set of {@link TrieEntry} nodes.\n     */\n    protected static class TrieEntry<K,V> extends BasicEntry<K, V> {\n\n        private static final long serialVersionUID = 4596023148184140013L;\n\n        /** The index this entry is comparing. */\n        protected int bitIndex;\n\n        /** The parent of this entry. */\n        protected TrieEntry<K,V> parent;\n\n        /** The left child of this entry. */\n        protected TrieEntry<K,V> left;\n\n        /** The right child of this entry. */\n        protected TrieEntry<K,V> right;\n\n        /** The entry who uplinks to this entry. */\n        protected TrieEntry<K,V> predecessor;\n\n        public TrieEntry(final K key, final V value, final int bitIndex) {\n            super(key, value);\n\n            this.bitIndex = bitIndex;\n\n            this.parent = null;\n            this.left = this;\n            this.right = null;\n            this.predecessor = this;\n        }\n\n        /**\n         * Whether or not the entry is storing a key.\n         * Only the root can potentially be empty, all other\n         * nodes must have a key.\n         */\n        public boolean isEmpty() {\n            return key == null;\n        }\n\n        /**\n         * Neither the left nor right child is a loopback.\n         */\n        public boolean isInternalNode() {\n            return left != this && right != this;\n        }\n\n        /**\n         * Either the left or right child is a loopback.\n         */\n        public boolean isExternalNode() {\n            return !isInternalNode();\n        }\n\n        @Override\n        public String toString() {\n            final StringBuilder buffer = new StringBuilder();\n\n            if (bitIndex == -1) {\n                buffer.append(\"RootEntry(\");\n            } else {\n                buffer.append(\"Entry(\");\n            }\n\n            buffer.append(\"key=\").append(getKey()).append(\" [\").append(bitIndex).append(\"], \");\n            buffer.append(\"value=\").append(getValue()).append(\", \");\n            //buffer.append(\"bitIndex=\").append(bitIndex).append(\", \");\n\n            if (parent != null) {\n                if (parent.bitIndex == -1) {\n                    buffer.append(\"parent=\").append(\"ROOT\");\n                } else {\n                    buffer.append(\"parent=\").append(parent.getKey()).append(\" [\").append(parent.bitIndex).append(\"]\");\n                }\n            } else {\n                buffer.append(\"parent=\").append(\"null\");\n            }\n            buffer.append(\", \");\n\n            if (left != null) {\n                if (left.bitIndex == -1) {\n                    buffer.append(\"left=\").append(\"ROOT\");\n                } else {\n                    buffer.append(\"left=\").append(left.getKey()).append(\" [\").append(left.bitIndex).append(\"]\");\n                }\n            } else {\n                buffer.append(\"left=\").append(\"null\");\n            }\n            buffer.append(\", \");\n\n            if (right != null) {\n                if (right.bitIndex == -1) {\n                    buffer.append(\"right=\").append(\"ROOT\");\n                } else {\n                    buffer.append(\"right=\").append(right.getKey()).append(\" [\").append(right.bitIndex).append(\"]\");\n                }\n            } else {\n                buffer.append(\"right=\").append(\"null\");\n            }\n            buffer.append(\", \");\n\n            if (predecessor != null) {\n                if(predecessor.bitIndex == -1) {\n                    buffer.append(\"predecessor=\").append(\"ROOT\");\n                } else {\n                    buffer.append(\"predecessor=\").append(predecessor.getKey()).append(\" [\").\n                           append(predecessor.bitIndex).append(\"]\");\n                }\n            }\n\n            buffer.append(\")\");\n            return buffer.toString();\n        }\n    }\n\n\n    /**\n     * This is a entry set view of the {@link Trie} as returned by {@link Map#entrySet()}.\n     */\n    private class EntrySet extends AbstractSet<Map.Entry<K,V>> {\n\n        @Override\n        public Iterator<Map.Entry<K,V>> iterator() {\n            return new EntryIterator();\n        }\n\n        @Override\n        public boolean contains(final Object o) {\n            if (!(o instanceof Map.Entry)) {\n                return false;\n            }\n\n            final TrieEntry<K,V> candidate = getEntry(((Map.Entry<?, ?>)o).getKey());\n            return candidate != null && candidate.equals(o);\n        }\n\n        @Override\n        public boolean remove(final Object obj) {\n            if (obj instanceof Map.Entry == false) {\n                return false;\n            }\n            if (contains(obj) == false) {\n                return false;\n            }\n            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n            AbstractPatriciaTrie.this.remove(entry.getKey());\n            return true;\n        }\n\n        @Override\n        public int size() {\n            return AbstractPatriciaTrie.this.size();\n        }\n\n        @Override\n        public void clear() {\n            AbstractPatriciaTrie.this.clear();\n        }\n\n        /**\n         * An {@link Iterator} that returns {@link Entry} Objects.\n         */\n        private class EntryIterator extends TrieIterator<Map.Entry<K,V>> {\n            @Override\n            public Map.Entry<K,V> next() {\n                return nextEntry();\n            }\n        }\n    }\n\n    /**\n     * This is a key set view of the {@link Trie} as returned by {@link Map#keySet()}.\n     */\n    private class KeySet extends AbstractSet<K> {\n\n        @Override\n        public Iterator<K> iterator() {\n            return new KeyIterator();\n        }\n\n        @Override\n        public int size() {\n            return AbstractPatriciaTrie.this.size();\n        }\n\n        @Override\n        public boolean contains(final Object o) {\n            return containsKey(o);\n        }\n\n        @Override\n        public boolean remove(final Object o) {\n            final int size = size();\n            AbstractPatriciaTrie.this.remove(o);\n            return size != size();\n        }\n\n        @Override\n        public void clear() {\n            AbstractPatriciaTrie.this.clear();\n        }\n\n        /**\n         * An {@link Iterator} that returns Key Objects.\n         */\n        private class KeyIterator extends TrieIterator<K> {\n            @Override\n            public K next() {\n                return nextEntry().getKey();\n            }\n        }\n    }\n\n    /**\n     * This is a value view of the {@link Trie} as returned by {@link Map#values()}.\n     */\n    private class Values extends AbstractCollection<V> {\n\n        @Override\n        public Iterator<V> iterator() {\n            return new ValueIterator();\n        }\n\n        @Override\n        public int size() {\n            return AbstractPatriciaTrie.this.size();\n        }\n\n        @Override\n        public boolean contains(final Object o) {\n            return containsValue(o);\n        }\n\n        @Override\n        public void clear() {\n            AbstractPatriciaTrie.this.clear();\n        }\n\n        @Override\n        public boolean remove(final Object o) {\n            for (final Iterator<V> it = iterator(); it.hasNext(); ) {\n                final V value = it.next();\n                if (compare(value, o)) {\n                    it.remove();\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        /**\n         * An {@link Iterator} that returns Value Objects.\n         */\n        private class ValueIterator extends TrieIterator<V> {\n            @Override\n            public V next() {\n                return nextEntry().getValue();\n            }\n        }\n    }\n\n    /**\n     * An iterator for the entries.\n     */\n    abstract class TrieIterator<E> implements Iterator<E> {\n\n        /** For fast-fail. */\n        protected int expectedModCount = AbstractPatriciaTrie.this.modCount;\n\n        protected TrieEntry<K, V> next; // the next node to return\n        protected TrieEntry<K, V> current; // the current entry we're on\n\n        /**\n         * Starts iteration from the root.\n         */\n        protected TrieIterator() {\n            next = AbstractPatriciaTrie.this.nextEntry(null);\n        }\n\n        /**\n         * Starts iteration at the given entry.\n         */\n        protected TrieIterator(final TrieEntry<K, V> firstEntry) {\n            next = firstEntry;\n        }\n\n        /**\n         * Returns the next {@link TrieEntry}.\n         */\n        protected TrieEntry<K,V> nextEntry() {\n            if (expectedModCount != AbstractPatriciaTrie.this.modCount) {\n                throw new ConcurrentModificationException();\n            }\n\n            final TrieEntry<K,V> e = next;\n            if (e == null) {\n                throw new NoSuchElementException();\n            }\n\n            next = findNext(e);\n            current = e;\n            return e;\n        }\n\n        /**\n         * @see PatriciaTrie#nextEntry(TrieEntry)\n         */\n        protected TrieEntry<K, V> findNext(final TrieEntry<K, V> prior) {\n            return AbstractPatriciaTrie.this.nextEntry(prior);\n        }\n\n        @Override\n        public boolean hasNext() {\n            return next != null;\n        }\n\n        @Override\n        public void remove() {\n            if (current == null) {\n                throw new IllegalStateException();\n            }\n\n            if (expectedModCount != AbstractPatriciaTrie.this.modCount) {\n                throw new ConcurrentModificationException();\n            }\n\n            final TrieEntry<K, V> node = current;\n            current = null;\n            AbstractPatriciaTrie.this.removeEntry(node);\n\n            expectedModCount = AbstractPatriciaTrie.this.modCount;\n        }\n    }\n\n    /**\n     * An {@link OrderedMapIterator} for a {@link Trie}.\n     */\n    private class TrieMapIterator extends TrieIterator<K> implements OrderedMapIterator<K, V> {\n\n        protected TrieEntry<K, V> previous; // the previous node to return\n\n        @Override\n        public K next() {\n            return nextEntry().getKey();\n        }\n\n        @Override\n        public K getKey() {\n            if (current == null) {\n                throw new IllegalStateException();\n            }\n            return current.getKey();\n        }\n\n        @Override\n        public V getValue() {\n            if (current == null) {\n                throw new IllegalStateException();\n            }\n            return current.getValue();\n        }\n\n        @Override\n        public V setValue(final V value) {\n            if (current == null) {\n                throw new IllegalStateException();\n            }\n            return current.setValue(value);\n        }\n\n        @Override\n        public boolean hasPrevious() {\n            return previous != null;\n        }\n\n        @Override\n        public K previous() {\n            return previousEntry().getKey();\n        }\n\n        @Override\n        protected TrieEntry<K, V> nextEntry() {\n            final TrieEntry<K, V> nextEntry = super.nextEntry();\n            previous = nextEntry;\n            return nextEntry;\n        }\n\n        protected TrieEntry<K,V> previousEntry() {\n            if (expectedModCount != AbstractPatriciaTrie.this.modCount) {\n                throw new ConcurrentModificationException();\n            }\n\n            final TrieEntry<K,V> e = previous;\n            if (e == null) {\n                throw new NoSuchElementException();\n            }\n\n            previous = AbstractPatriciaTrie.this.previousEntry(e);\n            next = current;\n            current = e;\n            return current;\n        }\n\n    }\n\n    /**\n     * A range view of the {@link Trie}.\n     */\n    private abstract class RangeMap extends AbstractMap<K, V>\n            implements SortedMap<K, V> {\n\n        /** The {@link #entrySet()} view. */\n        private transient volatile Set<Map.Entry<K, V>> entrySet;\n\n        /**\n         * Creates and returns an {@link #entrySet()} view of the {@link RangeMap}.\n         */\n        protected abstract Set<Map.Entry<K, V>> createEntrySet();\n\n        /**\n         * Returns the FROM Key.\n         */\n        protected abstract K getFromKey();\n\n        /**\n         * Whether or not the {@link #getFromKey()} is in the range.\n         */\n        protected abstract boolean isFromInclusive();\n\n        /**\n         * Returns the TO Key.\n         */\n        protected abstract K getToKey();\n\n        /**\n         * Whether or not the {@link #getToKey()} is in the range.\n         */\n        protected abstract boolean isToInclusive();\n\n        @Override\n        public Comparator<? super K> comparator() {\n            return AbstractPatriciaTrie.this.comparator();\n        }\n\n        @Override\n        public boolean containsKey(final Object key) {\n            if (!inRange(castKey(key))) {\n                return false;\n            }\n\n            return AbstractPatriciaTrie.this.containsKey(key);\n        }\n\n        @Override\n        public V remove(final Object key) {\n            if (!inRange(castKey(key))) {\n                return null;\n            }\n\n            return AbstractPatriciaTrie.this.remove(key);\n        }\n\n        @Override\n        public V get(final Object key) {\n            if (!inRange(castKey(key))) {\n                return null;\n            }\n\n            return AbstractPatriciaTrie.this.get(key);\n        }\n\n        @Override\n        public V put(final K key, final V value) {\n            if (!inRange(key)) {\n                throw new IllegalArgumentException(\"Key is out of range: \" + key);\n            }\n            return AbstractPatriciaTrie.this.put(key, value);\n        }\n\n        @Override\n        public Set<Map.Entry<K, V>> entrySet() {\n            if (entrySet == null) {\n                entrySet = createEntrySet();\n            }\n            return entrySet;\n        }\n\n        @Override\n        public SortedMap<K, V> subMap(final K fromKey, final K toKey) {\n            if (!inRange2(fromKey)) {\n                throw new IllegalArgumentException(\"FromKey is out of range: \" + fromKey);\n            }\n\n            if (!inRange2(toKey)) {\n                throw new IllegalArgumentException(\"ToKey is out of range: \" + toKey);\n            }\n\n            return createRangeMap(fromKey, isFromInclusive(), toKey, isToInclusive());\n        }\n\n        @Override\n        public SortedMap<K, V> headMap(final K toKey) {\n            if (!inRange2(toKey)) {\n                throw new IllegalArgumentException(\"ToKey is out of range: \" + toKey);\n            }\n            return createRangeMap(getFromKey(), isFromInclusive(), toKey, isToInclusive());\n        }\n\n        @Override\n        public SortedMap<K, V> tailMap(final K fromKey) {\n            if (!inRange2(fromKey)) {\n                throw new IllegalArgumentException(\"FromKey is out of range: \" + fromKey);\n            }\n            return createRangeMap(fromKey, isFromInclusive(), getToKey(), isToInclusive());\n        }\n\n        /**\n         * Returns true if the provided key is greater than TO and less than FROM.\n         */\n        protected boolean inRange(final K key) {\n            final K fromKey = getFromKey();\n            final K toKey = getToKey();\n\n            return (fromKey == null || inFromRange(key, false)) && (toKey == null || inToRange(key, false));\n        }\n\n        /**\n         * This form allows the high endpoint (as well as all legit keys).\n         */\n        protected boolean inRange2(final K key) {\n            final K fromKey = getFromKey();\n            final K toKey = getToKey();\n\n            return (fromKey == null || inFromRange(key, false)) && (toKey == null || inToRange(key, true));\n        }\n\n        /**\n         * Returns true if the provided key is in the FROM range of the {@link RangeMap}.\n         */\n        protected boolean inFromRange(final K key, final boolean forceInclusive) {\n            final K fromKey = getFromKey();\n            final boolean fromInclusive = isFromInclusive();\n\n            final int ret = getKeyAnalyzer().compare(key, fromKey);\n            if (fromInclusive || forceInclusive) {\n                return ret >= 0;\n            }\n            return ret > 0;\n        }\n\n        /**\n         * Returns true if the provided key is in the TO range of the {@link RangeMap}.\n         */\n        protected boolean inToRange(final K key, final boolean forceInclusive) {\n            final K toKey = getToKey();\n            final boolean toInclusive = isToInclusive();\n\n            final int ret = getKeyAnalyzer().compare(key, toKey);\n            if (toInclusive || forceInclusive) {\n                return ret <= 0;\n            }\n            return ret < 0;\n        }\n\n        /**\n         * Creates and returns a sub-range view of the current {@link RangeMap}.\n         */\n        protected abstract SortedMap<K, V> createRangeMap(K fromKey, boolean fromInclusive,\n                                                          K toKey, boolean toInclusive);\n    }\n\n   /**\n    * A {@link RangeMap} that deals with {@link Entry}s.\n    */\n   private class RangeEntryMap extends RangeMap {\n\n       /** The key to start from, null if the beginning. */\n       private final K fromKey;\n\n       /** The key to end at, null if till the end. */\n       private final K toKey;\n\n       /** Whether or not the 'from' is inclusive. */\n       private final boolean fromInclusive;\n\n       /** Whether or not the 'to' is inclusive. */\n       private final boolean toInclusive;\n\n       /**\n        * Creates a {@link RangeEntryMap} with the fromKey included and\n        * the toKey excluded from the range.\n        */\n       protected RangeEntryMap(final K fromKey, final K toKey) {\n           this(fromKey, true, toKey, false);\n       }\n\n       /**\n        * Creates a {@link RangeEntryMap}.\n        */\n       protected RangeEntryMap(final K fromKey, final boolean fromInclusive,\n                               final K toKey, final boolean toInclusive) {\n\n           if (fromKey == null && toKey == null) {\n               throw new IllegalArgumentException(\"must have a from or to!\");\n           }\n\n           if (fromKey != null && toKey != null && getKeyAnalyzer().compare(fromKey, toKey) > 0) {\n               throw new IllegalArgumentException(\"fromKey > toKey\");\n           }\n\n           this.fromKey = fromKey;\n           this.fromInclusive = fromInclusive;\n           this.toKey = toKey;\n           this.toInclusive = toInclusive;\n       }\n\n       @Override\n    public K firstKey() {\n           Map.Entry<K,V> e = null;\n           if (fromKey == null) {\n               e = firstEntry();\n           } else {\n               if (fromInclusive) {\n                   e = ceilingEntry(fromKey);\n               } else {\n                   e = higherEntry(fromKey);\n               }\n           }\n\n           final K first = e != null ? e.getKey() : null;\n           if (e == null || toKey != null && !inToRange(first, false)) {\n               throw new NoSuchElementException();\n           }\n           return first;\n       }\n\n       @Override\n    public K lastKey() {\n           Map.Entry<K,V> e;\n           if (toKey == null) {\n               e = lastEntry();\n           } else {\n               if (toInclusive) {\n                   e = floorEntry(toKey);\n               } else {\n                   e = lowerEntry(toKey);\n               }\n           }\n\n           final K last = e != null ? e.getKey() : null;\n           if (e == null || fromKey != null && !inFromRange(last, false)) {\n               throw new NoSuchElementException();\n           }\n           return last;\n       }\n\n       @Override\n       protected Set<Entry<K, V>> createEntrySet() {\n           return new RangeEntrySet(this);\n       }\n\n       @Override\n       public K getFromKey() {\n           return fromKey;\n       }\n\n       @Override\n       public K getToKey() {\n           return toKey;\n       }\n\n       @Override\n       public boolean isFromInclusive() {\n           return fromInclusive;\n       }\n\n       @Override\n       public boolean isToInclusive() {\n           return toInclusive;\n       }\n\n       @Override\n       protected SortedMap<K, V> createRangeMap(final K fromKey, final boolean fromInclusive,\n                                                final K toKey, final boolean toInclusive) {\n           return new RangeEntryMap(fromKey, fromInclusive, toKey, toInclusive);\n       }\n   }\n\n    /**\n     * A {@link Set} view of a {@link RangeMap}.\n     */\n    private class RangeEntrySet extends AbstractSet<Map.Entry<K, V>> {\n\n        private final RangeMap delegate;\n\n        private transient int size = -1;\n\n        private transient int expectedModCount;\n\n        /**\n         * Creates a {@link RangeEntrySet}.\n         */\n        public RangeEntrySet(final RangeMap delegate) {\n            if (delegate == null) {\n                throw new NullPointerException(\"delegate\");\n            }\n\n            this.delegate = delegate;\n        }\n\n        @Override\n        public Iterator<Map.Entry<K, V>> iterator() {\n            final K fromKey = delegate.getFromKey();\n            final K toKey = delegate.getToKey();\n\n            TrieEntry<K, V> first = null;\n            if (fromKey == null) {\n                first = firstEntry();\n            } else {\n                first = ceilingEntry(fromKey);\n            }\n\n            TrieEntry<K, V> last = null;\n            if (toKey != null) {\n                last = ceilingEntry(toKey);\n            }\n\n            return new EntryIterator(first, last);\n        }\n\n        @Override\n        public int size() {\n            if (size == -1 || expectedModCount != AbstractPatriciaTrie.this.modCount) {\n                size = 0;\n\n                for (final Iterator<?> it = iterator(); it.hasNext(); it.next()) {\n                    ++size;\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n            return size;\n        }\n\n        @Override\n        public boolean isEmpty() {\n            return !iterator().hasNext();\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        @Override\n        public boolean contains(final Object o) {\n            if (!(o instanceof Map.Entry)) {\n                return false;\n            }\n\n            final Map.Entry<K, V> entry = (Map.Entry<K, V>) o;\n            final K key = entry.getKey();\n            if (!delegate.inRange(key)) {\n                return false;\n            }\n\n            final TrieEntry<K, V> node = getEntry(key);\n            return node != null && compare(node.getValue(), entry.getValue());\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        @Override\n        public boolean remove(final Object o) {\n            if (!(o instanceof Map.Entry)) {\n                return false;\n            }\n\n            final Map.Entry<K, V> entry = (Map.Entry<K, V>) o;\n            final K key = entry.getKey();\n            if (!delegate.inRange(key)) {\n                return false;\n            }\n\n            final TrieEntry<K, V> node = getEntry(key);\n            if (node != null && compare(node.getValue(), entry.getValue())) {\n                removeEntry(node);\n                return true;\n            }\n            return false;\n        }\n\n        /**\n         * An {@link Iterator} for {@link RangeEntrySet}s.\n         */\n        private final class EntryIterator extends TrieIterator<Map.Entry<K,V>> {\n\n            private final K excludedKey;\n\n            /**\n             * Creates a {@link EntryIterator}.\n             */\n            private EntryIterator(final TrieEntry<K,V> first, final TrieEntry<K,V> last) {\n                super(first);\n                this.excludedKey = last != null ? last.getKey() : null;\n            }\n\n            @Override\n            public boolean hasNext() {\n                return next != null && !compare(next.key, excludedKey);\n            }\n\n            @Override\n            public Map.Entry<K,V> next() {\n                if (next == null || compare(next.key, excludedKey)) {\n                    throw new NoSuchElementException();\n                }\n                return nextEntry();\n            }\n        }\n    }\n\n    /**\n     * A submap used for prefix views over the {@link Trie}.\n     */\n    private class PrefixRangeMap extends RangeMap {\n\n        private final K prefix;\n\n        private final int offsetInBits;\n\n        private final int lengthInBits;\n\n        private K fromKey = null;\n\n        private K toKey = null;\n\n        private transient int expectedModCount = 0;\n\n        private int size = -1;\n\n        /**\n         * Creates a {@link PrefixRangeMap}.\n         */\n        private PrefixRangeMap(final K prefix, final int offsetInBits, final int lengthInBits) {\n            this.prefix = prefix;\n            this.offsetInBits = offsetInBits;\n            this.lengthInBits = lengthInBits;\n        }\n\n        /**\n         * This method does two things. It determines the FROM\n         * and TO range of the {@link PrefixRangeMap} and the number\n         * of elements in the range. This method must be called every\n         * time the {@link Trie} has changed.\n         */\n        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\n                if (it.hasNext()) {\n                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>)entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }\n\n        @Override\n        public K firstKey() {\n            fixup();\n\n            Map.Entry<K,V> e = null;\n            if (fromKey == null) {\n                e = firstEntry();\n            } else {\n                e = higherEntry(fromKey);\n            }\n\n            final K first = e != null ? e.getKey() : null;\n            if (e == null || !getKeyAnalyzer().isPrefix(prefix, offsetInBits, lengthInBits, first)) {\n                throw new NoSuchElementException();\n            }\n\n            return first;\n        }\n\n        @Override\n        public K lastKey() {\n            fixup();\n\n            Map.Entry<K,V> e = null;\n            if (toKey == null) {\n                e = lastEntry();\n            } else {\n                e = lowerEntry(toKey);\n            }\n\n            final K last = e != null ? e.getKey() : null;\n            if (e == null || !getKeyAnalyzer().isPrefix(prefix, offsetInBits, lengthInBits, last)) {\n                throw new NoSuchElementException();\n            }\n\n            return last;\n        }\n\n        /**\n         * Returns true if this {@link PrefixRangeMap}'s key is a prefix of the provided key.\n         */\n        @Override\n        protected boolean inRange(final K key) {\n            return getKeyAnalyzer().isPrefix(prefix, offsetInBits, lengthInBits, key);\n        }\n\n        /**\n         * Same as {@link #inRange(Object)}.\n         */\n        @Override\n        protected boolean inRange2(final K key) {\n            return inRange(key);\n        }\n\n        /**\n         * Returns true if the provided Key is in the FROM range of the {@link PrefixRangeMap}.\n         */\n        @Override\n        protected boolean inFromRange(final K key, final boolean forceInclusive) {\n            return getKeyAnalyzer().isPrefix(prefix, offsetInBits, lengthInBits, key);\n        }\n\n        /**\n         * Returns true if the provided Key is in the TO range of the {@link PrefixRangeMap}.\n         */\n        @Override\n        protected boolean inToRange(final K key, final boolean forceInclusive) {\n            return getKeyAnalyzer().isPrefix(prefix, offsetInBits, lengthInBits, key);\n        }\n\n        @Override\n        protected Set<Map.Entry<K, V>> createEntrySet() {\n            return new PrefixRangeEntrySet(this);\n        }\n\n        @Override\n        public K getFromKey() {\n            return fromKey;\n        }\n\n        @Override\n        public K getToKey() {\n            return toKey;\n        }\n\n        @Override\n        public boolean isFromInclusive() {\n            return false;\n        }\n\n        @Override\n        public boolean isToInclusive() {\n            return false;\n        }\n\n        @Override\n        protected SortedMap<K, V> createRangeMap(final K fromKey, final boolean fromInclusive,\n                                                 final K toKey, final boolean toInclusive) {\n            return new RangeEntryMap(fromKey, fromInclusive, toKey, toInclusive);\n        }\n\n        @Override\n        public void clear() {\n            Iterator<Map.Entry<K, V>> it = AbstractPatriciaTrie.this.entrySet().iterator();\n            Set<K> currentKeys = keySet();\n            while (it.hasNext()) {\n                if (currentKeys.contains(it.next().getKey())) {\n                    it.remove();\n                }\n            }\n        }\n    }\n\n    /**\n     * A prefix {@link RangeEntrySet} view of the {@link Trie}.\n     */\n    private final class PrefixRangeEntrySet extends RangeEntrySet {\n\n        private final PrefixRangeMap delegate;\n\n        private TrieEntry<K, V> prefixStart;\n\n        private int expectedModCount = 0;\n\n        /**\n         * Creates a {@link PrefixRangeEntrySet}.\n         */\n        public PrefixRangeEntrySet(final PrefixRangeMap delegate) {\n            super(delegate);\n            this.delegate = delegate;\n        }\n\n        @Override\n        public int size() {\n            return delegate.fixup();\n        }\n\n        @Override\n        public Iterator<Map.Entry<K,V>> iterator() {\n            if (AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                prefixStart = subtree(delegate.prefix, delegate.offsetInBits, delegate.lengthInBits);\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            if (prefixStart == null) {\n                final Set<Map.Entry<K,V>> empty = Collections.emptySet();\n                return empty.iterator();\n            } else if (delegate.lengthInBits > prefixStart.bitIndex) {\n                return new SingletonIterator(prefixStart);\n            } else {\n                return new EntryIterator(prefixStart, delegate.prefix, delegate.offsetInBits, delegate.lengthInBits);\n            }\n        }\n\n        /**\n         * An {@link Iterator} that holds a single {@link TrieEntry}.\n         */\n        private final class SingletonIterator implements Iterator<Map.Entry<K, V>> {\n\n            private final TrieEntry<K, V> entry;\n\n            private int hit = 0;\n\n            public SingletonIterator(final TrieEntry<K, V> entry) {\n                this.entry = entry;\n            }\n\n            @Override\n            public boolean hasNext() {\n                return hit == 0;\n            }\n\n            @Override\n            public Map.Entry<K, V> next() {\n                if (hit != 0) {\n                    throw new NoSuchElementException();\n                }\n\n                ++hit;\n                return entry;\n            }\n\n            @Override\n            public void remove() {\n                if (hit != 1) {\n                    throw new IllegalStateException();\n                }\n\n                ++hit;\n                AbstractPatriciaTrie.this.removeEntry(entry);\n            }\n        }\n\n        /**\n         * An {@link Iterator} for iterating over a prefix search.\n         */\n        private final class EntryIterator extends TrieIterator<Map.Entry<K, V>> {\n\n            // values to reset the subtree if we remove it.\n            private final K prefix;\n            private final int offset;\n            private final int lengthInBits;\n            private boolean lastOne;\n\n            private TrieEntry<K, V> subtree; // the subtree to search within\n\n            /**\n             * Starts iteration at the given entry & search only\n             * within the given subtree.\n             */\n            EntryIterator(final TrieEntry<K, V> startScan, final K prefix,\n                    final int offset, final int lengthInBits) {\n                subtree = startScan;\n                next = AbstractPatriciaTrie.this.followLeft(startScan);\n                this.prefix = prefix;\n                this.offset = offset;\n                this.lengthInBits = lengthInBits;\n            }\n\n            @Override\n            public Map.Entry<K,V> next() {\n                final Map.Entry<K, V> entry = nextEntry();\n                if (lastOne) {\n                    next = null;\n                }\n                return entry;\n            }\n\n            @Override\n            protected TrieEntry<K, V> findNext(final TrieEntry<K, V> prior) {\n                return AbstractPatriciaTrie.this.nextEntryInSubtree(prior, subtree);\n            }\n\n            @Override\n            public void remove() {\n                // If the current entry we're removing is the subtree\n                // then we need to find a new subtree parent.\n                boolean needsFixing = false;\n                final int bitIdx = subtree.bitIndex;\n                if (current == subtree) {\n                    needsFixing = true;\n                }\n\n                super.remove();\n\n                // If the subtree changed its bitIndex or we\n                // removed the old subtree, get a new one.\n                if (bitIdx != subtree.bitIndex || needsFixing) {\n                    subtree = subtree(prefix, offset, lengthInBits);\n                }\n\n                // If the subtree's bitIndex is less than the\n                // length of our prefix, it's the last item\n                // in the prefix tree.\n                if (lengthInBits >= subtree.bitIndex) {\n                    lastOne = true;\n                }\n            }\n        }\n    }\n\n    //-----------------------------------------------------------------------\n\n    /**\n     * Reads the content of the stream.\n     */\n    @SuppressWarnings(\"unchecked\") // This will fail at runtime if the stream is incorrect\n    private void readObject(final ObjectInputStream stream) throws IOException, ClassNotFoundException{\n        stream.defaultReadObject();\n        root = new TrieEntry<K, V>(null, null, -1);\n        int size = stream.readInt();\n        for(int i = 0; i < size; i++){\n            K k = (K) stream.readObject();\n            V v = (V) stream.readObject();\n            put(k, v);\n        }\n    }\n\n    /**\n     * Writes the content to the stream for serialization.\n     */\n    private void writeObject(final ObjectOutputStream stream) throws IOException{\n        stream.defaultWriteObject();\n        stream.writeInt(this.size());\n        for (final Entry<K, V> entry : entrySet()) {\n            stream.writeObject(entry.getKey());\n            stream.writeObject(entry.getValue());\n        }\n    }\n\n}\n"}]}
