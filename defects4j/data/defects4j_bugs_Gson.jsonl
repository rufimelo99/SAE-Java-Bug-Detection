{"project": "Gson", "bug_id": 1, "classes_modified": [{"class_name": "com.google.gson.TypeInfoFactory", "buggy_version": "/*\n * Copyright (C) 2008 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.gson;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.GenericArrayType;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.TypeVariable;\nimport java.lang.reflect.WildcardType;\n\n/**\n * A static factory class used to construct the \"TypeInfo\" objects.\n *\n * @author Inderjeet Singh\n * @author Joel Leitch\n */\nfinal class TypeInfoFactory {\n\n  private TypeInfoFactory() {\n    // Not instantiable since it provides factory methods only.\n  }\n\n  public static TypeInfoArray getTypeInfoForArray(Type type) {\n    Preconditions.checkArgument(TypeUtils.isArray(type));\n    return new TypeInfoArray(type);\n  }\n\n  /**\n   * Evaluates the \"actual\" type for the field.  If the field is a \"TypeVariable\" or has a\n   * \"TypeVariable\" in a parameterized type then it evaluates the real type.\n   *\n   * @param f the actual field object to retrieve the type from\n   * @param typeDefiningF the type that contains the field {@code f}\n   * @return the type information for the field\n   */\n  public static TypeInfo getTypeInfoForField(Field f, Type typeDefiningF) {\n    Class<?> classDefiningF = TypeUtils.toRawClass(typeDefiningF);\n    Type type = f.getGenericType();\n    Type actualType = getActualType(type, typeDefiningF, classDefiningF);\n    return new TypeInfo(actualType);\n  }\n\n  private static Type getActualType(\n      Type typeToEvaluate, Type parentType, Class<?> rawParentClass) {\n    if (typeToEvaluate instanceof Class<?>) {\n      return typeToEvaluate;\n    } else if (typeToEvaluate instanceof ParameterizedType) {\n      ParameterizedType castedType = (ParameterizedType) typeToEvaluate;\n      Type owner = castedType.getOwnerType();\n      Type[] actualTypeParameters =\n          extractRealTypes(castedType.getActualTypeArguments(), parentType, rawParentClass);\n      Type rawType = castedType.getRawType();\n      return new ParameterizedTypeImpl(rawType, actualTypeParameters, owner);\n    } else if (typeToEvaluate instanceof GenericArrayType) {\n      GenericArrayType castedType = (GenericArrayType) typeToEvaluate;\n      Type componentType = castedType.getGenericComponentType();\n      Type actualType = getActualType(componentType, parentType, rawParentClass);\n      if (componentType.equals(actualType)) {\n        return castedType;\n      }\n      return actualType instanceof Class<?> ?\n          TypeUtils.wrapWithArray(TypeUtils.toRawClass(actualType))\n          : new GenericArrayTypeImpl(actualType);\n    } else if (typeToEvaluate instanceof TypeVariable<?>) {\n      if (parentType instanceof ParameterizedType) {\n        // The class definition has the actual types used for the type variables.\n        // Find the matching actual type for the Type Variable used for the field.\n        // For example, class Foo<A> { A a; }\n        // new Foo<Integer>(); defines the actual type of A to be Integer.\n        // So, to find the type of the field a, we will have to look at the class'\n        // actual type arguments.\n        TypeVariable<?> fieldTypeVariable = (TypeVariable<?>) typeToEvaluate;\n        TypeVariable<?>[] classTypeVariables = rawParentClass.getTypeParameters();\n        ParameterizedType objParameterizedType = (ParameterizedType) parentType;\n        int indexOfActualTypeArgument = getIndex(classTypeVariables, fieldTypeVariable);\n        Type[] actualTypeArguments = objParameterizedType.getActualTypeArguments();\n        return actualTypeArguments[indexOfActualTypeArgument];\n\n\n      }\n\n      throw new UnsupportedOperationException(\"Expecting parameterized type, got \" + parentType\n          + \".\\n Are you missing the use of TypeToken idiom?\\n See \"\n          + \"http://sites.google.com/site/gson/gson-user-guide#TOC-Serializing-and-Deserializing-Gener\");\n    } else if (typeToEvaluate instanceof WildcardType) {\n      WildcardType castedType = (WildcardType) typeToEvaluate;\n      return getActualType(castedType.getUpperBounds()[0], parentType, rawParentClass);\n    } else {\n      throw new IllegalArgumentException(\"Type \\'\" + typeToEvaluate + \"\\' is not a Class, \"\n          + \"ParameterizedType, GenericArrayType or TypeVariable. Can't extract type.\");\n    }\n  }\n\n\n      // Evaluate type on this type\n\n\n\n\n  private static Type[] extractRealTypes(\n      Type[] actualTypeArguments, Type parentType, Class<?> rawParentClass) {\n    Preconditions.checkNotNull(actualTypeArguments);\n\n    Type[] retTypes = new Type[actualTypeArguments.length];\n    for (int i = 0; i < actualTypeArguments.length; ++i) {\n      retTypes[i] = getActualType(actualTypeArguments[i], parentType, rawParentClass);\n    }\n    return retTypes;\n  }\n\n  private static int getIndex(TypeVariable<?>[] types, TypeVariable<?> type) {\n    for (int i = 0; i < types.length; ++i) {\n      if (type.equals(types[i])) {\n        return i;\n      }\n    }\n    throw new IllegalStateException(\n        \"How can the type variable not be present in the class declaration!\");\n  }\n}\n", "fixed_version": "/*\n * Copyright (C) 2008 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.gson;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.GenericArrayType;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.TypeVariable;\nimport java.lang.reflect.WildcardType;\n\n/**\n * A static factory class used to construct the \"TypeInfo\" objects.\n *\n * @author Inderjeet Singh\n * @author Joel Leitch\n */\nfinal class TypeInfoFactory {\n\n  private TypeInfoFactory() {\n    // Not instantiable since it provides factory methods only.\n  }\n\n  public static TypeInfoArray getTypeInfoForArray(Type type) {\n    Preconditions.checkArgument(TypeUtils.isArray(type));\n    return new TypeInfoArray(type);\n  }\n\n  /**\n   * Evaluates the \"actual\" type for the field.  If the field is a \"TypeVariable\" or has a\n   * \"TypeVariable\" in a parameterized type then it evaluates the real type.\n   *\n   * @param f the actual field object to retrieve the type from\n   * @param typeDefiningF the type that contains the field {@code f}\n   * @return the type information for the field\n   */\n  public static TypeInfo getTypeInfoForField(Field f, Type typeDefiningF) {\n    Class<?> classDefiningF = TypeUtils.toRawClass(typeDefiningF);\n    Type type = f.getGenericType();\n    Type actualType = getActualType(type, typeDefiningF, classDefiningF);\n    return new TypeInfo(actualType);\n  }\n\n  private static Type getActualType(\n      Type typeToEvaluate, Type parentType, Class<?> rawParentClass) {\n    if (typeToEvaluate instanceof Class<?>) {\n      return typeToEvaluate;\n    } else if (typeToEvaluate instanceof ParameterizedType) {\n      ParameterizedType castedType = (ParameterizedType) typeToEvaluate;\n      Type owner = castedType.getOwnerType();\n      Type[] actualTypeParameters =\n          extractRealTypes(castedType.getActualTypeArguments(), parentType, rawParentClass);\n      Type rawType = castedType.getRawType();\n      return new ParameterizedTypeImpl(rawType, actualTypeParameters, owner);\n    } else if (typeToEvaluate instanceof GenericArrayType) {\n      GenericArrayType castedType = (GenericArrayType) typeToEvaluate;\n      Type componentType = castedType.getGenericComponentType();\n      Type actualType = getActualType(componentType, parentType, rawParentClass);\n      if (componentType.equals(actualType)) {\n        return castedType;\n      }\n      return actualType instanceof Class<?> ?\n          TypeUtils.wrapWithArray(TypeUtils.toRawClass(actualType))\n          : new GenericArrayTypeImpl(actualType);\n    } else if (typeToEvaluate instanceof TypeVariable<?>) {\n      if (parentType instanceof ParameterizedType) {\n        // The class definition has the actual types used for the type variables.\n        // Find the matching actual type for the Type Variable used for the field.\n        // For example, class Foo<A> { A a; }\n        // new Foo<Integer>(); defines the actual type of A to be Integer.\n        // So, to find the type of the field a, we will have to look at the class'\n        // actual type arguments.\n        TypeVariable<?> fieldTypeVariable = (TypeVariable<?>) typeToEvaluate;\n        TypeVariable<?>[] classTypeVariables = rawParentClass.getTypeParameters();\n        ParameterizedType objParameterizedType = (ParameterizedType) parentType;\n        int indexOfActualTypeArgument = getIndex(classTypeVariables, fieldTypeVariable);\n        Type[] actualTypeArguments = objParameterizedType.getActualTypeArguments();\n        return actualTypeArguments[indexOfActualTypeArgument];\n      } else if (typeToEvaluate instanceof TypeVariable<?>) {\n        Type theSearchedType = null;\n\n        do {\n          theSearchedType = extractTypeForHierarchy(parentType, (TypeVariable<?>) typeToEvaluate);\n        } while ((theSearchedType != null) && (theSearchedType instanceof TypeVariable<?>));\n\n        if (theSearchedType != null) {\n          return theSearchedType;\n        }\n      }\n\n      throw new UnsupportedOperationException(\"Expecting parameterized type, got \" + parentType\n          + \".\\n Are you missing the use of TypeToken idiom?\\n See \"\n          + \"http://sites.google.com/site/gson/gson-user-guide#TOC-Serializing-and-Deserializing-Gener\");\n    } else if (typeToEvaluate instanceof WildcardType) {\n      WildcardType castedType = (WildcardType) typeToEvaluate;\n      return getActualType(castedType.getUpperBounds()[0], parentType, rawParentClass);\n    } else {\n      throw new IllegalArgumentException(\"Type \\'\" + typeToEvaluate + \"\\' is not a Class, \"\n          + \"ParameterizedType, GenericArrayType or TypeVariable. Can't extract type.\");\n    }\n  }\n\n  private static Type extractTypeForHierarchy(Type parentType, TypeVariable<?> typeToEvaluate) {\n    Class<?> rawParentType = null;\n    if (parentType instanceof Class<?>) {\n      rawParentType = (Class<?>) parentType;\n    } else if (parentType instanceof ParameterizedType) {\n      ParameterizedType parentTypeAsPT = (ParameterizedType) parentType;\n      rawParentType = (Class<?>) parentTypeAsPT.getRawType();\n    } else {\n      return null;\n    }\n\n    Type superClass = rawParentType.getGenericSuperclass();\n    if (superClass instanceof ParameterizedType\n        && ((ParameterizedType) superClass).getRawType() == typeToEvaluate.getGenericDeclaration()) {\n      // Evaluate type on this type\n      TypeVariable<?>[] classTypeVariables =\n          ((Class<?>) ((ParameterizedType) superClass).getRawType()).getTypeParameters();\n      int indexOfActualTypeArgument = getIndex(classTypeVariables, typeToEvaluate);\n\n      Type[] actualTypeArguments = null;\n      if (parentType instanceof Class<?>) {\n        actualTypeArguments = ((ParameterizedType) superClass).getActualTypeArguments();\n      } else if (parentType instanceof ParameterizedType) {\n        actualTypeArguments = ((ParameterizedType) parentType).getActualTypeArguments();\n      } else {\n        return null;\n      }\n\n      return actualTypeArguments[indexOfActualTypeArgument];\n    }\n\n    Type searchedType = null;\n    if (superClass != null) {\n      searchedType = extractTypeForHierarchy(superClass, typeToEvaluate);\n    }\n    return searchedType;\n  }\n\n  private static Type[] extractRealTypes(\n      Type[] actualTypeArguments, Type parentType, Class<?> rawParentClass) {\n    Preconditions.checkNotNull(actualTypeArguments);\n\n    Type[] retTypes = new Type[actualTypeArguments.length];\n    for (int i = 0; i < actualTypeArguments.length; ++i) {\n      retTypes[i] = getActualType(actualTypeArguments[i], parentType, rawParentClass);\n    }\n    return retTypes;\n  }\n\n  private static int getIndex(TypeVariable<?>[] types, TypeVariable<?> type) {\n    for (int i = 0; i < types.length; ++i) {\n      if (type.equals(types[i])) {\n        return i;\n      }\n    }\n    throw new IllegalStateException(\n        \"How can the type variable not be present in the class declaration!\");\n  }\n}\n"}]}
{"project": "Gson", "bug_id": 2, "classes_modified": [{"class_name": "com.google.gson.internal.bind.TypeAdapters", "buggy_version": "/*\n * Copyright (C) 2011 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.gson.internal.bind;\n\nimport com.google.gson.Gson;\nimport com.google.gson.JsonArray;\nimport com.google.gson.JsonElement;\nimport com.google.gson.JsonIOException;\nimport com.google.gson.JsonNull;\nimport com.google.gson.JsonObject;\nimport com.google.gson.JsonPrimitive;\nimport com.google.gson.JsonSyntaxException;\nimport com.google.gson.TypeAdapter;\nimport com.google.gson.TypeAdapterFactory;\nimport com.google.gson.annotations.SerializedName;\nimport com.google.gson.internal.LazilyParsedNumber;\nimport com.google.gson.reflect.TypeToken;\nimport com.google.gson.stream.JsonReader;\nimport com.google.gson.stream.JsonToken;\nimport com.google.gson.stream.JsonWriter;\nimport java.io.IOException;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.net.InetAddress;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.sql.Timestamp;\nimport java.util.BitSet;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\nimport java.util.HashMap;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.StringTokenizer;\nimport java.util.UUID;\n\n/**\n * Type adapters for basic types.\n */\npublic final class TypeAdapters {\n  private TypeAdapters() {\n    throw new UnsupportedOperationException();\n  }\n\n  @SuppressWarnings(\"rawtypes\")\n  public static final TypeAdapter<Class> CLASS = new TypeAdapter<Class>() {\n    @Override\n    public void write(JsonWriter out, Class value) throws IOException {\n      if (value == null) {\n        out.nullValue();\n      } else {\n        throw new UnsupportedOperationException(\"Attempted to serialize java.lang.Class: \"\n            + value.getName() + \". Forgot to register a type adapter?\");\n      }\n    }\n    @Override\n    public Class read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      } else {\n        throw new UnsupportedOperationException(\n            \"Attempted to deserialize a java.lang.Class. Forgot to register a type adapter?\");\n      }\n    }\n  };\n  public static final TypeAdapterFactory CLASS_FACTORY = newFactory(Class.class, CLASS);\n\n  public static final TypeAdapter<BitSet> BIT_SET = new TypeAdapter<BitSet>() {\n    public BitSet read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n\n      BitSet bitset = new BitSet();\n      in.beginArray();\n      int i = 0;\n      JsonToken tokenType = in.peek();\n      while (tokenType != JsonToken.END_ARRAY) {\n        boolean set;\n        switch (tokenType) {\n        case NUMBER:\n          set = in.nextInt() != 0;\n          break;\n        case BOOLEAN:\n          set = in.nextBoolean();\n          break;\n        case STRING:\n          String stringValue = in.nextString();\n          try {\n            set = Integer.parseInt(stringValue) != 0;\n          } catch (NumberFormatException e) {\n            throw new JsonSyntaxException(\n                \"Error: Expecting: bitset number value (1, 0), Found: \" + stringValue);\n          }\n          break;\n        default:\n          throw new JsonSyntaxException(\"Invalid bitset value type: \" + tokenType);\n        }\n        if (set) {\n          bitset.set(i);\n        }\n        ++i;\n        tokenType = in.peek();\n      }\n      in.endArray();\n      return bitset;\n    }\n\n    public void write(JsonWriter out, BitSet src) throws IOException {\n      if (src == null) {\n        out.nullValue();\n        return;\n      }\n\n      out.beginArray();\n      for (int i = 0; i < src.length(); i++) {\n        int value = (src.get(i)) ? 1 : 0;\n        out.value(value);\n      }\n      out.endArray();\n    }\n  };\n\n  public static final TypeAdapterFactory BIT_SET_FACTORY = newFactory(BitSet.class, BIT_SET);\n\n  public static final TypeAdapter<Boolean> BOOLEAN = new TypeAdapter<Boolean>() {\n    @Override\n    public Boolean read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      } else if (in.peek() == JsonToken.STRING) {\n        // support strings for compatibility with GSON 1.7\n        return Boolean.parseBoolean(in.nextString());\n      }\n      return in.nextBoolean();\n    }\n    @Override\n    public void write(JsonWriter out, Boolean value) throws IOException {\n      if (value == null) {\n        out.nullValue();\n        return;\n      }\n      out.value(value);\n    }\n  };\n\n  /**\n   * Writes a boolean as a string. Useful for map keys, where booleans aren't\n   * otherwise permitted.\n   */\n  public static final TypeAdapter<Boolean> BOOLEAN_AS_STRING = new TypeAdapter<Boolean>() {\n    @Override public Boolean read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return Boolean.valueOf(in.nextString());\n    }\n\n    @Override public void write(JsonWriter out, Boolean value) throws IOException {\n      out.value(value == null ? \"null\" : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory BOOLEAN_FACTORY\n      = newFactory(boolean.class, Boolean.class, BOOLEAN);\n\n  public static final TypeAdapter<Number> BYTE = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        int intValue = in.nextInt();\n        return (byte) intValue;\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapterFactory BYTE_FACTORY\n      = newFactory(byte.class, Byte.class, BYTE);\n\n  public static final TypeAdapter<Number> SHORT = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return (short) in.nextInt();\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapterFactory SHORT_FACTORY\n      = newFactory(short.class, Short.class, SHORT);\n\n  public static final TypeAdapter<Number> INTEGER = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return in.nextInt();\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapterFactory INTEGER_FACTORY\n      = newFactory(int.class, Integer.class, INTEGER);\n\n  public static final TypeAdapter<Number> LONG = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return in.nextLong();\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapter<Number> FLOAT = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return (float) in.nextDouble();\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapter<Number> DOUBLE = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return in.nextDouble();\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapter<Number> NUMBER = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      JsonToken jsonToken = in.peek();\n      switch (jsonToken) {\n      case NULL:\n        in.nextNull();\n        return null;\n      case NUMBER:\n        return new LazilyParsedNumber(in.nextString());\n      default:\n        throw new JsonSyntaxException(\"Expecting number, got: \" + jsonToken);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapterFactory NUMBER_FACTORY = newFactory(Number.class, NUMBER);\n\n  public static final TypeAdapter<Character> CHARACTER = new TypeAdapter<Character>() {\n    @Override\n    public Character read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      String str = in.nextString();\n      if (str.length() != 1) {\n        throw new JsonSyntaxException(\"Expecting character, got: \" + str);\n      }\n      return str.charAt(0);\n    }\n    @Override\n    public void write(JsonWriter out, Character value) throws IOException {\n      out.value(value == null ? null : String.valueOf(value));\n    }\n  };\n\n  public static final TypeAdapterFactory CHARACTER_FACTORY\n      = newFactory(char.class, Character.class, CHARACTER);\n\n  public static final TypeAdapter<String> STRING = new TypeAdapter<String>() {\n    @Override\n    public String read(JsonReader in) throws IOException {\n      JsonToken peek = in.peek();\n      if (peek == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      /* coerce booleans to strings for backwards compatibility */\n      if (peek == JsonToken.BOOLEAN) {\n        return Boolean.toString(in.nextBoolean());\n      }\n      return in.nextString();\n    }\n    @Override\n    public void write(JsonWriter out, String value) throws IOException {\n      out.value(value);\n    }\n  };\n  \n  public static final TypeAdapter<BigDecimal> BIG_DECIMAL = new TypeAdapter<BigDecimal>() {\n    @Override public BigDecimal read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return new BigDecimal(in.nextString());\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n\n    @Override public void write(JsonWriter out, BigDecimal value) throws IOException {\n      out.value(value);\n    }\n  };\n  \n  public static final TypeAdapter<BigInteger> BIG_INTEGER = new TypeAdapter<BigInteger>() {\n    @Override public BigInteger read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return new BigInteger(in.nextString());\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n\n    @Override public void write(JsonWriter out, BigInteger value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapterFactory STRING_FACTORY = newFactory(String.class, STRING);\n\n  public static final TypeAdapter<StringBuilder> STRING_BUILDER = new TypeAdapter<StringBuilder>() {\n    @Override\n    public StringBuilder read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return new StringBuilder(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, StringBuilder value) throws IOException {\n      out.value(value == null ? null : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory STRING_BUILDER_FACTORY =\n    newFactory(StringBuilder.class, STRING_BUILDER);\n\n  public static final TypeAdapter<StringBuffer> STRING_BUFFER = new TypeAdapter<StringBuffer>() {\n    @Override\n    public StringBuffer read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return new StringBuffer(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, StringBuffer value) throws IOException {\n      out.value(value == null ? null : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory STRING_BUFFER_FACTORY =\n    newFactory(StringBuffer.class, STRING_BUFFER);\n\n  public static final TypeAdapter<URL> URL = new TypeAdapter<URL>() {\n    @Override\n    public URL read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      String nextString = in.nextString();\n      return \"null\".equals(nextString) ? null : new URL(nextString);\n    }\n    @Override\n    public void write(JsonWriter out, URL value) throws IOException {\n      out.value(value == null ? null : value.toExternalForm());\n    }\n  };\n\n  public static final TypeAdapterFactory URL_FACTORY = newFactory(URL.class, URL);\n\n  public static final TypeAdapter<URI> URI = new TypeAdapter<URI>() {\n    @Override\n    public URI read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        String nextString = in.nextString();\n        return \"null\".equals(nextString) ? null : new URI(nextString);\n      } catch (URISyntaxException e) {\n        throw new JsonIOException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, URI value) throws IOException {\n      out.value(value == null ? null : value.toASCIIString());\n    }\n  };\n\n  public static final TypeAdapterFactory URI_FACTORY = newFactory(URI.class, URI);\n\n  public static final TypeAdapter<InetAddress> INET_ADDRESS = new TypeAdapter<InetAddress>() {\n    @Override\n    public InetAddress read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      // regrettably, this should have included both the host name and the host address\n      return InetAddress.getByName(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, InetAddress value) throws IOException {\n      out.value(value == null ? null : value.getHostAddress());\n    }\n  };\n\n  public static final TypeAdapterFactory INET_ADDRESS_FACTORY =\n    newTypeHierarchyFactory(InetAddress.class, INET_ADDRESS);\n\n  public static final TypeAdapter<UUID> UUID = new TypeAdapter<UUID>() {\n    @Override\n    public UUID read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return java.util.UUID.fromString(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, UUID value) throws IOException {\n      out.value(value == null ? null : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory UUID_FACTORY = newFactory(UUID.class, UUID);\n\n  public static final TypeAdapterFactory TIMESTAMP_FACTORY = new TypeAdapterFactory() {\n    @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n      if (typeToken.getRawType() != Timestamp.class) {\n        return null;\n      }\n\n      final TypeAdapter<Date> dateTypeAdapter = gson.getAdapter(Date.class);\n      return (TypeAdapter<T>) new TypeAdapter<Timestamp>() {\n        @Override public Timestamp read(JsonReader in) throws IOException {\n          Date date = dateTypeAdapter.read(in);\n          return date != null ? new Timestamp(date.getTime()) : null;\n        }\n\n        @Override public void write(JsonWriter out, Timestamp value) throws IOException {\n          dateTypeAdapter.write(out, value);\n        }\n      };\n    }\n  };\n\n  public static final TypeAdapter<Calendar> CALENDAR = new TypeAdapter<Calendar>() {\n    private static final String YEAR = \"year\";\n    private static final String MONTH = \"month\";\n    private static final String DAY_OF_MONTH = \"dayOfMonth\";\n    private static final String HOUR_OF_DAY = \"hourOfDay\";\n    private static final String MINUTE = \"minute\";\n    private static final String SECOND = \"second\";\n\n    @Override\n    public Calendar read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return  null;\n      }\n      in.beginObject();\n      int year = 0;\n      int month = 0;\n      int dayOfMonth = 0;\n      int hourOfDay = 0;\n      int minute = 0;\n      int second = 0;\n      while (in.peek() != JsonToken.END_OBJECT) {\n        String name = in.nextName();\n        int value = in.nextInt();\n        if (YEAR.equals(name)) {\n          year = value;\n        } else if (MONTH.equals(name)) {\n          month = value;\n        } else if (DAY_OF_MONTH.equals(name)) {\n          dayOfMonth = value;\n        } else if (HOUR_OF_DAY.equals(name)) {\n          hourOfDay = value;\n        } else if (MINUTE.equals(name)) {\n          minute = value;\n        } else if (SECOND.equals(name)) {\n          second = value;\n        }\n      }\n      in.endObject();\n      return new GregorianCalendar(year, month, dayOfMonth, hourOfDay, minute, second);\n    }\n\n    @Override\n    public void write(JsonWriter out, Calendar value) throws IOException {\n      if (value == null) {\n        out.nullValue();\n        return;\n      }\n      out.beginObject();\n      out.name(YEAR);\n      out.value(value.get(Calendar.YEAR));\n      out.name(MONTH);\n      out.value(value.get(Calendar.MONTH));\n      out.name(DAY_OF_MONTH);\n      out.value(value.get(Calendar.DAY_OF_MONTH));\n      out.name(HOUR_OF_DAY);\n      out.value(value.get(Calendar.HOUR_OF_DAY));\n      out.name(MINUTE);\n      out.value(value.get(Calendar.MINUTE));\n      out.name(SECOND);\n      out.value(value.get(Calendar.SECOND));\n      out.endObject();\n    }\n  };\n\n  public static final TypeAdapterFactory CALENDAR_FACTORY =\n    newFactoryForMultipleTypes(Calendar.class, GregorianCalendar.class, CALENDAR);\n\n  public static final TypeAdapter<Locale> LOCALE = new TypeAdapter<Locale>() {\n    @Override\n    public Locale read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      String locale = in.nextString();\n      StringTokenizer tokenizer = new StringTokenizer(locale, \"_\");\n      String language = null;\n      String country = null;\n      String variant = null;\n      if (tokenizer.hasMoreElements()) {\n        language = tokenizer.nextToken();\n      }\n      if (tokenizer.hasMoreElements()) {\n        country = tokenizer.nextToken();\n      }\n      if (tokenizer.hasMoreElements()) {\n        variant = tokenizer.nextToken();\n      }\n      if (country == null && variant == null) {\n        return new Locale(language);\n      } else if (variant == null) {\n        return new Locale(language, country);\n      } else {\n        return new Locale(language, country, variant);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Locale value) throws IOException {\n      out.value(value == null ? null : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory LOCALE_FACTORY = newFactory(Locale.class, LOCALE);\n\n  public static final TypeAdapter<JsonElement> JSON_ELEMENT = new TypeAdapter<JsonElement>() {\n    @Override public JsonElement read(JsonReader in) throws IOException {\n      switch (in.peek()) {\n      case STRING:\n        return new JsonPrimitive(in.nextString());\n      case NUMBER:\n        String number = in.nextString();\n        return new JsonPrimitive(new LazilyParsedNumber(number));\n      case BOOLEAN:\n        return new JsonPrimitive(in.nextBoolean());\n      case NULL:\n        in.nextNull();\n        return JsonNull.INSTANCE;\n      case BEGIN_ARRAY:\n        JsonArray array = new JsonArray();\n        in.beginArray();\n        while (in.hasNext()) {\n          array.add(read(in));\n        }\n        in.endArray();\n        return array;\n      case BEGIN_OBJECT:\n        JsonObject object = new JsonObject();\n        in.beginObject();\n        while (in.hasNext()) {\n          object.add(in.nextName(), read(in));\n        }\n        in.endObject();\n        return object;\n      case END_DOCUMENT:\n      case NAME:\n      case END_OBJECT:\n      case END_ARRAY:\n      default:\n        throw new IllegalArgumentException();\n      }\n    }\n\n    @Override public void write(JsonWriter out, JsonElement value) throws IOException {\n      if (value == null || value.isJsonNull()) {\n        out.nullValue();\n      } else if (value.isJsonPrimitive()) {\n        JsonPrimitive primitive = value.getAsJsonPrimitive();\n        if (primitive.isNumber()) {\n          out.value(primitive.getAsNumber());\n        } else if (primitive.isBoolean()) {\n          out.value(primitive.getAsBoolean());\n        } else {\n          out.value(primitive.getAsString());\n        }\n\n      } else if (value.isJsonArray()) {\n        out.beginArray();\n        for (JsonElement e : value.getAsJsonArray()) {\n          write(out, e);\n        }\n        out.endArray();\n\n      } else if (value.isJsonObject()) {\n        out.beginObject();\n        for (Map.Entry<String, JsonElement> e : value.getAsJsonObject().entrySet()) {\n          out.name(e.getKey());\n          write(out, e.getValue());\n        }\n        out.endObject();\n\n      } else {\n        throw new IllegalArgumentException(\"Couldn't write \" + value.getClass());\n      }\n    }\n  };\n\n  public static final TypeAdapterFactory JSON_ELEMENT_FACTORY\n      = newTypeHierarchyFactory(JsonElement.class, JSON_ELEMENT);\n\n  private static final class EnumTypeAdapter<T extends Enum<T>> extends TypeAdapter<T> {\n    private final Map<String, T> nameToConstant = new HashMap<String, T>();\n    private final Map<T, String> constantToName = new HashMap<T, String>();\n\n    public EnumTypeAdapter(Class<T> classOfT) {\n      try {\n        for (T constant : classOfT.getEnumConstants()) {\n          String name = constant.name();\n          SerializedName annotation = classOfT.getField(name).getAnnotation(SerializedName.class);\n          if (annotation != null) {\n            name = annotation.value();\n            for (String alternate : annotation.alternate()) {\n              nameToConstant.put(alternate, constant);\n            }\n          }\n          nameToConstant.put(name, constant);\n          constantToName.put(constant, name);\n        }\n      } catch (NoSuchFieldException e) {\n        throw new AssertionError();\n      }\n    }\n    public T read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return nameToConstant.get(in.nextString());\n    }\n\n    public void write(JsonWriter out, T value) throws IOException {\n      out.value(value == null ? null : constantToName.get(value));\n    }\n  }\n\n  public static final TypeAdapterFactory ENUM_FACTORY = new TypeAdapterFactory() {\n    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n      Class<? super T> rawType = typeToken.getRawType();\n      if (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) {\n        return null;\n      }\n      if (!rawType.isEnum()) {\n        rawType = rawType.getSuperclass(); // handle anonymous subclasses\n      }\n      return (TypeAdapter<T>) new EnumTypeAdapter(rawType);\n    }\n  };\n\n  public static <TT> TypeAdapterFactory newFactory(\n      final TypeToken<TT> type, final TypeAdapter<TT> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n      public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n        return typeToken.equals(type) ? (TypeAdapter<T>) typeAdapter : null;\n      }\n    };\n  }\n\n  public static <TT> TypeAdapterFactory newFactory(\n      final Class<TT> type, final TypeAdapter<TT> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n      public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n        return typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n      }\n      @Override public String toString() {\n        return \"Factory[type=\" + type.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }\n\n  public static <TT> TypeAdapterFactory newFactory(\n      final Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n      public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n        Class<? super T> rawType = typeToken.getRawType();\n        return (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n      }\n      @Override public String toString() {\n        return \"Factory[type=\" + boxed.getName()\n            + \"+\" + unboxed.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }\n\n  public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\n      final Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n      public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n        Class<? super T> rawType = typeToken.getRawType();\n        return (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n      }\n      @Override public String toString() {\n        return \"Factory[type=\" + base.getName()\n            + \"+\" + sub.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }\n\n  /**\n   * Returns a factory for all subtypes of {@code typeAdapter}. We do a runtime check to confirm\n   * that the deserialized type matches the type requested.\n   */\n  public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\n      final Class<T1> clazz, final TypeAdapter<T1> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\")\n      public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\n        final Class<? super T2> requestedType = typeToken.getRawType();\n        if (!clazz.isAssignableFrom(requestedType)) {\n          return null;\n        }\n        return (TypeAdapter<T2>) typeAdapter;\n\n      }\n      @Override public String toString() {\n        return \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }\n}\n", "fixed_version": "/*\n * Copyright (C) 2011 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.gson.internal.bind;\n\nimport com.google.gson.Gson;\nimport com.google.gson.JsonArray;\nimport com.google.gson.JsonElement;\nimport com.google.gson.JsonIOException;\nimport com.google.gson.JsonNull;\nimport com.google.gson.JsonObject;\nimport com.google.gson.JsonPrimitive;\nimport com.google.gson.JsonSyntaxException;\nimport com.google.gson.TypeAdapter;\nimport com.google.gson.TypeAdapterFactory;\nimport com.google.gson.annotations.SerializedName;\nimport com.google.gson.internal.LazilyParsedNumber;\nimport com.google.gson.reflect.TypeToken;\nimport com.google.gson.stream.JsonReader;\nimport com.google.gson.stream.JsonToken;\nimport com.google.gson.stream.JsonWriter;\nimport java.io.IOException;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.net.InetAddress;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.sql.Timestamp;\nimport java.util.BitSet;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\nimport java.util.HashMap;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.StringTokenizer;\nimport java.util.UUID;\n\n/**\n * Type adapters for basic types.\n */\npublic final class TypeAdapters {\n  private TypeAdapters() {\n    throw new UnsupportedOperationException();\n  }\n\n  @SuppressWarnings(\"rawtypes\")\n  public static final TypeAdapter<Class> CLASS = new TypeAdapter<Class>() {\n    @Override\n    public void write(JsonWriter out, Class value) throws IOException {\n      if (value == null) {\n        out.nullValue();\n      } else {\n        throw new UnsupportedOperationException(\"Attempted to serialize java.lang.Class: \"\n            + value.getName() + \". Forgot to register a type adapter?\");\n      }\n    }\n    @Override\n    public Class read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      } else {\n        throw new UnsupportedOperationException(\n            \"Attempted to deserialize a java.lang.Class. Forgot to register a type adapter?\");\n      }\n    }\n  };\n  public static final TypeAdapterFactory CLASS_FACTORY = newFactory(Class.class, CLASS);\n\n  public static final TypeAdapter<BitSet> BIT_SET = new TypeAdapter<BitSet>() {\n    public BitSet read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n\n      BitSet bitset = new BitSet();\n      in.beginArray();\n      int i = 0;\n      JsonToken tokenType = in.peek();\n      while (tokenType != JsonToken.END_ARRAY) {\n        boolean set;\n        switch (tokenType) {\n        case NUMBER:\n          set = in.nextInt() != 0;\n          break;\n        case BOOLEAN:\n          set = in.nextBoolean();\n          break;\n        case STRING:\n          String stringValue = in.nextString();\n          try {\n            set = Integer.parseInt(stringValue) != 0;\n          } catch (NumberFormatException e) {\n            throw new JsonSyntaxException(\n                \"Error: Expecting: bitset number value (1, 0), Found: \" + stringValue);\n          }\n          break;\n        default:\n          throw new JsonSyntaxException(\"Invalid bitset value type: \" + tokenType);\n        }\n        if (set) {\n          bitset.set(i);\n        }\n        ++i;\n        tokenType = in.peek();\n      }\n      in.endArray();\n      return bitset;\n    }\n\n    public void write(JsonWriter out, BitSet src) throws IOException {\n      if (src == null) {\n        out.nullValue();\n        return;\n      }\n\n      out.beginArray();\n      for (int i = 0; i < src.length(); i++) {\n        int value = (src.get(i)) ? 1 : 0;\n        out.value(value);\n      }\n      out.endArray();\n    }\n  };\n\n  public static final TypeAdapterFactory BIT_SET_FACTORY = newFactory(BitSet.class, BIT_SET);\n\n  public static final TypeAdapter<Boolean> BOOLEAN = new TypeAdapter<Boolean>() {\n    @Override\n    public Boolean read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      } else if (in.peek() == JsonToken.STRING) {\n        // support strings for compatibility with GSON 1.7\n        return Boolean.parseBoolean(in.nextString());\n      }\n      return in.nextBoolean();\n    }\n    @Override\n    public void write(JsonWriter out, Boolean value) throws IOException {\n      if (value == null) {\n        out.nullValue();\n        return;\n      }\n      out.value(value);\n    }\n  };\n\n  /**\n   * Writes a boolean as a string. Useful for map keys, where booleans aren't\n   * otherwise permitted.\n   */\n  public static final TypeAdapter<Boolean> BOOLEAN_AS_STRING = new TypeAdapter<Boolean>() {\n    @Override public Boolean read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return Boolean.valueOf(in.nextString());\n    }\n\n    @Override public void write(JsonWriter out, Boolean value) throws IOException {\n      out.value(value == null ? \"null\" : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory BOOLEAN_FACTORY\n      = newFactory(boolean.class, Boolean.class, BOOLEAN);\n\n  public static final TypeAdapter<Number> BYTE = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        int intValue = in.nextInt();\n        return (byte) intValue;\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapterFactory BYTE_FACTORY\n      = newFactory(byte.class, Byte.class, BYTE);\n\n  public static final TypeAdapter<Number> SHORT = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return (short) in.nextInt();\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapterFactory SHORT_FACTORY\n      = newFactory(short.class, Short.class, SHORT);\n\n  public static final TypeAdapter<Number> INTEGER = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return in.nextInt();\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapterFactory INTEGER_FACTORY\n      = newFactory(int.class, Integer.class, INTEGER);\n\n  public static final TypeAdapter<Number> LONG = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return in.nextLong();\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapter<Number> FLOAT = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return (float) in.nextDouble();\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapter<Number> DOUBLE = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return in.nextDouble();\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapter<Number> NUMBER = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      JsonToken jsonToken = in.peek();\n      switch (jsonToken) {\n      case NULL:\n        in.nextNull();\n        return null;\n      case NUMBER:\n        return new LazilyParsedNumber(in.nextString());\n      default:\n        throw new JsonSyntaxException(\"Expecting number, got: \" + jsonToken);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapterFactory NUMBER_FACTORY = newFactory(Number.class, NUMBER);\n\n  public static final TypeAdapter<Character> CHARACTER = new TypeAdapter<Character>() {\n    @Override\n    public Character read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      String str = in.nextString();\n      if (str.length() != 1) {\n        throw new JsonSyntaxException(\"Expecting character, got: \" + str);\n      }\n      return str.charAt(0);\n    }\n    @Override\n    public void write(JsonWriter out, Character value) throws IOException {\n      out.value(value == null ? null : String.valueOf(value));\n    }\n  };\n\n  public static final TypeAdapterFactory CHARACTER_FACTORY\n      = newFactory(char.class, Character.class, CHARACTER);\n\n  public static final TypeAdapter<String> STRING = new TypeAdapter<String>() {\n    @Override\n    public String read(JsonReader in) throws IOException {\n      JsonToken peek = in.peek();\n      if (peek == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      /* coerce booleans to strings for backwards compatibility */\n      if (peek == JsonToken.BOOLEAN) {\n        return Boolean.toString(in.nextBoolean());\n      }\n      return in.nextString();\n    }\n    @Override\n    public void write(JsonWriter out, String value) throws IOException {\n      out.value(value);\n    }\n  };\n  \n  public static final TypeAdapter<BigDecimal> BIG_DECIMAL = new TypeAdapter<BigDecimal>() {\n    @Override public BigDecimal read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return new BigDecimal(in.nextString());\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n\n    @Override public void write(JsonWriter out, BigDecimal value) throws IOException {\n      out.value(value);\n    }\n  };\n  \n  public static final TypeAdapter<BigInteger> BIG_INTEGER = new TypeAdapter<BigInteger>() {\n    @Override public BigInteger read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return new BigInteger(in.nextString());\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n\n    @Override public void write(JsonWriter out, BigInteger value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapterFactory STRING_FACTORY = newFactory(String.class, STRING);\n\n  public static final TypeAdapter<StringBuilder> STRING_BUILDER = new TypeAdapter<StringBuilder>() {\n    @Override\n    public StringBuilder read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return new StringBuilder(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, StringBuilder value) throws IOException {\n      out.value(value == null ? null : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory STRING_BUILDER_FACTORY =\n    newFactory(StringBuilder.class, STRING_BUILDER);\n\n  public static final TypeAdapter<StringBuffer> STRING_BUFFER = new TypeAdapter<StringBuffer>() {\n    @Override\n    public StringBuffer read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return new StringBuffer(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, StringBuffer value) throws IOException {\n      out.value(value == null ? null : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory STRING_BUFFER_FACTORY =\n    newFactory(StringBuffer.class, STRING_BUFFER);\n\n  public static final TypeAdapter<URL> URL = new TypeAdapter<URL>() {\n    @Override\n    public URL read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      String nextString = in.nextString();\n      return \"null\".equals(nextString) ? null : new URL(nextString);\n    }\n    @Override\n    public void write(JsonWriter out, URL value) throws IOException {\n      out.value(value == null ? null : value.toExternalForm());\n    }\n  };\n\n  public static final TypeAdapterFactory URL_FACTORY = newFactory(URL.class, URL);\n\n  public static final TypeAdapter<URI> URI = new TypeAdapter<URI>() {\n    @Override\n    public URI read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        String nextString = in.nextString();\n        return \"null\".equals(nextString) ? null : new URI(nextString);\n      } catch (URISyntaxException e) {\n        throw new JsonIOException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, URI value) throws IOException {\n      out.value(value == null ? null : value.toASCIIString());\n    }\n  };\n\n  public static final TypeAdapterFactory URI_FACTORY = newFactory(URI.class, URI);\n\n  public static final TypeAdapter<InetAddress> INET_ADDRESS = new TypeAdapter<InetAddress>() {\n    @Override\n    public InetAddress read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      // regrettably, this should have included both the host name and the host address\n      return InetAddress.getByName(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, InetAddress value) throws IOException {\n      out.value(value == null ? null : value.getHostAddress());\n    }\n  };\n\n  public static final TypeAdapterFactory INET_ADDRESS_FACTORY =\n    newTypeHierarchyFactory(InetAddress.class, INET_ADDRESS);\n\n  public static final TypeAdapter<UUID> UUID = new TypeAdapter<UUID>() {\n    @Override\n    public UUID read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return java.util.UUID.fromString(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, UUID value) throws IOException {\n      out.value(value == null ? null : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory UUID_FACTORY = newFactory(UUID.class, UUID);\n\n  public static final TypeAdapterFactory TIMESTAMP_FACTORY = new TypeAdapterFactory() {\n    @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n      if (typeToken.getRawType() != Timestamp.class) {\n        return null;\n      }\n\n      final TypeAdapter<Date> dateTypeAdapter = gson.getAdapter(Date.class);\n      return (TypeAdapter<T>) new TypeAdapter<Timestamp>() {\n        @Override public Timestamp read(JsonReader in) throws IOException {\n          Date date = dateTypeAdapter.read(in);\n          return date != null ? new Timestamp(date.getTime()) : null;\n        }\n\n        @Override public void write(JsonWriter out, Timestamp value) throws IOException {\n          dateTypeAdapter.write(out, value);\n        }\n      };\n    }\n  };\n\n  public static final TypeAdapter<Calendar> CALENDAR = new TypeAdapter<Calendar>() {\n    private static final String YEAR = \"year\";\n    private static final String MONTH = \"month\";\n    private static final String DAY_OF_MONTH = \"dayOfMonth\";\n    private static final String HOUR_OF_DAY = \"hourOfDay\";\n    private static final String MINUTE = \"minute\";\n    private static final String SECOND = \"second\";\n\n    @Override\n    public Calendar read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return  null;\n      }\n      in.beginObject();\n      int year = 0;\n      int month = 0;\n      int dayOfMonth = 0;\n      int hourOfDay = 0;\n      int minute = 0;\n      int second = 0;\n      while (in.peek() != JsonToken.END_OBJECT) {\n        String name = in.nextName();\n        int value = in.nextInt();\n        if (YEAR.equals(name)) {\n          year = value;\n        } else if (MONTH.equals(name)) {\n          month = value;\n        } else if (DAY_OF_MONTH.equals(name)) {\n          dayOfMonth = value;\n        } else if (HOUR_OF_DAY.equals(name)) {\n          hourOfDay = value;\n        } else if (MINUTE.equals(name)) {\n          minute = value;\n        } else if (SECOND.equals(name)) {\n          second = value;\n        }\n      }\n      in.endObject();\n      return new GregorianCalendar(year, month, dayOfMonth, hourOfDay, minute, second);\n    }\n\n    @Override\n    public void write(JsonWriter out, Calendar value) throws IOException {\n      if (value == null) {\n        out.nullValue();\n        return;\n      }\n      out.beginObject();\n      out.name(YEAR);\n      out.value(value.get(Calendar.YEAR));\n      out.name(MONTH);\n      out.value(value.get(Calendar.MONTH));\n      out.name(DAY_OF_MONTH);\n      out.value(value.get(Calendar.DAY_OF_MONTH));\n      out.name(HOUR_OF_DAY);\n      out.value(value.get(Calendar.HOUR_OF_DAY));\n      out.name(MINUTE);\n      out.value(value.get(Calendar.MINUTE));\n      out.name(SECOND);\n      out.value(value.get(Calendar.SECOND));\n      out.endObject();\n    }\n  };\n\n  public static final TypeAdapterFactory CALENDAR_FACTORY =\n    newFactoryForMultipleTypes(Calendar.class, GregorianCalendar.class, CALENDAR);\n\n  public static final TypeAdapter<Locale> LOCALE = new TypeAdapter<Locale>() {\n    @Override\n    public Locale read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      String locale = in.nextString();\n      StringTokenizer tokenizer = new StringTokenizer(locale, \"_\");\n      String language = null;\n      String country = null;\n      String variant = null;\n      if (tokenizer.hasMoreElements()) {\n        language = tokenizer.nextToken();\n      }\n      if (tokenizer.hasMoreElements()) {\n        country = tokenizer.nextToken();\n      }\n      if (tokenizer.hasMoreElements()) {\n        variant = tokenizer.nextToken();\n      }\n      if (country == null && variant == null) {\n        return new Locale(language);\n      } else if (variant == null) {\n        return new Locale(language, country);\n      } else {\n        return new Locale(language, country, variant);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Locale value) throws IOException {\n      out.value(value == null ? null : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory LOCALE_FACTORY = newFactory(Locale.class, LOCALE);\n\n  public static final TypeAdapter<JsonElement> JSON_ELEMENT = new TypeAdapter<JsonElement>() {\n    @Override public JsonElement read(JsonReader in) throws IOException {\n      switch (in.peek()) {\n      case STRING:\n        return new JsonPrimitive(in.nextString());\n      case NUMBER:\n        String number = in.nextString();\n        return new JsonPrimitive(new LazilyParsedNumber(number));\n      case BOOLEAN:\n        return new JsonPrimitive(in.nextBoolean());\n      case NULL:\n        in.nextNull();\n        return JsonNull.INSTANCE;\n      case BEGIN_ARRAY:\n        JsonArray array = new JsonArray();\n        in.beginArray();\n        while (in.hasNext()) {\n          array.add(read(in));\n        }\n        in.endArray();\n        return array;\n      case BEGIN_OBJECT:\n        JsonObject object = new JsonObject();\n        in.beginObject();\n        while (in.hasNext()) {\n          object.add(in.nextName(), read(in));\n        }\n        in.endObject();\n        return object;\n      case END_DOCUMENT:\n      case NAME:\n      case END_OBJECT:\n      case END_ARRAY:\n      default:\n        throw new IllegalArgumentException();\n      }\n    }\n\n    @Override public void write(JsonWriter out, JsonElement value) throws IOException {\n      if (value == null || value.isJsonNull()) {\n        out.nullValue();\n      } else if (value.isJsonPrimitive()) {\n        JsonPrimitive primitive = value.getAsJsonPrimitive();\n        if (primitive.isNumber()) {\n          out.value(primitive.getAsNumber());\n        } else if (primitive.isBoolean()) {\n          out.value(primitive.getAsBoolean());\n        } else {\n          out.value(primitive.getAsString());\n        }\n\n      } else if (value.isJsonArray()) {\n        out.beginArray();\n        for (JsonElement e : value.getAsJsonArray()) {\n          write(out, e);\n        }\n        out.endArray();\n\n      } else if (value.isJsonObject()) {\n        out.beginObject();\n        for (Map.Entry<String, JsonElement> e : value.getAsJsonObject().entrySet()) {\n          out.name(e.getKey());\n          write(out, e.getValue());\n        }\n        out.endObject();\n\n      } else {\n        throw new IllegalArgumentException(\"Couldn't write \" + value.getClass());\n      }\n    }\n  };\n\n  public static final TypeAdapterFactory JSON_ELEMENT_FACTORY\n      = newTypeHierarchyFactory(JsonElement.class, JSON_ELEMENT);\n\n  private static final class EnumTypeAdapter<T extends Enum<T>> extends TypeAdapter<T> {\n    private final Map<String, T> nameToConstant = new HashMap<String, T>();\n    private final Map<T, String> constantToName = new HashMap<T, String>();\n\n    public EnumTypeAdapter(Class<T> classOfT) {\n      try {\n        for (T constant : classOfT.getEnumConstants()) {\n          String name = constant.name();\n          SerializedName annotation = classOfT.getField(name).getAnnotation(SerializedName.class);\n          if (annotation != null) {\n            name = annotation.value();\n            for (String alternate : annotation.alternate()) {\n              nameToConstant.put(alternate, constant);\n            }\n          }\n          nameToConstant.put(name, constant);\n          constantToName.put(constant, name);\n        }\n      } catch (NoSuchFieldException e) {\n        throw new AssertionError();\n      }\n    }\n    public T read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return nameToConstant.get(in.nextString());\n    }\n\n    public void write(JsonWriter out, T value) throws IOException {\n      out.value(value == null ? null : constantToName.get(value));\n    }\n  }\n\n  public static final TypeAdapterFactory ENUM_FACTORY = new TypeAdapterFactory() {\n    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n      Class<? super T> rawType = typeToken.getRawType();\n      if (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) {\n        return null;\n      }\n      if (!rawType.isEnum()) {\n        rawType = rawType.getSuperclass(); // handle anonymous subclasses\n      }\n      return (TypeAdapter<T>) new EnumTypeAdapter(rawType);\n    }\n  };\n\n  public static <TT> TypeAdapterFactory newFactory(\n      final TypeToken<TT> type, final TypeAdapter<TT> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n      public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n        return typeToken.equals(type) ? (TypeAdapter<T>) typeAdapter : null;\n      }\n    };\n  }\n\n  public static <TT> TypeAdapterFactory newFactory(\n      final Class<TT> type, final TypeAdapter<TT> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n      public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n        return typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n      }\n      @Override public String toString() {\n        return \"Factory[type=\" + type.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }\n\n  public static <TT> TypeAdapterFactory newFactory(\n      final Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n      public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n        Class<? super T> rawType = typeToken.getRawType();\n        return (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n      }\n      @Override public String toString() {\n        return \"Factory[type=\" + boxed.getName()\n            + \"+\" + unboxed.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }\n\n  public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\n      final Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n      public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n        Class<? super T> rawType = typeToken.getRawType();\n        return (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n      }\n      @Override public String toString() {\n        return \"Factory[type=\" + base.getName()\n            + \"+\" + sub.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }\n\n  /**\n   * Returns a factory for all subtypes of {@code typeAdapter}. We do a runtime check to confirm\n   * that the deserialized type matches the type requested.\n   */\n  public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\n      final Class<T1> clazz, final TypeAdapter<T1> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\")\n      public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\n        final Class<? super T2> requestedType = typeToken.getRawType();\n        if (!clazz.isAssignableFrom(requestedType)) {\n          return null;\n        }\n        return (TypeAdapter<T2>) new TypeAdapter<T1>() {\n          @Override public void write(JsonWriter out, T1 value) throws IOException {\n            typeAdapter.write(out, value);\n          }\n\n          @Override public T1 read(JsonReader in) throws IOException {\n            T1 result = typeAdapter.read(in);\n            if (result != null && !requestedType.isInstance(result)) {\n              throw new JsonSyntaxException(\"Expected a \" + requestedType.getName()\n                  + \" but was \" + result.getClass().getName());\n            }\n            return result;\n          }\n        };\n      }\n      @Override public String toString() {\n        return \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }\n}\n"}]}
{"project": "Gson", "bug_id": 3, "classes_modified": [{"class_name": "com.google.gson.internal.ConstructorConstructor", "buggy_version": "/*\n * Copyright (C) 2011 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.gson.internal;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.EnumSet;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedHashSet;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.Set;\nimport java.util.SortedMap;\nimport java.util.SortedSet;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\nimport com.google.gson.InstanceCreator;\nimport com.google.gson.JsonIOException;\nimport com.google.gson.reflect.TypeToken;\n\n/**\n * Returns a function that can construct an instance of a requested type.\n */\npublic final class ConstructorConstructor {\n  private final Map<Type, InstanceCreator<?>> instanceCreators;\n\n  public ConstructorConstructor(Map<Type, InstanceCreator<?>> instanceCreators) {\n    this.instanceCreators = instanceCreators;\n  }\n\n  public <T> ObjectConstructor<T> get(TypeToken<T> typeToken) {\n    final Type type = typeToken.getType();\n    final Class<? super T> rawType = typeToken.getRawType();\n\n    // first try an instance creator\n\n    @SuppressWarnings(\"unchecked\") // types must agree\n    final InstanceCreator<T> typeCreator = (InstanceCreator<T>) instanceCreators.get(type);\n    if (typeCreator != null) {\n      return new ObjectConstructor<T>() {\n        @Override public T construct() {\n          return typeCreator.createInstance(type);\n        }\n      };\n    }\n\n    // Next try raw type match for instance creators\n    @SuppressWarnings(\"unchecked\") // types must agree\n    final InstanceCreator<T> rawTypeCreator =\n        (InstanceCreator<T>) instanceCreators.get(rawType);\n    if (rawTypeCreator != null) {\n      return new ObjectConstructor<T>() {\n        @Override public T construct() {\n          return rawTypeCreator.createInstance(type);\n        }\n      };\n    }\n\n    ObjectConstructor<T> defaultConstructor = newDefaultConstructor(rawType);\n    if (defaultConstructor != null) {\n      return defaultConstructor;\n    }\n\n    ObjectConstructor<T> defaultImplementation = newDefaultImplementationConstructor(type, rawType);\n    if (defaultImplementation != null) {\n      return defaultImplementation;\n    }\n\n    // finally try unsafe\n    return newUnsafeAllocator(type, rawType);\n  }\n\n  private <T> ObjectConstructor<T> newDefaultConstructor(Class<? super T> rawType) {\n    try {\n      final Constructor<? super T> constructor = rawType.getDeclaredConstructor();\n      if (!constructor.isAccessible()) {\n        constructor.setAccessible(true);\n      }\n      return new ObjectConstructor<T>() {\n        @SuppressWarnings(\"unchecked\") // T is the same raw type as is requested\n        @Override public T construct() {\n          try {\n            Object[] args = null;\n            return (T) constructor.newInstance(args);\n          } catch (InstantiationException e) {\n            // TODO: JsonParseException ?\n            throw new RuntimeException(\"Failed to invoke \" + constructor + \" with no args\", e);\n          } catch (InvocationTargetException e) {\n            // TODO: don't wrap if cause is unchecked!\n            // TODO: JsonParseException ?\n            throw new RuntimeException(\"Failed to invoke \" + constructor + \" with no args\",\n                e.getTargetException());\n          } catch (IllegalAccessException e) {\n            throw new AssertionError(e);\n          }\n        }\n      };\n    } catch (NoSuchMethodException e) {\n      return null;\n    }\n  }\n\n  /**\n   * Constructors for common interface types like Map and List and their\n   * subtypes.\n   */\n  @SuppressWarnings(\"unchecked\") // use runtime checks to guarantee that 'T' is what it is\n  private <T> ObjectConstructor<T> newDefaultImplementationConstructor(\n      final Type type, Class<? super T> rawType) {\n    if (Collection.class.isAssignableFrom(rawType)) {\n      if (SortedSet.class.isAssignableFrom(rawType)) {\n        return new ObjectConstructor<T>() {\n          @Override public T construct() {\n            return (T) new TreeSet<Object>();\n          }\n        };\n      } else if (EnumSet.class.isAssignableFrom(rawType)) {\n        return new ObjectConstructor<T>() {\n          @SuppressWarnings(\"rawtypes\")\n          @Override public T construct() {\n            if (type instanceof ParameterizedType) {\n              Type elementType = ((ParameterizedType) type).getActualTypeArguments()[0];\n              if (elementType instanceof Class) {\n                return (T) EnumSet.noneOf((Class)elementType);\n              } else {\n                throw new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n              }\n            } else {\n              throw new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n            }\n          }\n        };\n      } else if (Set.class.isAssignableFrom(rawType)) {\n        return new ObjectConstructor<T>() {\n          @Override public T construct() {\n            return (T) new LinkedHashSet<Object>();\n          }\n        };\n      } else if (Queue.class.isAssignableFrom(rawType)) {\n        return new ObjectConstructor<T>() {\n          @Override public T construct() {\n            return (T) new LinkedList<Object>();\n          }\n        };\n      } else {\n        return new ObjectConstructor<T>() {\n          @Override public T construct() {\n            return (T) new ArrayList<Object>();\n          }\n        };\n      }\n    }\n\n    if (Map.class.isAssignableFrom(rawType)) {\n      if (SortedMap.class.isAssignableFrom(rawType)) {\n        return new ObjectConstructor<T>() {\n          @Override public T construct() {\n            return (T) new TreeMap<Object, Object>();\n          }\n        };\n      } else if (type instanceof ParameterizedType && !(String.class.isAssignableFrom(\n          TypeToken.get(((ParameterizedType) type).getActualTypeArguments()[0]).getRawType()))) {\n        return new ObjectConstructor<T>() {\n          @Override public T construct() {\n            return (T) new LinkedHashMap<Object, Object>();\n          }\n        };\n      } else {\n        return new ObjectConstructor<T>() {\n          @Override public T construct() {\n            return (T) new LinkedTreeMap<String, Object>();\n          }\n        };\n      }\n    }\n\n    return null;\n  }\n\n  private <T> ObjectConstructor<T> newUnsafeAllocator(\n      final Type type, final Class<? super T> rawType) {\n    return new ObjectConstructor<T>() {\n      private final UnsafeAllocator unsafeAllocator = UnsafeAllocator.create();\n      @SuppressWarnings(\"unchecked\")\n      @Override public T construct() {\n        try {\n          Object newInstance = unsafeAllocator.newInstance(rawType);\n          return (T) newInstance;\n        } catch (Exception e) {\n          throw new RuntimeException((\"Unable to invoke no-args constructor for \" + type + \". \"\n              + \"Register an InstanceCreator with Gson for this type may fix this problem.\"), e);\n        }\n      }\n    };\n  }\n\n  @Override public String toString() {\n    return instanceCreators.toString();\n  }\n}\n", "fixed_version": "/*\n * Copyright (C) 2011 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.gson.internal;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.EnumSet;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedHashSet;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.Set;\nimport java.util.SortedMap;\nimport java.util.SortedSet;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.concurrent.ConcurrentNavigableMap;\nimport java.util.concurrent.ConcurrentSkipListMap;\n\nimport com.google.gson.InstanceCreator;\nimport com.google.gson.JsonIOException;\nimport com.google.gson.reflect.TypeToken;\n\n/**\n * Returns a function that can construct an instance of a requested type.\n */\npublic final class ConstructorConstructor {\n  private final Map<Type, InstanceCreator<?>> instanceCreators;\n\n  public ConstructorConstructor(Map<Type, InstanceCreator<?>> instanceCreators) {\n    this.instanceCreators = instanceCreators;\n  }\n\n  public <T> ObjectConstructor<T> get(TypeToken<T> typeToken) {\n    final Type type = typeToken.getType();\n    final Class<? super T> rawType = typeToken.getRawType();\n\n    // first try an instance creator\n\n    @SuppressWarnings(\"unchecked\") // types must agree\n    final InstanceCreator<T> typeCreator = (InstanceCreator<T>) instanceCreators.get(type);\n    if (typeCreator != null) {\n      return new ObjectConstructor<T>() {\n        @Override public T construct() {\n          return typeCreator.createInstance(type);\n        }\n      };\n    }\n\n    // Next try raw type match for instance creators\n    @SuppressWarnings(\"unchecked\") // types must agree\n    final InstanceCreator<T> rawTypeCreator =\n        (InstanceCreator<T>) instanceCreators.get(rawType);\n    if (rawTypeCreator != null) {\n      return new ObjectConstructor<T>() {\n        @Override public T construct() {\n          return rawTypeCreator.createInstance(type);\n        }\n      };\n    }\n\n    ObjectConstructor<T> defaultConstructor = newDefaultConstructor(rawType);\n    if (defaultConstructor != null) {\n      return defaultConstructor;\n    }\n\n    ObjectConstructor<T> defaultImplementation = newDefaultImplementationConstructor(type, rawType);\n    if (defaultImplementation != null) {\n      return defaultImplementation;\n    }\n\n    // finally try unsafe\n    return newUnsafeAllocator(type, rawType);\n  }\n\n  private <T> ObjectConstructor<T> newDefaultConstructor(Class<? super T> rawType) {\n    try {\n      final Constructor<? super T> constructor = rawType.getDeclaredConstructor();\n      if (!constructor.isAccessible()) {\n        constructor.setAccessible(true);\n      }\n      return new ObjectConstructor<T>() {\n        @SuppressWarnings(\"unchecked\") // T is the same raw type as is requested\n        @Override public T construct() {\n          try {\n            Object[] args = null;\n            return (T) constructor.newInstance(args);\n          } catch (InstantiationException e) {\n            // TODO: JsonParseException ?\n            throw new RuntimeException(\"Failed to invoke \" + constructor + \" with no args\", e);\n          } catch (InvocationTargetException e) {\n            // TODO: don't wrap if cause is unchecked!\n            // TODO: JsonParseException ?\n            throw new RuntimeException(\"Failed to invoke \" + constructor + \" with no args\",\n                e.getTargetException());\n          } catch (IllegalAccessException e) {\n            throw new AssertionError(e);\n          }\n        }\n      };\n    } catch (NoSuchMethodException e) {\n      return null;\n    }\n  }\n\n  /**\n   * Constructors for common interface types like Map and List and their\n   * subtypes.\n   */\n  @SuppressWarnings(\"unchecked\") // use runtime checks to guarantee that 'T' is what it is\n  private <T> ObjectConstructor<T> newDefaultImplementationConstructor(\n      final Type type, Class<? super T> rawType) {\n    if (Collection.class.isAssignableFrom(rawType)) {\n      if (SortedSet.class.isAssignableFrom(rawType)) {\n        return new ObjectConstructor<T>() {\n          @Override public T construct() {\n            return (T) new TreeSet<Object>();\n          }\n        };\n      } else if (EnumSet.class.isAssignableFrom(rawType)) {\n        return new ObjectConstructor<T>() {\n          @SuppressWarnings(\"rawtypes\")\n          @Override public T construct() {\n            if (type instanceof ParameterizedType) {\n              Type elementType = ((ParameterizedType) type).getActualTypeArguments()[0];\n              if (elementType instanceof Class) {\n                return (T) EnumSet.noneOf((Class)elementType);\n              } else {\n                throw new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n              }\n            } else {\n              throw new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n            }\n          }\n        };\n      } else if (Set.class.isAssignableFrom(rawType)) {\n        return new ObjectConstructor<T>() {\n          @Override public T construct() {\n            return (T) new LinkedHashSet<Object>();\n          }\n        };\n      } else if (Queue.class.isAssignableFrom(rawType)) {\n        return new ObjectConstructor<T>() {\n          @Override public T construct() {\n            return (T) new LinkedList<Object>();\n          }\n        };\n      } else {\n        return new ObjectConstructor<T>() {\n          @Override public T construct() {\n            return (T) new ArrayList<Object>();\n          }\n        };\n      }\n    }\n\n    if (Map.class.isAssignableFrom(rawType)) {\n      if (ConcurrentNavigableMap.class.isAssignableFrom(rawType)) {\n        return new ObjectConstructor<T>() {\n          @Override public T construct() {\n            return (T) new ConcurrentSkipListMap<Object, Object>();\n          }\n        };\n      } else if (ConcurrentMap.class.isAssignableFrom(rawType)) {\n        return new ObjectConstructor<T>() {\n          @Override public T construct() {\n            return (T) new ConcurrentHashMap<Object, Object>();\n          }\n        };\n      } else if (SortedMap.class.isAssignableFrom(rawType)) {\n        return new ObjectConstructor<T>() {\n          @Override public T construct() {\n            return (T) new TreeMap<Object, Object>();\n          }\n        };\n      } else if (type instanceof ParameterizedType && !(String.class.isAssignableFrom(\n          TypeToken.get(((ParameterizedType) type).getActualTypeArguments()[0]).getRawType()))) {\n        return new ObjectConstructor<T>() {\n          @Override public T construct() {\n            return (T) new LinkedHashMap<Object, Object>();\n          }\n        };\n      } else {\n        return new ObjectConstructor<T>() {\n          @Override public T construct() {\n            return (T) new LinkedTreeMap<String, Object>();\n          }\n        };\n      }\n    }\n\n    return null;\n  }\n\n  private <T> ObjectConstructor<T> newUnsafeAllocator(\n      final Type type, final Class<? super T> rawType) {\n    return new ObjectConstructor<T>() {\n      private final UnsafeAllocator unsafeAllocator = UnsafeAllocator.create();\n      @SuppressWarnings(\"unchecked\")\n      @Override public T construct() {\n        try {\n          Object newInstance = unsafeAllocator.newInstance(rawType);\n          return (T) newInstance;\n        } catch (Exception e) {\n          throw new RuntimeException((\"Unable to invoke no-args constructor for \" + type + \". \"\n              + \"Register an InstanceCreator with Gson for this type may fix this problem.\"), e);\n        }\n      }\n    };\n  }\n\n  @Override public String toString() {\n    return instanceCreators.toString();\n  }\n}\n"}]}
{"project": "Gson", "bug_id": 4, "classes_modified": [{"class_name": "com.google.gson.stream.JsonReader", "buggy_version": "/*\n * Copyright (C) 2010 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.gson.stream;\n\nimport com.google.gson.internal.JsonReaderInternalAccess;\nimport com.google.gson.internal.bind.JsonTreeReader;\nimport java.io.Closeable;\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.io.Reader;\n\n/**\n * Reads a JSON (<a href=\"http://www.ietf.org/rfc/rfc7159.txt\">RFC 7159</a>)\n * encoded value as a stream of tokens. This stream includes both literal\n * values (strings, numbers, booleans, and nulls) as well as the begin and\n * end delimiters of objects and arrays. The tokens are traversed in\n * depth-first order, the same order that they appear in the JSON document.\n * Within JSON objects, name/value pairs are represented by a single token.\n *\n * <h3>Parsing JSON</h3>\n * To create a recursive descent parser for your own JSON streams, first create\n * an entry point method that creates a {@code JsonReader}.\n *\n * <p>Next, create handler methods for each structure in your JSON text. You'll\n * need a method for each object type and for each array type.\n * <ul>\n *   <li>Within <strong>array handling</strong> methods, first call {@link\n *       #beginArray} to consume the array's opening bracket. Then create a\n *       while loop that accumulates values, terminating when {@link #hasNext}\n *       is false. Finally, read the array's closing bracket by calling {@link\n *       #endArray}.\n *   <li>Within <strong>object handling</strong> methods, first call {@link\n *       #beginObject} to consume the object's opening brace. Then create a\n *       while loop that assigns values to local variables based on their name.\n *       This loop should terminate when {@link #hasNext} is false. Finally,\n *       read the object's closing brace by calling {@link #endObject}.\n * </ul>\n * <p>When a nested object or array is encountered, delegate to the\n * corresponding handler method.\n *\n * <p>When an unknown name is encountered, strict parsers should fail with an\n * exception. Lenient parsers should call {@link #skipValue()} to recursively\n * skip the value's nested tokens, which may otherwise conflict.\n *\n * <p>If a value may be null, you should first check using {@link #peek()}.\n * Null literals can be consumed using either {@link #nextNull()} or {@link\n * #skipValue()}.\n *\n * <h3>Example</h3>\n * Suppose we'd like to parse a stream of messages such as the following: <pre> {@code\n * [\n *   {\n *     \"id\": 912345678901,\n *     \"text\": \"How do I read a JSON stream in Java?\",\n *     \"geo\": null,\n *     \"user\": {\n *       \"name\": \"json_newb\",\n *       \"followers_count\": 41\n *      }\n *   },\n *   {\n *     \"id\": 912345678902,\n *     \"text\": \"@json_newb just use JsonReader!\",\n *     \"geo\": [50.454722, -104.606667],\n *     \"user\": {\n *       \"name\": \"jesse\",\n *       \"followers_count\": 2\n *     }\n *   }\n * ]}</pre>\n * This code implements the parser for the above structure: <pre>   {@code\n *\n *   public List<Message> readJsonStream(InputStream in) throws IOException {\n *     JsonReader reader = new JsonReader(new InputStreamReader(in, \"UTF-8\"));\n *     try {\n *       return readMessagesArray(reader);\n *     } finally {\n *       reader.close();\n *     }\n *   }\n *\n *   public List<Message> readMessagesArray(JsonReader reader) throws IOException {\n *     List<Message> messages = new ArrayList<Message>();\n *\n *     reader.beginArray();\n *     while (reader.hasNext()) {\n *       messages.add(readMessage(reader));\n *     }\n *     reader.endArray();\n *     return messages;\n *   }\n *\n *   public Message readMessage(JsonReader reader) throws IOException {\n *     long id = -1;\n *     String text = null;\n *     User user = null;\n *     List<Double> geo = null;\n *\n *     reader.beginObject();\n *     while (reader.hasNext()) {\n *       String name = reader.nextName();\n *       if (name.equals(\"id\")) {\n *         id = reader.nextLong();\n *       } else if (name.equals(\"text\")) {\n *         text = reader.nextString();\n *       } else if (name.equals(\"geo\") && reader.peek() != JsonToken.NULL) {\n *         geo = readDoublesArray(reader);\n *       } else if (name.equals(\"user\")) {\n *         user = readUser(reader);\n *       } else {\n *         reader.skipValue();\n *       }\n *     }\n *     reader.endObject();\n *     return new Message(id, text, user, geo);\n *   }\n *\n *   public List<Double> readDoublesArray(JsonReader reader) throws IOException {\n *     List<Double> doubles = new ArrayList<Double>();\n *\n *     reader.beginArray();\n *     while (reader.hasNext()) {\n *       doubles.add(reader.nextDouble());\n *     }\n *     reader.endArray();\n *     return doubles;\n *   }\n *\n *   public User readUser(JsonReader reader) throws IOException {\n *     String username = null;\n *     int followersCount = -1;\n *\n *     reader.beginObject();\n *     while (reader.hasNext()) {\n *       String name = reader.nextName();\n *       if (name.equals(\"name\")) {\n *         username = reader.nextString();\n *       } else if (name.equals(\"followers_count\")) {\n *         followersCount = reader.nextInt();\n *       } else {\n *         reader.skipValue();\n *       }\n *     }\n *     reader.endObject();\n *     return new User(username, followersCount);\n *   }}</pre>\n *\n * <h3>Number Handling</h3>\n * This reader permits numeric values to be read as strings and string values to\n * be read as numbers. For example, both elements of the JSON array {@code\n * [1, \"1\"]} may be read using either {@link #nextInt} or {@link #nextString}.\n * This behavior is intended to prevent lossy numeric conversions: double is\n * JavaScript's only numeric type and very large values like {@code\n * 9007199254740993} cannot be represented exactly on that platform. To minimize\n * precision loss, extremely large values should be written and read as strings\n * in JSON.\n *\n * <a name=\"nonexecuteprefix\"/><h3>Non-Execute Prefix</h3>\n * Web servers that serve private data using JSON may be vulnerable to <a\n * href=\"http://en.wikipedia.org/wiki/JSON#Cross-site_request_forgery\">Cross-site\n * request forgery</a> attacks. In such an attack, a malicious site gains access\n * to a private JSON file by executing it with an HTML {@code <script>} tag.\n *\n * <p>Prefixing JSON files with <code>\")]}'\\n\"</code> makes them non-executable\n * by {@code <script>} tags, disarming the attack. Since the prefix is malformed\n * JSON, strict parsing fails when it is encountered. This class permits the\n * non-execute prefix when {@link #setLenient(boolean) lenient parsing} is\n * enabled.\n *\n * <p>Each {@code JsonReader} may be used to read a single JSON stream. Instances\n * of this class are not thread safe.\n *\n * @author Jesse Wilson\n * @since 1.6\n */\npublic class JsonReader implements Closeable {\n  /** The only non-execute prefix this parser permits */\n  private static final char[] NON_EXECUTE_PREFIX = \")]}'\\n\".toCharArray();\n  private static final long MIN_INCOMPLETE_INTEGER = Long.MIN_VALUE / 10;\n\n  private static final int PEEKED_NONE = 0;\n  private static final int PEEKED_BEGIN_OBJECT = 1;\n  private static final int PEEKED_END_OBJECT = 2;\n  private static final int PEEKED_BEGIN_ARRAY = 3;\n  private static final int PEEKED_END_ARRAY = 4;\n  private static final int PEEKED_TRUE = 5;\n  private static final int PEEKED_FALSE = 6;\n  private static final int PEEKED_NULL = 7;\n  private static final int PEEKED_SINGLE_QUOTED = 8;\n  private static final int PEEKED_DOUBLE_QUOTED = 9;\n  private static final int PEEKED_UNQUOTED = 10;\n  /** When this is returned, the string value is stored in peekedString. */\n  private static final int PEEKED_BUFFERED = 11;\n  private static final int PEEKED_SINGLE_QUOTED_NAME = 12;\n  private static final int PEEKED_DOUBLE_QUOTED_NAME = 13;\n  private static final int PEEKED_UNQUOTED_NAME = 14;\n  /** When this is returned, the integer value is stored in peekedLong. */\n  private static final int PEEKED_LONG = 15;\n  private static final int PEEKED_NUMBER = 16;\n  private static final int PEEKED_EOF = 17;\n\n  /* State machine when parsing numbers */\n  private static final int NUMBER_CHAR_NONE = 0;\n  private static final int NUMBER_CHAR_SIGN = 1;\n  private static final int NUMBER_CHAR_DIGIT = 2;\n  private static final int NUMBER_CHAR_DECIMAL = 3;\n  private static final int NUMBER_CHAR_FRACTION_DIGIT = 4;\n  private static final int NUMBER_CHAR_EXP_E = 5;\n  private static final int NUMBER_CHAR_EXP_SIGN = 6;\n  private static final int NUMBER_CHAR_EXP_DIGIT = 7;\n\n  /** The input JSON. */\n  private final Reader in;\n\n  /** True to accept non-spec compliant JSON */\n  private boolean lenient = false;\n\n  /**\n   * Use a manual buffer to easily read and unread upcoming characters, and\n   * also so we can create strings without an intermediate StringBuilder.\n   * We decode literals directly out of this buffer, so it must be at least as\n   * long as the longest token that can be reported as a number.\n   */\n  private final char[] buffer = new char[1024];\n  private int pos = 0;\n  private int limit = 0;\n\n  private int lineNumber = 0;\n  private int lineStart = 0;\n\n  int peeked = PEEKED_NONE;\n\n  /**\n   * A peeked value that was composed entirely of digits with an optional\n   * leading dash. Positive values may not have a leading 0.\n   */\n  private long peekedLong;\n\n  /**\n   * The number of characters in a peeked number literal. Increment 'pos' by\n   * this after reading a number.\n   */\n  private int peekedNumberLength;\n\n  /**\n   * A peeked string that should be parsed on the next double, long or string.\n   * This is populated before a numeric value is parsed and used if that parsing\n   * fails.\n   */\n  private String peekedString;\n\n  /*\n   * The nesting stack. Using a manual array rather than an ArrayList saves 20%.\n   */\n  private int[] stack = new int[32];\n  private int stackSize = 0;\n  {\n    stack[stackSize++] = JsonScope.EMPTY_DOCUMENT;\n  }\n\n  /*\n   * The path members. It corresponds directly to stack: At indices where the\n   * stack contains an object (EMPTY_OBJECT, DANGLING_NAME or NONEMPTY_OBJECT),\n   * pathNames contains the name at this scope. Where it contains an array\n   * (EMPTY_ARRAY, NONEMPTY_ARRAY) pathIndices contains the current index in\n   * that array. Otherwise the value is undefined, and we take advantage of that\n   * by incrementing pathIndices when doing so isn't useful.\n   */\n  private String[] pathNames = new String[32];\n  private int[] pathIndices = new int[32];\n\n  /**\n   * Creates a new instance that reads a JSON-encoded stream from {@code in}.\n   */\n  public JsonReader(Reader in) {\n    if (in == null) {\n      throw new NullPointerException(\"in == null\");\n    }\n    this.in = in;\n  }\n\n  /**\n   * Configure this parser to be liberal in what it accepts. By default,\n   * this parser is strict and only accepts JSON as specified by <a\n   * href=\"http://www.ietf.org/rfc/rfc4627.txt\">RFC 4627</a>. Setting the\n   * parser to lenient causes it to ignore the following syntax errors:\n   *\n   * <ul>\n   *   <li>Streams that start with the <a href=\"#nonexecuteprefix\">non-execute\n   *       prefix</a>, <code>\")]}'\\n\"</code>.\n   *   <li>Streams that include multiple top-level values. With strict parsing,\n   *       each stream must contain exactly one top-level value.\n   *   <li>Top-level values of any type. With strict parsing, the top-level\n   *       value must be an object or an array.\n   *   <li>Numbers may be {@link Double#isNaN() NaNs} or {@link\n   *       Double#isInfinite() infinities}.\n   *   <li>End of line comments starting with {@code //} or {@code #} and\n   *       ending with a newline character.\n   *   <li>C-style comments starting with {@code /*} and ending with\n   *       {@code *}{@code /}. Such comments may not be nested.\n   *   <li>Names that are unquoted or {@code 'single quoted'}.\n   *   <li>Strings that are unquoted or {@code 'single quoted'}.\n   *   <li>Array elements separated by {@code ;} instead of {@code ,}.\n   *   <li>Unnecessary array separators. These are interpreted as if null\n   *       was the omitted value.\n   *   <li>Names and values separated by {@code =} or {@code =>} instead of\n   *       {@code :}.\n   *   <li>Name/value pairs separated by {@code ;} instead of {@code ,}.\n   * </ul>\n   */\n  public final void setLenient(boolean lenient) {\n    this.lenient = lenient;\n  }\n\n  /**\n   * Returns true if this parser is liberal in what it accepts.\n   */\n  public final boolean isLenient() {\n    return lenient;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is the\n   * beginning of a new array.\n   */\n  public void beginArray() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_BEGIN_ARRAY) {\n      push(JsonScope.EMPTY_ARRAY);\n      pathIndices[stackSize - 1] = 0;\n      peeked = PEEKED_NONE;\n    } else {\n      throw new IllegalStateException(\"Expected BEGIN_ARRAY but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is the\n   * end of the current array.\n   */\n  public void endArray() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_END_ARRAY) {\n      stackSize--;\n      pathIndices[stackSize - 1]++;\n      peeked = PEEKED_NONE;\n    } else {\n      throw new IllegalStateException(\"Expected END_ARRAY but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is the\n   * beginning of a new object.\n   */\n  public void beginObject() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_BEGIN_OBJECT) {\n      push(JsonScope.EMPTY_OBJECT);\n      peeked = PEEKED_NONE;\n    } else {\n      throw new IllegalStateException(\"Expected BEGIN_OBJECT but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is the\n   * end of the current object.\n   */\n  public void endObject() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_END_OBJECT) {\n      stackSize--;\n      pathNames[stackSize] = null; // Free the last path name so that it can be garbage collected!\n      pathIndices[stackSize - 1]++;\n      peeked = PEEKED_NONE;\n    } else {\n      throw new IllegalStateException(\"Expected END_OBJECT but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n  }\n\n  /**\n   * Returns true if the current array or object has another element.\n   */\n  public boolean hasNext() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    return p != PEEKED_END_OBJECT && p != PEEKED_END_ARRAY;\n  }\n\n  /**\n   * Returns the type of the next token without consuming it.\n   */\n  public JsonToken peek() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    switch (p) {\n    case PEEKED_BEGIN_OBJECT:\n      return JsonToken.BEGIN_OBJECT;\n    case PEEKED_END_OBJECT:\n      return JsonToken.END_OBJECT;\n    case PEEKED_BEGIN_ARRAY:\n      return JsonToken.BEGIN_ARRAY;\n    case PEEKED_END_ARRAY:\n      return JsonToken.END_ARRAY;\n    case PEEKED_SINGLE_QUOTED_NAME:\n    case PEEKED_DOUBLE_QUOTED_NAME:\n    case PEEKED_UNQUOTED_NAME:\n      return JsonToken.NAME;\n    case PEEKED_TRUE:\n    case PEEKED_FALSE:\n      return JsonToken.BOOLEAN;\n    case PEEKED_NULL:\n      return JsonToken.NULL;\n    case PEEKED_SINGLE_QUOTED:\n    case PEEKED_DOUBLE_QUOTED:\n    case PEEKED_UNQUOTED:\n    case PEEKED_BUFFERED:\n      return JsonToken.STRING;\n    case PEEKED_LONG:\n    case PEEKED_NUMBER:\n      return JsonToken.NUMBER;\n    case PEEKED_EOF:\n      return JsonToken.END_DOCUMENT;\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  int doPeek() throws IOException {\n    int peekStack = stack[stackSize - 1];\n    if (peekStack == JsonScope.EMPTY_ARRAY) {\n      stack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY;\n    } else if (peekStack == JsonScope.NONEMPTY_ARRAY) {\n      // Look for a comma before the next element.\n      int c = nextNonWhitespace(true);\n      switch (c) {\n      case ']':\n        return peeked = PEEKED_END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    } else if (peekStack == JsonScope.EMPTY_OBJECT || peekStack == JsonScope.NONEMPTY_OBJECT) {\n      stack[stackSize - 1] = JsonScope.DANGLING_NAME;\n      // Look for a comma before the next element.\n      if (peekStack == JsonScope.NONEMPTY_OBJECT) {\n        int c = nextNonWhitespace(true);\n        switch (c) {\n        case '}':\n          return peeked = PEEKED_END_OBJECT;\n        case ';':\n          checkLenient(); // fall-through\n        case ',':\n          break;\n        default:\n          throw syntaxError(\"Unterminated object\");\n        }\n      }\n      int c = nextNonWhitespace(true);\n      switch (c) {\n      case '\"':\n        return peeked = PEEKED_DOUBLE_QUOTED_NAME;\n      case '\\'':\n        checkLenient();\n        return peeked = PEEKED_SINGLE_QUOTED_NAME;\n      case '}':\n        if (peekStack != JsonScope.NONEMPTY_OBJECT) {\n          return peeked = PEEKED_END_OBJECT;\n        } else {\n          throw syntaxError(\"Expected name\");\n        }\n      default:\n        checkLenient();\n        pos--; // Don't consume the first character in an unquoted string.\n        if (isLiteral((char) c)) {\n          return peeked = PEEKED_UNQUOTED_NAME;\n        } else {\n          throw syntaxError(\"Expected name\");\n        }\n      }\n    } else if (peekStack == JsonScope.DANGLING_NAME) {\n      stack[stackSize - 1] = JsonScope.NONEMPTY_OBJECT;\n      // Look for a colon before the value.\n      int c = nextNonWhitespace(true);\n      switch (c) {\n      case ':':\n        break;\n      case '=':\n        checkLenient();\n        if ((pos < limit || fillBuffer(1)) && buffer[pos] == '>') {\n          pos++;\n        }\n        break;\n      default:\n        throw syntaxError(\"Expected ':'\");\n      }\n    } else if (peekStack == JsonScope.EMPTY_DOCUMENT) {\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      stack[stackSize - 1] = JsonScope.NONEMPTY_DOCUMENT;\n    } else if (peekStack == JsonScope.NONEMPTY_DOCUMENT) {\n      int c = nextNonWhitespace(false);\n      if (c == -1) {\n        return peeked = PEEKED_EOF;\n      } else {\n        checkLenient();\n        pos--;\n      }\n    } else if (peekStack == JsonScope.CLOSED) {\n      throw new IllegalStateException(\"JsonReader is closed\");\n    }\n\n    int c = nextNonWhitespace(true);\n    switch (c) {\n    case ']':\n      if (peekStack == JsonScope.EMPTY_ARRAY) {\n        return peeked = PEEKED_END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      // In lenient mode, a 0-length literal in an array means 'null'.\n      if (peekStack == JsonScope.EMPTY_ARRAY || peekStack == JsonScope.NONEMPTY_ARRAY) {\n        checkLenient();\n        pos--;\n        return peeked = PEEKED_NULL;\n      } else {\n        throw syntaxError(\"Unexpected value\");\n      }\n    case '\\'':\n      checkLenient();\n      return peeked = PEEKED_SINGLE_QUOTED;\n    case '\"':\n      if (stackSize == 1) {\n        checkLenient();\n      }\n      return peeked = PEEKED_DOUBLE_QUOTED;\n    case '[':\n      return peeked = PEEKED_BEGIN_ARRAY;\n    case '{':\n      return peeked = PEEKED_BEGIN_OBJECT;\n    default:\n      pos--; // Don't consume the first character in a literal value.\n    }\n    if (stackSize == 1) {\n      checkLenient();\n    }\n\n    int result = peekKeyword();\n    if (result != PEEKED_NONE) {\n      return result;\n    }\n\n    result = peekNumber();\n    if (result != PEEKED_NONE) {\n      return result;\n    }\n\n    if (!isLiteral(buffer[pos])) {\n      throw syntaxError(\"Expected value\");\n    }\n\n    checkLenient();\n    return peeked = PEEKED_UNQUOTED;\n  }\n\n  private int peekKeyword() throws IOException {\n    // Figure out which keyword we're matching against by its first character.\n    char c = buffer[pos];\n    String keyword;\n    String keywordUpper;\n    int peeking;\n    if (c == 't' || c == 'T') {\n      keyword = \"true\";\n      keywordUpper = \"TRUE\";\n      peeking = PEEKED_TRUE;\n    } else if (c == 'f' || c == 'F') {\n      keyword = \"false\";\n      keywordUpper = \"FALSE\";\n      peeking = PEEKED_FALSE;\n    } else if (c == 'n' || c == 'N') {\n      keyword = \"null\";\n      keywordUpper = \"NULL\";\n      peeking = PEEKED_NULL;\n    } else {\n      return PEEKED_NONE;\n    }\n\n    // Confirm that chars [1..length) match the keyword.\n    int length = keyword.length();\n    for (int i = 1; i < length; i++) {\n      if (pos + i >= limit && !fillBuffer(i + 1)) {\n        return PEEKED_NONE;\n      }\n      c = buffer[pos + i];\n      if (c != keyword.charAt(i) && c != keywordUpper.charAt(i)) {\n        return PEEKED_NONE;\n      }\n    }\n\n    if ((pos + length < limit || fillBuffer(length + 1))\n        && isLiteral(buffer[pos + length])) {\n      return PEEKED_NONE; // Don't match trues, falsey or nullsoft!\n    }\n\n    // We've found the keyword followed either by EOF or by a non-literal character.\n    pos += length;\n    return peeked = peeking;\n  }\n\n  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }\n\n  private boolean isLiteral(char c) throws IOException {\n    switch (c) {\n    case '/':\n    case '\\\\':\n    case ';':\n    case '#':\n    case '=':\n      checkLenient(); // fall-through\n    case '{':\n    case '}':\n    case '[':\n    case ']':\n    case ':':\n    case ',':\n    case ' ':\n    case '\\t':\n    case '\\f':\n    case '\\r':\n    case '\\n':\n      return false;\n    default:\n      return true;\n    }\n  }\n\n  /**\n   * Returns the next token, a {@link com.google.gson.stream.JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws java.io.IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      result = nextQuotedValue('\"');\n    } else {\n      throw new IllegalStateException(\"Expected a name but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n    peeked = PEEKED_NONE;\n    pathNames[stackSize - 1] = result;\n    return result;\n  }\n\n  /**\n   * Returns the {@link com.google.gson.stream.JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n      result = nextQuotedValue('\"');\n    } else if (p == PEEKED_BUFFERED) {\n      result = peekedString;\n      peekedString = null;\n    } else if (p == PEEKED_LONG) {\n      result = Long.toString(peekedLong);\n    } else if (p == PEEKED_NUMBER) {\n      result = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }\n\n  /**\n   * Returns the {@link com.google.gson.stream.JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    }\n    throw new IllegalStateException(\"Expected a boolean but was \" + peek()\n        + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_NULL) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n    } else {\n      throw new IllegalStateException(\"Expected null but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n  }\n\n  /**\n   * Returns the {@link com.google.gson.stream.JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double using {@link Double#parseDouble(String)}.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    if (p == PEEKED_LONG) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return (double) peekedLong;\n    }\n\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    } else if (p == PEEKED_UNQUOTED) {\n      peekedString = nextUnquotedValue();\n    } else if (p != PEEKED_BUFFERED) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double result = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new MalformedJsonException(\"JSON forbids NaN and infinities: \" + result\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }\n\n  /**\n   * Returns the {@link com.google.gson.stream.JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    if (p == PEEKED_LONG) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return peekedLong;\n    }\n\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      try {\n        long result = Long.parseLong(peekedString);\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n      } catch (NumberFormatException ignored) {\n        // Fall back to parse as a double below.\n      }\n    } else {\n      throw new IllegalStateException(\"Expected a long but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    long result = (long) asDouble;\n    if (result != asDouble) { // Make sure no precision was lost casting to 'long'.\n      throw new NumberFormatException(\"Expected a long but was \" + peekedString\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }\n\n  /**\n   * Returns the string up to but not including {@code quote}, unescaping any\n   * character escape sequences encountered along the way. The opening quote\n   * should have already been read. This consumes the closing quote, but does\n   * not include it in the returned string.\n   *\n   * @param quote either ' or \".\n   * @throws NumberFormatException if any unicode escape sequences are\n   *     malformed.\n   */\n  private String nextQuotedValue(char quote) throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    StringBuilder builder = new StringBuilder();\n    while (true) {\n      int p = pos;\n      int l = limit;\n      /* the index of the first character not yet appended to the builder. */\n      int start = p;\n      while (p < l) {\n        int c = buffer[p++];\n\n        if (c == quote) {\n          pos = p;\n          builder.append(buffer, start, p - start - 1);\n          return builder.toString();\n        } else if (c == '\\\\') {\n          pos = p;\n          builder.append(buffer, start, p - start - 1);\n          builder.append(readEscapeCharacter());\n          p = pos;\n          l = limit;\n          start = p;\n        } else if (c == '\\n') {\n          lineNumber++;\n          lineStart = p;\n        }\n      }\n\n      builder.append(buffer, start, p - start);\n      pos = p;\n      if (!fillBuffer(1)) {\n        throw syntaxError(\"Unterminated string\");\n      }\n    }\n  }\n\n  /**\n   * Returns an unquoted value as a string.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private String nextUnquotedValue() throws IOException {\n    StringBuilder builder = null;\n    int i = 0;\n\n    findNonLiteralCharacter:\n    while (true) {\n      for (; pos + i < limit; i++) {\n        switch (buffer[pos + i]) {\n        case '/':\n        case '\\\\':\n        case ';':\n        case '#':\n        case '=':\n          checkLenient(); // fall-through\n        case '{':\n        case '}':\n        case '[':\n        case ']':\n        case ':':\n        case ',':\n        case ' ':\n        case '\\t':\n        case '\\f':\n        case '\\r':\n        case '\\n':\n          break findNonLiteralCharacter;\n        }\n      }\n\n      // Attempt to load the entire literal into the buffer at once.\n      if (i < buffer.length) {\n        if (fillBuffer(i + 1)) {\n          continue;\n        } else {\n          break;\n        }\n      }\n\n      // use a StringBuilder when the value is too long. This is too long to be a number!\n      if (builder == null) {\n        builder = new StringBuilder();\n      }\n      builder.append(buffer, pos, i);\n      pos += i;\n      i = 0;\n      if (!fillBuffer(1)) {\n        break;\n      }\n    }\n\n    String result;\n    if (builder == null) {\n      result = new String(buffer, pos, i);\n    } else {\n      builder.append(buffer, pos, i);\n      result = builder.toString();\n    }\n    pos += i;\n    return result;\n  }\n\n  private void skipQuotedValue(char quote) throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    do {\n      int p = pos;\n      int l = limit;\n      /* the index of the first character not yet appended to the builder. */\n      while (p < l) {\n        int c = buffer[p++];\n        if (c == quote) {\n          pos = p;\n          return;\n        } else if (c == '\\\\') {\n          pos = p;\n          readEscapeCharacter();\n          p = pos;\n          l = limit;\n        } else if (c == '\\n') {\n          lineNumber++;\n          lineStart = p;\n        }\n      }\n      pos = p;\n    } while (fillBuffer(1));\n    throw syntaxError(\"Unterminated string\");\n  }\n\n  private void skipUnquotedValue() throws IOException {\n    do {\n      int i = 0;\n      for (; pos + i < limit; i++) {\n        switch (buffer[pos + i]) {\n        case '/':\n        case '\\\\':\n        case ';':\n        case '#':\n        case '=':\n          checkLenient(); // fall-through\n        case '{':\n        case '}':\n        case '[':\n        case ']':\n        case ':':\n        case ',':\n        case ' ':\n        case '\\t':\n        case '\\f':\n        case '\\r':\n        case '\\n':\n          pos += i;\n          return;\n        }\n      }\n      pos += i;\n    } while (fillBuffer(1));\n  }\n\n  /**\n   * Returns the {@link com.google.gson.stream.JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    int result;\n    if (p == PEEKED_LONG) {\n      result = (int) peekedLong;\n      if (peekedLong != result) { // Make sure no precision was lost casting to 'int'.\n        throw new NumberFormatException(\"Expected an int but was \" + peekedLong\n            + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n      }\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    }\n\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      try {\n        result = Integer.parseInt(peekedString);\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n      } catch (NumberFormatException ignored) {\n        // Fall back to parse as a double below.\n      }\n    } else {\n      throw new IllegalStateException(\"Expected an int but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    result = (int) asDouble;\n    if (result != asDouble) { // Make sure no precision was lost casting to 'int'.\n      throw new NumberFormatException(\"Expected an int but was \" + peekedString\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link java.io.Reader}.\n   */\n  public void close() throws IOException {\n    peeked = PEEKED_NONE;\n    stack[0] = JsonScope.CLOSED;\n    stackSize = 1;\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    int count = 0;\n    do {\n      int p = peeked;\n      if (p == PEEKED_NONE) {\n        p = doPeek();\n      }\n\n      if (p == PEEKED_BEGIN_ARRAY) {\n        push(JsonScope.EMPTY_ARRAY);\n        count++;\n      } else if (p == PEEKED_BEGIN_OBJECT) {\n        push(JsonScope.EMPTY_OBJECT);\n        count++;\n      } else if (p == PEEKED_END_ARRAY) {\n        stackSize--;\n        count--;\n      } else if (p == PEEKED_END_OBJECT) {\n        stackSize--;\n        count--;\n      } else if (p == PEEKED_UNQUOTED_NAME || p == PEEKED_UNQUOTED) {\n        skipUnquotedValue();\n      } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_SINGLE_QUOTED_NAME) {\n        skipQuotedValue('\\'');\n      } else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_DOUBLE_QUOTED_NAME) {\n        skipQuotedValue('\"');\n      } else if (p == PEEKED_NUMBER) {\n        pos += peekedNumberLength;\n      }\n      peeked = PEEKED_NONE;\n    } while (count != 0);\n\n    pathIndices[stackSize - 1]++;\n    pathNames[stackSize - 1] = \"null\";\n  }\n\n  private void push(int newTop) {\n    if (stackSize == stack.length) {\n      int[] newStack = new int[stackSize * 2];\n      int[] newPathIndices = new int[stackSize * 2];\n      String[] newPathNames = new String[stackSize * 2];\n      System.arraycopy(stack, 0, newStack, 0, stackSize);\n      System.arraycopy(pathIndices, 0, newPathIndices, 0, stackSize);\n      System.arraycopy(pathNames, 0, newPathNames, 0, stackSize);\n      stack = newStack;\n      pathIndices = newPathIndices;\n      pathNames = newPathNames;\n    }\n    stack[stackSize++] = newTop;\n  }\n\n  /**\n   * Returns true once {@code limit - pos >= minimum}. If the data is\n   * exhausted before that many characters are available, this returns\n   * false.\n   */\n  private boolean fillBuffer(int minimum) throws IOException {\n    char[] buffer = this.buffer;\n    lineStart -= pos;\n    if (limit != pos) {\n      limit -= pos;\n      System.arraycopy(buffer, pos, buffer, 0, limit);\n    } else {\n      limit = 0;\n    }\n\n    pos = 0;\n    int total;\n    while ((total = in.read(buffer, limit, buffer.length - limit)) != -1) {\n      limit += total;\n\n      // if this is the first read, consume an optional byte order mark (BOM) if it exists\n      if (lineNumber == 0 && lineStart == 0 && limit > 0 && buffer[0] == '\\ufeff') {\n        pos++;\n        lineStart++;\n        minimum++;\n      }\n\n      if (limit >= minimum) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  int getLineNumber() {\n    return lineNumber + 1;\n  }\n\n  int getColumnNumber() {\n    return pos - lineStart + 1;\n  }\n\n  /**\n   * Returns the next character in the stream that is neither whitespace nor a\n   * part of a comment. When this returns, the returned character is always at\n   * {@code buffer[pos-1]}; this means the caller can always push back the\n   * returned character by decrementing {@code pos}.\n   */\n  private int nextNonWhitespace(boolean throwOnEof) throws IOException {\n    /*\n     * This code uses ugly local variables 'p' and 'l' representing the 'pos'\n     * and 'limit' fields respectively. Using locals rather than fields saves\n     * a few field reads for each whitespace character in a pretty-printed\n     * document, resulting in a 5% speedup. We need to flush 'p' to its field\n     * before any (potentially indirect) call to fillBuffer() and reread both\n     * 'p' and 'l' after any (potentially indirect) call to the same method.\n     */\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n    while (true) {\n      if (p == l) {\n        pos = p;\n        if (!fillBuffer(1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      int c = buffer[p++];\n      if (c == '\\n') {\n        lineNumber++;\n        lineStart = p;\n        continue;\n      } else if (c == ' ' || c == '\\r' || c == '\\t') {\n        continue;\n      }\n\n      if (c == '/') {\n        pos = p;\n        if (p == l) {\n          pos--; // push back '/' so it's still in the buffer when this method returns\n          boolean charsLoaded = fillBuffer(2);\n          pos++; // consume the '/' again\n          if (!charsLoaded) {\n            return c;\n          }\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;\n          if (!skipTo(\"*/\")) {\n            throw syntaxError(\"Unterminated comment\");\n          }\n          p = pos + 2;\n          l = limit;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          p = pos;\n          l = limit;\n          continue;\n\n        default:\n          return c;\n        }\n      } else if (c == '#') {\n        pos = p;\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        p = pos;\n        l = limit;\n      } else {\n        pos = p;\n        return c;\n      }\n    }\n    if (throwOnEof) {\n      throw new EOFException(\"End of input\"\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n    } else {\n      return -1;\n    }\n  }\n\n  private void checkLenient() throws IOException {\n    if (!lenient) {\n      throw syntaxError(\"Use JsonReader.setLenient(true) to accept malformed JSON\");\n    }\n  }\n\n  /**\n   * Advances the position until after the next newline character. If the line\n   * is terminated by \"\\r\\n\", the '\\n' must be consumed as whitespace by the\n   * caller.\n   */\n  private void skipToEndOfLine() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      char c = buffer[pos++];\n      if (c == '\\n') {\n        lineNumber++;\n        lineStart = pos;\n        break;\n      } else if (c == '\\r') {\n        break;\n      }\n    }\n  }\n\n  /**\n   * @param toFind a string to search for. Must not contain a newline.\n   */\n  private boolean skipTo(String toFind) throws IOException {\n    outer:\n    for (; pos + toFind.length() <= limit || fillBuffer(toFind.length()); pos++) {\n      if (buffer[pos] == '\\n') {\n        lineNumber++;\n        lineStart = pos + 1;\n        continue;\n      }\n      for (int c = 0; c < toFind.length(); c++) {\n        if (buffer[pos + c] != toFind.charAt(c)) {\n          continue outer;\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n\n  @Override public String toString() {\n    return getClass().getSimpleName()\n        + \" at line \" + getLineNumber() + \" column \" + getColumnNumber();\n  }\n\n  /**\n   * Returns a <a href=\"http://goessner.net/articles/JsonPath/\">JsonPath</a> to\n   * the current location in the JSON value.\n   */\n  public String getPath() {\n    StringBuilder result = new StringBuilder().append('$');\n    for (int i = 0, size = stackSize; i < size; i++) {\n      switch (stack[i]) {\n        case JsonScope.EMPTY_ARRAY:\n        case JsonScope.NONEMPTY_ARRAY:\n          result.append('[').append(pathIndices[i]).append(']');\n          break;\n\n        case JsonScope.EMPTY_OBJECT:\n        case JsonScope.DANGLING_NAME:\n        case JsonScope.NONEMPTY_OBJECT:\n          result.append('.');\n          if (pathNames[i] != null) {\n            result.append(pathNames[i]);\n          }\n          break;\n\n        case JsonScope.NONEMPTY_DOCUMENT:\n        case JsonScope.EMPTY_DOCUMENT:\n        case JsonScope.CLOSED:\n          break;\n      }\n    }\n    return result.toString();\n  }\n\n  /**\n   * Unescapes the character identified by the character or characters that\n   * immediately follow a backslash. The backslash '\\' should have already\n   * been read. This supports both unicode escapes \"u000A\" and two-character\n   * escapes \"\\n\".\n   *\n   * @throws NumberFormatException if any unicode escape sequences are\n   *     malformed.\n   */\n  private char readEscapeCharacter() throws IOException {\n    if (pos == limit && !fillBuffer(1)) {\n      throw syntaxError(\"Unterminated escape sequence\");\n    }\n\n    char escaped = buffer[pos++];\n    switch (escaped) {\n    case 'u':\n      if (pos + 4 > limit && !fillBuffer(4)) {\n        throw syntaxError(\"Unterminated escape sequence\");\n      }\n      // Equivalent to Integer.parseInt(stringPool.get(buffer, pos, 4), 16);\n      char result = 0;\n      for (int i = pos, end = i + 4; i < end; i++) {\n        char c = buffer[i];\n        result <<= 4;\n        if (c >= '0' && c <= '9') {\n          result += (c - '0');\n        } else if (c >= 'a' && c <= 'f') {\n          result += (c - 'a' + 10);\n        } else if (c >= 'A' && c <= 'F') {\n          result += (c - 'A' + 10);\n        } else {\n          throw new NumberFormatException(\"\\\\u\" + new String(buffer, pos, 4));\n        }\n      }\n      pos += 4;\n      return result;\n\n    case 't':\n      return '\\t';\n\n    case 'b':\n      return '\\b';\n\n    case 'n':\n      return '\\n';\n\n    case 'r':\n      return '\\r';\n\n    case 'f':\n      return '\\f';\n\n    case '\\n':\n      lineNumber++;\n      lineStart = pos;\n      // fall-through\n\n    case '\\'':\n    case '\"':\n    case '\\\\':\n    default:\n      return escaped;\n    }\n  }\n\n  /**\n   * Throws a new IO exception with the given message and a context snippet\n   * with this reader's content.\n   */\n  private IOException syntaxError(String message) throws IOException {\n    throw new MalformedJsonException(message\n        + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace(true);\n    pos--;\n\n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n\n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n\n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  static {\n    JsonReaderInternalAccess.INSTANCE = new JsonReaderInternalAccess() {\n      @Override public void promoteNameToValue(JsonReader reader) throws IOException {\n        if (reader instanceof JsonTreeReader) {\n          ((JsonTreeReader)reader).promoteNameToValue();\n          return;\n        }\n        int p = reader.peeked;\n        if (p == PEEKED_NONE) {\n          p = reader.doPeek();\n        }\n        if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n          reader.peeked = PEEKED_DOUBLE_QUOTED;\n        } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n          reader.peeked = PEEKED_SINGLE_QUOTED;\n        } else if (p == PEEKED_UNQUOTED_NAME) {\n          reader.peeked = PEEKED_UNQUOTED;\n        } else {\n          throw new IllegalStateException(\"Expected a name but was \" + reader.peek() + \" \"\n              + \" at line \" + reader.getLineNumber() + \" column \" + reader.getColumnNumber()\n              + \" path \" + reader.getPath());\n        }\n      }\n    };\n  }\n}\n", "fixed_version": "/*\n * Copyright (C) 2010 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.gson.stream;\n\nimport com.google.gson.internal.JsonReaderInternalAccess;\nimport com.google.gson.internal.bind.JsonTreeReader;\nimport java.io.Closeable;\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.io.Reader;\n\n/**\n * Reads a JSON (<a href=\"http://www.ietf.org/rfc/rfc7159.txt\">RFC 7159</a>)\n * encoded value as a stream of tokens. This stream includes both literal\n * values (strings, numbers, booleans, and nulls) as well as the begin and\n * end delimiters of objects and arrays. The tokens are traversed in\n * depth-first order, the same order that they appear in the JSON document.\n * Within JSON objects, name/value pairs are represented by a single token.\n *\n * <h3>Parsing JSON</h3>\n * To create a recursive descent parser for your own JSON streams, first create\n * an entry point method that creates a {@code JsonReader}.\n *\n * <p>Next, create handler methods for each structure in your JSON text. You'll\n * need a method for each object type and for each array type.\n * <ul>\n *   <li>Within <strong>array handling</strong> methods, first call {@link\n *       #beginArray} to consume the array's opening bracket. Then create a\n *       while loop that accumulates values, terminating when {@link #hasNext}\n *       is false. Finally, read the array's closing bracket by calling {@link\n *       #endArray}.\n *   <li>Within <strong>object handling</strong> methods, first call {@link\n *       #beginObject} to consume the object's opening brace. Then create a\n *       while loop that assigns values to local variables based on their name.\n *       This loop should terminate when {@link #hasNext} is false. Finally,\n *       read the object's closing brace by calling {@link #endObject}.\n * </ul>\n * <p>When a nested object or array is encountered, delegate to the\n * corresponding handler method.\n *\n * <p>When an unknown name is encountered, strict parsers should fail with an\n * exception. Lenient parsers should call {@link #skipValue()} to recursively\n * skip the value's nested tokens, which may otherwise conflict.\n *\n * <p>If a value may be null, you should first check using {@link #peek()}.\n * Null literals can be consumed using either {@link #nextNull()} or {@link\n * #skipValue()}.\n *\n * <h3>Example</h3>\n * Suppose we'd like to parse a stream of messages such as the following: <pre> {@code\n * [\n *   {\n *     \"id\": 912345678901,\n *     \"text\": \"How do I read a JSON stream in Java?\",\n *     \"geo\": null,\n *     \"user\": {\n *       \"name\": \"json_newb\",\n *       \"followers_count\": 41\n *      }\n *   },\n *   {\n *     \"id\": 912345678902,\n *     \"text\": \"@json_newb just use JsonReader!\",\n *     \"geo\": [50.454722, -104.606667],\n *     \"user\": {\n *       \"name\": \"jesse\",\n *       \"followers_count\": 2\n *     }\n *   }\n * ]}</pre>\n * This code implements the parser for the above structure: <pre>   {@code\n *\n *   public List<Message> readJsonStream(InputStream in) throws IOException {\n *     JsonReader reader = new JsonReader(new InputStreamReader(in, \"UTF-8\"));\n *     try {\n *       return readMessagesArray(reader);\n *     } finally {\n *       reader.close();\n *     }\n *   }\n *\n *   public List<Message> readMessagesArray(JsonReader reader) throws IOException {\n *     List<Message> messages = new ArrayList<Message>();\n *\n *     reader.beginArray();\n *     while (reader.hasNext()) {\n *       messages.add(readMessage(reader));\n *     }\n *     reader.endArray();\n *     return messages;\n *   }\n *\n *   public Message readMessage(JsonReader reader) throws IOException {\n *     long id = -1;\n *     String text = null;\n *     User user = null;\n *     List<Double> geo = null;\n *\n *     reader.beginObject();\n *     while (reader.hasNext()) {\n *       String name = reader.nextName();\n *       if (name.equals(\"id\")) {\n *         id = reader.nextLong();\n *       } else if (name.equals(\"text\")) {\n *         text = reader.nextString();\n *       } else if (name.equals(\"geo\") && reader.peek() != JsonToken.NULL) {\n *         geo = readDoublesArray(reader);\n *       } else if (name.equals(\"user\")) {\n *         user = readUser(reader);\n *       } else {\n *         reader.skipValue();\n *       }\n *     }\n *     reader.endObject();\n *     return new Message(id, text, user, geo);\n *   }\n *\n *   public List<Double> readDoublesArray(JsonReader reader) throws IOException {\n *     List<Double> doubles = new ArrayList<Double>();\n *\n *     reader.beginArray();\n *     while (reader.hasNext()) {\n *       doubles.add(reader.nextDouble());\n *     }\n *     reader.endArray();\n *     return doubles;\n *   }\n *\n *   public User readUser(JsonReader reader) throws IOException {\n *     String username = null;\n *     int followersCount = -1;\n *\n *     reader.beginObject();\n *     while (reader.hasNext()) {\n *       String name = reader.nextName();\n *       if (name.equals(\"name\")) {\n *         username = reader.nextString();\n *       } else if (name.equals(\"followers_count\")) {\n *         followersCount = reader.nextInt();\n *       } else {\n *         reader.skipValue();\n *       }\n *     }\n *     reader.endObject();\n *     return new User(username, followersCount);\n *   }}</pre>\n *\n * <h3>Number Handling</h3>\n * This reader permits numeric values to be read as strings and string values to\n * be read as numbers. For example, both elements of the JSON array {@code\n * [1, \"1\"]} may be read using either {@link #nextInt} or {@link #nextString}.\n * This behavior is intended to prevent lossy numeric conversions: double is\n * JavaScript's only numeric type and very large values like {@code\n * 9007199254740993} cannot be represented exactly on that platform. To minimize\n * precision loss, extremely large values should be written and read as strings\n * in JSON.\n *\n * <a name=\"nonexecuteprefix\"/><h3>Non-Execute Prefix</h3>\n * Web servers that serve private data using JSON may be vulnerable to <a\n * href=\"http://en.wikipedia.org/wiki/JSON#Cross-site_request_forgery\">Cross-site\n * request forgery</a> attacks. In such an attack, a malicious site gains access\n * to a private JSON file by executing it with an HTML {@code <script>} tag.\n *\n * <p>Prefixing JSON files with <code>\")]}'\\n\"</code> makes them non-executable\n * by {@code <script>} tags, disarming the attack. Since the prefix is malformed\n * JSON, strict parsing fails when it is encountered. This class permits the\n * non-execute prefix when {@link #setLenient(boolean) lenient parsing} is\n * enabled.\n *\n * <p>Each {@code JsonReader} may be used to read a single JSON stream. Instances\n * of this class are not thread safe.\n *\n * @author Jesse Wilson\n * @since 1.6\n */\npublic class JsonReader implements Closeable {\n  /** The only non-execute prefix this parser permits */\n  private static final char[] NON_EXECUTE_PREFIX = \")]}'\\n\".toCharArray();\n  private static final long MIN_INCOMPLETE_INTEGER = Long.MIN_VALUE / 10;\n\n  private static final int PEEKED_NONE = 0;\n  private static final int PEEKED_BEGIN_OBJECT = 1;\n  private static final int PEEKED_END_OBJECT = 2;\n  private static final int PEEKED_BEGIN_ARRAY = 3;\n  private static final int PEEKED_END_ARRAY = 4;\n  private static final int PEEKED_TRUE = 5;\n  private static final int PEEKED_FALSE = 6;\n  private static final int PEEKED_NULL = 7;\n  private static final int PEEKED_SINGLE_QUOTED = 8;\n  private static final int PEEKED_DOUBLE_QUOTED = 9;\n  private static final int PEEKED_UNQUOTED = 10;\n  /** When this is returned, the string value is stored in peekedString. */\n  private static final int PEEKED_BUFFERED = 11;\n  private static final int PEEKED_SINGLE_QUOTED_NAME = 12;\n  private static final int PEEKED_DOUBLE_QUOTED_NAME = 13;\n  private static final int PEEKED_UNQUOTED_NAME = 14;\n  /** When this is returned, the integer value is stored in peekedLong. */\n  private static final int PEEKED_LONG = 15;\n  private static final int PEEKED_NUMBER = 16;\n  private static final int PEEKED_EOF = 17;\n\n  /* State machine when parsing numbers */\n  private static final int NUMBER_CHAR_NONE = 0;\n  private static final int NUMBER_CHAR_SIGN = 1;\n  private static final int NUMBER_CHAR_DIGIT = 2;\n  private static final int NUMBER_CHAR_DECIMAL = 3;\n  private static final int NUMBER_CHAR_FRACTION_DIGIT = 4;\n  private static final int NUMBER_CHAR_EXP_E = 5;\n  private static final int NUMBER_CHAR_EXP_SIGN = 6;\n  private static final int NUMBER_CHAR_EXP_DIGIT = 7;\n\n  /** The input JSON. */\n  private final Reader in;\n\n  /** True to accept non-spec compliant JSON */\n  private boolean lenient = false;\n\n  /**\n   * Use a manual buffer to easily read and unread upcoming characters, and\n   * also so we can create strings without an intermediate StringBuilder.\n   * We decode literals directly out of this buffer, so it must be at least as\n   * long as the longest token that can be reported as a number.\n   */\n  private final char[] buffer = new char[1024];\n  private int pos = 0;\n  private int limit = 0;\n\n  private int lineNumber = 0;\n  private int lineStart = 0;\n\n  int peeked = PEEKED_NONE;\n\n  /**\n   * A peeked value that was composed entirely of digits with an optional\n   * leading dash. Positive values may not have a leading 0.\n   */\n  private long peekedLong;\n\n  /**\n   * The number of characters in a peeked number literal. Increment 'pos' by\n   * this after reading a number.\n   */\n  private int peekedNumberLength;\n\n  /**\n   * A peeked string that should be parsed on the next double, long or string.\n   * This is populated before a numeric value is parsed and used if that parsing\n   * fails.\n   */\n  private String peekedString;\n\n  /*\n   * The nesting stack. Using a manual array rather than an ArrayList saves 20%.\n   */\n  private int[] stack = new int[32];\n  private int stackSize = 0;\n  {\n    stack[stackSize++] = JsonScope.EMPTY_DOCUMENT;\n  }\n\n  /*\n   * The path members. It corresponds directly to stack: At indices where the\n   * stack contains an object (EMPTY_OBJECT, DANGLING_NAME or NONEMPTY_OBJECT),\n   * pathNames contains the name at this scope. Where it contains an array\n   * (EMPTY_ARRAY, NONEMPTY_ARRAY) pathIndices contains the current index in\n   * that array. Otherwise the value is undefined, and we take advantage of that\n   * by incrementing pathIndices when doing so isn't useful.\n   */\n  private String[] pathNames = new String[32];\n  private int[] pathIndices = new int[32];\n\n  /**\n   * Creates a new instance that reads a JSON-encoded stream from {@code in}.\n   */\n  public JsonReader(Reader in) {\n    if (in == null) {\n      throw new NullPointerException(\"in == null\");\n    }\n    this.in = in;\n  }\n\n  /**\n   * Configure this parser to be liberal in what it accepts. By default,\n   * this parser is strict and only accepts JSON as specified by <a\n   * href=\"http://www.ietf.org/rfc/rfc4627.txt\">RFC 4627</a>. Setting the\n   * parser to lenient causes it to ignore the following syntax errors:\n   *\n   * <ul>\n   *   <li>Streams that start with the <a href=\"#nonexecuteprefix\">non-execute\n   *       prefix</a>, <code>\")]}'\\n\"</code>.\n   *   <li>Streams that include multiple top-level values. With strict parsing,\n   *       each stream must contain exactly one top-level value.\n   *   <li>Top-level values of any type. With strict parsing, the top-level\n   *       value must be an object or an array.\n   *   <li>Numbers may be {@link Double#isNaN() NaNs} or {@link\n   *       Double#isInfinite() infinities}.\n   *   <li>End of line comments starting with {@code //} or {@code #} and\n   *       ending with a newline character.\n   *   <li>C-style comments starting with {@code /*} and ending with\n   *       {@code *}{@code /}. Such comments may not be nested.\n   *   <li>Names that are unquoted or {@code 'single quoted'}.\n   *   <li>Strings that are unquoted or {@code 'single quoted'}.\n   *   <li>Array elements separated by {@code ;} instead of {@code ,}.\n   *   <li>Unnecessary array separators. These are interpreted as if null\n   *       was the omitted value.\n   *   <li>Names and values separated by {@code =} or {@code =>} instead of\n   *       {@code :}.\n   *   <li>Name/value pairs separated by {@code ;} instead of {@code ,}.\n   * </ul>\n   */\n  public final void setLenient(boolean lenient) {\n    this.lenient = lenient;\n  }\n\n  /**\n   * Returns true if this parser is liberal in what it accepts.\n   */\n  public final boolean isLenient() {\n    return lenient;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is the\n   * beginning of a new array.\n   */\n  public void beginArray() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_BEGIN_ARRAY) {\n      push(JsonScope.EMPTY_ARRAY);\n      pathIndices[stackSize - 1] = 0;\n      peeked = PEEKED_NONE;\n    } else {\n      throw new IllegalStateException(\"Expected BEGIN_ARRAY but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is the\n   * end of the current array.\n   */\n  public void endArray() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_END_ARRAY) {\n      stackSize--;\n      pathIndices[stackSize - 1]++;\n      peeked = PEEKED_NONE;\n    } else {\n      throw new IllegalStateException(\"Expected END_ARRAY but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is the\n   * beginning of a new object.\n   */\n  public void beginObject() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_BEGIN_OBJECT) {\n      push(JsonScope.EMPTY_OBJECT);\n      peeked = PEEKED_NONE;\n    } else {\n      throw new IllegalStateException(\"Expected BEGIN_OBJECT but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is the\n   * end of the current object.\n   */\n  public void endObject() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_END_OBJECT) {\n      stackSize--;\n      pathNames[stackSize] = null; // Free the last path name so that it can be garbage collected!\n      pathIndices[stackSize - 1]++;\n      peeked = PEEKED_NONE;\n    } else {\n      throw new IllegalStateException(\"Expected END_OBJECT but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n  }\n\n  /**\n   * Returns true if the current array or object has another element.\n   */\n  public boolean hasNext() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    return p != PEEKED_END_OBJECT && p != PEEKED_END_ARRAY;\n  }\n\n  /**\n   * Returns the type of the next token without consuming it.\n   */\n  public JsonToken peek() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    switch (p) {\n    case PEEKED_BEGIN_OBJECT:\n      return JsonToken.BEGIN_OBJECT;\n    case PEEKED_END_OBJECT:\n      return JsonToken.END_OBJECT;\n    case PEEKED_BEGIN_ARRAY:\n      return JsonToken.BEGIN_ARRAY;\n    case PEEKED_END_ARRAY:\n      return JsonToken.END_ARRAY;\n    case PEEKED_SINGLE_QUOTED_NAME:\n    case PEEKED_DOUBLE_QUOTED_NAME:\n    case PEEKED_UNQUOTED_NAME:\n      return JsonToken.NAME;\n    case PEEKED_TRUE:\n    case PEEKED_FALSE:\n      return JsonToken.BOOLEAN;\n    case PEEKED_NULL:\n      return JsonToken.NULL;\n    case PEEKED_SINGLE_QUOTED:\n    case PEEKED_DOUBLE_QUOTED:\n    case PEEKED_UNQUOTED:\n    case PEEKED_BUFFERED:\n      return JsonToken.STRING;\n    case PEEKED_LONG:\n    case PEEKED_NUMBER:\n      return JsonToken.NUMBER;\n    case PEEKED_EOF:\n      return JsonToken.END_DOCUMENT;\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  int doPeek() throws IOException {\n    int peekStack = stack[stackSize - 1];\n    if (peekStack == JsonScope.EMPTY_ARRAY) {\n      stack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY;\n    } else if (peekStack == JsonScope.NONEMPTY_ARRAY) {\n      // Look for a comma before the next element.\n      int c = nextNonWhitespace(true);\n      switch (c) {\n      case ']':\n        return peeked = PEEKED_END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    } else if (peekStack == JsonScope.EMPTY_OBJECT || peekStack == JsonScope.NONEMPTY_OBJECT) {\n      stack[stackSize - 1] = JsonScope.DANGLING_NAME;\n      // Look for a comma before the next element.\n      if (peekStack == JsonScope.NONEMPTY_OBJECT) {\n        int c = nextNonWhitespace(true);\n        switch (c) {\n        case '}':\n          return peeked = PEEKED_END_OBJECT;\n        case ';':\n          checkLenient(); // fall-through\n        case ',':\n          break;\n        default:\n          throw syntaxError(\"Unterminated object\");\n        }\n      }\n      int c = nextNonWhitespace(true);\n      switch (c) {\n      case '\"':\n        return peeked = PEEKED_DOUBLE_QUOTED_NAME;\n      case '\\'':\n        checkLenient();\n        return peeked = PEEKED_SINGLE_QUOTED_NAME;\n      case '}':\n        if (peekStack != JsonScope.NONEMPTY_OBJECT) {\n          return peeked = PEEKED_END_OBJECT;\n        } else {\n          throw syntaxError(\"Expected name\");\n        }\n      default:\n        checkLenient();\n        pos--; // Don't consume the first character in an unquoted string.\n        if (isLiteral((char) c)) {\n          return peeked = PEEKED_UNQUOTED_NAME;\n        } else {\n          throw syntaxError(\"Expected name\");\n        }\n      }\n    } else if (peekStack == JsonScope.DANGLING_NAME) {\n      stack[stackSize - 1] = JsonScope.NONEMPTY_OBJECT;\n      // Look for a colon before the value.\n      int c = nextNonWhitespace(true);\n      switch (c) {\n      case ':':\n        break;\n      case '=':\n        checkLenient();\n        if ((pos < limit || fillBuffer(1)) && buffer[pos] == '>') {\n          pos++;\n        }\n        break;\n      default:\n        throw syntaxError(\"Expected ':'\");\n      }\n    } else if (peekStack == JsonScope.EMPTY_DOCUMENT) {\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      stack[stackSize - 1] = JsonScope.NONEMPTY_DOCUMENT;\n    } else if (peekStack == JsonScope.NONEMPTY_DOCUMENT) {\n      int c = nextNonWhitespace(false);\n      if (c == -1) {\n        return peeked = PEEKED_EOF;\n      } else {\n        checkLenient();\n        pos--;\n      }\n    } else if (peekStack == JsonScope.CLOSED) {\n      throw new IllegalStateException(\"JsonReader is closed\");\n    }\n\n    int c = nextNonWhitespace(true);\n    switch (c) {\n    case ']':\n      if (peekStack == JsonScope.EMPTY_ARRAY) {\n        return peeked = PEEKED_END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      // In lenient mode, a 0-length literal in an array means 'null'.\n      if (peekStack == JsonScope.EMPTY_ARRAY || peekStack == JsonScope.NONEMPTY_ARRAY) {\n        checkLenient();\n        pos--;\n        return peeked = PEEKED_NULL;\n      } else {\n        throw syntaxError(\"Unexpected value\");\n      }\n    case '\\'':\n      checkLenient();\n      return peeked = PEEKED_SINGLE_QUOTED;\n    case '\"':\n      return peeked = PEEKED_DOUBLE_QUOTED;\n    case '[':\n      return peeked = PEEKED_BEGIN_ARRAY;\n    case '{':\n      return peeked = PEEKED_BEGIN_OBJECT;\n    default:\n      pos--; // Don't consume the first character in a literal value.\n    }\n\n    int result = peekKeyword();\n    if (result != PEEKED_NONE) {\n      return result;\n    }\n\n    result = peekNumber();\n    if (result != PEEKED_NONE) {\n      return result;\n    }\n\n    if (!isLiteral(buffer[pos])) {\n      throw syntaxError(\"Expected value\");\n    }\n\n    checkLenient();\n    return peeked = PEEKED_UNQUOTED;\n  }\n\n  private int peekKeyword() throws IOException {\n    // Figure out which keyword we're matching against by its first character.\n    char c = buffer[pos];\n    String keyword;\n    String keywordUpper;\n    int peeking;\n    if (c == 't' || c == 'T') {\n      keyword = \"true\";\n      keywordUpper = \"TRUE\";\n      peeking = PEEKED_TRUE;\n    } else if (c == 'f' || c == 'F') {\n      keyword = \"false\";\n      keywordUpper = \"FALSE\";\n      peeking = PEEKED_FALSE;\n    } else if (c == 'n' || c == 'N') {\n      keyword = \"null\";\n      keywordUpper = \"NULL\";\n      peeking = PEEKED_NULL;\n    } else {\n      return PEEKED_NONE;\n    }\n\n    // Confirm that chars [1..length) match the keyword.\n    int length = keyword.length();\n    for (int i = 1; i < length; i++) {\n      if (pos + i >= limit && !fillBuffer(i + 1)) {\n        return PEEKED_NONE;\n      }\n      c = buffer[pos + i];\n      if (c != keyword.charAt(i) && c != keywordUpper.charAt(i)) {\n        return PEEKED_NONE;\n      }\n    }\n\n    if ((pos + length < limit || fillBuffer(length + 1))\n        && isLiteral(buffer[pos + length])) {\n      return PEEKED_NONE; // Don't match trues, falsey or nullsoft!\n    }\n\n    // We've found the keyword followed either by EOF or by a non-literal character.\n    pos += length;\n    return peeked = peeking;\n  }\n\n  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }\n\n  private boolean isLiteral(char c) throws IOException {\n    switch (c) {\n    case '/':\n    case '\\\\':\n    case ';':\n    case '#':\n    case '=':\n      checkLenient(); // fall-through\n    case '{':\n    case '}':\n    case '[':\n    case ']':\n    case ':':\n    case ',':\n    case ' ':\n    case '\\t':\n    case '\\f':\n    case '\\r':\n    case '\\n':\n      return false;\n    default:\n      return true;\n    }\n  }\n\n  /**\n   * Returns the next token, a {@link com.google.gson.stream.JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws java.io.IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      result = nextQuotedValue('\"');\n    } else {\n      throw new IllegalStateException(\"Expected a name but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n    peeked = PEEKED_NONE;\n    pathNames[stackSize - 1] = result;\n    return result;\n  }\n\n  /**\n   * Returns the {@link com.google.gson.stream.JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n      result = nextQuotedValue('\"');\n    } else if (p == PEEKED_BUFFERED) {\n      result = peekedString;\n      peekedString = null;\n    } else if (p == PEEKED_LONG) {\n      result = Long.toString(peekedLong);\n    } else if (p == PEEKED_NUMBER) {\n      result = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }\n\n  /**\n   * Returns the {@link com.google.gson.stream.JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    }\n    throw new IllegalStateException(\"Expected a boolean but was \" + peek()\n        + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_NULL) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n    } else {\n      throw new IllegalStateException(\"Expected null but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n  }\n\n  /**\n   * Returns the {@link com.google.gson.stream.JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double using {@link Double#parseDouble(String)}.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    if (p == PEEKED_LONG) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return (double) peekedLong;\n    }\n\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    } else if (p == PEEKED_UNQUOTED) {\n      peekedString = nextUnquotedValue();\n    } else if (p != PEEKED_BUFFERED) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double result = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new MalformedJsonException(\"JSON forbids NaN and infinities: \" + result\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }\n\n  /**\n   * Returns the {@link com.google.gson.stream.JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    if (p == PEEKED_LONG) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return peekedLong;\n    }\n\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      try {\n        long result = Long.parseLong(peekedString);\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n      } catch (NumberFormatException ignored) {\n        // Fall back to parse as a double below.\n      }\n    } else {\n      throw new IllegalStateException(\"Expected a long but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    long result = (long) asDouble;\n    if (result != asDouble) { // Make sure no precision was lost casting to 'long'.\n      throw new NumberFormatException(\"Expected a long but was \" + peekedString\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }\n\n  /**\n   * Returns the string up to but not including {@code quote}, unescaping any\n   * character escape sequences encountered along the way. The opening quote\n   * should have already been read. This consumes the closing quote, but does\n   * not include it in the returned string.\n   *\n   * @param quote either ' or \".\n   * @throws NumberFormatException if any unicode escape sequences are\n   *     malformed.\n   */\n  private String nextQuotedValue(char quote) throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    StringBuilder builder = new StringBuilder();\n    while (true) {\n      int p = pos;\n      int l = limit;\n      /* the index of the first character not yet appended to the builder. */\n      int start = p;\n      while (p < l) {\n        int c = buffer[p++];\n\n        if (c == quote) {\n          pos = p;\n          builder.append(buffer, start, p - start - 1);\n          return builder.toString();\n        } else if (c == '\\\\') {\n          pos = p;\n          builder.append(buffer, start, p - start - 1);\n          builder.append(readEscapeCharacter());\n          p = pos;\n          l = limit;\n          start = p;\n        } else if (c == '\\n') {\n          lineNumber++;\n          lineStart = p;\n        }\n      }\n\n      builder.append(buffer, start, p - start);\n      pos = p;\n      if (!fillBuffer(1)) {\n        throw syntaxError(\"Unterminated string\");\n      }\n    }\n  }\n\n  /**\n   * Returns an unquoted value as a string.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private String nextUnquotedValue() throws IOException {\n    StringBuilder builder = null;\n    int i = 0;\n\n    findNonLiteralCharacter:\n    while (true) {\n      for (; pos + i < limit; i++) {\n        switch (buffer[pos + i]) {\n        case '/':\n        case '\\\\':\n        case ';':\n        case '#':\n        case '=':\n          checkLenient(); // fall-through\n        case '{':\n        case '}':\n        case '[':\n        case ']':\n        case ':':\n        case ',':\n        case ' ':\n        case '\\t':\n        case '\\f':\n        case '\\r':\n        case '\\n':\n          break findNonLiteralCharacter;\n        }\n      }\n\n      // Attempt to load the entire literal into the buffer at once.\n      if (i < buffer.length) {\n        if (fillBuffer(i + 1)) {\n          continue;\n        } else {\n          break;\n        }\n      }\n\n      // use a StringBuilder when the value is too long. This is too long to be a number!\n      if (builder == null) {\n        builder = new StringBuilder();\n      }\n      builder.append(buffer, pos, i);\n      pos += i;\n      i = 0;\n      if (!fillBuffer(1)) {\n        break;\n      }\n    }\n\n    String result;\n    if (builder == null) {\n      result = new String(buffer, pos, i);\n    } else {\n      builder.append(buffer, pos, i);\n      result = builder.toString();\n    }\n    pos += i;\n    return result;\n  }\n\n  private void skipQuotedValue(char quote) throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    do {\n      int p = pos;\n      int l = limit;\n      /* the index of the first character not yet appended to the builder. */\n      while (p < l) {\n        int c = buffer[p++];\n        if (c == quote) {\n          pos = p;\n          return;\n        } else if (c == '\\\\') {\n          pos = p;\n          readEscapeCharacter();\n          p = pos;\n          l = limit;\n        } else if (c == '\\n') {\n          lineNumber++;\n          lineStart = p;\n        }\n      }\n      pos = p;\n    } while (fillBuffer(1));\n    throw syntaxError(\"Unterminated string\");\n  }\n\n  private void skipUnquotedValue() throws IOException {\n    do {\n      int i = 0;\n      for (; pos + i < limit; i++) {\n        switch (buffer[pos + i]) {\n        case '/':\n        case '\\\\':\n        case ';':\n        case '#':\n        case '=':\n          checkLenient(); // fall-through\n        case '{':\n        case '}':\n        case '[':\n        case ']':\n        case ':':\n        case ',':\n        case ' ':\n        case '\\t':\n        case '\\f':\n        case '\\r':\n        case '\\n':\n          pos += i;\n          return;\n        }\n      }\n      pos += i;\n    } while (fillBuffer(1));\n  }\n\n  /**\n   * Returns the {@link com.google.gson.stream.JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    int result;\n    if (p == PEEKED_LONG) {\n      result = (int) peekedLong;\n      if (peekedLong != result) { // Make sure no precision was lost casting to 'int'.\n        throw new NumberFormatException(\"Expected an int but was \" + peekedLong\n            + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n      }\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    }\n\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      try {\n        result = Integer.parseInt(peekedString);\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n      } catch (NumberFormatException ignored) {\n        // Fall back to parse as a double below.\n      }\n    } else {\n      throw new IllegalStateException(\"Expected an int but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    result = (int) asDouble;\n    if (result != asDouble) { // Make sure no precision was lost casting to 'int'.\n      throw new NumberFormatException(\"Expected an int but was \" + peekedString\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link java.io.Reader}.\n   */\n  public void close() throws IOException {\n    peeked = PEEKED_NONE;\n    stack[0] = JsonScope.CLOSED;\n    stackSize = 1;\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    int count = 0;\n    do {\n      int p = peeked;\n      if (p == PEEKED_NONE) {\n        p = doPeek();\n      }\n\n      if (p == PEEKED_BEGIN_ARRAY) {\n        push(JsonScope.EMPTY_ARRAY);\n        count++;\n      } else if (p == PEEKED_BEGIN_OBJECT) {\n        push(JsonScope.EMPTY_OBJECT);\n        count++;\n      } else if (p == PEEKED_END_ARRAY) {\n        stackSize--;\n        count--;\n      } else if (p == PEEKED_END_OBJECT) {\n        stackSize--;\n        count--;\n      } else if (p == PEEKED_UNQUOTED_NAME || p == PEEKED_UNQUOTED) {\n        skipUnquotedValue();\n      } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_SINGLE_QUOTED_NAME) {\n        skipQuotedValue('\\'');\n      } else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_DOUBLE_QUOTED_NAME) {\n        skipQuotedValue('\"');\n      } else if (p == PEEKED_NUMBER) {\n        pos += peekedNumberLength;\n      }\n      peeked = PEEKED_NONE;\n    } while (count != 0);\n\n    pathIndices[stackSize - 1]++;\n    pathNames[stackSize - 1] = \"null\";\n  }\n\n  private void push(int newTop) {\n    if (stackSize == stack.length) {\n      int[] newStack = new int[stackSize * 2];\n      int[] newPathIndices = new int[stackSize * 2];\n      String[] newPathNames = new String[stackSize * 2];\n      System.arraycopy(stack, 0, newStack, 0, stackSize);\n      System.arraycopy(pathIndices, 0, newPathIndices, 0, stackSize);\n      System.arraycopy(pathNames, 0, newPathNames, 0, stackSize);\n      stack = newStack;\n      pathIndices = newPathIndices;\n      pathNames = newPathNames;\n    }\n    stack[stackSize++] = newTop;\n  }\n\n  /**\n   * Returns true once {@code limit - pos >= minimum}. If the data is\n   * exhausted before that many characters are available, this returns\n   * false.\n   */\n  private boolean fillBuffer(int minimum) throws IOException {\n    char[] buffer = this.buffer;\n    lineStart -= pos;\n    if (limit != pos) {\n      limit -= pos;\n      System.arraycopy(buffer, pos, buffer, 0, limit);\n    } else {\n      limit = 0;\n    }\n\n    pos = 0;\n    int total;\n    while ((total = in.read(buffer, limit, buffer.length - limit)) != -1) {\n      limit += total;\n\n      // if this is the first read, consume an optional byte order mark (BOM) if it exists\n      if (lineNumber == 0 && lineStart == 0 && limit > 0 && buffer[0] == '\\ufeff') {\n        pos++;\n        lineStart++;\n        minimum++;\n      }\n\n      if (limit >= minimum) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  int getLineNumber() {\n    return lineNumber + 1;\n  }\n\n  int getColumnNumber() {\n    return pos - lineStart + 1;\n  }\n\n  /**\n   * Returns the next character in the stream that is neither whitespace nor a\n   * part of a comment. When this returns, the returned character is always at\n   * {@code buffer[pos-1]}; this means the caller can always push back the\n   * returned character by decrementing {@code pos}.\n   */\n  private int nextNonWhitespace(boolean throwOnEof) throws IOException {\n    /*\n     * This code uses ugly local variables 'p' and 'l' representing the 'pos'\n     * and 'limit' fields respectively. Using locals rather than fields saves\n     * a few field reads for each whitespace character in a pretty-printed\n     * document, resulting in a 5% speedup. We need to flush 'p' to its field\n     * before any (potentially indirect) call to fillBuffer() and reread both\n     * 'p' and 'l' after any (potentially indirect) call to the same method.\n     */\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n    while (true) {\n      if (p == l) {\n        pos = p;\n        if (!fillBuffer(1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      int c = buffer[p++];\n      if (c == '\\n') {\n        lineNumber++;\n        lineStart = p;\n        continue;\n      } else if (c == ' ' || c == '\\r' || c == '\\t') {\n        continue;\n      }\n\n      if (c == '/') {\n        pos = p;\n        if (p == l) {\n          pos--; // push back '/' so it's still in the buffer when this method returns\n          boolean charsLoaded = fillBuffer(2);\n          pos++; // consume the '/' again\n          if (!charsLoaded) {\n            return c;\n          }\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;\n          if (!skipTo(\"*/\")) {\n            throw syntaxError(\"Unterminated comment\");\n          }\n          p = pos + 2;\n          l = limit;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          p = pos;\n          l = limit;\n          continue;\n\n        default:\n          return c;\n        }\n      } else if (c == '#') {\n        pos = p;\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        p = pos;\n        l = limit;\n      } else {\n        pos = p;\n        return c;\n      }\n    }\n    if (throwOnEof) {\n      throw new EOFException(\"End of input\"\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n    } else {\n      return -1;\n    }\n  }\n\n  private void checkLenient() throws IOException {\n    if (!lenient) {\n      throw syntaxError(\"Use JsonReader.setLenient(true) to accept malformed JSON\");\n    }\n  }\n\n  /**\n   * Advances the position until after the next newline character. If the line\n   * is terminated by \"\\r\\n\", the '\\n' must be consumed as whitespace by the\n   * caller.\n   */\n  private void skipToEndOfLine() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      char c = buffer[pos++];\n      if (c == '\\n') {\n        lineNumber++;\n        lineStart = pos;\n        break;\n      } else if (c == '\\r') {\n        break;\n      }\n    }\n  }\n\n  /**\n   * @param toFind a string to search for. Must not contain a newline.\n   */\n  private boolean skipTo(String toFind) throws IOException {\n    outer:\n    for (; pos + toFind.length() <= limit || fillBuffer(toFind.length()); pos++) {\n      if (buffer[pos] == '\\n') {\n        lineNumber++;\n        lineStart = pos + 1;\n        continue;\n      }\n      for (int c = 0; c < toFind.length(); c++) {\n        if (buffer[pos + c] != toFind.charAt(c)) {\n          continue outer;\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n\n  @Override public String toString() {\n    return getClass().getSimpleName()\n        + \" at line \" + getLineNumber() + \" column \" + getColumnNumber();\n  }\n\n  /**\n   * Returns a <a href=\"http://goessner.net/articles/JsonPath/\">JsonPath</a> to\n   * the current location in the JSON value.\n   */\n  public String getPath() {\n    StringBuilder result = new StringBuilder().append('$');\n    for (int i = 0, size = stackSize; i < size; i++) {\n      switch (stack[i]) {\n        case JsonScope.EMPTY_ARRAY:\n        case JsonScope.NONEMPTY_ARRAY:\n          result.append('[').append(pathIndices[i]).append(']');\n          break;\n\n        case JsonScope.EMPTY_OBJECT:\n        case JsonScope.DANGLING_NAME:\n        case JsonScope.NONEMPTY_OBJECT:\n          result.append('.');\n          if (pathNames[i] != null) {\n            result.append(pathNames[i]);\n          }\n          break;\n\n        case JsonScope.NONEMPTY_DOCUMENT:\n        case JsonScope.EMPTY_DOCUMENT:\n        case JsonScope.CLOSED:\n          break;\n      }\n    }\n    return result.toString();\n  }\n\n  /**\n   * Unescapes the character identified by the character or characters that\n   * immediately follow a backslash. The backslash '\\' should have already\n   * been read. This supports both unicode escapes \"u000A\" and two-character\n   * escapes \"\\n\".\n   *\n   * @throws NumberFormatException if any unicode escape sequences are\n   *     malformed.\n   */\n  private char readEscapeCharacter() throws IOException {\n    if (pos == limit && !fillBuffer(1)) {\n      throw syntaxError(\"Unterminated escape sequence\");\n    }\n\n    char escaped = buffer[pos++];\n    switch (escaped) {\n    case 'u':\n      if (pos + 4 > limit && !fillBuffer(4)) {\n        throw syntaxError(\"Unterminated escape sequence\");\n      }\n      // Equivalent to Integer.parseInt(stringPool.get(buffer, pos, 4), 16);\n      char result = 0;\n      for (int i = pos, end = i + 4; i < end; i++) {\n        char c = buffer[i];\n        result <<= 4;\n        if (c >= '0' && c <= '9') {\n          result += (c - '0');\n        } else if (c >= 'a' && c <= 'f') {\n          result += (c - 'a' + 10);\n        } else if (c >= 'A' && c <= 'F') {\n          result += (c - 'A' + 10);\n        } else {\n          throw new NumberFormatException(\"\\\\u\" + new String(buffer, pos, 4));\n        }\n      }\n      pos += 4;\n      return result;\n\n    case 't':\n      return '\\t';\n\n    case 'b':\n      return '\\b';\n\n    case 'n':\n      return '\\n';\n\n    case 'r':\n      return '\\r';\n\n    case 'f':\n      return '\\f';\n\n    case '\\n':\n      lineNumber++;\n      lineStart = pos;\n      // fall-through\n\n    case '\\'':\n    case '\"':\n    case '\\\\':\n    default:\n      return escaped;\n    }\n  }\n\n  /**\n   * Throws a new IO exception with the given message and a context snippet\n   * with this reader's content.\n   */\n  private IOException syntaxError(String message) throws IOException {\n    throw new MalformedJsonException(message\n        + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace(true);\n    pos--;\n\n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n\n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n\n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  static {\n    JsonReaderInternalAccess.INSTANCE = new JsonReaderInternalAccess() {\n      @Override public void promoteNameToValue(JsonReader reader) throws IOException {\n        if (reader instanceof JsonTreeReader) {\n          ((JsonTreeReader)reader).promoteNameToValue();\n          return;\n        }\n        int p = reader.peeked;\n        if (p == PEEKED_NONE) {\n          p = reader.doPeek();\n        }\n        if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n          reader.peeked = PEEKED_DOUBLE_QUOTED;\n        } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n          reader.peeked = PEEKED_SINGLE_QUOTED;\n        } else if (p == PEEKED_UNQUOTED_NAME) {\n          reader.peeked = PEEKED_UNQUOTED;\n        } else {\n          throw new IllegalStateException(\"Expected a name but was \" + reader.peek() + \" \"\n              + \" at line \" + reader.getLineNumber() + \" column \" + reader.getColumnNumber()\n              + \" path \" + reader.getPath());\n        }\n      }\n    };\n  }\n}\n"}, {"class_name": "com.google.gson.stream.JsonWriter", "buggy_version": "/*\n * Copyright (C) 2010 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.gson.stream;\n\nimport java.io.Closeable;\nimport java.io.Flushable;\nimport java.io.IOException;\nimport java.io.Writer;\n\nimport static com.google.gson.stream.JsonScope.DANGLING_NAME;\nimport static com.google.gson.stream.JsonScope.EMPTY_ARRAY;\nimport static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;\nimport static com.google.gson.stream.JsonScope.EMPTY_OBJECT;\nimport static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;\nimport static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;\nimport static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;\n\n/**\n * Writes a JSON (<a href=\"http://www.ietf.org/rfc/rfc7159.txt\">RFC 7159</a>)\n * encoded value to a stream, one token at a time. The stream includes both\n * literal values (strings, numbers, booleans and nulls) as well as the begin\n * and end delimiters of objects and arrays.\n *\n * <h3>Encoding JSON</h3>\n * To encode your data as JSON, create a new {@code JsonWriter}. Each JSON\n * document must contain one top-level array or object. Call methods on the\n * writer as you walk the structure's contents, nesting arrays and objects as\n * necessary:\n * <ul>\n *   <li>To write <strong>arrays</strong>, first call {@link #beginArray()}.\n *       Write each of the array's elements with the appropriate {@link #value}\n *       methods or by nesting other arrays and objects. Finally close the array\n *       using {@link #endArray()}.\n *   <li>To write <strong>objects</strong>, first call {@link #beginObject()}.\n *       Write each of the object's properties by alternating calls to\n *       {@link #name} with the property's value. Write property values with the\n *       appropriate {@link #value} method or by nesting other objects or arrays.\n *       Finally close the object using {@link #endObject()}.\n * </ul>\n *\n * <h3>Example</h3>\n * Suppose we'd like to encode a stream of messages such as the following: <pre> {@code\n * [\n *   {\n *     \"id\": 912345678901,\n *     \"text\": \"How do I stream JSON in Java?\",\n *     \"geo\": null,\n *     \"user\": {\n *       \"name\": \"json_newb\",\n *       \"followers_count\": 41\n *      }\n *   },\n *   {\n *     \"id\": 912345678902,\n *     \"text\": \"@json_newb just use JsonWriter!\",\n *     \"geo\": [50.454722, -104.606667],\n *     \"user\": {\n *       \"name\": \"jesse\",\n *       \"followers_count\": 2\n *     }\n *   }\n * ]}</pre>\n * This code encodes the above structure: <pre>   {@code\n *   public void writeJsonStream(OutputStream out, List<Message> messages) throws IOException {\n *     JsonWriter writer = new JsonWriter(new OutputStreamWriter(out, \"UTF-8\"));\n *     writer.setIndent(\"    \");\n *     writeMessagesArray(writer, messages);\n *     writer.close();\n *   }\n *\n *   public void writeMessagesArray(JsonWriter writer, List<Message> messages) throws IOException {\n *     writer.beginArray();\n *     for (Message message : messages) {\n *       writeMessage(writer, message);\n *     }\n *     writer.endArray();\n *   }\n *\n *   public void writeMessage(JsonWriter writer, Message message) throws IOException {\n *     writer.beginObject();\n *     writer.name(\"id\").value(message.getId());\n *     writer.name(\"text\").value(message.getText());\n *     if (message.getGeo() != null) {\n *       writer.name(\"geo\");\n *       writeDoublesArray(writer, message.getGeo());\n *     } else {\n *       writer.name(\"geo\").nullValue();\n *     }\n *     writer.name(\"user\");\n *     writeUser(writer, message.getUser());\n *     writer.endObject();\n *   }\n *\n *   public void writeUser(JsonWriter writer, User user) throws IOException {\n *     writer.beginObject();\n *     writer.name(\"name\").value(user.getName());\n *     writer.name(\"followers_count\").value(user.getFollowersCount());\n *     writer.endObject();\n *   }\n *\n *   public void writeDoublesArray(JsonWriter writer, List<Double> doubles) throws IOException {\n *     writer.beginArray();\n *     for (Double value : doubles) {\n *       writer.value(value);\n *     }\n *     writer.endArray();\n *   }}</pre>\n *\n * <p>Each {@code JsonWriter} may be used to write a single JSON stream.\n * Instances of this class are not thread safe. Calls that would result in a\n * malformed JSON string will fail with an {@link IllegalStateException}.\n *\n * @author Jesse Wilson\n * @since 1.6\n */\npublic class JsonWriter implements Closeable, Flushable {\n\n  /*\n   * From RFC 7159, \"All Unicode characters may be placed within the\n   * quotation marks except for the characters that must be escaped:\n   * quotation mark, reverse solidus, and the control characters\n   * (U+0000 through U+001F).\"\n   *\n   * We also escape '\\u2028' and '\\u2029', which JavaScript interprets as\n   * newline characters. This prevents eval() from failing with a syntax\n   * error. http://code.google.com/p/google-gson/issues/detail?id=341\n   */\n  private static final String[] REPLACEMENT_CHARS;\n  private static final String[] HTML_SAFE_REPLACEMENT_CHARS;\n  static {\n    REPLACEMENT_CHARS = new String[128];\n    for (int i = 0; i <= 0x1f; i++) {\n      REPLACEMENT_CHARS[i] = String.format(\"\\\\u%04x\", (int) i);\n    }\n    REPLACEMENT_CHARS['\"'] = \"\\\\\\\"\";\n    REPLACEMENT_CHARS['\\\\'] = \"\\\\\\\\\";\n    REPLACEMENT_CHARS['\\t'] = \"\\\\t\";\n    REPLACEMENT_CHARS['\\b'] = \"\\\\b\";\n    REPLACEMENT_CHARS['\\n'] = \"\\\\n\";\n    REPLACEMENT_CHARS['\\r'] = \"\\\\r\";\n    REPLACEMENT_CHARS['\\f'] = \"\\\\f\";\n    HTML_SAFE_REPLACEMENT_CHARS = REPLACEMENT_CHARS.clone();\n    HTML_SAFE_REPLACEMENT_CHARS['<'] = \"\\\\u003c\";\n    HTML_SAFE_REPLACEMENT_CHARS['>'] = \"\\\\u003e\";\n    HTML_SAFE_REPLACEMENT_CHARS['&'] = \"\\\\u0026\";\n    HTML_SAFE_REPLACEMENT_CHARS['='] = \"\\\\u003d\";\n    HTML_SAFE_REPLACEMENT_CHARS['\\''] = \"\\\\u0027\";\n  }\n\n  /** The output data, containing at most one top-level array or object. */\n  private final Writer out;\n\n  private int[] stack = new int[32];\n  private int stackSize = 0;\n  {\n    push(EMPTY_DOCUMENT);\n  }\n\n  /**\n   * A string containing a full set of spaces for a single level of\n   * indentation, or null for no pretty printing.\n   */\n  private String indent;\n\n  /**\n   * The name/value separator; either \":\" or \": \".\n   */\n  private String separator = \":\";\n\n  private boolean lenient;\n\n  private boolean htmlSafe;\n\n  private String deferredName;\n\n  private boolean serializeNulls = true;\n\n  /**\n   * Creates a new instance that writes a JSON-encoded stream to {@code out}.\n   * For best performance, ensure {@link Writer} is buffered; wrapping in\n   * {@link java.io.BufferedWriter BufferedWriter} if necessary.\n   */\n  public JsonWriter(Writer out) {\n    if (out == null) {\n      throw new NullPointerException(\"out == null\");\n    }\n    this.out = out;\n  }\n\n  /**\n   * Sets the indentation string to be repeated for each level of indentation\n   * in the encoded document. If {@code indent.isEmpty()} the encoded document\n   * will be compact. Otherwise the encoded document will be more\n   * human-readable.\n   *\n   * @param indent a string containing only whitespace.\n   */\n  public final void setIndent(String indent) {\n    if (indent.length() == 0) {\n      this.indent = null;\n      this.separator = \":\";\n    } else {\n      this.indent = indent;\n      this.separator = \": \";\n    }\n  }\n\n  /**\n   * Configure this writer to relax its syntax rules. By default, this writer\n   * only emits well-formed JSON as specified by <a\n   * href=\"http://www.ietf.org/rfc/rfc7159.txt\">RFC 7159</a>. Setting the writer\n   * to lenient permits the following:\n   * <ul>\n   *   <li>Top-level values of any type. With strict writing, the top-level\n   *       value must be an object or an array.\n   *   <li>Numbers may be {@link Double#isNaN() NaNs} or {@link\n   *       Double#isInfinite() infinities}.\n   * </ul>\n   */\n  public final void setLenient(boolean lenient) {\n    this.lenient = lenient;\n  }\n\n  /**\n   * Returns true if this writer has relaxed syntax rules.\n   */\n  public boolean isLenient() {\n    return lenient;\n  }\n\n  /**\n   * Configure this writer to emit JSON that's safe for direct inclusion in HTML\n   * and XML documents. This escapes the HTML characters {@code <}, {@code >},\n   * {@code &} and {@code =} before writing them to the stream. Without this\n   * setting, your XML/HTML encoder should replace these characters with the\n   * corresponding escape sequences.\n   */\n  public final void setHtmlSafe(boolean htmlSafe) {\n    this.htmlSafe = htmlSafe;\n  }\n\n  /**\n   * Returns true if this writer writes JSON that's safe for inclusion in HTML\n   * and XML documents.\n   */\n  public final boolean isHtmlSafe() {\n    return htmlSafe;\n  }\n\n  /**\n   * Sets whether object members are serialized when their value is null.\n   * This has no impact on array elements. The default is true.\n   */\n  public final void setSerializeNulls(boolean serializeNulls) {\n    this.serializeNulls = serializeNulls;\n  }\n\n  /**\n   * Returns true if object members are serialized when their value is null.\n   * This has no impact on array elements. The default is true.\n   */\n  public final boolean getSerializeNulls() {\n    return serializeNulls;\n  }\n\n  /**\n   * Begins encoding a new array. Each call to this method must be paired with\n   * a call to {@link #endArray}.\n   *\n   * @return this writer.\n   */\n  public JsonWriter beginArray() throws IOException {\n    writeDeferredName();\n    return open(EMPTY_ARRAY, \"[\");\n  }\n\n  /**\n   * Ends encoding the current array.\n   *\n   * @return this writer.\n   */\n  public JsonWriter endArray() throws IOException {\n    return close(EMPTY_ARRAY, NONEMPTY_ARRAY, \"]\");\n  }\n\n  /**\n   * Begins encoding a new object. Each call to this method must be paired\n   * with a call to {@link #endObject}.\n   *\n   * @return this writer.\n   */\n  public JsonWriter beginObject() throws IOException {\n    writeDeferredName();\n    return open(EMPTY_OBJECT, \"{\");\n  }\n\n  /**\n   * Ends encoding the current object.\n   *\n   * @return this writer.\n   */\n  public JsonWriter endObject() throws IOException {\n    return close(EMPTY_OBJECT, NONEMPTY_OBJECT, \"}\");\n  }\n\n  /**\n   * Enters a new scope by appending any necessary whitespace and the given\n   * bracket.\n   */\n  private JsonWriter open(int empty, String openBracket) throws IOException {\n    beforeValue(true);\n    push(empty);\n    out.write(openBracket);\n    return this;\n  }\n\n  /**\n   * Closes the current scope by appending any necessary whitespace and the\n   * given bracket.\n   */\n  private JsonWriter close(int empty, int nonempty, String closeBracket)\n      throws IOException {\n    int context = peek();\n    if (context != nonempty && context != empty) {\n      throw new IllegalStateException(\"Nesting problem.\");\n    }\n    if (deferredName != null) {\n      throw new IllegalStateException(\"Dangling name: \" + deferredName);\n    }\n\n    stackSize--;\n    if (context == nonempty) {\n      newline();\n    }\n    out.write(closeBracket);\n    return this;\n  }\n\n  private void push(int newTop) {\n    if (stackSize == stack.length) {\n      int[] newStack = new int[stackSize * 2];\n      System.arraycopy(stack, 0, newStack, 0, stackSize);\n      stack = newStack;\n    }\n    stack[stackSize++] = newTop;\n  }\n\n  /**\n   * Returns the value on the top of the stack.\n   */\n  private int peek() {\n    if (stackSize == 0) {\n      throw new IllegalStateException(\"JsonWriter is closed.\");\n    }\n    return stack[stackSize - 1];\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(int topOfStack) {\n    stack[stackSize - 1] = topOfStack;\n  }\n\n  /**\n   * Encodes the property name.\n   *\n   * @param name the name of the forthcoming value. May not be null.\n   * @return this writer.\n   */\n  public JsonWriter name(String name) throws IOException {\n    if (name == null) {\n      throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) {\n      throw new IllegalStateException();\n    }\n    if (stackSize == 0) {\n      throw new IllegalStateException(\"JsonWriter is closed.\");\n    }\n    deferredName = name;\n    return this;\n  }\n\n  private void writeDeferredName() throws IOException {\n    if (deferredName != null) {\n      beforeName();\n      string(deferredName);\n      deferredName = null;\n    }\n  }\n\n  /**\n   * Encodes {@code value}.\n   *\n   * @param value the literal string value, or null to encode a null literal.\n   * @return this writer.\n   */\n  public JsonWriter value(String value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n    writeDeferredName();\n    beforeValue(false);\n    string(value);\n    return this;\n  }\n\n  /**\n   * Writes {@code value} directly to the writer without quoting or\n   * escaping.\n   *\n   * @param value the literal string value, or null to encode a null literal.\n   * @return this writer.\n   */\n  public JsonWriter jsonValue(String value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n    writeDeferredName();\n    beforeValue(false);\n    out.append(value);\n    return this;\n  }\n\n  /**\n   * Encodes {@code null}.\n   *\n   * @return this writer.\n   */\n  public JsonWriter nullValue() throws IOException {\n    if (deferredName != null) {\n      if (serializeNulls) {\n        writeDeferredName();\n      } else {\n        deferredName = null;\n        return this; // skip the name and the value\n      }\n    }\n    beforeValue(false);\n    out.write(\"null\");\n    return this;\n  }\n\n  /**\n   * Encodes {@code value}.\n   *\n   * @return this writer.\n   */\n  public JsonWriter value(boolean value) throws IOException {\n    writeDeferredName();\n    beforeValue(false);\n    out.write(value ? \"true\" : \"false\");\n    return this;\n  }\n\n  /**\n   * Encodes {@code value}.\n   *\n   * @param value a finite value. May not be {@link Double#isNaN() NaNs} or\n   *     {@link Double#isInfinite() infinities}.\n   * @return this writer.\n   */\n  public JsonWriter value(double value) throws IOException {\n    if (Double.isNaN(value) || Double.isInfinite(value)) {\n      throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n    }\n    writeDeferredName();\n    beforeValue(false);\n    out.append(Double.toString(value));\n    return this;\n  }\n\n  /**\n   * Encodes {@code value}.\n   *\n   * @return this writer.\n   */\n  public JsonWriter value(long value) throws IOException {\n    writeDeferredName();\n    beforeValue(false);\n    out.write(Long.toString(value));\n    return this;\n  }\n\n  /**\n   * Encodes {@code value}.\n   *\n   * @param value a finite value. May not be {@link Double#isNaN() NaNs} or\n   *     {@link Double#isInfinite() infinities}.\n   * @return this writer.\n   */\n  public JsonWriter value(Number value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n\n    writeDeferredName();\n    String string = value.toString();\n    if (!lenient\n        && (string.equals(\"-Infinity\") || string.equals(\"Infinity\") || string.equals(\"NaN\"))) {\n      throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n    }\n    beforeValue(false);\n    out.append(string);\n    return this;\n  }\n\n  /**\n   * Ensures all buffered data is written to the underlying {@link Writer}\n   * and flushes that writer.\n   */\n  public void flush() throws IOException {\n    if (stackSize == 0) {\n      throw new IllegalStateException(\"JsonWriter is closed.\");\n    }\n    out.flush();\n  }\n\n  /**\n   * Flushes and closes this writer and the underlying {@link Writer}.\n   *\n   * @throws IOException if the JSON document is incomplete.\n   */\n  public void close() throws IOException {\n    out.close();\n\n    int size = stackSize;\n    if (size > 1 || size == 1 && stack[size - 1] != NONEMPTY_DOCUMENT) {\n      throw new IOException(\"Incomplete document\");\n    }\n    stackSize = 0;\n  }\n\n  private void string(String value) throws IOException {\n    String[] replacements = htmlSafe ? HTML_SAFE_REPLACEMENT_CHARS : REPLACEMENT_CHARS;\n    out.write(\"\\\"\");\n    int last = 0;\n    int length = value.length();\n    for (int i = 0; i < length; i++) {\n      char c = value.charAt(i);\n      String replacement;\n      if (c < 128) {\n        replacement = replacements[c];\n        if (replacement == null) {\n          continue;\n        }\n      } else if (c == '\\u2028') {\n        replacement = \"\\\\u2028\";\n      } else if (c == '\\u2029') {\n        replacement = \"\\\\u2029\";\n      } else {\n        continue;\n      }\n      if (last < i) {\n        out.write(value, last, i - last);\n      }\n      out.write(replacement);\n      last = i + 1;\n    }\n    if (last < length) {\n      out.write(value, last, length - last);\n    }\n    out.write(\"\\\"\");\n  }\n\n  private void newline() throws IOException {\n    if (indent == null) {\n      return;\n    }\n\n    out.write(\"\\n\");\n    for (int i = 1, size = stackSize; i < size; i++) {\n      out.write(indent);\n    }\n  }\n\n  /**\n   * Inserts any necessary separators and whitespace before a name. Also\n   * adjusts the stack to expect the name's value.\n   */\n  private void beforeName() throws IOException {\n    int context = peek();\n    if (context == NONEMPTY_OBJECT) { // first in object\n      out.write(',');\n    } else if (context != EMPTY_OBJECT) { // not in an object!\n      throw new IllegalStateException(\"Nesting problem.\");\n    }\n    newline();\n    replaceTop(DANGLING_NAME);\n  }\n\n  /**\n   * Inserts any necessary separators and whitespace before a literal value,\n   * inline array, or inline object. Also adjusts the stack to expect either a\n   * closing bracket or another element.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private void beforeValue(boolean root) throws IOException {\n    switch (peek()) {\n    case NONEMPTY_DOCUMENT:\n      if (!lenient) {\n        throw new IllegalStateException(\n            \"JSON must have only one top-level value.\");\n      }\n      // fall-through\n    case EMPTY_DOCUMENT: // first in document\n      if (!lenient && !root) {\n        throw new IllegalStateException(\n            \"JSON must start with an array or an object.\");\n      }\n      replaceTop(NONEMPTY_DOCUMENT);\n      break;\n\n    case EMPTY_ARRAY: // first in array\n      replaceTop(NONEMPTY_ARRAY);\n      newline();\n      break;\n\n    case NONEMPTY_ARRAY: // another in array\n      out.append(',');\n      newline();\n      break;\n\n    case DANGLING_NAME: // value for name\n      out.append(separator);\n      replaceTop(NONEMPTY_OBJECT);\n      break;\n\n    default:\n      throw new IllegalStateException(\"Nesting problem.\");\n    }\n  }\n}\n", "fixed_version": "/*\n * Copyright (C) 2010 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.gson.stream;\n\nimport java.io.Closeable;\nimport java.io.Flushable;\nimport java.io.IOException;\nimport java.io.Writer;\n\nimport static com.google.gson.stream.JsonScope.DANGLING_NAME;\nimport static com.google.gson.stream.JsonScope.EMPTY_ARRAY;\nimport static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;\nimport static com.google.gson.stream.JsonScope.EMPTY_OBJECT;\nimport static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;\nimport static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;\nimport static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;\n\n/**\n * Writes a JSON (<a href=\"http://www.ietf.org/rfc/rfc7159.txt\">RFC 7159</a>)\n * encoded value to a stream, one token at a time. The stream includes both\n * literal values (strings, numbers, booleans and nulls) as well as the begin\n * and end delimiters of objects and arrays.\n *\n * <h3>Encoding JSON</h3>\n * To encode your data as JSON, create a new {@code JsonWriter}. Each JSON\n * document must contain one top-level array or object. Call methods on the\n * writer as you walk the structure's contents, nesting arrays and objects as\n * necessary:\n * <ul>\n *   <li>To write <strong>arrays</strong>, first call {@link #beginArray()}.\n *       Write each of the array's elements with the appropriate {@link #value}\n *       methods or by nesting other arrays and objects. Finally close the array\n *       using {@link #endArray()}.\n *   <li>To write <strong>objects</strong>, first call {@link #beginObject()}.\n *       Write each of the object's properties by alternating calls to\n *       {@link #name} with the property's value. Write property values with the\n *       appropriate {@link #value} method or by nesting other objects or arrays.\n *       Finally close the object using {@link #endObject()}.\n * </ul>\n *\n * <h3>Example</h3>\n * Suppose we'd like to encode a stream of messages such as the following: <pre> {@code\n * [\n *   {\n *     \"id\": 912345678901,\n *     \"text\": \"How do I stream JSON in Java?\",\n *     \"geo\": null,\n *     \"user\": {\n *       \"name\": \"json_newb\",\n *       \"followers_count\": 41\n *      }\n *   },\n *   {\n *     \"id\": 912345678902,\n *     \"text\": \"@json_newb just use JsonWriter!\",\n *     \"geo\": [50.454722, -104.606667],\n *     \"user\": {\n *       \"name\": \"jesse\",\n *       \"followers_count\": 2\n *     }\n *   }\n * ]}</pre>\n * This code encodes the above structure: <pre>   {@code\n *   public void writeJsonStream(OutputStream out, List<Message> messages) throws IOException {\n *     JsonWriter writer = new JsonWriter(new OutputStreamWriter(out, \"UTF-8\"));\n *     writer.setIndent(\"    \");\n *     writeMessagesArray(writer, messages);\n *     writer.close();\n *   }\n *\n *   public void writeMessagesArray(JsonWriter writer, List<Message> messages) throws IOException {\n *     writer.beginArray();\n *     for (Message message : messages) {\n *       writeMessage(writer, message);\n *     }\n *     writer.endArray();\n *   }\n *\n *   public void writeMessage(JsonWriter writer, Message message) throws IOException {\n *     writer.beginObject();\n *     writer.name(\"id\").value(message.getId());\n *     writer.name(\"text\").value(message.getText());\n *     if (message.getGeo() != null) {\n *       writer.name(\"geo\");\n *       writeDoublesArray(writer, message.getGeo());\n *     } else {\n *       writer.name(\"geo\").nullValue();\n *     }\n *     writer.name(\"user\");\n *     writeUser(writer, message.getUser());\n *     writer.endObject();\n *   }\n *\n *   public void writeUser(JsonWriter writer, User user) throws IOException {\n *     writer.beginObject();\n *     writer.name(\"name\").value(user.getName());\n *     writer.name(\"followers_count\").value(user.getFollowersCount());\n *     writer.endObject();\n *   }\n *\n *   public void writeDoublesArray(JsonWriter writer, List<Double> doubles) throws IOException {\n *     writer.beginArray();\n *     for (Double value : doubles) {\n *       writer.value(value);\n *     }\n *     writer.endArray();\n *   }}</pre>\n *\n * <p>Each {@code JsonWriter} may be used to write a single JSON stream.\n * Instances of this class are not thread safe. Calls that would result in a\n * malformed JSON string will fail with an {@link IllegalStateException}.\n *\n * @author Jesse Wilson\n * @since 1.6\n */\npublic class JsonWriter implements Closeable, Flushable {\n\n  /*\n   * From RFC 7159, \"All Unicode characters may be placed within the\n   * quotation marks except for the characters that must be escaped:\n   * quotation mark, reverse solidus, and the control characters\n   * (U+0000 through U+001F).\"\n   *\n   * We also escape '\\u2028' and '\\u2029', which JavaScript interprets as\n   * newline characters. This prevents eval() from failing with a syntax\n   * error. http://code.google.com/p/google-gson/issues/detail?id=341\n   */\n  private static final String[] REPLACEMENT_CHARS;\n  private static final String[] HTML_SAFE_REPLACEMENT_CHARS;\n  static {\n    REPLACEMENT_CHARS = new String[128];\n    for (int i = 0; i <= 0x1f; i++) {\n      REPLACEMENT_CHARS[i] = String.format(\"\\\\u%04x\", (int) i);\n    }\n    REPLACEMENT_CHARS['\"'] = \"\\\\\\\"\";\n    REPLACEMENT_CHARS['\\\\'] = \"\\\\\\\\\";\n    REPLACEMENT_CHARS['\\t'] = \"\\\\t\";\n    REPLACEMENT_CHARS['\\b'] = \"\\\\b\";\n    REPLACEMENT_CHARS['\\n'] = \"\\\\n\";\n    REPLACEMENT_CHARS['\\r'] = \"\\\\r\";\n    REPLACEMENT_CHARS['\\f'] = \"\\\\f\";\n    HTML_SAFE_REPLACEMENT_CHARS = REPLACEMENT_CHARS.clone();\n    HTML_SAFE_REPLACEMENT_CHARS['<'] = \"\\\\u003c\";\n    HTML_SAFE_REPLACEMENT_CHARS['>'] = \"\\\\u003e\";\n    HTML_SAFE_REPLACEMENT_CHARS['&'] = \"\\\\u0026\";\n    HTML_SAFE_REPLACEMENT_CHARS['='] = \"\\\\u003d\";\n    HTML_SAFE_REPLACEMENT_CHARS['\\''] = \"\\\\u0027\";\n  }\n\n  /** The output data, containing at most one top-level array or object. */\n  private final Writer out;\n\n  private int[] stack = new int[32];\n  private int stackSize = 0;\n  {\n    push(EMPTY_DOCUMENT);\n  }\n\n  /**\n   * A string containing a full set of spaces for a single level of\n   * indentation, or null for no pretty printing.\n   */\n  private String indent;\n\n  /**\n   * The name/value separator; either \":\" or \": \".\n   */\n  private String separator = \":\";\n\n  private boolean lenient;\n\n  private boolean htmlSafe;\n\n  private String deferredName;\n\n  private boolean serializeNulls = true;\n\n  /**\n   * Creates a new instance that writes a JSON-encoded stream to {@code out}.\n   * For best performance, ensure {@link Writer} is buffered; wrapping in\n   * {@link java.io.BufferedWriter BufferedWriter} if necessary.\n   */\n  public JsonWriter(Writer out) {\n    if (out == null) {\n      throw new NullPointerException(\"out == null\");\n    }\n    this.out = out;\n  }\n\n  /**\n   * Sets the indentation string to be repeated for each level of indentation\n   * in the encoded document. If {@code indent.isEmpty()} the encoded document\n   * will be compact. Otherwise the encoded document will be more\n   * human-readable.\n   *\n   * @param indent a string containing only whitespace.\n   */\n  public final void setIndent(String indent) {\n    if (indent.length() == 0) {\n      this.indent = null;\n      this.separator = \":\";\n    } else {\n      this.indent = indent;\n      this.separator = \": \";\n    }\n  }\n\n  /**\n   * Configure this writer to relax its syntax rules. By default, this writer\n   * only emits well-formed JSON as specified by <a\n   * href=\"http://www.ietf.org/rfc/rfc7159.txt\">RFC 7159</a>. Setting the writer\n   * to lenient permits the following:\n   * <ul>\n   *   <li>Top-level values of any type. With strict writing, the top-level\n   *       value must be an object or an array.\n   *   <li>Numbers may be {@link Double#isNaN() NaNs} or {@link\n   *       Double#isInfinite() infinities}.\n   * </ul>\n   */\n  public final void setLenient(boolean lenient) {\n    this.lenient = lenient;\n  }\n\n  /**\n   * Returns true if this writer has relaxed syntax rules.\n   */\n  public boolean isLenient() {\n    return lenient;\n  }\n\n  /**\n   * Configure this writer to emit JSON that's safe for direct inclusion in HTML\n   * and XML documents. This escapes the HTML characters {@code <}, {@code >},\n   * {@code &} and {@code =} before writing them to the stream. Without this\n   * setting, your XML/HTML encoder should replace these characters with the\n   * corresponding escape sequences.\n   */\n  public final void setHtmlSafe(boolean htmlSafe) {\n    this.htmlSafe = htmlSafe;\n  }\n\n  /**\n   * Returns true if this writer writes JSON that's safe for inclusion in HTML\n   * and XML documents.\n   */\n  public final boolean isHtmlSafe() {\n    return htmlSafe;\n  }\n\n  /**\n   * Sets whether object members are serialized when their value is null.\n   * This has no impact on array elements. The default is true.\n   */\n  public final void setSerializeNulls(boolean serializeNulls) {\n    this.serializeNulls = serializeNulls;\n  }\n\n  /**\n   * Returns true if object members are serialized when their value is null.\n   * This has no impact on array elements. The default is true.\n   */\n  public final boolean getSerializeNulls() {\n    return serializeNulls;\n  }\n\n  /**\n   * Begins encoding a new array. Each call to this method must be paired with\n   * a call to {@link #endArray}.\n   *\n   * @return this writer.\n   */\n  public JsonWriter beginArray() throws IOException {\n    writeDeferredName();\n    return open(EMPTY_ARRAY, \"[\");\n  }\n\n  /**\n   * Ends encoding the current array.\n   *\n   * @return this writer.\n   */\n  public JsonWriter endArray() throws IOException {\n    return close(EMPTY_ARRAY, NONEMPTY_ARRAY, \"]\");\n  }\n\n  /**\n   * Begins encoding a new object. Each call to this method must be paired\n   * with a call to {@link #endObject}.\n   *\n   * @return this writer.\n   */\n  public JsonWriter beginObject() throws IOException {\n    writeDeferredName();\n    return open(EMPTY_OBJECT, \"{\");\n  }\n\n  /**\n   * Ends encoding the current object.\n   *\n   * @return this writer.\n   */\n  public JsonWriter endObject() throws IOException {\n    return close(EMPTY_OBJECT, NONEMPTY_OBJECT, \"}\");\n  }\n\n  /**\n   * Enters a new scope by appending any necessary whitespace and the given\n   * bracket.\n   */\n  private JsonWriter open(int empty, String openBracket) throws IOException {\n    beforeValue();\n    push(empty);\n    out.write(openBracket);\n    return this;\n  }\n\n  /**\n   * Closes the current scope by appending any necessary whitespace and the\n   * given bracket.\n   */\n  private JsonWriter close(int empty, int nonempty, String closeBracket)\n      throws IOException {\n    int context = peek();\n    if (context != nonempty && context != empty) {\n      throw new IllegalStateException(\"Nesting problem.\");\n    }\n    if (deferredName != null) {\n      throw new IllegalStateException(\"Dangling name: \" + deferredName);\n    }\n\n    stackSize--;\n    if (context == nonempty) {\n      newline();\n    }\n    out.write(closeBracket);\n    return this;\n  }\n\n  private void push(int newTop) {\n    if (stackSize == stack.length) {\n      int[] newStack = new int[stackSize * 2];\n      System.arraycopy(stack, 0, newStack, 0, stackSize);\n      stack = newStack;\n    }\n    stack[stackSize++] = newTop;\n  }\n\n  /**\n   * Returns the value on the top of the stack.\n   */\n  private int peek() {\n    if (stackSize == 0) {\n      throw new IllegalStateException(\"JsonWriter is closed.\");\n    }\n    return stack[stackSize - 1];\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(int topOfStack) {\n    stack[stackSize - 1] = topOfStack;\n  }\n\n  /**\n   * Encodes the property name.\n   *\n   * @param name the name of the forthcoming value. May not be null.\n   * @return this writer.\n   */\n  public JsonWriter name(String name) throws IOException {\n    if (name == null) {\n      throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) {\n      throw new IllegalStateException();\n    }\n    if (stackSize == 0) {\n      throw new IllegalStateException(\"JsonWriter is closed.\");\n    }\n    deferredName = name;\n    return this;\n  }\n\n  private void writeDeferredName() throws IOException {\n    if (deferredName != null) {\n      beforeName();\n      string(deferredName);\n      deferredName = null;\n    }\n  }\n\n  /**\n   * Encodes {@code value}.\n   *\n   * @param value the literal string value, or null to encode a null literal.\n   * @return this writer.\n   */\n  public JsonWriter value(String value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n    writeDeferredName();\n    beforeValue();\n    string(value);\n    return this;\n  }\n\n  /**\n   * Writes {@code value} directly to the writer without quoting or\n   * escaping.\n   *\n   * @param value the literal string value, or null to encode a null literal.\n   * @return this writer.\n   */\n  public JsonWriter jsonValue(String value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n    writeDeferredName();\n    beforeValue();\n    out.append(value);\n    return this;\n  }\n\n  /**\n   * Encodes {@code null}.\n   *\n   * @return this writer.\n   */\n  public JsonWriter nullValue() throws IOException {\n    if (deferredName != null) {\n      if (serializeNulls) {\n        writeDeferredName();\n      } else {\n        deferredName = null;\n        return this; // skip the name and the value\n      }\n    }\n    beforeValue();\n    out.write(\"null\");\n    return this;\n  }\n\n  /**\n   * Encodes {@code value}.\n   *\n   * @return this writer.\n   */\n  public JsonWriter value(boolean value) throws IOException {\n    writeDeferredName();\n    beforeValue();\n    out.write(value ? \"true\" : \"false\");\n    return this;\n  }\n\n  /**\n   * Encodes {@code value}.\n   *\n   * @param value a finite value. May not be {@link Double#isNaN() NaNs} or\n   *     {@link Double#isInfinite() infinities}.\n   * @return this writer.\n   */\n  public JsonWriter value(double value) throws IOException {\n    if (Double.isNaN(value) || Double.isInfinite(value)) {\n      throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n    }\n    writeDeferredName();\n    beforeValue();\n    out.append(Double.toString(value));\n    return this;\n  }\n\n  /**\n   * Encodes {@code value}.\n   *\n   * @return this writer.\n   */\n  public JsonWriter value(long value) throws IOException {\n    writeDeferredName();\n    beforeValue();\n    out.write(Long.toString(value));\n    return this;\n  }\n\n  /**\n   * Encodes {@code value}.\n   *\n   * @param value a finite value. May not be {@link Double#isNaN() NaNs} or\n   *     {@link Double#isInfinite() infinities}.\n   * @return this writer.\n   */\n  public JsonWriter value(Number value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n\n    writeDeferredName();\n    String string = value.toString();\n    if (!lenient\n        && (string.equals(\"-Infinity\") || string.equals(\"Infinity\") || string.equals(\"NaN\"))) {\n      throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n    }\n    beforeValue();\n    out.append(string);\n    return this;\n  }\n\n  /**\n   * Ensures all buffered data is written to the underlying {@link Writer}\n   * and flushes that writer.\n   */\n  public void flush() throws IOException {\n    if (stackSize == 0) {\n      throw new IllegalStateException(\"JsonWriter is closed.\");\n    }\n    out.flush();\n  }\n\n  /**\n   * Flushes and closes this writer and the underlying {@link Writer}.\n   *\n   * @throws IOException if the JSON document is incomplete.\n   */\n  public void close() throws IOException {\n    out.close();\n\n    int size = stackSize;\n    if (size > 1 || size == 1 && stack[size - 1] != NONEMPTY_DOCUMENT) {\n      throw new IOException(\"Incomplete document\");\n    }\n    stackSize = 0;\n  }\n\n  private void string(String value) throws IOException {\n    String[] replacements = htmlSafe ? HTML_SAFE_REPLACEMENT_CHARS : REPLACEMENT_CHARS;\n    out.write(\"\\\"\");\n    int last = 0;\n    int length = value.length();\n    for (int i = 0; i < length; i++) {\n      char c = value.charAt(i);\n      String replacement;\n      if (c < 128) {\n        replacement = replacements[c];\n        if (replacement == null) {\n          continue;\n        }\n      } else if (c == '\\u2028') {\n        replacement = \"\\\\u2028\";\n      } else if (c == '\\u2029') {\n        replacement = \"\\\\u2029\";\n      } else {\n        continue;\n      }\n      if (last < i) {\n        out.write(value, last, i - last);\n      }\n      out.write(replacement);\n      last = i + 1;\n    }\n    if (last < length) {\n      out.write(value, last, length - last);\n    }\n    out.write(\"\\\"\");\n  }\n\n  private void newline() throws IOException {\n    if (indent == null) {\n      return;\n    }\n\n    out.write(\"\\n\");\n    for (int i = 1, size = stackSize; i < size; i++) {\n      out.write(indent);\n    }\n  }\n\n  /**\n   * Inserts any necessary separators and whitespace before a name. Also\n   * adjusts the stack to expect the name's value.\n   */\n  private void beforeName() throws IOException {\n    int context = peek();\n    if (context == NONEMPTY_OBJECT) { // first in object\n      out.write(',');\n    } else if (context != EMPTY_OBJECT) { // not in an object!\n      throw new IllegalStateException(\"Nesting problem.\");\n    }\n    newline();\n    replaceTop(DANGLING_NAME);\n  }\n\n  /**\n   * Inserts any necessary separators and whitespace before a literal value,\n   * inline array, or inline object. Also adjusts the stack to expect either a\n   * closing bracket or another element.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private void beforeValue() throws IOException {\n    switch (peek()) {\n    case NONEMPTY_DOCUMENT:\n      if (!lenient) {\n        throw new IllegalStateException(\n            \"JSON must have only one top-level value.\");\n      }\n      // fall-through\n    case EMPTY_DOCUMENT: // first in document\n      replaceTop(NONEMPTY_DOCUMENT);\n      break;\n\n    case EMPTY_ARRAY: // first in array\n      replaceTop(NONEMPTY_ARRAY);\n      newline();\n      break;\n\n    case NONEMPTY_ARRAY: // another in array\n      out.append(',');\n      newline();\n      break;\n\n    case DANGLING_NAME: // value for name\n      out.append(separator);\n      replaceTop(NONEMPTY_OBJECT);\n      break;\n\n    default:\n      throw new IllegalStateException(\"Nesting problem.\");\n    }\n  }\n}\n"}]}
{"project": "Gson", "bug_id": 5, "classes_modified": [{"class_name": "com.google.gson.internal.bind.util.ISO8601Utils", "buggy_version": "package com.google.gson.internal.bind.util;\n\nimport java.text.ParseException;\nimport java.text.ParsePosition;\nimport java.util.*;\n\n/**\n * Utilities methods for manipulating dates in iso8601 format. This is much much faster and GC friendly than using SimpleDateFormat so\n * highly suitable if you (un)serialize lots of date objects.\n * \n * Supported parse format: [yyyy-MM-dd|yyyyMMdd][T(hh:mm[:ss[.sss]]|hhmm[ss[.sss]])]?[Z|[+-]hh[:]mm]]\n * \n * @see <a href=\"http://www.w3.org/TR/NOTE-datetime\">this specification</a>\n */\n//Date parsing code from Jackson databind ISO8601Utils.java\n// https://github.com/FasterXML/jackson-databind/blob/master/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java\npublic class ISO8601Utils\n{\n    /**\n     * ID to represent the 'UTC' string, default timezone since Jackson 2.7\n     * \n     * @since 2.7\n     */\n    private static final String UTC_ID = \"UTC\";\n    /**\n     * The UTC timezone, prefetched to avoid more lookups.\n     * \n     * @since 2.7\n     */\n    private static final TimeZone TIMEZONE_UTC = TimeZone.getTimeZone(UTC_ID);\n\n    /*\n    /**********************************************************\n    /* Formatting\n    /**********************************************************\n     */\n\n    /**\n     * Format a date into 'yyyy-MM-ddThh:mm:ssZ' (default timezone, no milliseconds precision)\n     * \n     * @param date the date to format\n     * @return the date formatted as 'yyyy-MM-ddThh:mm:ssZ'\n     */\n    public static String format(Date date) {\n        return format(date, false, TIMEZONE_UTC);\n    }\n\n    /**\n     * Format a date into 'yyyy-MM-ddThh:mm:ss[.sss]Z' (GMT timezone)\n     * \n     * @param date the date to format\n     * @param millis true to include millis precision otherwise false\n     * @return the date formatted as 'yyyy-MM-ddThh:mm:ss[.sss]Z'\n     */\n    public static String format(Date date, boolean millis) {\n        return format(date, millis, TIMEZONE_UTC);\n    }\n\n    /**\n     * Format date into yyyy-MM-ddThh:mm:ss[.sss][Z|[+-]hh:mm]\n     * \n     * @param date the date to format\n     * @param millis true to include millis precision otherwise false\n     * @param tz timezone to use for the formatting (UTC will produce 'Z')\n     * @return the date formatted as yyyy-MM-ddThh:mm:ss[.sss][Z|[+-]hh:mm]\n     */\n    public static String format(Date date, boolean millis, TimeZone tz) {\n        Calendar calendar = new GregorianCalendar(tz, Locale.US);\n        calendar.setTime(date);\n\n        // estimate capacity of buffer as close as we can (yeah, that's pedantic ;)\n        int capacity = \"yyyy-MM-ddThh:mm:ss\".length();\n        capacity += millis ? \".sss\".length() : 0;\n        capacity += tz.getRawOffset() == 0 ? \"Z\".length() : \"+hh:mm\".length();\n        StringBuilder formatted = new StringBuilder(capacity);\n\n        padInt(formatted, calendar.get(Calendar.YEAR), \"yyyy\".length());\n        formatted.append('-');\n        padInt(formatted, calendar.get(Calendar.MONTH) + 1, \"MM\".length());\n        formatted.append('-');\n        padInt(formatted, calendar.get(Calendar.DAY_OF_MONTH), \"dd\".length());\n        formatted.append('T');\n        padInt(formatted, calendar.get(Calendar.HOUR_OF_DAY), \"hh\".length());\n        formatted.append(':');\n        padInt(formatted, calendar.get(Calendar.MINUTE), \"mm\".length());\n        formatted.append(':');\n        padInt(formatted, calendar.get(Calendar.SECOND), \"ss\".length());\n        if (millis) {\n            formatted.append('.');\n            padInt(formatted, calendar.get(Calendar.MILLISECOND), \"sss\".length());\n        }\n\n        int offset = tz.getOffset(calendar.getTimeInMillis());\n        if (offset != 0) {\n            int hours = Math.abs((offset / (60 * 1000)) / 60);\n            int minutes = Math.abs((offset / (60 * 1000)) % 60);\n            formatted.append(offset < 0 ? '-' : '+');\n            padInt(formatted, hours, \"hh\".length());\n            formatted.append(':');\n            padInt(formatted, minutes, \"mm\".length());\n        } else {\n            formatted.append('Z');\n        }\n\n        return formatted.toString();\n    }\n\n    /*\n    /**********************************************************\n    /* Parsing\n    /**********************************************************\n     */\n\n    /**\n     * Parse a date from ISO-8601 formatted string. It expects a format\n     * [yyyy-MM-dd|yyyyMMdd][T(hh:mm[:ss[.sss]]|hhmm[ss[.sss]])]?[Z|[+-]hh[:mm]]]\n     * \n     * @param date ISO string to parse in the appropriate format.\n     * @param pos The position to start parsing from, updated to where parsing stopped.\n     * @return the parsed date\n     * @throws ParseException if the date is not in the appropriate format\n     */\n    public static Date parse(String date, ParsePosition pos) throws ParseException {\n        Exception fail = null;\n        try {\n            int offset = pos.getIndex();\n\n            // extract year\n            int year = parseInt(date, offset, offset += 4);\n            if (checkOffset(date, offset, '-')) {\n                offset += 1;\n            }\n\n            // extract month\n            int month = parseInt(date, offset, offset += 2);\n            if (checkOffset(date, offset, '-')) {\n                offset += 1;\n            }\n\n            // extract day\n            int day = parseInt(date, offset, offset += 2);\n            // default time value\n            int hour = 0;\n            int minutes = 0;\n            int seconds = 0;\n            int milliseconds = 0; // always use 0 otherwise returned date will include millis of current time\n\n            // if the value has no time component (and no time zone), we are done\n            boolean hasT = checkOffset(date, offset, 'T');\n            \n            if (!hasT && (date.length() <= offset)) {\n                Calendar calendar = new GregorianCalendar(year, month - 1, day);\n\n                pos.setIndex(offset);\n                return calendar.getTime();\n            }\n\n            if (hasT) {\n\n                // extract hours, minutes, seconds and milliseconds\n                hour = parseInt(date, offset += 1, offset += 2);\n                if (checkOffset(date, offset, ':')) {\n                    offset += 1;\n                }\n\n                minutes = parseInt(date, offset, offset += 2);\n                if (checkOffset(date, offset, ':')) {\n                    offset += 1;\n                }\n                // second and milliseconds can be optional\n                if (date.length() > offset) {\n                    char c = date.charAt(offset);\n                    if (c != 'Z' && c != '+' && c != '-') {\n                        seconds = parseInt(date, offset, offset += 2);\n                        if (seconds > 59 && seconds < 63) seconds = 59; // truncate up to 3 leap seconds\n                        // milliseconds can be optional in the format\n                        if (checkOffset(date, offset, '.')) {\n                            offset += 1;\n                            int endOffset = indexOfNonDigit(date, offset + 1); // assume at least one digit\n                            int parseEndOffset = Math.min(endOffset, offset + 3); // parse up to 3 digits\n                            int fraction = parseInt(date, offset, parseEndOffset);\n                            // compensate for \"missing\" digits\n                            switch (parseEndOffset - offset) { // number of digits parsed\n                            case 2:\n                                milliseconds = fraction * 10;\n                                break;\n                            case 1:\n                                milliseconds = fraction * 100;\n                                break;\n                            default:\n                                milliseconds = fraction;\n                            }\n                            offset = endOffset;\n                        }\n                    }\n                }\n            }\n\n            // extract timezone\n            if (date.length() <= offset) {\n                throw new IllegalArgumentException(\"No time zone indicator\");\n            }\n\n            TimeZone timezone = null;\n            char timezoneIndicator = date.charAt(offset);\n\n            if (timezoneIndicator == 'Z') {\n                timezone = TIMEZONE_UTC;\n                offset += 1;\n            } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n                String timezoneOffset = date.substring(offset);\n\n                // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00\n\n                offset += timezoneOffset.length();\n                // 18-Jun-2015, tatu: Minor simplification, skip offset of \"+0000\"/\"+00:00\"\n                if (\"+0000\".equals(timezoneOffset) || \"+00:00\".equals(timezoneOffset)) {\n                    timezone = TIMEZONE_UTC;\n                } else {\n                    // 18-Jun-2015, tatu: Looks like offsets only work from GMT, not UTC...\n                    //    not sure why, but that's the way it looks. Further, Javadocs for\n                    //    `java.util.TimeZone` specifically instruct use of GMT as base for\n                    //    custom timezones... odd.\n                    String timezoneId = \"GMT\" + timezoneOffset;\n//                    String timezoneId = \"UTC\" + timezoneOffset;\n\n                    timezone = TimeZone.getTimeZone(timezoneId);\n\n                    String act = timezone.getID();\n                    if (!act.equals(timezoneId)) {\n                        /* 22-Jan-2015, tatu: Looks like canonical version has colons, but we may be given\n                         *    one without. If so, don't sweat.\n                         *   Yes, very inefficient. Hopefully not hit often.\n                         *   If it becomes a perf problem, add 'loose' comparison instead.\n                         */\n                        String cleaned = act.replace(\":\", \"\");\n                        if (!cleaned.equals(timezoneId)) {\n                            throw new IndexOutOfBoundsException(\"Mismatching time zone indicator: \"+timezoneId+\" given, resolves to \"\n                                    +timezone.getID());\n                        }\n                    }\n                }\n            } else {\n                throw new IndexOutOfBoundsException(\"Invalid time zone indicator '\" + timezoneIndicator+\"'\");\n            }\n\n            Calendar calendar = new GregorianCalendar(timezone);\n            calendar.setLenient(false);\n            calendar.set(Calendar.YEAR, year);\n            calendar.set(Calendar.MONTH, month - 1);\n            calendar.set(Calendar.DAY_OF_MONTH, day);\n            calendar.set(Calendar.HOUR_OF_DAY, hour);\n            calendar.set(Calendar.MINUTE, minutes);\n            calendar.set(Calendar.SECOND, seconds);\n            calendar.set(Calendar.MILLISECOND, milliseconds);\n\n            pos.setIndex(offset);\n            return calendar.getTime();\n            // If we get a ParseException it'll already have the right message/offset.\n            // Other exception types can convert here.\n        } catch (IndexOutOfBoundsException e) {\n            fail = e;\n        } catch (NumberFormatException e) {\n            fail = e;\n        } catch (IllegalArgumentException e) {\n            fail = e;\n        }\n        String input = (date == null) ? null : ('\"' + date + \"'\");\n        String msg = fail.getMessage();\n        if (msg == null || msg.isEmpty()) {\n            msg = \"(\"+fail.getClass().getName()+\")\";\n        }\n        ParseException ex = new ParseException(\"Failed to parse date [\" + input + \"]: \" + msg, pos.getIndex());\n        ex.initCause(fail);\n        throw ex;\n    }\n\n    /**\n     * Check if the expected character exist at the given offset in the value.\n     * \n     * @param value the string to check at the specified offset\n     * @param offset the offset to look for the expected character\n     * @param expected the expected character\n     * @return true if the expected character exist at the given offset\n     */\n    private static boolean checkOffset(String value, int offset, char expected) {\n        return (offset < value.length()) && (value.charAt(offset) == expected);\n    }\n\n    /**\n     * Parse an integer located between 2 given offsets in a string\n     * \n     * @param value the string to parse\n     * @param beginIndex the start index for the integer in the string\n     * @param endIndex the end index for the integer in the string\n     * @return the int\n     * @throws NumberFormatException if the value is not a number\n     */\n    private static int parseInt(String value, int beginIndex, int endIndex) throws NumberFormatException {\n        if (beginIndex < 0 || endIndex > value.length() || beginIndex > endIndex) {\n            throw new NumberFormatException(value);\n        }\n        // use same logic as in Integer.parseInt() but less generic we're not supporting negative values\n        int i = beginIndex;\n        int result = 0;\n        int digit;\n        if (i < endIndex) {\n            digit = Character.digit(value.charAt(i++), 10);\n            if (digit < 0) {\n                throw new NumberFormatException(\"Invalid number: \" + value.substring(beginIndex, endIndex));\n            }\n            result = -digit;\n        }\n        while (i < endIndex) {\n            digit = Character.digit(value.charAt(i++), 10);\n            if (digit < 0) {\n                throw new NumberFormatException(\"Invalid number: \" + value.substring(beginIndex, endIndex));\n            }\n            result *= 10;\n            result -= digit;\n        }\n        return -result;\n    }\n\n    /**\n     * Zero pad a number to a specified length\n     * \n     * @param buffer buffer to use for padding\n     * @param value the integer value to pad if necessary.\n     * @param length the length of the string we should zero pad\n     */\n    private static void padInt(StringBuilder buffer, int value, int length) {\n        String strValue = Integer.toString(value);\n        for (int i = length - strValue.length(); i > 0; i--) {\n            buffer.append('0');\n        }\n        buffer.append(strValue);\n    }\n\n    /**\n     * Returns the index of the first character in the string that is not a digit, starting at offset.\n     */\n    private static int indexOfNonDigit(String string, int offset) {\n        for (int i = offset; i < string.length(); i++) {\n            char c = string.charAt(i);\n            if (c < '0' || c > '9') return i;\n        }\n        return string.length();\n    }\n\n}\n", "fixed_version": "package com.google.gson.internal.bind.util;\n\nimport java.text.ParseException;\nimport java.text.ParsePosition;\nimport java.util.*;\n\n/**\n * Utilities methods for manipulating dates in iso8601 format. This is much much faster and GC friendly than using SimpleDateFormat so\n * highly suitable if you (un)serialize lots of date objects.\n * \n * Supported parse format: [yyyy-MM-dd|yyyyMMdd][T(hh:mm[:ss[.sss]]|hhmm[ss[.sss]])]?[Z|[+-]hh[:]mm]]\n * \n * @see <a href=\"http://www.w3.org/TR/NOTE-datetime\">this specification</a>\n */\n//Date parsing code from Jackson databind ISO8601Utils.java\n// https://github.com/FasterXML/jackson-databind/blob/master/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java\npublic class ISO8601Utils\n{\n    /**\n     * ID to represent the 'UTC' string, default timezone since Jackson 2.7\n     * \n     * @since 2.7\n     */\n    private static final String UTC_ID = \"UTC\";\n    /**\n     * The UTC timezone, prefetched to avoid more lookups.\n     * \n     * @since 2.7\n     */\n    private static final TimeZone TIMEZONE_UTC = TimeZone.getTimeZone(UTC_ID);\n\n    /*\n    /**********************************************************\n    /* Formatting\n    /**********************************************************\n     */\n\n    /**\n     * Format a date into 'yyyy-MM-ddThh:mm:ssZ' (default timezone, no milliseconds precision)\n     * \n     * @param date the date to format\n     * @return the date formatted as 'yyyy-MM-ddThh:mm:ssZ'\n     */\n    public static String format(Date date) {\n        return format(date, false, TIMEZONE_UTC);\n    }\n\n    /**\n     * Format a date into 'yyyy-MM-ddThh:mm:ss[.sss]Z' (GMT timezone)\n     * \n     * @param date the date to format\n     * @param millis true to include millis precision otherwise false\n     * @return the date formatted as 'yyyy-MM-ddThh:mm:ss[.sss]Z'\n     */\n    public static String format(Date date, boolean millis) {\n        return format(date, millis, TIMEZONE_UTC);\n    }\n\n    /**\n     * Format date into yyyy-MM-ddThh:mm:ss[.sss][Z|[+-]hh:mm]\n     * \n     * @param date the date to format\n     * @param millis true to include millis precision otherwise false\n     * @param tz timezone to use for the formatting (UTC will produce 'Z')\n     * @return the date formatted as yyyy-MM-ddThh:mm:ss[.sss][Z|[+-]hh:mm]\n     */\n    public static String format(Date date, boolean millis, TimeZone tz) {\n        Calendar calendar = new GregorianCalendar(tz, Locale.US);\n        calendar.setTime(date);\n\n        // estimate capacity of buffer as close as we can (yeah, that's pedantic ;)\n        int capacity = \"yyyy-MM-ddThh:mm:ss\".length();\n        capacity += millis ? \".sss\".length() : 0;\n        capacity += tz.getRawOffset() == 0 ? \"Z\".length() : \"+hh:mm\".length();\n        StringBuilder formatted = new StringBuilder(capacity);\n\n        padInt(formatted, calendar.get(Calendar.YEAR), \"yyyy\".length());\n        formatted.append('-');\n        padInt(formatted, calendar.get(Calendar.MONTH) + 1, \"MM\".length());\n        formatted.append('-');\n        padInt(formatted, calendar.get(Calendar.DAY_OF_MONTH), \"dd\".length());\n        formatted.append('T');\n        padInt(formatted, calendar.get(Calendar.HOUR_OF_DAY), \"hh\".length());\n        formatted.append(':');\n        padInt(formatted, calendar.get(Calendar.MINUTE), \"mm\".length());\n        formatted.append(':');\n        padInt(formatted, calendar.get(Calendar.SECOND), \"ss\".length());\n        if (millis) {\n            formatted.append('.');\n            padInt(formatted, calendar.get(Calendar.MILLISECOND), \"sss\".length());\n        }\n\n        int offset = tz.getOffset(calendar.getTimeInMillis());\n        if (offset != 0) {\n            int hours = Math.abs((offset / (60 * 1000)) / 60);\n            int minutes = Math.abs((offset / (60 * 1000)) % 60);\n            formatted.append(offset < 0 ? '-' : '+');\n            padInt(formatted, hours, \"hh\".length());\n            formatted.append(':');\n            padInt(formatted, minutes, \"mm\".length());\n        } else {\n            formatted.append('Z');\n        }\n\n        return formatted.toString();\n    }\n\n    /*\n    /**********************************************************\n    /* Parsing\n    /**********************************************************\n     */\n\n    /**\n     * Parse a date from ISO-8601 formatted string. It expects a format\n     * [yyyy-MM-dd|yyyyMMdd][T(hh:mm[:ss[.sss]]|hhmm[ss[.sss]])]?[Z|[+-]hh[:mm]]]\n     * \n     * @param date ISO string to parse in the appropriate format.\n     * @param pos The position to start parsing from, updated to where parsing stopped.\n     * @return the parsed date\n     * @throws ParseException if the date is not in the appropriate format\n     */\n    public static Date parse(String date, ParsePosition pos) throws ParseException {\n        Exception fail = null;\n        try {\n            int offset = pos.getIndex();\n\n            // extract year\n            int year = parseInt(date, offset, offset += 4);\n            if (checkOffset(date, offset, '-')) {\n                offset += 1;\n            }\n\n            // extract month\n            int month = parseInt(date, offset, offset += 2);\n            if (checkOffset(date, offset, '-')) {\n                offset += 1;\n            }\n\n            // extract day\n            int day = parseInt(date, offset, offset += 2);\n            // default time value\n            int hour = 0;\n            int minutes = 0;\n            int seconds = 0;\n            int milliseconds = 0; // always use 0 otherwise returned date will include millis of current time\n\n            // if the value has no time component (and no time zone), we are done\n            boolean hasT = checkOffset(date, offset, 'T');\n            \n            if (!hasT && (date.length() <= offset)) {\n                Calendar calendar = new GregorianCalendar(year, month - 1, day);\n\n                pos.setIndex(offset);\n                return calendar.getTime();\n            }\n\n            if (hasT) {\n\n                // extract hours, minutes, seconds and milliseconds\n                hour = parseInt(date, offset += 1, offset += 2);\n                if (checkOffset(date, offset, ':')) {\n                    offset += 1;\n                }\n\n                minutes = parseInt(date, offset, offset += 2);\n                if (checkOffset(date, offset, ':')) {\n                    offset += 1;\n                }\n                // second and milliseconds can be optional\n                if (date.length() > offset) {\n                    char c = date.charAt(offset);\n                    if (c != 'Z' && c != '+' && c != '-') {\n                        seconds = parseInt(date, offset, offset += 2);\n                        if (seconds > 59 && seconds < 63) seconds = 59; // truncate up to 3 leap seconds\n                        // milliseconds can be optional in the format\n                        if (checkOffset(date, offset, '.')) {\n                            offset += 1;\n                            int endOffset = indexOfNonDigit(date, offset + 1); // assume at least one digit\n                            int parseEndOffset = Math.min(endOffset, offset + 3); // parse up to 3 digits\n                            int fraction = parseInt(date, offset, parseEndOffset);\n                            // compensate for \"missing\" digits\n                            switch (parseEndOffset - offset) { // number of digits parsed\n                            case 2:\n                                milliseconds = fraction * 10;\n                                break;\n                            case 1:\n                                milliseconds = fraction * 100;\n                                break;\n                            default:\n                                milliseconds = fraction;\n                            }\n                            offset = endOffset;\n                        }\n                    }\n                }\n            }\n\n            // extract timezone\n            if (date.length() <= offset) {\n                throw new IllegalArgumentException(\"No time zone indicator\");\n            }\n\n            TimeZone timezone = null;\n            char timezoneIndicator = date.charAt(offset);\n\n            if (timezoneIndicator == 'Z') {\n                timezone = TIMEZONE_UTC;\n                offset += 1;\n            } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n                String timezoneOffset = date.substring(offset);\n\n                // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00\n                timezoneOffset = timezoneOffset.length() >= 5 ? timezoneOffset : timezoneOffset + \"00\";\n\n                offset += timezoneOffset.length();\n                // 18-Jun-2015, tatu: Minor simplification, skip offset of \"+0000\"/\"+00:00\"\n                if (\"+0000\".equals(timezoneOffset) || \"+00:00\".equals(timezoneOffset)) {\n                    timezone = TIMEZONE_UTC;\n                } else {\n                    // 18-Jun-2015, tatu: Looks like offsets only work from GMT, not UTC...\n                    //    not sure why, but that's the way it looks. Further, Javadocs for\n                    //    `java.util.TimeZone` specifically instruct use of GMT as base for\n                    //    custom timezones... odd.\n                    String timezoneId = \"GMT\" + timezoneOffset;\n//                    String timezoneId = \"UTC\" + timezoneOffset;\n\n                    timezone = TimeZone.getTimeZone(timezoneId);\n\n                    String act = timezone.getID();\n                    if (!act.equals(timezoneId)) {\n                        /* 22-Jan-2015, tatu: Looks like canonical version has colons, but we may be given\n                         *    one without. If so, don't sweat.\n                         *   Yes, very inefficient. Hopefully not hit often.\n                         *   If it becomes a perf problem, add 'loose' comparison instead.\n                         */\n                        String cleaned = act.replace(\":\", \"\");\n                        if (!cleaned.equals(timezoneId)) {\n                            throw new IndexOutOfBoundsException(\"Mismatching time zone indicator: \"+timezoneId+\" given, resolves to \"\n                                    +timezone.getID());\n                        }\n                    }\n                }\n            } else {\n                throw new IndexOutOfBoundsException(\"Invalid time zone indicator '\" + timezoneIndicator+\"'\");\n            }\n\n            Calendar calendar = new GregorianCalendar(timezone);\n            calendar.setLenient(false);\n            calendar.set(Calendar.YEAR, year);\n            calendar.set(Calendar.MONTH, month - 1);\n            calendar.set(Calendar.DAY_OF_MONTH, day);\n            calendar.set(Calendar.HOUR_OF_DAY, hour);\n            calendar.set(Calendar.MINUTE, minutes);\n            calendar.set(Calendar.SECOND, seconds);\n            calendar.set(Calendar.MILLISECOND, milliseconds);\n\n            pos.setIndex(offset);\n            return calendar.getTime();\n            // If we get a ParseException it'll already have the right message/offset.\n            // Other exception types can convert here.\n        } catch (IndexOutOfBoundsException e) {\n            fail = e;\n        } catch (NumberFormatException e) {\n            fail = e;\n        } catch (IllegalArgumentException e) {\n            fail = e;\n        }\n        String input = (date == null) ? null : ('\"' + date + \"'\");\n        String msg = fail.getMessage();\n        if (msg == null || msg.isEmpty()) {\n            msg = \"(\"+fail.getClass().getName()+\")\";\n        }\n        ParseException ex = new ParseException(\"Failed to parse date [\" + input + \"]: \" + msg, pos.getIndex());\n        ex.initCause(fail);\n        throw ex;\n    }\n\n    /**\n     * Check if the expected character exist at the given offset in the value.\n     * \n     * @param value the string to check at the specified offset\n     * @param offset the offset to look for the expected character\n     * @param expected the expected character\n     * @return true if the expected character exist at the given offset\n     */\n    private static boolean checkOffset(String value, int offset, char expected) {\n        return (offset < value.length()) && (value.charAt(offset) == expected);\n    }\n\n    /**\n     * Parse an integer located between 2 given offsets in a string\n     * \n     * @param value the string to parse\n     * @param beginIndex the start index for the integer in the string\n     * @param endIndex the end index for the integer in the string\n     * @return the int\n     * @throws NumberFormatException if the value is not a number\n     */\n    private static int parseInt(String value, int beginIndex, int endIndex) throws NumberFormatException {\n        if (beginIndex < 0 || endIndex > value.length() || beginIndex > endIndex) {\n            throw new NumberFormatException(value);\n        }\n        // use same logic as in Integer.parseInt() but less generic we're not supporting negative values\n        int i = beginIndex;\n        int result = 0;\n        int digit;\n        if (i < endIndex) {\n            digit = Character.digit(value.charAt(i++), 10);\n            if (digit < 0) {\n                throw new NumberFormatException(\"Invalid number: \" + value.substring(beginIndex, endIndex));\n            }\n            result = -digit;\n        }\n        while (i < endIndex) {\n            digit = Character.digit(value.charAt(i++), 10);\n            if (digit < 0) {\n                throw new NumberFormatException(\"Invalid number: \" + value.substring(beginIndex, endIndex));\n            }\n            result *= 10;\n            result -= digit;\n        }\n        return -result;\n    }\n\n    /**\n     * Zero pad a number to a specified length\n     * \n     * @param buffer buffer to use for padding\n     * @param value the integer value to pad if necessary.\n     * @param length the length of the string we should zero pad\n     */\n    private static void padInt(StringBuilder buffer, int value, int length) {\n        String strValue = Integer.toString(value);\n        for (int i = length - strValue.length(); i > 0; i--) {\n            buffer.append('0');\n        }\n        buffer.append(strValue);\n    }\n\n    /**\n     * Returns the index of the first character in the string that is not a digit, starting at offset.\n     */\n    private static int indexOfNonDigit(String string, int offset) {\n        for (int i = offset; i < string.length(); i++) {\n            char c = string.charAt(i);\n            if (c < '0' || c > '9') return i;\n        }\n        return string.length();\n    }\n\n}\n"}]}
{"project": "Gson", "bug_id": 6, "classes_modified": [{"class_name": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory", "buggy_version": "/*\n * Copyright (C) 2014 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.gson.internal.bind;\n\nimport com.google.gson.Gson;\nimport com.google.gson.TypeAdapter;\nimport com.google.gson.TypeAdapterFactory;\nimport com.google.gson.annotations.JsonAdapter;\nimport com.google.gson.internal.ConstructorConstructor;\nimport com.google.gson.reflect.TypeToken;\n\n/**\n * Given a type T, looks for the annotation {@link JsonAdapter} and uses an instance of the\n * specified class as the default type adapter.\n *\n * @since 2.3\n */\npublic final class JsonAdapterAnnotationTypeAdapterFactory implements TypeAdapterFactory {\n\n  private final ConstructorConstructor constructorConstructor;\n\n  public JsonAdapterAnnotationTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\n    this.constructorConstructor = constructorConstructor;\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  @Override\n  public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> targetType) {\n    JsonAdapter annotation = targetType.getRawType().getAnnotation(JsonAdapter.class);\n    if (annotation == null) {\n      return null;\n    }\n    return (TypeAdapter<T>) getTypeAdapter(constructorConstructor, gson, targetType, annotation);\n  }\n\n  @SuppressWarnings(\"unchecked\") // Casts guarded by conditionals.\n  static TypeAdapter<?> getTypeAdapter(ConstructorConstructor constructorConstructor, Gson gson,\n      TypeToken<?> fieldType, JsonAdapter annotation) {\n    Class<?> value = annotation.value();\n    TypeAdapter<?> typeAdapter;\n    if (TypeAdapter.class.isAssignableFrom(value)) {\n      Class<TypeAdapter<?>> typeAdapterClass = (Class<TypeAdapter<?>>) value;\n      typeAdapter = constructorConstructor.get(TypeToken.get(typeAdapterClass)).construct();\n    } else if (TypeAdapterFactory.class.isAssignableFrom(value)) {\n      Class<TypeAdapterFactory> typeAdapterFactory = (Class<TypeAdapterFactory>) value;\n      typeAdapter = constructorConstructor.get(TypeToken.get(typeAdapterFactory))\n          .construct()\n          .create(gson, fieldType);\n    } else {\n      throw new IllegalArgumentException(\n          \"@JsonAdapter value must be TypeAdapter or TypeAdapterFactory reference.\");\n    }\n      typeAdapter = typeAdapter.nullSafe();\n    return typeAdapter;\n  }\n}\n", "fixed_version": "/*\n * Copyright (C) 2014 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.gson.internal.bind;\n\nimport com.google.gson.Gson;\nimport com.google.gson.TypeAdapter;\nimport com.google.gson.TypeAdapterFactory;\nimport com.google.gson.annotations.JsonAdapter;\nimport com.google.gson.internal.ConstructorConstructor;\nimport com.google.gson.reflect.TypeToken;\n\n/**\n * Given a type T, looks for the annotation {@link JsonAdapter} and uses an instance of the\n * specified class as the default type adapter.\n *\n * @since 2.3\n */\npublic final class JsonAdapterAnnotationTypeAdapterFactory implements TypeAdapterFactory {\n\n  private final ConstructorConstructor constructorConstructor;\n\n  public JsonAdapterAnnotationTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\n    this.constructorConstructor = constructorConstructor;\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  @Override\n  public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> targetType) {\n    JsonAdapter annotation = targetType.getRawType().getAnnotation(JsonAdapter.class);\n    if (annotation == null) {\n      return null;\n    }\n    return (TypeAdapter<T>) getTypeAdapter(constructorConstructor, gson, targetType, annotation);\n  }\n\n  @SuppressWarnings(\"unchecked\") // Casts guarded by conditionals.\n  static TypeAdapter<?> getTypeAdapter(ConstructorConstructor constructorConstructor, Gson gson,\n      TypeToken<?> fieldType, JsonAdapter annotation) {\n    Class<?> value = annotation.value();\n    TypeAdapter<?> typeAdapter;\n    if (TypeAdapter.class.isAssignableFrom(value)) {\n      Class<TypeAdapter<?>> typeAdapterClass = (Class<TypeAdapter<?>>) value;\n      typeAdapter = constructorConstructor.get(TypeToken.get(typeAdapterClass)).construct();\n    } else if (TypeAdapterFactory.class.isAssignableFrom(value)) {\n      Class<TypeAdapterFactory> typeAdapterFactory = (Class<TypeAdapterFactory>) value;\n      typeAdapter = constructorConstructor.get(TypeToken.get(typeAdapterFactory))\n          .construct()\n          .create(gson, fieldType);\n    } else {\n      throw new IllegalArgumentException(\n          \"@JsonAdapter value must be TypeAdapter or TypeAdapterFactory reference.\");\n    }\n    if (typeAdapter != null) {\n      typeAdapter = typeAdapter.nullSafe();\n    }\n    return typeAdapter;\n  }\n}\n"}]}
{"project": "Gson", "bug_id": 7, "classes_modified": [{"class_name": "com.google.gson.stream.JsonReader", "buggy_version": "/*\n * Copyright (C) 2010 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.gson.stream;\n\nimport com.google.gson.internal.JsonReaderInternalAccess;\nimport com.google.gson.internal.bind.JsonTreeReader;\nimport java.io.Closeable;\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.io.Reader;\n\n/**\n * Reads a JSON (<a href=\"http://www.ietf.org/rfc/rfc7159.txt\">RFC 7159</a>)\n * encoded value as a stream of tokens. This stream includes both literal\n * values (strings, numbers, booleans, and nulls) as well as the begin and\n * end delimiters of objects and arrays. The tokens are traversed in\n * depth-first order, the same order that they appear in the JSON document.\n * Within JSON objects, name/value pairs are represented by a single token.\n *\n * <h3>Parsing JSON</h3>\n * To create a recursive descent parser for your own JSON streams, first create\n * an entry point method that creates a {@code JsonReader}.\n *\n * <p>Next, create handler methods for each structure in your JSON text. You'll\n * need a method for each object type and for each array type.\n * <ul>\n *   <li>Within <strong>array handling</strong> methods, first call {@link\n *       #beginArray} to consume the array's opening bracket. Then create a\n *       while loop that accumulates values, terminating when {@link #hasNext}\n *       is false. Finally, read the array's closing bracket by calling {@link\n *       #endArray}.\n *   <li>Within <strong>object handling</strong> methods, first call {@link\n *       #beginObject} to consume the object's opening brace. Then create a\n *       while loop that assigns values to local variables based on their name.\n *       This loop should terminate when {@link #hasNext} is false. Finally,\n *       read the object's closing brace by calling {@link #endObject}.\n * </ul>\n * <p>When a nested object or array is encountered, delegate to the\n * corresponding handler method.\n *\n * <p>When an unknown name is encountered, strict parsers should fail with an\n * exception. Lenient parsers should call {@link #skipValue()} to recursively\n * skip the value's nested tokens, which may otherwise conflict.\n *\n * <p>If a value may be null, you should first check using {@link #peek()}.\n * Null literals can be consumed using either {@link #nextNull()} or {@link\n * #skipValue()}.\n *\n * <h3>Example</h3>\n * Suppose we'd like to parse a stream of messages such as the following: <pre> {@code\n * [\n *   {\n *     \"id\": 912345678901,\n *     \"text\": \"How do I read a JSON stream in Java?\",\n *     \"geo\": null,\n *     \"user\": {\n *       \"name\": \"json_newb\",\n *       \"followers_count\": 41\n *      }\n *   },\n *   {\n *     \"id\": 912345678902,\n *     \"text\": \"@json_newb just use JsonReader!\",\n *     \"geo\": [50.454722, -104.606667],\n *     \"user\": {\n *       \"name\": \"jesse\",\n *       \"followers_count\": 2\n *     }\n *   }\n * ]}</pre>\n * This code implements the parser for the above structure: <pre>   {@code\n *\n *   public List<Message> readJsonStream(InputStream in) throws IOException {\n *     JsonReader reader = new JsonReader(new InputStreamReader(in, \"UTF-8\"));\n *     try {\n *       return readMessagesArray(reader);\n *     } finally {\n *       reader.close();\n *     }\n *   }\n *\n *   public List<Message> readMessagesArray(JsonReader reader) throws IOException {\n *     List<Message> messages = new ArrayList<Message>();\n *\n *     reader.beginArray();\n *     while (reader.hasNext()) {\n *       messages.add(readMessage(reader));\n *     }\n *     reader.endArray();\n *     return messages;\n *   }\n *\n *   public Message readMessage(JsonReader reader) throws IOException {\n *     long id = -1;\n *     String text = null;\n *     User user = null;\n *     List<Double> geo = null;\n *\n *     reader.beginObject();\n *     while (reader.hasNext()) {\n *       String name = reader.nextName();\n *       if (name.equals(\"id\")) {\n *         id = reader.nextLong();\n *       } else if (name.equals(\"text\")) {\n *         text = reader.nextString();\n *       } else if (name.equals(\"geo\") && reader.peek() != JsonToken.NULL) {\n *         geo = readDoublesArray(reader);\n *       } else if (name.equals(\"user\")) {\n *         user = readUser(reader);\n *       } else {\n *         reader.skipValue();\n *       }\n *     }\n *     reader.endObject();\n *     return new Message(id, text, user, geo);\n *   }\n *\n *   public List<Double> readDoublesArray(JsonReader reader) throws IOException {\n *     List<Double> doubles = new ArrayList<Double>();\n *\n *     reader.beginArray();\n *     while (reader.hasNext()) {\n *       doubles.add(reader.nextDouble());\n *     }\n *     reader.endArray();\n *     return doubles;\n *   }\n *\n *   public User readUser(JsonReader reader) throws IOException {\n *     String username = null;\n *     int followersCount = -1;\n *\n *     reader.beginObject();\n *     while (reader.hasNext()) {\n *       String name = reader.nextName();\n *       if (name.equals(\"name\")) {\n *         username = reader.nextString();\n *       } else if (name.equals(\"followers_count\")) {\n *         followersCount = reader.nextInt();\n *       } else {\n *         reader.skipValue();\n *       }\n *     }\n *     reader.endObject();\n *     return new User(username, followersCount);\n *   }}</pre>\n *\n * <h3>Number Handling</h3>\n * This reader permits numeric values to be read as strings and string values to\n * be read as numbers. For example, both elements of the JSON array {@code\n * [1, \"1\"]} may be read using either {@link #nextInt} or {@link #nextString}.\n * This behavior is intended to prevent lossy numeric conversions: double is\n * JavaScript's only numeric type and very large values like {@code\n * 9007199254740993} cannot be represented exactly on that platform. To minimize\n * precision loss, extremely large values should be written and read as strings\n * in JSON.\n *\n * <a name=\"nonexecuteprefix\"/><h3>Non-Execute Prefix</h3>\n * Web servers that serve private data using JSON may be vulnerable to <a\n * href=\"http://en.wikipedia.org/wiki/JSON#Cross-site_request_forgery\">Cross-site\n * request forgery</a> attacks. In such an attack, a malicious site gains access\n * to a private JSON file by executing it with an HTML {@code <script>} tag.\n *\n * <p>Prefixing JSON files with <code>\")]}'\\n\"</code> makes them non-executable\n * by {@code <script>} tags, disarming the attack. Since the prefix is malformed\n * JSON, strict parsing fails when it is encountered. This class permits the\n * non-execute prefix when {@link #setLenient(boolean) lenient parsing} is\n * enabled.\n *\n * <p>Each {@code JsonReader} may be used to read a single JSON stream. Instances\n * of this class are not thread safe.\n *\n * @author Jesse Wilson\n * @since 1.6\n */\npublic class JsonReader implements Closeable {\n  /** The only non-execute prefix this parser permits */\n  private static final char[] NON_EXECUTE_PREFIX = \")]}'\\n\".toCharArray();\n  private static final long MIN_INCOMPLETE_INTEGER = Long.MIN_VALUE / 10;\n\n  private static final int PEEKED_NONE = 0;\n  private static final int PEEKED_BEGIN_OBJECT = 1;\n  private static final int PEEKED_END_OBJECT = 2;\n  private static final int PEEKED_BEGIN_ARRAY = 3;\n  private static final int PEEKED_END_ARRAY = 4;\n  private static final int PEEKED_TRUE = 5;\n  private static final int PEEKED_FALSE = 6;\n  private static final int PEEKED_NULL = 7;\n  private static final int PEEKED_SINGLE_QUOTED = 8;\n  private static final int PEEKED_DOUBLE_QUOTED = 9;\n  private static final int PEEKED_UNQUOTED = 10;\n  /** When this is returned, the string value is stored in peekedString. */\n  private static final int PEEKED_BUFFERED = 11;\n  private static final int PEEKED_SINGLE_QUOTED_NAME = 12;\n  private static final int PEEKED_DOUBLE_QUOTED_NAME = 13;\n  private static final int PEEKED_UNQUOTED_NAME = 14;\n  /** When this is returned, the integer value is stored in peekedLong. */\n  private static final int PEEKED_LONG = 15;\n  private static final int PEEKED_NUMBER = 16;\n  private static final int PEEKED_EOF = 17;\n\n  /* State machine when parsing numbers */\n  private static final int NUMBER_CHAR_NONE = 0;\n  private static final int NUMBER_CHAR_SIGN = 1;\n  private static final int NUMBER_CHAR_DIGIT = 2;\n  private static final int NUMBER_CHAR_DECIMAL = 3;\n  private static final int NUMBER_CHAR_FRACTION_DIGIT = 4;\n  private static final int NUMBER_CHAR_EXP_E = 5;\n  private static final int NUMBER_CHAR_EXP_SIGN = 6;\n  private static final int NUMBER_CHAR_EXP_DIGIT = 7;\n\n  /** The input JSON. */\n  private final Reader in;\n\n  /** True to accept non-spec compliant JSON */\n  private boolean lenient = false;\n\n  /**\n   * Use a manual buffer to easily read and unread upcoming characters, and\n   * also so we can create strings without an intermediate StringBuilder.\n   * We decode literals directly out of this buffer, so it must be at least as\n   * long as the longest token that can be reported as a number.\n   */\n  private final char[] buffer = new char[1024];\n  private int pos = 0;\n  private int limit = 0;\n\n  private int lineNumber = 0;\n  private int lineStart = 0;\n\n  int peeked = PEEKED_NONE;\n\n  /**\n   * A peeked value that was composed entirely of digits with an optional\n   * leading dash. Positive values may not have a leading 0.\n   */\n  private long peekedLong;\n\n  /**\n   * The number of characters in a peeked number literal. Increment 'pos' by\n   * this after reading a number.\n   */\n  private int peekedNumberLength;\n\n  /**\n   * A peeked string that should be parsed on the next double, long or string.\n   * This is populated before a numeric value is parsed and used if that parsing\n   * fails.\n   */\n  private String peekedString;\n\n  /*\n   * The nesting stack. Using a manual array rather than an ArrayList saves 20%.\n   */\n  private int[] stack = new int[32];\n  private int stackSize = 0;\n  {\n    stack[stackSize++] = JsonScope.EMPTY_DOCUMENT;\n  }\n\n  /*\n   * The path members. It corresponds directly to stack: At indices where the\n   * stack contains an object (EMPTY_OBJECT, DANGLING_NAME or NONEMPTY_OBJECT),\n   * pathNames contains the name at this scope. Where it contains an array\n   * (EMPTY_ARRAY, NONEMPTY_ARRAY) pathIndices contains the current index in\n   * that array. Otherwise the value is undefined, and we take advantage of that\n   * by incrementing pathIndices when doing so isn't useful.\n   */\n  private String[] pathNames = new String[32];\n  private int[] pathIndices = new int[32];\n\n  /**\n   * Creates a new instance that reads a JSON-encoded stream from {@code in}.\n   */\n  public JsonReader(Reader in) {\n    if (in == null) {\n      throw new NullPointerException(\"in == null\");\n    }\n    this.in = in;\n  }\n\n  /**\n   * Configure this parser to be liberal in what it accepts. By default,\n   * this parser is strict and only accepts JSON as specified by <a\n   * href=\"http://www.ietf.org/rfc/rfc4627.txt\">RFC 4627</a>. Setting the\n   * parser to lenient causes it to ignore the following syntax errors:\n   *\n   * <ul>\n   *   <li>Streams that start with the <a href=\"#nonexecuteprefix\">non-execute\n   *       prefix</a>, <code>\")]}'\\n\"</code>.\n   *   <li>Streams that include multiple top-level values. With strict parsing,\n   *       each stream must contain exactly one top-level value.\n   *   <li>Top-level values of any type. With strict parsing, the top-level\n   *       value must be an object or an array.\n   *   <li>Numbers may be {@link Double#isNaN() NaNs} or {@link\n   *       Double#isInfinite() infinities}.\n   *   <li>End of line comments starting with {@code //} or {@code #} and\n   *       ending with a newline character.\n   *   <li>C-style comments starting with {@code /*} and ending with\n   *       {@code *}{@code /}. Such comments may not be nested.\n   *   <li>Names that are unquoted or {@code 'single quoted'}.\n   *   <li>Strings that are unquoted or {@code 'single quoted'}.\n   *   <li>Array elements separated by {@code ;} instead of {@code ,}.\n   *   <li>Unnecessary array separators. These are interpreted as if null\n   *       was the omitted value.\n   *   <li>Names and values separated by {@code =} or {@code =>} instead of\n   *       {@code :}.\n   *   <li>Name/value pairs separated by {@code ;} instead of {@code ,}.\n   * </ul>\n   */\n  public final void setLenient(boolean lenient) {\n    this.lenient = lenient;\n  }\n\n  /**\n   * Returns true if this parser is liberal in what it accepts.\n   */\n  public final boolean isLenient() {\n    return lenient;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is the\n   * beginning of a new array.\n   */\n  public void beginArray() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_BEGIN_ARRAY) {\n      push(JsonScope.EMPTY_ARRAY);\n      pathIndices[stackSize - 1] = 0;\n      peeked = PEEKED_NONE;\n    } else {\n      throw new IllegalStateException(\"Expected BEGIN_ARRAY but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is the\n   * end of the current array.\n   */\n  public void endArray() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_END_ARRAY) {\n      stackSize--;\n      pathIndices[stackSize - 1]++;\n      peeked = PEEKED_NONE;\n    } else {\n      throw new IllegalStateException(\"Expected END_ARRAY but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is the\n   * beginning of a new object.\n   */\n  public void beginObject() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_BEGIN_OBJECT) {\n      push(JsonScope.EMPTY_OBJECT);\n      peeked = PEEKED_NONE;\n    } else {\n      throw new IllegalStateException(\"Expected BEGIN_OBJECT but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is the\n   * end of the current object.\n   */\n  public void endObject() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_END_OBJECT) {\n      stackSize--;\n      pathNames[stackSize] = null; // Free the last path name so that it can be garbage collected!\n      pathIndices[stackSize - 1]++;\n      peeked = PEEKED_NONE;\n    } else {\n      throw new IllegalStateException(\"Expected END_OBJECT but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n  }\n\n  /**\n   * Returns true if the current array or object has another element.\n   */\n  public boolean hasNext() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    return p != PEEKED_END_OBJECT && p != PEEKED_END_ARRAY;\n  }\n\n  /**\n   * Returns the type of the next token without consuming it.\n   */\n  public JsonToken peek() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    switch (p) {\n    case PEEKED_BEGIN_OBJECT:\n      return JsonToken.BEGIN_OBJECT;\n    case PEEKED_END_OBJECT:\n      return JsonToken.END_OBJECT;\n    case PEEKED_BEGIN_ARRAY:\n      return JsonToken.BEGIN_ARRAY;\n    case PEEKED_END_ARRAY:\n      return JsonToken.END_ARRAY;\n    case PEEKED_SINGLE_QUOTED_NAME:\n    case PEEKED_DOUBLE_QUOTED_NAME:\n    case PEEKED_UNQUOTED_NAME:\n      return JsonToken.NAME;\n    case PEEKED_TRUE:\n    case PEEKED_FALSE:\n      return JsonToken.BOOLEAN;\n    case PEEKED_NULL:\n      return JsonToken.NULL;\n    case PEEKED_SINGLE_QUOTED:\n    case PEEKED_DOUBLE_QUOTED:\n    case PEEKED_UNQUOTED:\n    case PEEKED_BUFFERED:\n      return JsonToken.STRING;\n    case PEEKED_LONG:\n    case PEEKED_NUMBER:\n      return JsonToken.NUMBER;\n    case PEEKED_EOF:\n      return JsonToken.END_DOCUMENT;\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  int doPeek() throws IOException {\n    int peekStack = stack[stackSize - 1];\n    if (peekStack == JsonScope.EMPTY_ARRAY) {\n      stack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY;\n    } else if (peekStack == JsonScope.NONEMPTY_ARRAY) {\n      // Look for a comma before the next element.\n      int c = nextNonWhitespace(true);\n      switch (c) {\n      case ']':\n        return peeked = PEEKED_END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    } else if (peekStack == JsonScope.EMPTY_OBJECT || peekStack == JsonScope.NONEMPTY_OBJECT) {\n      stack[stackSize - 1] = JsonScope.DANGLING_NAME;\n      // Look for a comma before the next element.\n      if (peekStack == JsonScope.NONEMPTY_OBJECT) {\n        int c = nextNonWhitespace(true);\n        switch (c) {\n        case '}':\n          return peeked = PEEKED_END_OBJECT;\n        case ';':\n          checkLenient(); // fall-through\n        case ',':\n          break;\n        default:\n          throw syntaxError(\"Unterminated object\");\n        }\n      }\n      int c = nextNonWhitespace(true);\n      switch (c) {\n      case '\"':\n        return peeked = PEEKED_DOUBLE_QUOTED_NAME;\n      case '\\'':\n        checkLenient();\n        return peeked = PEEKED_SINGLE_QUOTED_NAME;\n      case '}':\n        if (peekStack != JsonScope.NONEMPTY_OBJECT) {\n          return peeked = PEEKED_END_OBJECT;\n        } else {\n          throw syntaxError(\"Expected name\");\n        }\n      default:\n        checkLenient();\n        pos--; // Don't consume the first character in an unquoted string.\n        if (isLiteral((char) c)) {\n          return peeked = PEEKED_UNQUOTED_NAME;\n        } else {\n          throw syntaxError(\"Expected name\");\n        }\n      }\n    } else if (peekStack == JsonScope.DANGLING_NAME) {\n      stack[stackSize - 1] = JsonScope.NONEMPTY_OBJECT;\n      // Look for a colon before the value.\n      int c = nextNonWhitespace(true);\n      switch (c) {\n      case ':':\n        break;\n      case '=':\n        checkLenient();\n        if ((pos < limit || fillBuffer(1)) && buffer[pos] == '>') {\n          pos++;\n        }\n        break;\n      default:\n        throw syntaxError(\"Expected ':'\");\n      }\n    } else if (peekStack == JsonScope.EMPTY_DOCUMENT) {\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      stack[stackSize - 1] = JsonScope.NONEMPTY_DOCUMENT;\n    } else if (peekStack == JsonScope.NONEMPTY_DOCUMENT) {\n      int c = nextNonWhitespace(false);\n      if (c == -1) {\n        return peeked = PEEKED_EOF;\n      } else {\n        checkLenient();\n        pos--;\n      }\n    } else if (peekStack == JsonScope.CLOSED) {\n      throw new IllegalStateException(\"JsonReader is closed\");\n    }\n\n    int c = nextNonWhitespace(true);\n    switch (c) {\n    case ']':\n      if (peekStack == JsonScope.EMPTY_ARRAY) {\n        return peeked = PEEKED_END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      // In lenient mode, a 0-length literal in an array means 'null'.\n      if (peekStack == JsonScope.EMPTY_ARRAY || peekStack == JsonScope.NONEMPTY_ARRAY) {\n        checkLenient();\n        pos--;\n        return peeked = PEEKED_NULL;\n      } else {\n        throw syntaxError(\"Unexpected value\");\n      }\n    case '\\'':\n      checkLenient();\n      return peeked = PEEKED_SINGLE_QUOTED;\n    case '\"':\n      return peeked = PEEKED_DOUBLE_QUOTED;\n    case '[':\n      return peeked = PEEKED_BEGIN_ARRAY;\n    case '{':\n      return peeked = PEEKED_BEGIN_OBJECT;\n    default:\n      pos--; // Don't consume the first character in a literal value.\n    }\n\n    int result = peekKeyword();\n    if (result != PEEKED_NONE) {\n      return result;\n    }\n\n    result = peekNumber();\n    if (result != PEEKED_NONE) {\n      return result;\n    }\n\n    if (!isLiteral(buffer[pos])) {\n      throw syntaxError(\"Expected value\");\n    }\n\n    checkLenient();\n    return peeked = PEEKED_UNQUOTED;\n  }\n\n  private int peekKeyword() throws IOException {\n    // Figure out which keyword we're matching against by its first character.\n    char c = buffer[pos];\n    String keyword;\n    String keywordUpper;\n    int peeking;\n    if (c == 't' || c == 'T') {\n      keyword = \"true\";\n      keywordUpper = \"TRUE\";\n      peeking = PEEKED_TRUE;\n    } else if (c == 'f' || c == 'F') {\n      keyword = \"false\";\n      keywordUpper = \"FALSE\";\n      peeking = PEEKED_FALSE;\n    } else if (c == 'n' || c == 'N') {\n      keyword = \"null\";\n      keywordUpper = \"NULL\";\n      peeking = PEEKED_NULL;\n    } else {\n      return PEEKED_NONE;\n    }\n\n    // Confirm that chars [1..length) match the keyword.\n    int length = keyword.length();\n    for (int i = 1; i < length; i++) {\n      if (pos + i >= limit && !fillBuffer(i + 1)) {\n        return PEEKED_NONE;\n      }\n      c = buffer[pos + i];\n      if (c != keyword.charAt(i) && c != keywordUpper.charAt(i)) {\n        return PEEKED_NONE;\n      }\n    }\n\n    if ((pos + length < limit || fillBuffer(length + 1))\n        && isLiteral(buffer[pos + length])) {\n      return PEEKED_NONE; // Don't match trues, falsey or nullsoft!\n    }\n\n    // We've found the keyword followed either by EOF or by a non-literal character.\n    pos += length;\n    return peeked = peeking;\n  }\n\n  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }\n\n  private boolean isLiteral(char c) throws IOException {\n    switch (c) {\n    case '/':\n    case '\\\\':\n    case ';':\n    case '#':\n    case '=':\n      checkLenient(); // fall-through\n    case '{':\n    case '}':\n    case '[':\n    case ']':\n    case ':':\n    case ',':\n    case ' ':\n    case '\\t':\n    case '\\f':\n    case '\\r':\n    case '\\n':\n      return false;\n    default:\n      return true;\n    }\n  }\n\n  /**\n   * Returns the next token, a {@link com.google.gson.stream.JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws java.io.IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      result = nextQuotedValue('\"');\n    } else {\n      throw new IllegalStateException(\"Expected a name but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n    peeked = PEEKED_NONE;\n    pathNames[stackSize - 1] = result;\n    return result;\n  }\n\n  /**\n   * Returns the {@link com.google.gson.stream.JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n      result = nextQuotedValue('\"');\n    } else if (p == PEEKED_BUFFERED) {\n      result = peekedString;\n      peekedString = null;\n    } else if (p == PEEKED_LONG) {\n      result = Long.toString(peekedLong);\n    } else if (p == PEEKED_NUMBER) {\n      result = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }\n\n  /**\n   * Returns the {@link com.google.gson.stream.JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    }\n    throw new IllegalStateException(\"Expected a boolean but was \" + peek()\n        + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_NULL) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n    } else {\n      throw new IllegalStateException(\"Expected null but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n  }\n\n  /**\n   * Returns the {@link com.google.gson.stream.JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double using {@link Double#parseDouble(String)}.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    if (p == PEEKED_LONG) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return (double) peekedLong;\n    }\n\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    } else if (p == PEEKED_UNQUOTED) {\n      peekedString = nextUnquotedValue();\n    } else if (p != PEEKED_BUFFERED) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double result = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new MalformedJsonException(\"JSON forbids NaN and infinities: \" + result\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }\n\n  /**\n   * Returns the {@link com.google.gson.stream.JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    if (p == PEEKED_LONG) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return peekedLong;\n    }\n\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      try {\n        long result = Long.parseLong(peekedString);\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n      } catch (NumberFormatException ignored) {\n        // Fall back to parse as a double below.\n      }\n    } else {\n      throw new IllegalStateException(\"Expected a long but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    long result = (long) asDouble;\n    if (result != asDouble) { // Make sure no precision was lost casting to 'long'.\n      throw new NumberFormatException(\"Expected a long but was \" + peekedString\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }\n\n  /**\n   * Returns the string up to but not including {@code quote}, unescaping any\n   * character escape sequences encountered along the way. The opening quote\n   * should have already been read. This consumes the closing quote, but does\n   * not include it in the returned string.\n   *\n   * @param quote either ' or \".\n   * @throws NumberFormatException if any unicode escape sequences are\n   *     malformed.\n   */\n  private String nextQuotedValue(char quote) throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    StringBuilder builder = new StringBuilder();\n    while (true) {\n      int p = pos;\n      int l = limit;\n      /* the index of the first character not yet appended to the builder. */\n      int start = p;\n      while (p < l) {\n        int c = buffer[p++];\n\n        if (c == quote) {\n          pos = p;\n          builder.append(buffer, start, p - start - 1);\n          return builder.toString();\n        } else if (c == '\\\\') {\n          pos = p;\n          builder.append(buffer, start, p - start - 1);\n          builder.append(readEscapeCharacter());\n          p = pos;\n          l = limit;\n          start = p;\n        } else if (c == '\\n') {\n          lineNumber++;\n          lineStart = p;\n        }\n      }\n\n      builder.append(buffer, start, p - start);\n      pos = p;\n      if (!fillBuffer(1)) {\n        throw syntaxError(\"Unterminated string\");\n      }\n    }\n  }\n\n  /**\n   * Returns an unquoted value as a string.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private String nextUnquotedValue() throws IOException {\n    StringBuilder builder = null;\n    int i = 0;\n\n    findNonLiteralCharacter:\n    while (true) {\n      for (; pos + i < limit; i++) {\n        switch (buffer[pos + i]) {\n        case '/':\n        case '\\\\':\n        case ';':\n        case '#':\n        case '=':\n          checkLenient(); // fall-through\n        case '{':\n        case '}':\n        case '[':\n        case ']':\n        case ':':\n        case ',':\n        case ' ':\n        case '\\t':\n        case '\\f':\n        case '\\r':\n        case '\\n':\n          break findNonLiteralCharacter;\n        }\n      }\n\n      // Attempt to load the entire literal into the buffer at once.\n      if (i < buffer.length) {\n        if (fillBuffer(i + 1)) {\n          continue;\n        } else {\n          break;\n        }\n      }\n\n      // use a StringBuilder when the value is too long. This is too long to be a number!\n      if (builder == null) {\n        builder = new StringBuilder();\n      }\n      builder.append(buffer, pos, i);\n      pos += i;\n      i = 0;\n      if (!fillBuffer(1)) {\n        break;\n      }\n    }\n\n    String result;\n    if (builder == null) {\n      result = new String(buffer, pos, i);\n    } else {\n      builder.append(buffer, pos, i);\n      result = builder.toString();\n    }\n    pos += i;\n    return result;\n  }\n\n  private void skipQuotedValue(char quote) throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    do {\n      int p = pos;\n      int l = limit;\n      /* the index of the first character not yet appended to the builder. */\n      while (p < l) {\n        int c = buffer[p++];\n        if (c == quote) {\n          pos = p;\n          return;\n        } else if (c == '\\\\') {\n          pos = p;\n          readEscapeCharacter();\n          p = pos;\n          l = limit;\n        } else if (c == '\\n') {\n          lineNumber++;\n          lineStart = p;\n        }\n      }\n      pos = p;\n    } while (fillBuffer(1));\n    throw syntaxError(\"Unterminated string\");\n  }\n\n  private void skipUnquotedValue() throws IOException {\n    do {\n      int i = 0;\n      for (; pos + i < limit; i++) {\n        switch (buffer[pos + i]) {\n        case '/':\n        case '\\\\':\n        case ';':\n        case '#':\n        case '=':\n          checkLenient(); // fall-through\n        case '{':\n        case '}':\n        case '[':\n        case ']':\n        case ':':\n        case ',':\n        case ' ':\n        case '\\t':\n        case '\\f':\n        case '\\r':\n        case '\\n':\n          pos += i;\n          return;\n        }\n      }\n      pos += i;\n    } while (fillBuffer(1));\n  }\n\n  /**\n   * Returns the {@link com.google.gson.stream.JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    int result;\n    if (p == PEEKED_LONG) {\n      result = (int) peekedLong;\n      if (peekedLong != result) { // Make sure no precision was lost casting to 'int'.\n        throw new NumberFormatException(\"Expected an int but was \" + peekedLong\n            + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n      }\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    }\n\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      try {\n        result = Integer.parseInt(peekedString);\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n      } catch (NumberFormatException ignored) {\n        // Fall back to parse as a double below.\n      }\n    } else {\n      throw new IllegalStateException(\"Expected an int but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    result = (int) asDouble;\n    if (result != asDouble) { // Make sure no precision was lost casting to 'int'.\n      throw new NumberFormatException(\"Expected an int but was \" + peekedString\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link java.io.Reader}.\n   */\n  public void close() throws IOException {\n    peeked = PEEKED_NONE;\n    stack[0] = JsonScope.CLOSED;\n    stackSize = 1;\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    int count = 0;\n    do {\n      int p = peeked;\n      if (p == PEEKED_NONE) {\n        p = doPeek();\n      }\n\n      if (p == PEEKED_BEGIN_ARRAY) {\n        push(JsonScope.EMPTY_ARRAY);\n        count++;\n      } else if (p == PEEKED_BEGIN_OBJECT) {\n        push(JsonScope.EMPTY_OBJECT);\n        count++;\n      } else if (p == PEEKED_END_ARRAY) {\n        stackSize--;\n        count--;\n      } else if (p == PEEKED_END_OBJECT) {\n        stackSize--;\n        count--;\n      } else if (p == PEEKED_UNQUOTED_NAME || p == PEEKED_UNQUOTED) {\n        skipUnquotedValue();\n      } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_SINGLE_QUOTED_NAME) {\n        skipQuotedValue('\\'');\n      } else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_DOUBLE_QUOTED_NAME) {\n        skipQuotedValue('\"');\n      } else if (p == PEEKED_NUMBER) {\n        pos += peekedNumberLength;\n      }\n      peeked = PEEKED_NONE;\n    } while (count != 0);\n\n    pathIndices[stackSize - 1]++;\n    pathNames[stackSize - 1] = \"null\";\n  }\n\n  private void push(int newTop) {\n    if (stackSize == stack.length) {\n      int[] newStack = new int[stackSize * 2];\n      int[] newPathIndices = new int[stackSize * 2];\n      String[] newPathNames = new String[stackSize * 2];\n      System.arraycopy(stack, 0, newStack, 0, stackSize);\n      System.arraycopy(pathIndices, 0, newPathIndices, 0, stackSize);\n      System.arraycopy(pathNames, 0, newPathNames, 0, stackSize);\n      stack = newStack;\n      pathIndices = newPathIndices;\n      pathNames = newPathNames;\n    }\n    stack[stackSize++] = newTop;\n  }\n\n  /**\n   * Returns true once {@code limit - pos >= minimum}. If the data is\n   * exhausted before that many characters are available, this returns\n   * false.\n   */\n  private boolean fillBuffer(int minimum) throws IOException {\n    char[] buffer = this.buffer;\n    lineStart -= pos;\n    if (limit != pos) {\n      limit -= pos;\n      System.arraycopy(buffer, pos, buffer, 0, limit);\n    } else {\n      limit = 0;\n    }\n\n    pos = 0;\n    int total;\n    while ((total = in.read(buffer, limit, buffer.length - limit)) != -1) {\n      limit += total;\n\n      // if this is the first read, consume an optional byte order mark (BOM) if it exists\n      if (lineNumber == 0 && lineStart == 0 && limit > 0 && buffer[0] == '\\ufeff') {\n        pos++;\n        lineStart++;\n        minimum++;\n      }\n\n      if (limit >= minimum) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  int getLineNumber() {\n    return lineNumber + 1;\n  }\n\n  int getColumnNumber() {\n    return pos - lineStart + 1;\n  }\n\n  /**\n   * Returns the next character in the stream that is neither whitespace nor a\n   * part of a comment. When this returns, the returned character is always at\n   * {@code buffer[pos-1]}; this means the caller can always push back the\n   * returned character by decrementing {@code pos}.\n   */\n  private int nextNonWhitespace(boolean throwOnEof) throws IOException {\n    /*\n     * This code uses ugly local variables 'p' and 'l' representing the 'pos'\n     * and 'limit' fields respectively. Using locals rather than fields saves\n     * a few field reads for each whitespace character in a pretty-printed\n     * document, resulting in a 5% speedup. We need to flush 'p' to its field\n     * before any (potentially indirect) call to fillBuffer() and reread both\n     * 'p' and 'l' after any (potentially indirect) call to the same method.\n     */\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n    while (true) {\n      if (p == l) {\n        pos = p;\n        if (!fillBuffer(1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      int c = buffer[p++];\n      if (c == '\\n') {\n        lineNumber++;\n        lineStart = p;\n        continue;\n      } else if (c == ' ' || c == '\\r' || c == '\\t') {\n        continue;\n      }\n\n      if (c == '/') {\n        pos = p;\n        if (p == l) {\n          pos--; // push back '/' so it's still in the buffer when this method returns\n          boolean charsLoaded = fillBuffer(2);\n          pos++; // consume the '/' again\n          if (!charsLoaded) {\n            return c;\n          }\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;\n          if (!skipTo(\"*/\")) {\n            throw syntaxError(\"Unterminated comment\");\n          }\n          p = pos + 2;\n          l = limit;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          p = pos;\n          l = limit;\n          continue;\n\n        default:\n          return c;\n        }\n      } else if (c == '#') {\n        pos = p;\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        p = pos;\n        l = limit;\n      } else {\n        pos = p;\n        return c;\n      }\n    }\n    if (throwOnEof) {\n      throw new EOFException(\"End of input\"\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n    } else {\n      return -1;\n    }\n  }\n\n  private void checkLenient() throws IOException {\n    if (!lenient) {\n      throw syntaxError(\"Use JsonReader.setLenient(true) to accept malformed JSON\");\n    }\n  }\n\n  /**\n   * Advances the position until after the next newline character. If the line\n   * is terminated by \"\\r\\n\", the '\\n' must be consumed as whitespace by the\n   * caller.\n   */\n  private void skipToEndOfLine() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      char c = buffer[pos++];\n      if (c == '\\n') {\n        lineNumber++;\n        lineStart = pos;\n        break;\n      } else if (c == '\\r') {\n        break;\n      }\n    }\n  }\n\n  /**\n   * @param toFind a string to search for. Must not contain a newline.\n   */\n  private boolean skipTo(String toFind) throws IOException {\n    outer:\n    for (; pos + toFind.length() <= limit || fillBuffer(toFind.length()); pos++) {\n      if (buffer[pos] == '\\n') {\n        lineNumber++;\n        lineStart = pos + 1;\n        continue;\n      }\n      for (int c = 0; c < toFind.length(); c++) {\n        if (buffer[pos + c] != toFind.charAt(c)) {\n          continue outer;\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n\n  @Override public String toString() {\n    return getClass().getSimpleName()\n        + \" at line \" + getLineNumber() + \" column \" + getColumnNumber();\n  }\n\n  /**\n   * Returns a <a href=\"http://goessner.net/articles/JsonPath/\">JsonPath</a> to\n   * the current location in the JSON value.\n   */\n  public String getPath() {\n    StringBuilder result = new StringBuilder().append('$');\n    for (int i = 0, size = stackSize; i < size; i++) {\n      switch (stack[i]) {\n        case JsonScope.EMPTY_ARRAY:\n        case JsonScope.NONEMPTY_ARRAY:\n          result.append('[').append(pathIndices[i]).append(']');\n          break;\n\n        case JsonScope.EMPTY_OBJECT:\n        case JsonScope.DANGLING_NAME:\n        case JsonScope.NONEMPTY_OBJECT:\n          result.append('.');\n          if (pathNames[i] != null) {\n            result.append(pathNames[i]);\n          }\n          break;\n\n        case JsonScope.NONEMPTY_DOCUMENT:\n        case JsonScope.EMPTY_DOCUMENT:\n        case JsonScope.CLOSED:\n          break;\n      }\n    }\n    return result.toString();\n  }\n\n  /**\n   * Unescapes the character identified by the character or characters that\n   * immediately follow a backslash. The backslash '\\' should have already\n   * been read. This supports both unicode escapes \"u000A\" and two-character\n   * escapes \"\\n\".\n   *\n   * @throws NumberFormatException if any unicode escape sequences are\n   *     malformed.\n   */\n  private char readEscapeCharacter() throws IOException {\n    if (pos == limit && !fillBuffer(1)) {\n      throw syntaxError(\"Unterminated escape sequence\");\n    }\n\n    char escaped = buffer[pos++];\n    switch (escaped) {\n    case 'u':\n      if (pos + 4 > limit && !fillBuffer(4)) {\n        throw syntaxError(\"Unterminated escape sequence\");\n      }\n      // Equivalent to Integer.parseInt(stringPool.get(buffer, pos, 4), 16);\n      char result = 0;\n      for (int i = pos, end = i + 4; i < end; i++) {\n        char c = buffer[i];\n        result <<= 4;\n        if (c >= '0' && c <= '9') {\n          result += (c - '0');\n        } else if (c >= 'a' && c <= 'f') {\n          result += (c - 'a' + 10);\n        } else if (c >= 'A' && c <= 'F') {\n          result += (c - 'A' + 10);\n        } else {\n          throw new NumberFormatException(\"\\\\u\" + new String(buffer, pos, 4));\n        }\n      }\n      pos += 4;\n      return result;\n\n    case 't':\n      return '\\t';\n\n    case 'b':\n      return '\\b';\n\n    case 'n':\n      return '\\n';\n\n    case 'r':\n      return '\\r';\n\n    case 'f':\n      return '\\f';\n\n    case '\\n':\n      lineNumber++;\n      lineStart = pos;\n      // fall-through\n\n    case '\\'':\n    case '\"':\n    case '\\\\':\n    default:\n      return escaped;\n    }\n  }\n\n  /**\n   * Throws a new IO exception with the given message and a context snippet\n   * with this reader's content.\n   */\n  private IOException syntaxError(String message) throws IOException {\n    throw new MalformedJsonException(message\n        + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace(true);\n    pos--;\n\n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n\n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n\n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  static {\n    JsonReaderInternalAccess.INSTANCE = new JsonReaderInternalAccess() {\n      @Override public void promoteNameToValue(JsonReader reader) throws IOException {\n        if (reader instanceof JsonTreeReader) {\n          ((JsonTreeReader)reader).promoteNameToValue();\n          return;\n        }\n        int p = reader.peeked;\n        if (p == PEEKED_NONE) {\n          p = reader.doPeek();\n        }\n        if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n          reader.peeked = PEEKED_DOUBLE_QUOTED;\n        } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n          reader.peeked = PEEKED_SINGLE_QUOTED;\n        } else if (p == PEEKED_UNQUOTED_NAME) {\n          reader.peeked = PEEKED_UNQUOTED;\n        } else {\n          throw new IllegalStateException(\"Expected a name but was \" + reader.peek() + \" \"\n              + \" at line \" + reader.getLineNumber() + \" column \" + reader.getColumnNumber()\n              + \" path \" + reader.getPath());\n        }\n      }\n    };\n  }\n}\n", "fixed_version": "/*\n * Copyright (C) 2010 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.gson.stream;\n\nimport com.google.gson.internal.JsonReaderInternalAccess;\nimport com.google.gson.internal.bind.JsonTreeReader;\nimport java.io.Closeable;\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.io.Reader;\n\n/**\n * Reads a JSON (<a href=\"http://www.ietf.org/rfc/rfc7159.txt\">RFC 7159</a>)\n * encoded value as a stream of tokens. This stream includes both literal\n * values (strings, numbers, booleans, and nulls) as well as the begin and\n * end delimiters of objects and arrays. The tokens are traversed in\n * depth-first order, the same order that they appear in the JSON document.\n * Within JSON objects, name/value pairs are represented by a single token.\n *\n * <h3>Parsing JSON</h3>\n * To create a recursive descent parser for your own JSON streams, first create\n * an entry point method that creates a {@code JsonReader}.\n *\n * <p>Next, create handler methods for each structure in your JSON text. You'll\n * need a method for each object type and for each array type.\n * <ul>\n *   <li>Within <strong>array handling</strong> methods, first call {@link\n *       #beginArray} to consume the array's opening bracket. Then create a\n *       while loop that accumulates values, terminating when {@link #hasNext}\n *       is false. Finally, read the array's closing bracket by calling {@link\n *       #endArray}.\n *   <li>Within <strong>object handling</strong> methods, first call {@link\n *       #beginObject} to consume the object's opening brace. Then create a\n *       while loop that assigns values to local variables based on their name.\n *       This loop should terminate when {@link #hasNext} is false. Finally,\n *       read the object's closing brace by calling {@link #endObject}.\n * </ul>\n * <p>When a nested object or array is encountered, delegate to the\n * corresponding handler method.\n *\n * <p>When an unknown name is encountered, strict parsers should fail with an\n * exception. Lenient parsers should call {@link #skipValue()} to recursively\n * skip the value's nested tokens, which may otherwise conflict.\n *\n * <p>If a value may be null, you should first check using {@link #peek()}.\n * Null literals can be consumed using either {@link #nextNull()} or {@link\n * #skipValue()}.\n *\n * <h3>Example</h3>\n * Suppose we'd like to parse a stream of messages such as the following: <pre> {@code\n * [\n *   {\n *     \"id\": 912345678901,\n *     \"text\": \"How do I read a JSON stream in Java?\",\n *     \"geo\": null,\n *     \"user\": {\n *       \"name\": \"json_newb\",\n *       \"followers_count\": 41\n *      }\n *   },\n *   {\n *     \"id\": 912345678902,\n *     \"text\": \"@json_newb just use JsonReader!\",\n *     \"geo\": [50.454722, -104.606667],\n *     \"user\": {\n *       \"name\": \"jesse\",\n *       \"followers_count\": 2\n *     }\n *   }\n * ]}</pre>\n * This code implements the parser for the above structure: <pre>   {@code\n *\n *   public List<Message> readJsonStream(InputStream in) throws IOException {\n *     JsonReader reader = new JsonReader(new InputStreamReader(in, \"UTF-8\"));\n *     try {\n *       return readMessagesArray(reader);\n *     } finally {\n *       reader.close();\n *     }\n *   }\n *\n *   public List<Message> readMessagesArray(JsonReader reader) throws IOException {\n *     List<Message> messages = new ArrayList<Message>();\n *\n *     reader.beginArray();\n *     while (reader.hasNext()) {\n *       messages.add(readMessage(reader));\n *     }\n *     reader.endArray();\n *     return messages;\n *   }\n *\n *   public Message readMessage(JsonReader reader) throws IOException {\n *     long id = -1;\n *     String text = null;\n *     User user = null;\n *     List<Double> geo = null;\n *\n *     reader.beginObject();\n *     while (reader.hasNext()) {\n *       String name = reader.nextName();\n *       if (name.equals(\"id\")) {\n *         id = reader.nextLong();\n *       } else if (name.equals(\"text\")) {\n *         text = reader.nextString();\n *       } else if (name.equals(\"geo\") && reader.peek() != JsonToken.NULL) {\n *         geo = readDoublesArray(reader);\n *       } else if (name.equals(\"user\")) {\n *         user = readUser(reader);\n *       } else {\n *         reader.skipValue();\n *       }\n *     }\n *     reader.endObject();\n *     return new Message(id, text, user, geo);\n *   }\n *\n *   public List<Double> readDoublesArray(JsonReader reader) throws IOException {\n *     List<Double> doubles = new ArrayList<Double>();\n *\n *     reader.beginArray();\n *     while (reader.hasNext()) {\n *       doubles.add(reader.nextDouble());\n *     }\n *     reader.endArray();\n *     return doubles;\n *   }\n *\n *   public User readUser(JsonReader reader) throws IOException {\n *     String username = null;\n *     int followersCount = -1;\n *\n *     reader.beginObject();\n *     while (reader.hasNext()) {\n *       String name = reader.nextName();\n *       if (name.equals(\"name\")) {\n *         username = reader.nextString();\n *       } else if (name.equals(\"followers_count\")) {\n *         followersCount = reader.nextInt();\n *       } else {\n *         reader.skipValue();\n *       }\n *     }\n *     reader.endObject();\n *     return new User(username, followersCount);\n *   }}</pre>\n *\n * <h3>Number Handling</h3>\n * This reader permits numeric values to be read as strings and string values to\n * be read as numbers. For example, both elements of the JSON array {@code\n * [1, \"1\"]} may be read using either {@link #nextInt} or {@link #nextString}.\n * This behavior is intended to prevent lossy numeric conversions: double is\n * JavaScript's only numeric type and very large values like {@code\n * 9007199254740993} cannot be represented exactly on that platform. To minimize\n * precision loss, extremely large values should be written and read as strings\n * in JSON.\n *\n * <a name=\"nonexecuteprefix\"/><h3>Non-Execute Prefix</h3>\n * Web servers that serve private data using JSON may be vulnerable to <a\n * href=\"http://en.wikipedia.org/wiki/JSON#Cross-site_request_forgery\">Cross-site\n * request forgery</a> attacks. In such an attack, a malicious site gains access\n * to a private JSON file by executing it with an HTML {@code <script>} tag.\n *\n * <p>Prefixing JSON files with <code>\")]}'\\n\"</code> makes them non-executable\n * by {@code <script>} tags, disarming the attack. Since the prefix is malformed\n * JSON, strict parsing fails when it is encountered. This class permits the\n * non-execute prefix when {@link #setLenient(boolean) lenient parsing} is\n * enabled.\n *\n * <p>Each {@code JsonReader} may be used to read a single JSON stream. Instances\n * of this class are not thread safe.\n *\n * @author Jesse Wilson\n * @since 1.6\n */\npublic class JsonReader implements Closeable {\n  /** The only non-execute prefix this parser permits */\n  private static final char[] NON_EXECUTE_PREFIX = \")]}'\\n\".toCharArray();\n  private static final long MIN_INCOMPLETE_INTEGER = Long.MIN_VALUE / 10;\n\n  private static final int PEEKED_NONE = 0;\n  private static final int PEEKED_BEGIN_OBJECT = 1;\n  private static final int PEEKED_END_OBJECT = 2;\n  private static final int PEEKED_BEGIN_ARRAY = 3;\n  private static final int PEEKED_END_ARRAY = 4;\n  private static final int PEEKED_TRUE = 5;\n  private static final int PEEKED_FALSE = 6;\n  private static final int PEEKED_NULL = 7;\n  private static final int PEEKED_SINGLE_QUOTED = 8;\n  private static final int PEEKED_DOUBLE_QUOTED = 9;\n  private static final int PEEKED_UNQUOTED = 10;\n  /** When this is returned, the string value is stored in peekedString. */\n  private static final int PEEKED_BUFFERED = 11;\n  private static final int PEEKED_SINGLE_QUOTED_NAME = 12;\n  private static final int PEEKED_DOUBLE_QUOTED_NAME = 13;\n  private static final int PEEKED_UNQUOTED_NAME = 14;\n  /** When this is returned, the integer value is stored in peekedLong. */\n  private static final int PEEKED_LONG = 15;\n  private static final int PEEKED_NUMBER = 16;\n  private static final int PEEKED_EOF = 17;\n\n  /* State machine when parsing numbers */\n  private static final int NUMBER_CHAR_NONE = 0;\n  private static final int NUMBER_CHAR_SIGN = 1;\n  private static final int NUMBER_CHAR_DIGIT = 2;\n  private static final int NUMBER_CHAR_DECIMAL = 3;\n  private static final int NUMBER_CHAR_FRACTION_DIGIT = 4;\n  private static final int NUMBER_CHAR_EXP_E = 5;\n  private static final int NUMBER_CHAR_EXP_SIGN = 6;\n  private static final int NUMBER_CHAR_EXP_DIGIT = 7;\n\n  /** The input JSON. */\n  private final Reader in;\n\n  /** True to accept non-spec compliant JSON */\n  private boolean lenient = false;\n\n  /**\n   * Use a manual buffer to easily read and unread upcoming characters, and\n   * also so we can create strings without an intermediate StringBuilder.\n   * We decode literals directly out of this buffer, so it must be at least as\n   * long as the longest token that can be reported as a number.\n   */\n  private final char[] buffer = new char[1024];\n  private int pos = 0;\n  private int limit = 0;\n\n  private int lineNumber = 0;\n  private int lineStart = 0;\n\n  int peeked = PEEKED_NONE;\n\n  /**\n   * A peeked value that was composed entirely of digits with an optional\n   * leading dash. Positive values may not have a leading 0.\n   */\n  private long peekedLong;\n\n  /**\n   * The number of characters in a peeked number literal. Increment 'pos' by\n   * this after reading a number.\n   */\n  private int peekedNumberLength;\n\n  /**\n   * A peeked string that should be parsed on the next double, long or string.\n   * This is populated before a numeric value is parsed and used if that parsing\n   * fails.\n   */\n  private String peekedString;\n\n  /*\n   * The nesting stack. Using a manual array rather than an ArrayList saves 20%.\n   */\n  private int[] stack = new int[32];\n  private int stackSize = 0;\n  {\n    stack[stackSize++] = JsonScope.EMPTY_DOCUMENT;\n  }\n\n  /*\n   * The path members. It corresponds directly to stack: At indices where the\n   * stack contains an object (EMPTY_OBJECT, DANGLING_NAME or NONEMPTY_OBJECT),\n   * pathNames contains the name at this scope. Where it contains an array\n   * (EMPTY_ARRAY, NONEMPTY_ARRAY) pathIndices contains the current index in\n   * that array. Otherwise the value is undefined, and we take advantage of that\n   * by incrementing pathIndices when doing so isn't useful.\n   */\n  private String[] pathNames = new String[32];\n  private int[] pathIndices = new int[32];\n\n  /**\n   * Creates a new instance that reads a JSON-encoded stream from {@code in}.\n   */\n  public JsonReader(Reader in) {\n    if (in == null) {\n      throw new NullPointerException(\"in == null\");\n    }\n    this.in = in;\n  }\n\n  /**\n   * Configure this parser to be liberal in what it accepts. By default,\n   * this parser is strict and only accepts JSON as specified by <a\n   * href=\"http://www.ietf.org/rfc/rfc4627.txt\">RFC 4627</a>. Setting the\n   * parser to lenient causes it to ignore the following syntax errors:\n   *\n   * <ul>\n   *   <li>Streams that start with the <a href=\"#nonexecuteprefix\">non-execute\n   *       prefix</a>, <code>\")]}'\\n\"</code>.\n   *   <li>Streams that include multiple top-level values. With strict parsing,\n   *       each stream must contain exactly one top-level value.\n   *   <li>Top-level values of any type. With strict parsing, the top-level\n   *       value must be an object or an array.\n   *   <li>Numbers may be {@link Double#isNaN() NaNs} or {@link\n   *       Double#isInfinite() infinities}.\n   *   <li>End of line comments starting with {@code //} or {@code #} and\n   *       ending with a newline character.\n   *   <li>C-style comments starting with {@code /*} and ending with\n   *       {@code *}{@code /}. Such comments may not be nested.\n   *   <li>Names that are unquoted or {@code 'single quoted'}.\n   *   <li>Strings that are unquoted or {@code 'single quoted'}.\n   *   <li>Array elements separated by {@code ;} instead of {@code ,}.\n   *   <li>Unnecessary array separators. These are interpreted as if null\n   *       was the omitted value.\n   *   <li>Names and values separated by {@code =} or {@code =>} instead of\n   *       {@code :}.\n   *   <li>Name/value pairs separated by {@code ;} instead of {@code ,}.\n   * </ul>\n   */\n  public final void setLenient(boolean lenient) {\n    this.lenient = lenient;\n  }\n\n  /**\n   * Returns true if this parser is liberal in what it accepts.\n   */\n  public final boolean isLenient() {\n    return lenient;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is the\n   * beginning of a new array.\n   */\n  public void beginArray() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_BEGIN_ARRAY) {\n      push(JsonScope.EMPTY_ARRAY);\n      pathIndices[stackSize - 1] = 0;\n      peeked = PEEKED_NONE;\n    } else {\n      throw new IllegalStateException(\"Expected BEGIN_ARRAY but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is the\n   * end of the current array.\n   */\n  public void endArray() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_END_ARRAY) {\n      stackSize--;\n      pathIndices[stackSize - 1]++;\n      peeked = PEEKED_NONE;\n    } else {\n      throw new IllegalStateException(\"Expected END_ARRAY but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is the\n   * beginning of a new object.\n   */\n  public void beginObject() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_BEGIN_OBJECT) {\n      push(JsonScope.EMPTY_OBJECT);\n      peeked = PEEKED_NONE;\n    } else {\n      throw new IllegalStateException(\"Expected BEGIN_OBJECT but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is the\n   * end of the current object.\n   */\n  public void endObject() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_END_OBJECT) {\n      stackSize--;\n      pathNames[stackSize] = null; // Free the last path name so that it can be garbage collected!\n      pathIndices[stackSize - 1]++;\n      peeked = PEEKED_NONE;\n    } else {\n      throw new IllegalStateException(\"Expected END_OBJECT but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n  }\n\n  /**\n   * Returns true if the current array or object has another element.\n   */\n  public boolean hasNext() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    return p != PEEKED_END_OBJECT && p != PEEKED_END_ARRAY;\n  }\n\n  /**\n   * Returns the type of the next token without consuming it.\n   */\n  public JsonToken peek() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    switch (p) {\n    case PEEKED_BEGIN_OBJECT:\n      return JsonToken.BEGIN_OBJECT;\n    case PEEKED_END_OBJECT:\n      return JsonToken.END_OBJECT;\n    case PEEKED_BEGIN_ARRAY:\n      return JsonToken.BEGIN_ARRAY;\n    case PEEKED_END_ARRAY:\n      return JsonToken.END_ARRAY;\n    case PEEKED_SINGLE_QUOTED_NAME:\n    case PEEKED_DOUBLE_QUOTED_NAME:\n    case PEEKED_UNQUOTED_NAME:\n      return JsonToken.NAME;\n    case PEEKED_TRUE:\n    case PEEKED_FALSE:\n      return JsonToken.BOOLEAN;\n    case PEEKED_NULL:\n      return JsonToken.NULL;\n    case PEEKED_SINGLE_QUOTED:\n    case PEEKED_DOUBLE_QUOTED:\n    case PEEKED_UNQUOTED:\n    case PEEKED_BUFFERED:\n      return JsonToken.STRING;\n    case PEEKED_LONG:\n    case PEEKED_NUMBER:\n      return JsonToken.NUMBER;\n    case PEEKED_EOF:\n      return JsonToken.END_DOCUMENT;\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  int doPeek() throws IOException {\n    int peekStack = stack[stackSize - 1];\n    if (peekStack == JsonScope.EMPTY_ARRAY) {\n      stack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY;\n    } else if (peekStack == JsonScope.NONEMPTY_ARRAY) {\n      // Look for a comma before the next element.\n      int c = nextNonWhitespace(true);\n      switch (c) {\n      case ']':\n        return peeked = PEEKED_END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    } else if (peekStack == JsonScope.EMPTY_OBJECT || peekStack == JsonScope.NONEMPTY_OBJECT) {\n      stack[stackSize - 1] = JsonScope.DANGLING_NAME;\n      // Look for a comma before the next element.\n      if (peekStack == JsonScope.NONEMPTY_OBJECT) {\n        int c = nextNonWhitespace(true);\n        switch (c) {\n        case '}':\n          return peeked = PEEKED_END_OBJECT;\n        case ';':\n          checkLenient(); // fall-through\n        case ',':\n          break;\n        default:\n          throw syntaxError(\"Unterminated object\");\n        }\n      }\n      int c = nextNonWhitespace(true);\n      switch (c) {\n      case '\"':\n        return peeked = PEEKED_DOUBLE_QUOTED_NAME;\n      case '\\'':\n        checkLenient();\n        return peeked = PEEKED_SINGLE_QUOTED_NAME;\n      case '}':\n        if (peekStack != JsonScope.NONEMPTY_OBJECT) {\n          return peeked = PEEKED_END_OBJECT;\n        } else {\n          throw syntaxError(\"Expected name\");\n        }\n      default:\n        checkLenient();\n        pos--; // Don't consume the first character in an unquoted string.\n        if (isLiteral((char) c)) {\n          return peeked = PEEKED_UNQUOTED_NAME;\n        } else {\n          throw syntaxError(\"Expected name\");\n        }\n      }\n    } else if (peekStack == JsonScope.DANGLING_NAME) {\n      stack[stackSize - 1] = JsonScope.NONEMPTY_OBJECT;\n      // Look for a colon before the value.\n      int c = nextNonWhitespace(true);\n      switch (c) {\n      case ':':\n        break;\n      case '=':\n        checkLenient();\n        if ((pos < limit || fillBuffer(1)) && buffer[pos] == '>') {\n          pos++;\n        }\n        break;\n      default:\n        throw syntaxError(\"Expected ':'\");\n      }\n    } else if (peekStack == JsonScope.EMPTY_DOCUMENT) {\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      stack[stackSize - 1] = JsonScope.NONEMPTY_DOCUMENT;\n    } else if (peekStack == JsonScope.NONEMPTY_DOCUMENT) {\n      int c = nextNonWhitespace(false);\n      if (c == -1) {\n        return peeked = PEEKED_EOF;\n      } else {\n        checkLenient();\n        pos--;\n      }\n    } else if (peekStack == JsonScope.CLOSED) {\n      throw new IllegalStateException(\"JsonReader is closed\");\n    }\n\n    int c = nextNonWhitespace(true);\n    switch (c) {\n    case ']':\n      if (peekStack == JsonScope.EMPTY_ARRAY) {\n        return peeked = PEEKED_END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      // In lenient mode, a 0-length literal in an array means 'null'.\n      if (peekStack == JsonScope.EMPTY_ARRAY || peekStack == JsonScope.NONEMPTY_ARRAY) {\n        checkLenient();\n        pos--;\n        return peeked = PEEKED_NULL;\n      } else {\n        throw syntaxError(\"Unexpected value\");\n      }\n    case '\\'':\n      checkLenient();\n      return peeked = PEEKED_SINGLE_QUOTED;\n    case '\"':\n      return peeked = PEEKED_DOUBLE_QUOTED;\n    case '[':\n      return peeked = PEEKED_BEGIN_ARRAY;\n    case '{':\n      return peeked = PEEKED_BEGIN_OBJECT;\n    default:\n      pos--; // Don't consume the first character in a literal value.\n    }\n\n    int result = peekKeyword();\n    if (result != PEEKED_NONE) {\n      return result;\n    }\n\n    result = peekNumber();\n    if (result != PEEKED_NONE) {\n      return result;\n    }\n\n    if (!isLiteral(buffer[pos])) {\n      throw syntaxError(\"Expected value\");\n    }\n\n    checkLenient();\n    return peeked = PEEKED_UNQUOTED;\n  }\n\n  private int peekKeyword() throws IOException {\n    // Figure out which keyword we're matching against by its first character.\n    char c = buffer[pos];\n    String keyword;\n    String keywordUpper;\n    int peeking;\n    if (c == 't' || c == 'T') {\n      keyword = \"true\";\n      keywordUpper = \"TRUE\";\n      peeking = PEEKED_TRUE;\n    } else if (c == 'f' || c == 'F') {\n      keyword = \"false\";\n      keywordUpper = \"FALSE\";\n      peeking = PEEKED_FALSE;\n    } else if (c == 'n' || c == 'N') {\n      keyword = \"null\";\n      keywordUpper = \"NULL\";\n      peeking = PEEKED_NULL;\n    } else {\n      return PEEKED_NONE;\n    }\n\n    // Confirm that chars [1..length) match the keyword.\n    int length = keyword.length();\n    for (int i = 1; i < length; i++) {\n      if (pos + i >= limit && !fillBuffer(i + 1)) {\n        return PEEKED_NONE;\n      }\n      c = buffer[pos + i];\n      if (c != keyword.charAt(i) && c != keywordUpper.charAt(i)) {\n        return PEEKED_NONE;\n      }\n    }\n\n    if ((pos + length < limit || fillBuffer(length + 1))\n        && isLiteral(buffer[pos + length])) {\n      return PEEKED_NONE; // Don't match trues, falsey or nullsoft!\n    }\n\n    // We've found the keyword followed either by EOF or by a non-literal character.\n    pos += length;\n    return peeked = peeking;\n  }\n\n  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }\n\n  private boolean isLiteral(char c) throws IOException {\n    switch (c) {\n    case '/':\n    case '\\\\':\n    case ';':\n    case '#':\n    case '=':\n      checkLenient(); // fall-through\n    case '{':\n    case '}':\n    case '[':\n    case ']':\n    case ':':\n    case ',':\n    case ' ':\n    case '\\t':\n    case '\\f':\n    case '\\r':\n    case '\\n':\n      return false;\n    default:\n      return true;\n    }\n  }\n\n  /**\n   * Returns the next token, a {@link com.google.gson.stream.JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws java.io.IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      result = nextQuotedValue('\"');\n    } else {\n      throw new IllegalStateException(\"Expected a name but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n    peeked = PEEKED_NONE;\n    pathNames[stackSize - 1] = result;\n    return result;\n  }\n\n  /**\n   * Returns the {@link com.google.gson.stream.JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n      result = nextQuotedValue('\"');\n    } else if (p == PEEKED_BUFFERED) {\n      result = peekedString;\n      peekedString = null;\n    } else if (p == PEEKED_LONG) {\n      result = Long.toString(peekedLong);\n    } else if (p == PEEKED_NUMBER) {\n      result = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }\n\n  /**\n   * Returns the {@link com.google.gson.stream.JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    }\n    throw new IllegalStateException(\"Expected a boolean but was \" + peek()\n        + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_NULL) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n    } else {\n      throw new IllegalStateException(\"Expected null but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n  }\n\n  /**\n   * Returns the {@link com.google.gson.stream.JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double using {@link Double#parseDouble(String)}.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    if (p == PEEKED_LONG) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return (double) peekedLong;\n    }\n\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    } else if (p == PEEKED_UNQUOTED) {\n      peekedString = nextUnquotedValue();\n    } else if (p != PEEKED_BUFFERED) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double result = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new MalformedJsonException(\"JSON forbids NaN and infinities: \" + result\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }\n\n  /**\n   * Returns the {@link com.google.gson.stream.JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    if (p == PEEKED_LONG) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return peekedLong;\n    }\n\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n      if (p == PEEKED_UNQUOTED) {\n        peekedString = nextUnquotedValue();\n      } else {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      }\n      try {\n        long result = Long.parseLong(peekedString);\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n      } catch (NumberFormatException ignored) {\n        // Fall back to parse as a double below.\n      }\n    } else {\n      throw new IllegalStateException(\"Expected a long but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    long result = (long) asDouble;\n    if (result != asDouble) { // Make sure no precision was lost casting to 'long'.\n      throw new NumberFormatException(\"Expected a long but was \" + peekedString\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }\n\n  /**\n   * Returns the string up to but not including {@code quote}, unescaping any\n   * character escape sequences encountered along the way. The opening quote\n   * should have already been read. This consumes the closing quote, but does\n   * not include it in the returned string.\n   *\n   * @param quote either ' or \".\n   * @throws NumberFormatException if any unicode escape sequences are\n   *     malformed.\n   */\n  private String nextQuotedValue(char quote) throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    StringBuilder builder = new StringBuilder();\n    while (true) {\n      int p = pos;\n      int l = limit;\n      /* the index of the first character not yet appended to the builder. */\n      int start = p;\n      while (p < l) {\n        int c = buffer[p++];\n\n        if (c == quote) {\n          pos = p;\n          builder.append(buffer, start, p - start - 1);\n          return builder.toString();\n        } else if (c == '\\\\') {\n          pos = p;\n          builder.append(buffer, start, p - start - 1);\n          builder.append(readEscapeCharacter());\n          p = pos;\n          l = limit;\n          start = p;\n        } else if (c == '\\n') {\n          lineNumber++;\n          lineStart = p;\n        }\n      }\n\n      builder.append(buffer, start, p - start);\n      pos = p;\n      if (!fillBuffer(1)) {\n        throw syntaxError(\"Unterminated string\");\n      }\n    }\n  }\n\n  /**\n   * Returns an unquoted value as a string.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private String nextUnquotedValue() throws IOException {\n    StringBuilder builder = null;\n    int i = 0;\n\n    findNonLiteralCharacter:\n    while (true) {\n      for (; pos + i < limit; i++) {\n        switch (buffer[pos + i]) {\n        case '/':\n        case '\\\\':\n        case ';':\n        case '#':\n        case '=':\n          checkLenient(); // fall-through\n        case '{':\n        case '}':\n        case '[':\n        case ']':\n        case ':':\n        case ',':\n        case ' ':\n        case '\\t':\n        case '\\f':\n        case '\\r':\n        case '\\n':\n          break findNonLiteralCharacter;\n        }\n      }\n\n      // Attempt to load the entire literal into the buffer at once.\n      if (i < buffer.length) {\n        if (fillBuffer(i + 1)) {\n          continue;\n        } else {\n          break;\n        }\n      }\n\n      // use a StringBuilder when the value is too long. This is too long to be a number!\n      if (builder == null) {\n        builder = new StringBuilder();\n      }\n      builder.append(buffer, pos, i);\n      pos += i;\n      i = 0;\n      if (!fillBuffer(1)) {\n        break;\n      }\n    }\n\n    String result;\n    if (builder == null) {\n      result = new String(buffer, pos, i);\n    } else {\n      builder.append(buffer, pos, i);\n      result = builder.toString();\n    }\n    pos += i;\n    return result;\n  }\n\n  private void skipQuotedValue(char quote) throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    do {\n      int p = pos;\n      int l = limit;\n      /* the index of the first character not yet appended to the builder. */\n      while (p < l) {\n        int c = buffer[p++];\n        if (c == quote) {\n          pos = p;\n          return;\n        } else if (c == '\\\\') {\n          pos = p;\n          readEscapeCharacter();\n          p = pos;\n          l = limit;\n        } else if (c == '\\n') {\n          lineNumber++;\n          lineStart = p;\n        }\n      }\n      pos = p;\n    } while (fillBuffer(1));\n    throw syntaxError(\"Unterminated string\");\n  }\n\n  private void skipUnquotedValue() throws IOException {\n    do {\n      int i = 0;\n      for (; pos + i < limit; i++) {\n        switch (buffer[pos + i]) {\n        case '/':\n        case '\\\\':\n        case ';':\n        case '#':\n        case '=':\n          checkLenient(); // fall-through\n        case '{':\n        case '}':\n        case '[':\n        case ']':\n        case ':':\n        case ',':\n        case ' ':\n        case '\\t':\n        case '\\f':\n        case '\\r':\n        case '\\n':\n          pos += i;\n          return;\n        }\n      }\n      pos += i;\n    } while (fillBuffer(1));\n  }\n\n  /**\n   * Returns the {@link com.google.gson.stream.JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    int result;\n    if (p == PEEKED_LONG) {\n      result = (int) peekedLong;\n      if (peekedLong != result) { // Make sure no precision was lost casting to 'int'.\n        throw new NumberFormatException(\"Expected an int but was \" + peekedLong\n            + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n      }\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    }\n\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n      if (p == PEEKED_UNQUOTED) {\n        peekedString = nextUnquotedValue();\n      } else {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      }\n      try {\n        result = Integer.parseInt(peekedString);\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n      } catch (NumberFormatException ignored) {\n        // Fall back to parse as a double below.\n      }\n    } else {\n      throw new IllegalStateException(\"Expected an int but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    result = (int) asDouble;\n    if (result != asDouble) { // Make sure no precision was lost casting to 'int'.\n      throw new NumberFormatException(\"Expected an int but was \" + peekedString\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link java.io.Reader}.\n   */\n  public void close() throws IOException {\n    peeked = PEEKED_NONE;\n    stack[0] = JsonScope.CLOSED;\n    stackSize = 1;\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    int count = 0;\n    do {\n      int p = peeked;\n      if (p == PEEKED_NONE) {\n        p = doPeek();\n      }\n\n      if (p == PEEKED_BEGIN_ARRAY) {\n        push(JsonScope.EMPTY_ARRAY);\n        count++;\n      } else if (p == PEEKED_BEGIN_OBJECT) {\n        push(JsonScope.EMPTY_OBJECT);\n        count++;\n      } else if (p == PEEKED_END_ARRAY) {\n        stackSize--;\n        count--;\n      } else if (p == PEEKED_END_OBJECT) {\n        stackSize--;\n        count--;\n      } else if (p == PEEKED_UNQUOTED_NAME || p == PEEKED_UNQUOTED) {\n        skipUnquotedValue();\n      } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_SINGLE_QUOTED_NAME) {\n        skipQuotedValue('\\'');\n      } else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_DOUBLE_QUOTED_NAME) {\n        skipQuotedValue('\"');\n      } else if (p == PEEKED_NUMBER) {\n        pos += peekedNumberLength;\n      }\n      peeked = PEEKED_NONE;\n    } while (count != 0);\n\n    pathIndices[stackSize - 1]++;\n    pathNames[stackSize - 1] = \"null\";\n  }\n\n  private void push(int newTop) {\n    if (stackSize == stack.length) {\n      int[] newStack = new int[stackSize * 2];\n      int[] newPathIndices = new int[stackSize * 2];\n      String[] newPathNames = new String[stackSize * 2];\n      System.arraycopy(stack, 0, newStack, 0, stackSize);\n      System.arraycopy(pathIndices, 0, newPathIndices, 0, stackSize);\n      System.arraycopy(pathNames, 0, newPathNames, 0, stackSize);\n      stack = newStack;\n      pathIndices = newPathIndices;\n      pathNames = newPathNames;\n    }\n    stack[stackSize++] = newTop;\n  }\n\n  /**\n   * Returns true once {@code limit - pos >= minimum}. If the data is\n   * exhausted before that many characters are available, this returns\n   * false.\n   */\n  private boolean fillBuffer(int minimum) throws IOException {\n    char[] buffer = this.buffer;\n    lineStart -= pos;\n    if (limit != pos) {\n      limit -= pos;\n      System.arraycopy(buffer, pos, buffer, 0, limit);\n    } else {\n      limit = 0;\n    }\n\n    pos = 0;\n    int total;\n    while ((total = in.read(buffer, limit, buffer.length - limit)) != -1) {\n      limit += total;\n\n      // if this is the first read, consume an optional byte order mark (BOM) if it exists\n      if (lineNumber == 0 && lineStart == 0 && limit > 0 && buffer[0] == '\\ufeff') {\n        pos++;\n        lineStart++;\n        minimum++;\n      }\n\n      if (limit >= minimum) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  int getLineNumber() {\n    return lineNumber + 1;\n  }\n\n  int getColumnNumber() {\n    return pos - lineStart + 1;\n  }\n\n  /**\n   * Returns the next character in the stream that is neither whitespace nor a\n   * part of a comment. When this returns, the returned character is always at\n   * {@code buffer[pos-1]}; this means the caller can always push back the\n   * returned character by decrementing {@code pos}.\n   */\n  private int nextNonWhitespace(boolean throwOnEof) throws IOException {\n    /*\n     * This code uses ugly local variables 'p' and 'l' representing the 'pos'\n     * and 'limit' fields respectively. Using locals rather than fields saves\n     * a few field reads for each whitespace character in a pretty-printed\n     * document, resulting in a 5% speedup. We need to flush 'p' to its field\n     * before any (potentially indirect) call to fillBuffer() and reread both\n     * 'p' and 'l' after any (potentially indirect) call to the same method.\n     */\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n    while (true) {\n      if (p == l) {\n        pos = p;\n        if (!fillBuffer(1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      int c = buffer[p++];\n      if (c == '\\n') {\n        lineNumber++;\n        lineStart = p;\n        continue;\n      } else if (c == ' ' || c == '\\r' || c == '\\t') {\n        continue;\n      }\n\n      if (c == '/') {\n        pos = p;\n        if (p == l) {\n          pos--; // push back '/' so it's still in the buffer when this method returns\n          boolean charsLoaded = fillBuffer(2);\n          pos++; // consume the '/' again\n          if (!charsLoaded) {\n            return c;\n          }\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;\n          if (!skipTo(\"*/\")) {\n            throw syntaxError(\"Unterminated comment\");\n          }\n          p = pos + 2;\n          l = limit;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          p = pos;\n          l = limit;\n          continue;\n\n        default:\n          return c;\n        }\n      } else if (c == '#') {\n        pos = p;\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        p = pos;\n        l = limit;\n      } else {\n        pos = p;\n        return c;\n      }\n    }\n    if (throwOnEof) {\n      throw new EOFException(\"End of input\"\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n    } else {\n      return -1;\n    }\n  }\n\n  private void checkLenient() throws IOException {\n    if (!lenient) {\n      throw syntaxError(\"Use JsonReader.setLenient(true) to accept malformed JSON\");\n    }\n  }\n\n  /**\n   * Advances the position until after the next newline character. If the line\n   * is terminated by \"\\r\\n\", the '\\n' must be consumed as whitespace by the\n   * caller.\n   */\n  private void skipToEndOfLine() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      char c = buffer[pos++];\n      if (c == '\\n') {\n        lineNumber++;\n        lineStart = pos;\n        break;\n      } else if (c == '\\r') {\n        break;\n      }\n    }\n  }\n\n  /**\n   * @param toFind a string to search for. Must not contain a newline.\n   */\n  private boolean skipTo(String toFind) throws IOException {\n    outer:\n    for (; pos + toFind.length() <= limit || fillBuffer(toFind.length()); pos++) {\n      if (buffer[pos] == '\\n') {\n        lineNumber++;\n        lineStart = pos + 1;\n        continue;\n      }\n      for (int c = 0; c < toFind.length(); c++) {\n        if (buffer[pos + c] != toFind.charAt(c)) {\n          continue outer;\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n\n  @Override public String toString() {\n    return getClass().getSimpleName()\n        + \" at line \" + getLineNumber() + \" column \" + getColumnNumber();\n  }\n\n  /**\n   * Returns a <a href=\"http://goessner.net/articles/JsonPath/\">JsonPath</a> to\n   * the current location in the JSON value.\n   */\n  public String getPath() {\n    StringBuilder result = new StringBuilder().append('$');\n    for (int i = 0, size = stackSize; i < size; i++) {\n      switch (stack[i]) {\n        case JsonScope.EMPTY_ARRAY:\n        case JsonScope.NONEMPTY_ARRAY:\n          result.append('[').append(pathIndices[i]).append(']');\n          break;\n\n        case JsonScope.EMPTY_OBJECT:\n        case JsonScope.DANGLING_NAME:\n        case JsonScope.NONEMPTY_OBJECT:\n          result.append('.');\n          if (pathNames[i] != null) {\n            result.append(pathNames[i]);\n          }\n          break;\n\n        case JsonScope.NONEMPTY_DOCUMENT:\n        case JsonScope.EMPTY_DOCUMENT:\n        case JsonScope.CLOSED:\n          break;\n      }\n    }\n    return result.toString();\n  }\n\n  /**\n   * Unescapes the character identified by the character or characters that\n   * immediately follow a backslash. The backslash '\\' should have already\n   * been read. This supports both unicode escapes \"u000A\" and two-character\n   * escapes \"\\n\".\n   *\n   * @throws NumberFormatException if any unicode escape sequences are\n   *     malformed.\n   */\n  private char readEscapeCharacter() throws IOException {\n    if (pos == limit && !fillBuffer(1)) {\n      throw syntaxError(\"Unterminated escape sequence\");\n    }\n\n    char escaped = buffer[pos++];\n    switch (escaped) {\n    case 'u':\n      if (pos + 4 > limit && !fillBuffer(4)) {\n        throw syntaxError(\"Unterminated escape sequence\");\n      }\n      // Equivalent to Integer.parseInt(stringPool.get(buffer, pos, 4), 16);\n      char result = 0;\n      for (int i = pos, end = i + 4; i < end; i++) {\n        char c = buffer[i];\n        result <<= 4;\n        if (c >= '0' && c <= '9') {\n          result += (c - '0');\n        } else if (c >= 'a' && c <= 'f') {\n          result += (c - 'a' + 10);\n        } else if (c >= 'A' && c <= 'F') {\n          result += (c - 'A' + 10);\n        } else {\n          throw new NumberFormatException(\"\\\\u\" + new String(buffer, pos, 4));\n        }\n      }\n      pos += 4;\n      return result;\n\n    case 't':\n      return '\\t';\n\n    case 'b':\n      return '\\b';\n\n    case 'n':\n      return '\\n';\n\n    case 'r':\n      return '\\r';\n\n    case 'f':\n      return '\\f';\n\n    case '\\n':\n      lineNumber++;\n      lineStart = pos;\n      // fall-through\n\n    case '\\'':\n    case '\"':\n    case '\\\\':\n    default:\n      return escaped;\n    }\n  }\n\n  /**\n   * Throws a new IO exception with the given message and a context snippet\n   * with this reader's content.\n   */\n  private IOException syntaxError(String message) throws IOException {\n    throw new MalformedJsonException(message\n        + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace(true);\n    pos--;\n\n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n\n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n\n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  static {\n    JsonReaderInternalAccess.INSTANCE = new JsonReaderInternalAccess() {\n      @Override public void promoteNameToValue(JsonReader reader) throws IOException {\n        if (reader instanceof JsonTreeReader) {\n          ((JsonTreeReader)reader).promoteNameToValue();\n          return;\n        }\n        int p = reader.peeked;\n        if (p == PEEKED_NONE) {\n          p = reader.doPeek();\n        }\n        if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n          reader.peeked = PEEKED_DOUBLE_QUOTED;\n        } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n          reader.peeked = PEEKED_SINGLE_QUOTED;\n        } else if (p == PEEKED_UNQUOTED_NAME) {\n          reader.peeked = PEEKED_UNQUOTED;\n        } else {\n          throw new IllegalStateException(\"Expected a name but was \" + reader.peek() + \" \"\n              + \" at line \" + reader.getLineNumber() + \" column \" + reader.getColumnNumber()\n              + \" path \" + reader.getPath());\n        }\n      }\n    };\n  }\n}\n"}]}
{"project": "Gson", "bug_id": 8, "classes_modified": [{"class_name": "com.google.gson.internal.UnsafeAllocator", "buggy_version": "/*\n * Copyright (C) 2011 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.gson.internal;\n\nimport java.io.ObjectInputStream;\nimport java.io.ObjectStreamClass;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\n\n/**\n * Do sneaky things to allocate objects without invoking their constructors.\n *\n * @author Joel Leitch\n * @author Jesse Wilson\n */\npublic abstract class UnsafeAllocator {\n  public abstract <T> T newInstance(Class<T> c) throws Exception;\n\n  public static UnsafeAllocator create() {\n    // try JVM\n    // public class Unsafe {\n    //   public Object allocateInstance(Class<?> type);\n    // }\n    try {\n      Class<?> unsafeClass = Class.forName(\"sun.misc.Unsafe\");\n      Field f = unsafeClass.getDeclaredField(\"theUnsafe\");\n      f.setAccessible(true);\n      final Object unsafe = f.get(null);\n      final Method allocateInstance = unsafeClass.getMethod(\"allocateInstance\", Class.class);\n      return new UnsafeAllocator() {\n        @Override\n        @SuppressWarnings(\"unchecked\")\n        public <T> T newInstance(Class<T> c) throws Exception {\n          return (T) allocateInstance.invoke(unsafe, c);\n        }\n      };\n    } catch (Exception ignored) {\n    }\n\n    // try dalvikvm, post-gingerbread\n    // public class ObjectStreamClass {\n    //   private static native int getConstructorId(Class<?> c);\n    //   private static native Object newInstance(Class<?> instantiationClass, int methodId);\n    // }\n    try {\n      Method getConstructorId = ObjectStreamClass.class\n          .getDeclaredMethod(\"getConstructorId\", Class.class);\n      getConstructorId.setAccessible(true);\n      final int constructorId = (Integer) getConstructorId.invoke(null, Object.class);\n      final Method newInstance = ObjectStreamClass.class\n          .getDeclaredMethod(\"newInstance\", Class.class, int.class);\n      newInstance.setAccessible(true);\n      return new UnsafeAllocator() {\n        @Override\n        @SuppressWarnings(\"unchecked\")\n        public <T> T newInstance(Class<T> c) throws Exception {\n          return (T) newInstance.invoke(null, c, constructorId);\n        }\n      };\n    } catch (Exception ignored) {\n    }\n\n    // try dalvikvm, pre-gingerbread\n    // public class ObjectInputStream {\n    //   private static native Object newInstance(\n    //     Class<?> instantiationClass, Class<?> constructorClass);\n    // }\n    try {\n      final Method newInstance = ObjectInputStream.class\n          .getDeclaredMethod(\"newInstance\", Class.class, Class.class);\n      newInstance.setAccessible(true);\n      return new UnsafeAllocator() {\n        @Override\n        @SuppressWarnings(\"unchecked\")\n        public <T> T newInstance(Class<T> c) throws Exception {\n          return (T) newInstance.invoke(null, c, Object.class);\n        }\n      };\n    } catch (Exception ignored) {\n    }\n\n    // give up\n    return new UnsafeAllocator() {\n      @Override\n      public <T> T newInstance(Class<T> c) {\n        throw new UnsupportedOperationException(\"Cannot allocate \" + c);\n      }\n    };\n  }\n\n  /**\n   * Check if the class can be instantiated by unsafe allocator. If the instance has interface or abstract modifiers\n   * throw an {@link java.lang.UnsupportedOperationException}\n   * @param c instance of the class to be checked\n   */\n}\n", "fixed_version": "/*\n * Copyright (C) 2011 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.gson.internal;\n\nimport java.io.ObjectInputStream;\nimport java.io.ObjectStreamClass;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\n\n/**\n * Do sneaky things to allocate objects without invoking their constructors.\n *\n * @author Joel Leitch\n * @author Jesse Wilson\n */\npublic abstract class UnsafeAllocator {\n  public abstract <T> T newInstance(Class<T> c) throws Exception;\n\n  public static UnsafeAllocator create() {\n    // try JVM\n    // public class Unsafe {\n    //   public Object allocateInstance(Class<?> type);\n    // }\n    try {\n      Class<?> unsafeClass = Class.forName(\"sun.misc.Unsafe\");\n      Field f = unsafeClass.getDeclaredField(\"theUnsafe\");\n      f.setAccessible(true);\n      final Object unsafe = f.get(null);\n      final Method allocateInstance = unsafeClass.getMethod(\"allocateInstance\", Class.class);\n      return new UnsafeAllocator() {\n        @Override\n        @SuppressWarnings(\"unchecked\")\n        public <T> T newInstance(Class<T> c) throws Exception {\n          assertInstantiable(c);\n          return (T) allocateInstance.invoke(unsafe, c);\n        }\n      };\n    } catch (Exception ignored) {\n    }\n\n    // try dalvikvm, post-gingerbread\n    // public class ObjectStreamClass {\n    //   private static native int getConstructorId(Class<?> c);\n    //   private static native Object newInstance(Class<?> instantiationClass, int methodId);\n    // }\n    try {\n      Method getConstructorId = ObjectStreamClass.class\n          .getDeclaredMethod(\"getConstructorId\", Class.class);\n      getConstructorId.setAccessible(true);\n      final int constructorId = (Integer) getConstructorId.invoke(null, Object.class);\n      final Method newInstance = ObjectStreamClass.class\n          .getDeclaredMethod(\"newInstance\", Class.class, int.class);\n      newInstance.setAccessible(true);\n      return new UnsafeAllocator() {\n        @Override\n        @SuppressWarnings(\"unchecked\")\n        public <T> T newInstance(Class<T> c) throws Exception {\n          assertInstantiable(c);\n          return (T) newInstance.invoke(null, c, constructorId);\n        }\n      };\n    } catch (Exception ignored) {\n    }\n\n    // try dalvikvm, pre-gingerbread\n    // public class ObjectInputStream {\n    //   private static native Object newInstance(\n    //     Class<?> instantiationClass, Class<?> constructorClass);\n    // }\n    try {\n      final Method newInstance = ObjectInputStream.class\n          .getDeclaredMethod(\"newInstance\", Class.class, Class.class);\n      newInstance.setAccessible(true);\n      return new UnsafeAllocator() {\n        @Override\n        @SuppressWarnings(\"unchecked\")\n        public <T> T newInstance(Class<T> c) throws Exception {\n          assertInstantiable(c);\n          return (T) newInstance.invoke(null, c, Object.class);\n        }\n      };\n    } catch (Exception ignored) {\n    }\n\n    // give up\n    return new UnsafeAllocator() {\n      @Override\n      public <T> T newInstance(Class<T> c) {\n        throw new UnsupportedOperationException(\"Cannot allocate \" + c);\n      }\n    };\n  }\n\n  /**\n   * Check if the class can be instantiated by unsafe allocator. If the instance has interface or abstract modifiers\n   * throw an {@link java.lang.UnsupportedOperationException}\n   * @param c instance of the class to be checked\n   */\n  private static void assertInstantiable(Class<?> c) {\n    int modifiers = c.getModifiers();\n    if (Modifier.isInterface(modifiers)) {\n      throw new UnsupportedOperationException(\"Interface can't be instantiated! Interface name: \" + c.getName());\n    }\n    if (Modifier.isAbstract(modifiers)) {\n      throw new UnsupportedOperationException(\"Abstract class can't be instantiated! Class name: \" + c.getName());\n    }\n  }\n}\n"}]}
{"project": "Gson", "bug_id": 9, "classes_modified": [{"class_name": "com.google.gson.internal.bind.JsonTreeWriter", "buggy_version": "/*\n * Copyright (C) 2011 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.gson.internal.bind;\n\nimport com.google.gson.JsonArray;\nimport com.google.gson.JsonElement;\nimport com.google.gson.JsonNull;\nimport com.google.gson.JsonObject;\nimport com.google.gson.JsonPrimitive;\nimport com.google.gson.stream.JsonWriter;\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * This writer creates a JsonElement.\n */\npublic final class JsonTreeWriter extends JsonWriter {\n  private static final Writer UNWRITABLE_WRITER = new Writer() {\n    @Override public void write(char[] buffer, int offset, int counter) {\n      throw new AssertionError();\n    }\n    @Override public void flush() throws IOException {\n      throw new AssertionError();\n    }\n    @Override public void close() throws IOException {\n      throw new AssertionError();\n    }\n  };\n  /** Added to the top of the stack when this writer is closed to cause following ops to fail. */\n  private static final JsonPrimitive SENTINEL_CLOSED = new JsonPrimitive(\"closed\");\n\n  /** The JsonElements and JsonArrays under modification, outermost to innermost. */\n  private final List<JsonElement> stack = new ArrayList<JsonElement>();\n\n  /** The name for the next JSON object value. If non-null, the top of the stack is a JsonObject. */\n  private String pendingName;\n\n  /** the JSON element constructed by this writer. */\n  private JsonElement product = JsonNull.INSTANCE; // TODO: is this really what we want?;\n\n  public JsonTreeWriter() {\n    super(UNWRITABLE_WRITER);\n  }\n\n  /**\n   * Returns the top level object produced by this writer.\n   */\n  public JsonElement get() {\n    if (!stack.isEmpty()) {\n      throw new IllegalStateException(\"Expected one JSON element but was \" + stack);\n    }\n    return product;\n  }\n\n  private JsonElement peek() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private void put(JsonElement value) {\n    if (pendingName != null) {\n      if (!value.isJsonNull() || getSerializeNulls()) {\n        JsonObject object = (JsonObject) peek();\n        object.add(pendingName, value);\n      }\n      pendingName = null;\n    } else if (stack.isEmpty()) {\n      product = value;\n    } else {\n      JsonElement element = peek();\n      if (element instanceof JsonArray) {\n        ((JsonArray) element).add(value);\n      } else {\n        throw new IllegalStateException();\n      }\n    }\n  }\n\n  @Override public JsonWriter beginArray() throws IOException {\n    JsonArray array = new JsonArray();\n    put(array);\n    stack.add(array);\n    return this;\n  }\n\n  @Override public JsonWriter endArray() throws IOException {\n    if (stack.isEmpty() || pendingName != null) {\n      throw new IllegalStateException();\n    }\n    JsonElement element = peek();\n    if (element instanceof JsonArray) {\n      stack.remove(stack.size() - 1);\n      return this;\n    }\n    throw new IllegalStateException();\n  }\n\n  @Override public JsonWriter beginObject() throws IOException {\n    JsonObject object = new JsonObject();\n    put(object);\n    stack.add(object);\n    return this;\n  }\n\n  @Override public JsonWriter endObject() throws IOException {\n    if (stack.isEmpty() || pendingName != null) {\n      throw new IllegalStateException();\n    }\n    JsonElement element = peek();\n    if (element instanceof JsonObject) {\n      stack.remove(stack.size() - 1);\n      return this;\n    }\n    throw new IllegalStateException();\n  }\n\n  @Override public JsonWriter name(String name) throws IOException {\n    if (stack.isEmpty() || pendingName != null) {\n      throw new IllegalStateException();\n    }\n    JsonElement element = peek();\n    if (element instanceof JsonObject) {\n      pendingName = name;\n      return this;\n    }\n    throw new IllegalStateException();\n  }\n\n  @Override public JsonWriter value(String value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n    put(new JsonPrimitive(value));\n    return this;\n  }\n\n  @Override public JsonWriter nullValue() throws IOException {\n    put(JsonNull.INSTANCE);\n    return this;\n  }\n\n  @Override public JsonWriter value(boolean value) throws IOException {\n    put(new JsonPrimitive(value));\n    return this;\n  }\n\n\n  @Override public JsonWriter value(double value) throws IOException {\n    if (!isLenient() && (Double.isNaN(value) || Double.isInfinite(value))) {\n      throw new IllegalArgumentException(\"JSON forbids NaN and infinities: \" + value);\n    }\n    put(new JsonPrimitive(value));\n    return this;\n  }\n\n  @Override public JsonWriter value(long value) throws IOException {\n    put(new JsonPrimitive(value));\n    return this;\n  }\n\n  @Override public JsonWriter value(Number value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n\n    if (!isLenient()) {\n      double d = value.doubleValue();\n      if (Double.isNaN(d) || Double.isInfinite(d)) {\n        throw new IllegalArgumentException(\"JSON forbids NaN and infinities: \" + value);\n      }\n    }\n\n    put(new JsonPrimitive(value));\n    return this;\n  }\n\n  @Override public void flush() throws IOException {\n  }\n\n  @Override public void close() throws IOException {\n    if (!stack.isEmpty()) {\n      throw new IOException(\"Incomplete document\");\n    }\n    stack.add(SENTINEL_CLOSED);\n  }\n}\n", "fixed_version": "/*\n * Copyright (C) 2011 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.gson.internal.bind;\n\nimport com.google.gson.JsonArray;\nimport com.google.gson.JsonElement;\nimport com.google.gson.JsonNull;\nimport com.google.gson.JsonObject;\nimport com.google.gson.JsonPrimitive;\nimport com.google.gson.stream.JsonWriter;\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * This writer creates a JsonElement.\n */\npublic final class JsonTreeWriter extends JsonWriter {\n  private static final Writer UNWRITABLE_WRITER = new Writer() {\n    @Override public void write(char[] buffer, int offset, int counter) {\n      throw new AssertionError();\n    }\n    @Override public void flush() throws IOException {\n      throw new AssertionError();\n    }\n    @Override public void close() throws IOException {\n      throw new AssertionError();\n    }\n  };\n  /** Added to the top of the stack when this writer is closed to cause following ops to fail. */\n  private static final JsonPrimitive SENTINEL_CLOSED = new JsonPrimitive(\"closed\");\n\n  /** The JsonElements and JsonArrays under modification, outermost to innermost. */\n  private final List<JsonElement> stack = new ArrayList<JsonElement>();\n\n  /** The name for the next JSON object value. If non-null, the top of the stack is a JsonObject. */\n  private String pendingName;\n\n  /** the JSON element constructed by this writer. */\n  private JsonElement product = JsonNull.INSTANCE; // TODO: is this really what we want?;\n\n  public JsonTreeWriter() {\n    super(UNWRITABLE_WRITER);\n  }\n\n  /**\n   * Returns the top level object produced by this writer.\n   */\n  public JsonElement get() {\n    if (!stack.isEmpty()) {\n      throw new IllegalStateException(\"Expected one JSON element but was \" + stack);\n    }\n    return product;\n  }\n\n  private JsonElement peek() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private void put(JsonElement value) {\n    if (pendingName != null) {\n      if (!value.isJsonNull() || getSerializeNulls()) {\n        JsonObject object = (JsonObject) peek();\n        object.add(pendingName, value);\n      }\n      pendingName = null;\n    } else if (stack.isEmpty()) {\n      product = value;\n    } else {\n      JsonElement element = peek();\n      if (element instanceof JsonArray) {\n        ((JsonArray) element).add(value);\n      } else {\n        throw new IllegalStateException();\n      }\n    }\n  }\n\n  @Override public JsonWriter beginArray() throws IOException {\n    JsonArray array = new JsonArray();\n    put(array);\n    stack.add(array);\n    return this;\n  }\n\n  @Override public JsonWriter endArray() throws IOException {\n    if (stack.isEmpty() || pendingName != null) {\n      throw new IllegalStateException();\n    }\n    JsonElement element = peek();\n    if (element instanceof JsonArray) {\n      stack.remove(stack.size() - 1);\n      return this;\n    }\n    throw new IllegalStateException();\n  }\n\n  @Override public JsonWriter beginObject() throws IOException {\n    JsonObject object = new JsonObject();\n    put(object);\n    stack.add(object);\n    return this;\n  }\n\n  @Override public JsonWriter endObject() throws IOException {\n    if (stack.isEmpty() || pendingName != null) {\n      throw new IllegalStateException();\n    }\n    JsonElement element = peek();\n    if (element instanceof JsonObject) {\n      stack.remove(stack.size() - 1);\n      return this;\n    }\n    throw new IllegalStateException();\n  }\n\n  @Override public JsonWriter name(String name) throws IOException {\n    if (stack.isEmpty() || pendingName != null) {\n      throw new IllegalStateException();\n    }\n    JsonElement element = peek();\n    if (element instanceof JsonObject) {\n      pendingName = name;\n      return this;\n    }\n    throw new IllegalStateException();\n  }\n\n  @Override public JsonWriter value(String value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n    put(new JsonPrimitive(value));\n    return this;\n  }\n\n  @Override public JsonWriter nullValue() throws IOException {\n    put(JsonNull.INSTANCE);\n    return this;\n  }\n\n  @Override public JsonWriter value(boolean value) throws IOException {\n    put(new JsonPrimitive(value));\n    return this;\n  }\n\n  @Override public JsonWriter value(Boolean value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n    put(new JsonPrimitive(value));\n    return this;\n  }\n\n  @Override public JsonWriter value(double value) throws IOException {\n    if (!isLenient() && (Double.isNaN(value) || Double.isInfinite(value))) {\n      throw new IllegalArgumentException(\"JSON forbids NaN and infinities: \" + value);\n    }\n    put(new JsonPrimitive(value));\n    return this;\n  }\n\n  @Override public JsonWriter value(long value) throws IOException {\n    put(new JsonPrimitive(value));\n    return this;\n  }\n\n  @Override public JsonWriter value(Number value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n\n    if (!isLenient()) {\n      double d = value.doubleValue();\n      if (Double.isNaN(d) || Double.isInfinite(d)) {\n        throw new IllegalArgumentException(\"JSON forbids NaN and infinities: \" + value);\n      }\n    }\n\n    put(new JsonPrimitive(value));\n    return this;\n  }\n\n  @Override public void flush() throws IOException {\n  }\n\n  @Override public void close() throws IOException {\n    if (!stack.isEmpty()) {\n      throw new IOException(\"Incomplete document\");\n    }\n    stack.add(SENTINEL_CLOSED);\n  }\n}\n"}, {"class_name": "com.google.gson.internal.bind.TypeAdapters", "buggy_version": "/*\n * Copyright (C) 2011 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.gson.internal.bind;\n\nimport java.io.IOException;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.net.InetAddress;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.sql.Timestamp;\nimport java.util.ArrayList;\nimport java.util.BitSet;\nimport java.util.Calendar;\nimport java.util.Currency;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.StringTokenizer;\nimport java.util.UUID;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicIntegerArray;\n\nimport com.google.gson.Gson;\nimport com.google.gson.JsonArray;\nimport com.google.gson.JsonElement;\nimport com.google.gson.JsonIOException;\nimport com.google.gson.JsonNull;\nimport com.google.gson.JsonObject;\nimport com.google.gson.JsonPrimitive;\nimport com.google.gson.JsonSyntaxException;\nimport com.google.gson.TypeAdapter;\nimport com.google.gson.TypeAdapterFactory;\nimport com.google.gson.annotations.SerializedName;\nimport com.google.gson.internal.LazilyParsedNumber;\nimport com.google.gson.reflect.TypeToken;\nimport com.google.gson.stream.JsonReader;\nimport com.google.gson.stream.JsonToken;\nimport com.google.gson.stream.JsonWriter;\n\n/**\n * Type adapters for basic types.\n */\npublic final class TypeAdapters {\n  private TypeAdapters() {\n    throw new UnsupportedOperationException();\n  }\n\n  @SuppressWarnings(\"rawtypes\")\n  public static final TypeAdapter<Class> CLASS = new TypeAdapter<Class>() {\n    @Override\n    public void write(JsonWriter out, Class value) throws IOException {\n      if (value == null) {\n        out.nullValue();\n      } else {\n        throw new UnsupportedOperationException(\"Attempted to serialize java.lang.Class: \"\n            + value.getName() + \". Forgot to register a type adapter?\");\n      }\n    }\n    @Override\n    public Class read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      } else {\n        throw new UnsupportedOperationException(\n            \"Attempted to deserialize a java.lang.Class. Forgot to register a type adapter?\");\n      }\n    }\n  };\n  public static final TypeAdapterFactory CLASS_FACTORY = newFactory(Class.class, CLASS);\n\n  public static final TypeAdapter<BitSet> BIT_SET = new TypeAdapter<BitSet>() {\n    @Override public BitSet read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n\n      BitSet bitset = new BitSet();\n      in.beginArray();\n      int i = 0;\n      JsonToken tokenType = in.peek();\n      while (tokenType != JsonToken.END_ARRAY) {\n        boolean set;\n        switch (tokenType) {\n        case NUMBER:\n          set = in.nextInt() != 0;\n          break;\n        case BOOLEAN:\n          set = in.nextBoolean();\n          break;\n        case STRING:\n          String stringValue = in.nextString();\n          try {\n            set = Integer.parseInt(stringValue) != 0;\n          } catch (NumberFormatException e) {\n            throw new JsonSyntaxException(\n                \"Error: Expecting: bitset number value (1, 0), Found: \" + stringValue);\n          }\n          break;\n        default:\n          throw new JsonSyntaxException(\"Invalid bitset value type: \" + tokenType);\n        }\n        if (set) {\n          bitset.set(i);\n        }\n        ++i;\n        tokenType = in.peek();\n      }\n      in.endArray();\n      return bitset;\n    }\n\n    @Override public void write(JsonWriter out, BitSet src) throws IOException {\n      if (src == null) {\n        out.nullValue();\n        return;\n      }\n\n      out.beginArray();\n      for (int i = 0; i < src.length(); i++) {\n        int value = (src.get(i)) ? 1 : 0;\n        out.value(value);\n      }\n      out.endArray();\n    }\n  };\n\n  public static final TypeAdapterFactory BIT_SET_FACTORY = newFactory(BitSet.class, BIT_SET);\n\n  public static final TypeAdapter<Boolean> BOOLEAN = new TypeAdapter<Boolean>() {\n    @Override\n    public Boolean read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      } else if (in.peek() == JsonToken.STRING) {\n        // support strings for compatibility with GSON 1.7\n        return Boolean.parseBoolean(in.nextString());\n      }\n      return in.nextBoolean();\n    }\n    @Override\n    public void write(JsonWriter out, Boolean value) throws IOException {\n      if (value == null) {\n        out.nullValue();\n        return;\n      }\n      out.value(value);\n    }\n  };\n\n  /**\n   * Writes a boolean as a string. Useful for map keys, where booleans aren't\n   * otherwise permitted.\n   */\n  public static final TypeAdapter<Boolean> BOOLEAN_AS_STRING = new TypeAdapter<Boolean>() {\n    @Override public Boolean read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return Boolean.valueOf(in.nextString());\n    }\n\n    @Override public void write(JsonWriter out, Boolean value) throws IOException {\n      out.value(value == null ? \"null\" : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory BOOLEAN_FACTORY\n      = newFactory(boolean.class, Boolean.class, BOOLEAN);\n\n  public static final TypeAdapter<Number> BYTE = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        int intValue = in.nextInt();\n        return (byte) intValue;\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapterFactory BYTE_FACTORY\n      = newFactory(byte.class, Byte.class, BYTE);\n\n  public static final TypeAdapter<Number> SHORT = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return (short) in.nextInt();\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapterFactory SHORT_FACTORY\n      = newFactory(short.class, Short.class, SHORT);\n\n  public static final TypeAdapter<Number> INTEGER = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return in.nextInt();\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n  public static final TypeAdapterFactory INTEGER_FACTORY\n      = newFactory(int.class, Integer.class, INTEGER);\n\n  public static final TypeAdapter<AtomicInteger> ATOMIC_INTEGER = new TypeAdapter<AtomicInteger>() {\n    @Override public AtomicInteger read(JsonReader in) throws IOException {\n      try {\n        return new AtomicInteger(in.nextInt());\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override public void write(JsonWriter out, AtomicInteger value) throws IOException {\n      out.value(value.get());\n    }\n  }.nullSafe();\n  public static final TypeAdapterFactory ATOMIC_INTEGER_FACTORY =\n      newFactory(AtomicInteger.class, TypeAdapters.ATOMIC_INTEGER);\n\n  public static final TypeAdapter<AtomicBoolean> ATOMIC_BOOLEAN = new TypeAdapter<AtomicBoolean>() {\n    @Override public AtomicBoolean read(JsonReader in) throws IOException {\n      return new AtomicBoolean(in.nextBoolean());\n    }\n    @Override public void write(JsonWriter out, AtomicBoolean value) throws IOException {\n      out.value(value.get());\n    }\n  }.nullSafe();\n  public static final TypeAdapterFactory ATOMIC_BOOLEAN_FACTORY =\n      newFactory(AtomicBoolean.class, TypeAdapters.ATOMIC_BOOLEAN);\n\n  public static final TypeAdapter<AtomicIntegerArray> ATOMIC_INTEGER_ARRAY = new TypeAdapter<AtomicIntegerArray>() {\n    @Override public AtomicIntegerArray read(JsonReader in) throws IOException {\n        List<Integer> list = new ArrayList<Integer>();\n        in.beginArray();\n        while (in.hasNext()) {\n          try {\n            int integer = in.nextInt();\n            list.add(integer);\n          } catch (NumberFormatException e) {\n            throw new JsonSyntaxException(e);\n          }\n        }\n        in.endArray();\n        int length = list.size();\n        AtomicIntegerArray array = new AtomicIntegerArray(length);\n        for (int i = 0; i < length; ++i) {\n          array.set(i, list.get(i));\n        }\n        return array;\n    }\n    @Override public void write(JsonWriter out, AtomicIntegerArray value) throws IOException {\n      out.beginArray();\n      for (int i = 0, length = value.length(); i < length; i++) {\n        out.value(value.get(i));\n      }\n      out.endArray();\n    }\n  }.nullSafe();\n  public static final TypeAdapterFactory ATOMIC_INTEGER_ARRAY_FACTORY =\n      newFactory(AtomicIntegerArray.class, TypeAdapters.ATOMIC_INTEGER_ARRAY);\n\n  public static final TypeAdapter<Number> LONG = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return in.nextLong();\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapter<Number> FLOAT = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return (float) in.nextDouble();\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapter<Number> DOUBLE = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return in.nextDouble();\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapter<Number> NUMBER = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      JsonToken jsonToken = in.peek();\n      switch (jsonToken) {\n      case NULL:\n        in.nextNull();\n        return null;\n      case NUMBER:\n        return new LazilyParsedNumber(in.nextString());\n      default:\n        throw new JsonSyntaxException(\"Expecting number, got: \" + jsonToken);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapterFactory NUMBER_FACTORY = newFactory(Number.class, NUMBER);\n\n  public static final TypeAdapter<Character> CHARACTER = new TypeAdapter<Character>() {\n    @Override\n    public Character read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      String str = in.nextString();\n      if (str.length() != 1) {\n        throw new JsonSyntaxException(\"Expecting character, got: \" + str);\n      }\n      return str.charAt(0);\n    }\n    @Override\n    public void write(JsonWriter out, Character value) throws IOException {\n      out.value(value == null ? null : String.valueOf(value));\n    }\n  };\n\n  public static final TypeAdapterFactory CHARACTER_FACTORY\n      = newFactory(char.class, Character.class, CHARACTER);\n\n  public static final TypeAdapter<String> STRING = new TypeAdapter<String>() {\n    @Override\n    public String read(JsonReader in) throws IOException {\n      JsonToken peek = in.peek();\n      if (peek == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      /* coerce booleans to strings for backwards compatibility */\n      if (peek == JsonToken.BOOLEAN) {\n        return Boolean.toString(in.nextBoolean());\n      }\n      return in.nextString();\n    }\n    @Override\n    public void write(JsonWriter out, String value) throws IOException {\n      out.value(value);\n    }\n  };\n  \n  public static final TypeAdapter<BigDecimal> BIG_DECIMAL = new TypeAdapter<BigDecimal>() {\n    @Override public BigDecimal read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return new BigDecimal(in.nextString());\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n\n    @Override public void write(JsonWriter out, BigDecimal value) throws IOException {\n      out.value(value);\n    }\n  };\n  \n  public static final TypeAdapter<BigInteger> BIG_INTEGER = new TypeAdapter<BigInteger>() {\n    @Override public BigInteger read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return new BigInteger(in.nextString());\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n\n    @Override public void write(JsonWriter out, BigInteger value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapterFactory STRING_FACTORY = newFactory(String.class, STRING);\n\n  public static final TypeAdapter<StringBuilder> STRING_BUILDER = new TypeAdapter<StringBuilder>() {\n    @Override\n    public StringBuilder read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return new StringBuilder(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, StringBuilder value) throws IOException {\n      out.value(value == null ? null : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory STRING_BUILDER_FACTORY =\n    newFactory(StringBuilder.class, STRING_BUILDER);\n\n  public static final TypeAdapter<StringBuffer> STRING_BUFFER = new TypeAdapter<StringBuffer>() {\n    @Override\n    public StringBuffer read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return new StringBuffer(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, StringBuffer value) throws IOException {\n      out.value(value == null ? null : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory STRING_BUFFER_FACTORY =\n    newFactory(StringBuffer.class, STRING_BUFFER);\n\n  public static final TypeAdapter<URL> URL = new TypeAdapter<URL>() {\n    @Override\n    public URL read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      String nextString = in.nextString();\n      return \"null\".equals(nextString) ? null : new URL(nextString);\n    }\n    @Override\n    public void write(JsonWriter out, URL value) throws IOException {\n      out.value(value == null ? null : value.toExternalForm());\n    }\n  };\n\n  public static final TypeAdapterFactory URL_FACTORY = newFactory(URL.class, URL);\n\n  public static final TypeAdapter<URI> URI = new TypeAdapter<URI>() {\n    @Override\n    public URI read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        String nextString = in.nextString();\n        return \"null\".equals(nextString) ? null : new URI(nextString);\n      } catch (URISyntaxException e) {\n        throw new JsonIOException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, URI value) throws IOException {\n      out.value(value == null ? null : value.toASCIIString());\n    }\n  };\n\n  public static final TypeAdapterFactory URI_FACTORY = newFactory(URI.class, URI);\n\n  public static final TypeAdapter<InetAddress> INET_ADDRESS = new TypeAdapter<InetAddress>() {\n    @Override\n    public InetAddress read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      // regrettably, this should have included both the host name and the host address\n      return InetAddress.getByName(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, InetAddress value) throws IOException {\n      out.value(value == null ? null : value.getHostAddress());\n    }\n  };\n\n  public static final TypeAdapterFactory INET_ADDRESS_FACTORY =\n    newTypeHierarchyFactory(InetAddress.class, INET_ADDRESS);\n\n  public static final TypeAdapter<UUID> UUID = new TypeAdapter<UUID>() {\n    @Override\n    public UUID read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return java.util.UUID.fromString(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, UUID value) throws IOException {\n      out.value(value == null ? null : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory UUID_FACTORY = newFactory(UUID.class, UUID);\n\n  public static final TypeAdapter<Currency> CURRENCY = new TypeAdapter<Currency>() {\n    @Override\n    public Currency read(JsonReader in) throws IOException {\n      return Currency.getInstance(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, Currency value) throws IOException {\n      out.value(value.getCurrencyCode());\n    }\n  }.nullSafe();\n  public static final TypeAdapterFactory CURRENCY_FACTORY = newFactory(Currency.class, CURRENCY);\n\n  public static final TypeAdapterFactory TIMESTAMP_FACTORY = new TypeAdapterFactory() {\n    @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n    @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n      if (typeToken.getRawType() != Timestamp.class) {\n        return null;\n      }\n\n      final TypeAdapter<Date> dateTypeAdapter = gson.getAdapter(Date.class);\n      return (TypeAdapter<T>) new TypeAdapter<Timestamp>() {\n        @Override public Timestamp read(JsonReader in) throws IOException {\n          Date date = dateTypeAdapter.read(in);\n          return date != null ? new Timestamp(date.getTime()) : null;\n        }\n\n        @Override public void write(JsonWriter out, Timestamp value) throws IOException {\n          dateTypeAdapter.write(out, value);\n        }\n      };\n    }\n  };\n\n  public static final TypeAdapter<Calendar> CALENDAR = new TypeAdapter<Calendar>() {\n    private static final String YEAR = \"year\";\n    private static final String MONTH = \"month\";\n    private static final String DAY_OF_MONTH = \"dayOfMonth\";\n    private static final String HOUR_OF_DAY = \"hourOfDay\";\n    private static final String MINUTE = \"minute\";\n    private static final String SECOND = \"second\";\n\n    @Override\n    public Calendar read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return  null;\n      }\n      in.beginObject();\n      int year = 0;\n      int month = 0;\n      int dayOfMonth = 0;\n      int hourOfDay = 0;\n      int minute = 0;\n      int second = 0;\n      while (in.peek() != JsonToken.END_OBJECT) {\n        String name = in.nextName();\n        int value = in.nextInt();\n        if (YEAR.equals(name)) {\n          year = value;\n        } else if (MONTH.equals(name)) {\n          month = value;\n        } else if (DAY_OF_MONTH.equals(name)) {\n          dayOfMonth = value;\n        } else if (HOUR_OF_DAY.equals(name)) {\n          hourOfDay = value;\n        } else if (MINUTE.equals(name)) {\n          minute = value;\n        } else if (SECOND.equals(name)) {\n          second = value;\n        }\n      }\n      in.endObject();\n      return new GregorianCalendar(year, month, dayOfMonth, hourOfDay, minute, second);\n    }\n\n    @Override\n    public void write(JsonWriter out, Calendar value) throws IOException {\n      if (value == null) {\n        out.nullValue();\n        return;\n      }\n      out.beginObject();\n      out.name(YEAR);\n      out.value(value.get(Calendar.YEAR));\n      out.name(MONTH);\n      out.value(value.get(Calendar.MONTH));\n      out.name(DAY_OF_MONTH);\n      out.value(value.get(Calendar.DAY_OF_MONTH));\n      out.name(HOUR_OF_DAY);\n      out.value(value.get(Calendar.HOUR_OF_DAY));\n      out.name(MINUTE);\n      out.value(value.get(Calendar.MINUTE));\n      out.name(SECOND);\n      out.value(value.get(Calendar.SECOND));\n      out.endObject();\n    }\n  };\n\n  public static final TypeAdapterFactory CALENDAR_FACTORY =\n    newFactoryForMultipleTypes(Calendar.class, GregorianCalendar.class, CALENDAR);\n\n  public static final TypeAdapter<Locale> LOCALE = new TypeAdapter<Locale>() {\n    @Override\n    public Locale read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      String locale = in.nextString();\n      StringTokenizer tokenizer = new StringTokenizer(locale, \"_\");\n      String language = null;\n      String country = null;\n      String variant = null;\n      if (tokenizer.hasMoreElements()) {\n        language = tokenizer.nextToken();\n      }\n      if (tokenizer.hasMoreElements()) {\n        country = tokenizer.nextToken();\n      }\n      if (tokenizer.hasMoreElements()) {\n        variant = tokenizer.nextToken();\n      }\n      if (country == null && variant == null) {\n        return new Locale(language);\n      } else if (variant == null) {\n        return new Locale(language, country);\n      } else {\n        return new Locale(language, country, variant);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Locale value) throws IOException {\n      out.value(value == null ? null : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory LOCALE_FACTORY = newFactory(Locale.class, LOCALE);\n\n  public static final TypeAdapter<JsonElement> JSON_ELEMENT = new TypeAdapter<JsonElement>() {\n    @Override public JsonElement read(JsonReader in) throws IOException {\n      switch (in.peek()) {\n      case STRING:\n        return new JsonPrimitive(in.nextString());\n      case NUMBER:\n        String number = in.nextString();\n        return new JsonPrimitive(new LazilyParsedNumber(number));\n      case BOOLEAN:\n        return new JsonPrimitive(in.nextBoolean());\n      case NULL:\n        in.nextNull();\n        return JsonNull.INSTANCE;\n      case BEGIN_ARRAY:\n        JsonArray array = new JsonArray();\n        in.beginArray();\n        while (in.hasNext()) {\n          array.add(read(in));\n        }\n        in.endArray();\n        return array;\n      case BEGIN_OBJECT:\n        JsonObject object = new JsonObject();\n        in.beginObject();\n        while (in.hasNext()) {\n          object.add(in.nextName(), read(in));\n        }\n        in.endObject();\n        return object;\n      case END_DOCUMENT:\n      case NAME:\n      case END_OBJECT:\n      case END_ARRAY:\n      default:\n        throw new IllegalArgumentException();\n      }\n    }\n\n    @Override public void write(JsonWriter out, JsonElement value) throws IOException {\n      if (value == null || value.isJsonNull()) {\n        out.nullValue();\n      } else if (value.isJsonPrimitive()) {\n        JsonPrimitive primitive = value.getAsJsonPrimitive();\n        if (primitive.isNumber()) {\n          out.value(primitive.getAsNumber());\n        } else if (primitive.isBoolean()) {\n          out.value(primitive.getAsBoolean());\n        } else {\n          out.value(primitive.getAsString());\n        }\n\n      } else if (value.isJsonArray()) {\n        out.beginArray();\n        for (JsonElement e : value.getAsJsonArray()) {\n          write(out, e);\n        }\n        out.endArray();\n\n      } else if (value.isJsonObject()) {\n        out.beginObject();\n        for (Map.Entry<String, JsonElement> e : value.getAsJsonObject().entrySet()) {\n          out.name(e.getKey());\n          write(out, e.getValue());\n        }\n        out.endObject();\n\n      } else {\n        throw new IllegalArgumentException(\"Couldn't write \" + value.getClass());\n      }\n    }\n  };\n\n  public static final TypeAdapterFactory JSON_ELEMENT_FACTORY\n      = newTypeHierarchyFactory(JsonElement.class, JSON_ELEMENT);\n\n  private static final class EnumTypeAdapter<T extends Enum<T>> extends TypeAdapter<T> {\n    private final Map<String, T> nameToConstant = new HashMap<String, T>();\n    private final Map<T, String> constantToName = new HashMap<T, String>();\n\n    public EnumTypeAdapter(Class<T> classOfT) {\n      try {\n        for (T constant : classOfT.getEnumConstants()) {\n          String name = constant.name();\n          SerializedName annotation = classOfT.getField(name).getAnnotation(SerializedName.class);\n          if (annotation != null) {\n            name = annotation.value();\n            for (String alternate : annotation.alternate()) {\n              nameToConstant.put(alternate, constant);\n            }\n          }\n          nameToConstant.put(name, constant);\n          constantToName.put(constant, name);\n        }\n      } catch (NoSuchFieldException e) {\n        throw new AssertionError(\"Missing field in \" + classOfT.getName(), e);\n      }\n    }\n    @Override public T read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return nameToConstant.get(in.nextString());\n    }\n\n    @Override public void write(JsonWriter out, T value) throws IOException {\n      out.value(value == null ? null : constantToName.get(value));\n    }\n  }\n\n  public static final TypeAdapterFactory ENUM_FACTORY = new TypeAdapterFactory() {\n    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n    @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n      Class<? super T> rawType = typeToken.getRawType();\n      if (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) {\n        return null;\n      }\n      if (!rawType.isEnum()) {\n        rawType = rawType.getSuperclass(); // handle anonymous subclasses\n      }\n      return (TypeAdapter<T>) new EnumTypeAdapter(rawType);\n    }\n  };\n\n  public static <TT> TypeAdapterFactory newFactory(\n      final TypeToken<TT> type, final TypeAdapter<TT> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n        return typeToken.equals(type) ? (TypeAdapter<T>) typeAdapter : null;\n      }\n    };\n  }\n\n  public static <TT> TypeAdapterFactory newFactory(\n      final Class<TT> type, final TypeAdapter<TT> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n        return typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n      }\n      @Override public String toString() {\n        return \"Factory[type=\" + type.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }\n\n  public static <TT> TypeAdapterFactory newFactory(\n      final Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n        Class<? super T> rawType = typeToken.getRawType();\n        return (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n      }\n      @Override public String toString() {\n        return \"Factory[type=\" + boxed.getName()\n            + \"+\" + unboxed.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }\n\n  public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\n      final Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n        Class<? super T> rawType = typeToken.getRawType();\n        return (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n      }\n      @Override public String toString() {\n        return \"Factory[type=\" + base.getName()\n            + \"+\" + sub.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }\n\n  /**\n   * Returns a factory for all subtypes of {@code typeAdapter}. We do a runtime check to confirm\n   * that the deserialized type matches the type requested.\n   */\n  public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\n      final Class<T1> clazz, final TypeAdapter<T1> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\")\n      @Override public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\n        final Class<? super T2> requestedType = typeToken.getRawType();\n        if (!clazz.isAssignableFrom(requestedType)) {\n          return null;\n        }\n        return (TypeAdapter<T2>) new TypeAdapter<T1>() {\n          @Override public void write(JsonWriter out, T1 value) throws IOException {\n            typeAdapter.write(out, value);\n          }\n\n          @Override public T1 read(JsonReader in) throws IOException {\n            T1 result = typeAdapter.read(in);\n            if (result != null && !requestedType.isInstance(result)) {\n              throw new JsonSyntaxException(\"Expected a \" + requestedType.getName()\n                  + \" but was \" + result.getClass().getName());\n            }\n            return result;\n          }\n        };\n      }\n      @Override public String toString() {\n        return \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }\n}\n", "fixed_version": "/*\n * Copyright (C) 2011 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.gson.internal.bind;\n\nimport java.io.IOException;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.net.InetAddress;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.sql.Timestamp;\nimport java.util.ArrayList;\nimport java.util.BitSet;\nimport java.util.Calendar;\nimport java.util.Currency;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.StringTokenizer;\nimport java.util.UUID;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicIntegerArray;\n\nimport com.google.gson.Gson;\nimport com.google.gson.JsonArray;\nimport com.google.gson.JsonElement;\nimport com.google.gson.JsonIOException;\nimport com.google.gson.JsonNull;\nimport com.google.gson.JsonObject;\nimport com.google.gson.JsonPrimitive;\nimport com.google.gson.JsonSyntaxException;\nimport com.google.gson.TypeAdapter;\nimport com.google.gson.TypeAdapterFactory;\nimport com.google.gson.annotations.SerializedName;\nimport com.google.gson.internal.LazilyParsedNumber;\nimport com.google.gson.reflect.TypeToken;\nimport com.google.gson.stream.JsonReader;\nimport com.google.gson.stream.JsonToken;\nimport com.google.gson.stream.JsonWriter;\n\n/**\n * Type adapters for basic types.\n */\npublic final class TypeAdapters {\n  private TypeAdapters() {\n    throw new UnsupportedOperationException();\n  }\n\n  @SuppressWarnings(\"rawtypes\")\n  public static final TypeAdapter<Class> CLASS = new TypeAdapter<Class>() {\n    @Override\n    public void write(JsonWriter out, Class value) throws IOException {\n      if (value == null) {\n        out.nullValue();\n      } else {\n        throw new UnsupportedOperationException(\"Attempted to serialize java.lang.Class: \"\n            + value.getName() + \". Forgot to register a type adapter?\");\n      }\n    }\n    @Override\n    public Class read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      } else {\n        throw new UnsupportedOperationException(\n            \"Attempted to deserialize a java.lang.Class. Forgot to register a type adapter?\");\n      }\n    }\n  };\n  public static final TypeAdapterFactory CLASS_FACTORY = newFactory(Class.class, CLASS);\n\n  public static final TypeAdapter<BitSet> BIT_SET = new TypeAdapter<BitSet>() {\n    @Override public BitSet read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n\n      BitSet bitset = new BitSet();\n      in.beginArray();\n      int i = 0;\n      JsonToken tokenType = in.peek();\n      while (tokenType != JsonToken.END_ARRAY) {\n        boolean set;\n        switch (tokenType) {\n        case NUMBER:\n          set = in.nextInt() != 0;\n          break;\n        case BOOLEAN:\n          set = in.nextBoolean();\n          break;\n        case STRING:\n          String stringValue = in.nextString();\n          try {\n            set = Integer.parseInt(stringValue) != 0;\n          } catch (NumberFormatException e) {\n            throw new JsonSyntaxException(\n                \"Error: Expecting: bitset number value (1, 0), Found: \" + stringValue);\n          }\n          break;\n        default:\n          throw new JsonSyntaxException(\"Invalid bitset value type: \" + tokenType);\n        }\n        if (set) {\n          bitset.set(i);\n        }\n        ++i;\n        tokenType = in.peek();\n      }\n      in.endArray();\n      return bitset;\n    }\n\n    @Override public void write(JsonWriter out, BitSet src) throws IOException {\n      if (src == null) {\n        out.nullValue();\n        return;\n      }\n\n      out.beginArray();\n      for (int i = 0; i < src.length(); i++) {\n        int value = (src.get(i)) ? 1 : 0;\n        out.value(value);\n      }\n      out.endArray();\n    }\n  };\n\n  public static final TypeAdapterFactory BIT_SET_FACTORY = newFactory(BitSet.class, BIT_SET);\n\n  public static final TypeAdapter<Boolean> BOOLEAN = new TypeAdapter<Boolean>() {\n    @Override\n    public Boolean read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      } else if (in.peek() == JsonToken.STRING) {\n        // support strings for compatibility with GSON 1.7\n        return Boolean.parseBoolean(in.nextString());\n      }\n      return in.nextBoolean();\n    }\n    @Override\n    public void write(JsonWriter out, Boolean value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  /**\n   * Writes a boolean as a string. Useful for map keys, where booleans aren't\n   * otherwise permitted.\n   */\n  public static final TypeAdapter<Boolean> BOOLEAN_AS_STRING = new TypeAdapter<Boolean>() {\n    @Override public Boolean read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return Boolean.valueOf(in.nextString());\n    }\n\n    @Override public void write(JsonWriter out, Boolean value) throws IOException {\n      out.value(value == null ? \"null\" : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory BOOLEAN_FACTORY\n      = newFactory(boolean.class, Boolean.class, BOOLEAN);\n\n  public static final TypeAdapter<Number> BYTE = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        int intValue = in.nextInt();\n        return (byte) intValue;\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapterFactory BYTE_FACTORY\n      = newFactory(byte.class, Byte.class, BYTE);\n\n  public static final TypeAdapter<Number> SHORT = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return (short) in.nextInt();\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapterFactory SHORT_FACTORY\n      = newFactory(short.class, Short.class, SHORT);\n\n  public static final TypeAdapter<Number> INTEGER = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return in.nextInt();\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n  public static final TypeAdapterFactory INTEGER_FACTORY\n      = newFactory(int.class, Integer.class, INTEGER);\n\n  public static final TypeAdapter<AtomicInteger> ATOMIC_INTEGER = new TypeAdapter<AtomicInteger>() {\n    @Override public AtomicInteger read(JsonReader in) throws IOException {\n      try {\n        return new AtomicInteger(in.nextInt());\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override public void write(JsonWriter out, AtomicInteger value) throws IOException {\n      out.value(value.get());\n    }\n  }.nullSafe();\n  public static final TypeAdapterFactory ATOMIC_INTEGER_FACTORY =\n      newFactory(AtomicInteger.class, TypeAdapters.ATOMIC_INTEGER);\n\n  public static final TypeAdapter<AtomicBoolean> ATOMIC_BOOLEAN = new TypeAdapter<AtomicBoolean>() {\n    @Override public AtomicBoolean read(JsonReader in) throws IOException {\n      return new AtomicBoolean(in.nextBoolean());\n    }\n    @Override public void write(JsonWriter out, AtomicBoolean value) throws IOException {\n      out.value(value.get());\n    }\n  }.nullSafe();\n  public static final TypeAdapterFactory ATOMIC_BOOLEAN_FACTORY =\n      newFactory(AtomicBoolean.class, TypeAdapters.ATOMIC_BOOLEAN);\n\n  public static final TypeAdapter<AtomicIntegerArray> ATOMIC_INTEGER_ARRAY = new TypeAdapter<AtomicIntegerArray>() {\n    @Override public AtomicIntegerArray read(JsonReader in) throws IOException {\n        List<Integer> list = new ArrayList<Integer>();\n        in.beginArray();\n        while (in.hasNext()) {\n          try {\n            int integer = in.nextInt();\n            list.add(integer);\n          } catch (NumberFormatException e) {\n            throw new JsonSyntaxException(e);\n          }\n        }\n        in.endArray();\n        int length = list.size();\n        AtomicIntegerArray array = new AtomicIntegerArray(length);\n        for (int i = 0; i < length; ++i) {\n          array.set(i, list.get(i));\n        }\n        return array;\n    }\n    @Override public void write(JsonWriter out, AtomicIntegerArray value) throws IOException {\n      out.beginArray();\n      for (int i = 0, length = value.length(); i < length; i++) {\n        out.value(value.get(i));\n      }\n      out.endArray();\n    }\n  }.nullSafe();\n  public static final TypeAdapterFactory ATOMIC_INTEGER_ARRAY_FACTORY =\n      newFactory(AtomicIntegerArray.class, TypeAdapters.ATOMIC_INTEGER_ARRAY);\n\n  public static final TypeAdapter<Number> LONG = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return in.nextLong();\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapter<Number> FLOAT = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return (float) in.nextDouble();\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapter<Number> DOUBLE = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return in.nextDouble();\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapter<Number> NUMBER = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      JsonToken jsonToken = in.peek();\n      switch (jsonToken) {\n      case NULL:\n        in.nextNull();\n        return null;\n      case NUMBER:\n        return new LazilyParsedNumber(in.nextString());\n      default:\n        throw new JsonSyntaxException(\"Expecting number, got: \" + jsonToken);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapterFactory NUMBER_FACTORY = newFactory(Number.class, NUMBER);\n\n  public static final TypeAdapter<Character> CHARACTER = new TypeAdapter<Character>() {\n    @Override\n    public Character read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      String str = in.nextString();\n      if (str.length() != 1) {\n        throw new JsonSyntaxException(\"Expecting character, got: \" + str);\n      }\n      return str.charAt(0);\n    }\n    @Override\n    public void write(JsonWriter out, Character value) throws IOException {\n      out.value(value == null ? null : String.valueOf(value));\n    }\n  };\n\n  public static final TypeAdapterFactory CHARACTER_FACTORY\n      = newFactory(char.class, Character.class, CHARACTER);\n\n  public static final TypeAdapter<String> STRING = new TypeAdapter<String>() {\n    @Override\n    public String read(JsonReader in) throws IOException {\n      JsonToken peek = in.peek();\n      if (peek == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      /* coerce booleans to strings for backwards compatibility */\n      if (peek == JsonToken.BOOLEAN) {\n        return Boolean.toString(in.nextBoolean());\n      }\n      return in.nextString();\n    }\n    @Override\n    public void write(JsonWriter out, String value) throws IOException {\n      out.value(value);\n    }\n  };\n  \n  public static final TypeAdapter<BigDecimal> BIG_DECIMAL = new TypeAdapter<BigDecimal>() {\n    @Override public BigDecimal read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return new BigDecimal(in.nextString());\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n\n    @Override public void write(JsonWriter out, BigDecimal value) throws IOException {\n      out.value(value);\n    }\n  };\n  \n  public static final TypeAdapter<BigInteger> BIG_INTEGER = new TypeAdapter<BigInteger>() {\n    @Override public BigInteger read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return new BigInteger(in.nextString());\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n\n    @Override public void write(JsonWriter out, BigInteger value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapterFactory STRING_FACTORY = newFactory(String.class, STRING);\n\n  public static final TypeAdapter<StringBuilder> STRING_BUILDER = new TypeAdapter<StringBuilder>() {\n    @Override\n    public StringBuilder read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return new StringBuilder(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, StringBuilder value) throws IOException {\n      out.value(value == null ? null : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory STRING_BUILDER_FACTORY =\n    newFactory(StringBuilder.class, STRING_BUILDER);\n\n  public static final TypeAdapter<StringBuffer> STRING_BUFFER = new TypeAdapter<StringBuffer>() {\n    @Override\n    public StringBuffer read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return new StringBuffer(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, StringBuffer value) throws IOException {\n      out.value(value == null ? null : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory STRING_BUFFER_FACTORY =\n    newFactory(StringBuffer.class, STRING_BUFFER);\n\n  public static final TypeAdapter<URL> URL = new TypeAdapter<URL>() {\n    @Override\n    public URL read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      String nextString = in.nextString();\n      return \"null\".equals(nextString) ? null : new URL(nextString);\n    }\n    @Override\n    public void write(JsonWriter out, URL value) throws IOException {\n      out.value(value == null ? null : value.toExternalForm());\n    }\n  };\n\n  public static final TypeAdapterFactory URL_FACTORY = newFactory(URL.class, URL);\n\n  public static final TypeAdapter<URI> URI = new TypeAdapter<URI>() {\n    @Override\n    public URI read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        String nextString = in.nextString();\n        return \"null\".equals(nextString) ? null : new URI(nextString);\n      } catch (URISyntaxException e) {\n        throw new JsonIOException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, URI value) throws IOException {\n      out.value(value == null ? null : value.toASCIIString());\n    }\n  };\n\n  public static final TypeAdapterFactory URI_FACTORY = newFactory(URI.class, URI);\n\n  public static final TypeAdapter<InetAddress> INET_ADDRESS = new TypeAdapter<InetAddress>() {\n    @Override\n    public InetAddress read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      // regrettably, this should have included both the host name and the host address\n      return InetAddress.getByName(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, InetAddress value) throws IOException {\n      out.value(value == null ? null : value.getHostAddress());\n    }\n  };\n\n  public static final TypeAdapterFactory INET_ADDRESS_FACTORY =\n    newTypeHierarchyFactory(InetAddress.class, INET_ADDRESS);\n\n  public static final TypeAdapter<UUID> UUID = new TypeAdapter<UUID>() {\n    @Override\n    public UUID read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return java.util.UUID.fromString(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, UUID value) throws IOException {\n      out.value(value == null ? null : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory UUID_FACTORY = newFactory(UUID.class, UUID);\n\n  public static final TypeAdapter<Currency> CURRENCY = new TypeAdapter<Currency>() {\n    @Override\n    public Currency read(JsonReader in) throws IOException {\n      return Currency.getInstance(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, Currency value) throws IOException {\n      out.value(value.getCurrencyCode());\n    }\n  }.nullSafe();\n  public static final TypeAdapterFactory CURRENCY_FACTORY = newFactory(Currency.class, CURRENCY);\n\n  public static final TypeAdapterFactory TIMESTAMP_FACTORY = new TypeAdapterFactory() {\n    @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n    @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n      if (typeToken.getRawType() != Timestamp.class) {\n        return null;\n      }\n\n      final TypeAdapter<Date> dateTypeAdapter = gson.getAdapter(Date.class);\n      return (TypeAdapter<T>) new TypeAdapter<Timestamp>() {\n        @Override public Timestamp read(JsonReader in) throws IOException {\n          Date date = dateTypeAdapter.read(in);\n          return date != null ? new Timestamp(date.getTime()) : null;\n        }\n\n        @Override public void write(JsonWriter out, Timestamp value) throws IOException {\n          dateTypeAdapter.write(out, value);\n        }\n      };\n    }\n  };\n\n  public static final TypeAdapter<Calendar> CALENDAR = new TypeAdapter<Calendar>() {\n    private static final String YEAR = \"year\";\n    private static final String MONTH = \"month\";\n    private static final String DAY_OF_MONTH = \"dayOfMonth\";\n    private static final String HOUR_OF_DAY = \"hourOfDay\";\n    private static final String MINUTE = \"minute\";\n    private static final String SECOND = \"second\";\n\n    @Override\n    public Calendar read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return  null;\n      }\n      in.beginObject();\n      int year = 0;\n      int month = 0;\n      int dayOfMonth = 0;\n      int hourOfDay = 0;\n      int minute = 0;\n      int second = 0;\n      while (in.peek() != JsonToken.END_OBJECT) {\n        String name = in.nextName();\n        int value = in.nextInt();\n        if (YEAR.equals(name)) {\n          year = value;\n        } else if (MONTH.equals(name)) {\n          month = value;\n        } else if (DAY_OF_MONTH.equals(name)) {\n          dayOfMonth = value;\n        } else if (HOUR_OF_DAY.equals(name)) {\n          hourOfDay = value;\n        } else if (MINUTE.equals(name)) {\n          minute = value;\n        } else if (SECOND.equals(name)) {\n          second = value;\n        }\n      }\n      in.endObject();\n      return new GregorianCalendar(year, month, dayOfMonth, hourOfDay, minute, second);\n    }\n\n    @Override\n    public void write(JsonWriter out, Calendar value) throws IOException {\n      if (value == null) {\n        out.nullValue();\n        return;\n      }\n      out.beginObject();\n      out.name(YEAR);\n      out.value(value.get(Calendar.YEAR));\n      out.name(MONTH);\n      out.value(value.get(Calendar.MONTH));\n      out.name(DAY_OF_MONTH);\n      out.value(value.get(Calendar.DAY_OF_MONTH));\n      out.name(HOUR_OF_DAY);\n      out.value(value.get(Calendar.HOUR_OF_DAY));\n      out.name(MINUTE);\n      out.value(value.get(Calendar.MINUTE));\n      out.name(SECOND);\n      out.value(value.get(Calendar.SECOND));\n      out.endObject();\n    }\n  };\n\n  public static final TypeAdapterFactory CALENDAR_FACTORY =\n    newFactoryForMultipleTypes(Calendar.class, GregorianCalendar.class, CALENDAR);\n\n  public static final TypeAdapter<Locale> LOCALE = new TypeAdapter<Locale>() {\n    @Override\n    public Locale read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      String locale = in.nextString();\n      StringTokenizer tokenizer = new StringTokenizer(locale, \"_\");\n      String language = null;\n      String country = null;\n      String variant = null;\n      if (tokenizer.hasMoreElements()) {\n        language = tokenizer.nextToken();\n      }\n      if (tokenizer.hasMoreElements()) {\n        country = tokenizer.nextToken();\n      }\n      if (tokenizer.hasMoreElements()) {\n        variant = tokenizer.nextToken();\n      }\n      if (country == null && variant == null) {\n        return new Locale(language);\n      } else if (variant == null) {\n        return new Locale(language, country);\n      } else {\n        return new Locale(language, country, variant);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Locale value) throws IOException {\n      out.value(value == null ? null : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory LOCALE_FACTORY = newFactory(Locale.class, LOCALE);\n\n  public static final TypeAdapter<JsonElement> JSON_ELEMENT = new TypeAdapter<JsonElement>() {\n    @Override public JsonElement read(JsonReader in) throws IOException {\n      switch (in.peek()) {\n      case STRING:\n        return new JsonPrimitive(in.nextString());\n      case NUMBER:\n        String number = in.nextString();\n        return new JsonPrimitive(new LazilyParsedNumber(number));\n      case BOOLEAN:\n        return new JsonPrimitive(in.nextBoolean());\n      case NULL:\n        in.nextNull();\n        return JsonNull.INSTANCE;\n      case BEGIN_ARRAY:\n        JsonArray array = new JsonArray();\n        in.beginArray();\n        while (in.hasNext()) {\n          array.add(read(in));\n        }\n        in.endArray();\n        return array;\n      case BEGIN_OBJECT:\n        JsonObject object = new JsonObject();\n        in.beginObject();\n        while (in.hasNext()) {\n          object.add(in.nextName(), read(in));\n        }\n        in.endObject();\n        return object;\n      case END_DOCUMENT:\n      case NAME:\n      case END_OBJECT:\n      case END_ARRAY:\n      default:\n        throw new IllegalArgumentException();\n      }\n    }\n\n    @Override public void write(JsonWriter out, JsonElement value) throws IOException {\n      if (value == null || value.isJsonNull()) {\n        out.nullValue();\n      } else if (value.isJsonPrimitive()) {\n        JsonPrimitive primitive = value.getAsJsonPrimitive();\n        if (primitive.isNumber()) {\n          out.value(primitive.getAsNumber());\n        } else if (primitive.isBoolean()) {\n          out.value(primitive.getAsBoolean());\n        } else {\n          out.value(primitive.getAsString());\n        }\n\n      } else if (value.isJsonArray()) {\n        out.beginArray();\n        for (JsonElement e : value.getAsJsonArray()) {\n          write(out, e);\n        }\n        out.endArray();\n\n      } else if (value.isJsonObject()) {\n        out.beginObject();\n        for (Map.Entry<String, JsonElement> e : value.getAsJsonObject().entrySet()) {\n          out.name(e.getKey());\n          write(out, e.getValue());\n        }\n        out.endObject();\n\n      } else {\n        throw new IllegalArgumentException(\"Couldn't write \" + value.getClass());\n      }\n    }\n  };\n\n  public static final TypeAdapterFactory JSON_ELEMENT_FACTORY\n      = newTypeHierarchyFactory(JsonElement.class, JSON_ELEMENT);\n\n  private static final class EnumTypeAdapter<T extends Enum<T>> extends TypeAdapter<T> {\n    private final Map<String, T> nameToConstant = new HashMap<String, T>();\n    private final Map<T, String> constantToName = new HashMap<T, String>();\n\n    public EnumTypeAdapter(Class<T> classOfT) {\n      try {\n        for (T constant : classOfT.getEnumConstants()) {\n          String name = constant.name();\n          SerializedName annotation = classOfT.getField(name).getAnnotation(SerializedName.class);\n          if (annotation != null) {\n            name = annotation.value();\n            for (String alternate : annotation.alternate()) {\n              nameToConstant.put(alternate, constant);\n            }\n          }\n          nameToConstant.put(name, constant);\n          constantToName.put(constant, name);\n        }\n      } catch (NoSuchFieldException e) {\n        throw new AssertionError(\"Missing field in \" + classOfT.getName(), e);\n      }\n    }\n    @Override public T read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return nameToConstant.get(in.nextString());\n    }\n\n    @Override public void write(JsonWriter out, T value) throws IOException {\n      out.value(value == null ? null : constantToName.get(value));\n    }\n  }\n\n  public static final TypeAdapterFactory ENUM_FACTORY = new TypeAdapterFactory() {\n    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n    @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n      Class<? super T> rawType = typeToken.getRawType();\n      if (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) {\n        return null;\n      }\n      if (!rawType.isEnum()) {\n        rawType = rawType.getSuperclass(); // handle anonymous subclasses\n      }\n      return (TypeAdapter<T>) new EnumTypeAdapter(rawType);\n    }\n  };\n\n  public static <TT> TypeAdapterFactory newFactory(\n      final TypeToken<TT> type, final TypeAdapter<TT> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n        return typeToken.equals(type) ? (TypeAdapter<T>) typeAdapter : null;\n      }\n    };\n  }\n\n  public static <TT> TypeAdapterFactory newFactory(\n      final Class<TT> type, final TypeAdapter<TT> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n        return typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n      }\n      @Override public String toString() {\n        return \"Factory[type=\" + type.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }\n\n  public static <TT> TypeAdapterFactory newFactory(\n      final Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n        Class<? super T> rawType = typeToken.getRawType();\n        return (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n      }\n      @Override public String toString() {\n        return \"Factory[type=\" + boxed.getName()\n            + \"+\" + unboxed.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }\n\n  public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\n      final Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n        Class<? super T> rawType = typeToken.getRawType();\n        return (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n      }\n      @Override public String toString() {\n        return \"Factory[type=\" + base.getName()\n            + \"+\" + sub.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }\n\n  /**\n   * Returns a factory for all subtypes of {@code typeAdapter}. We do a runtime check to confirm\n   * that the deserialized type matches the type requested.\n   */\n  public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\n      final Class<T1> clazz, final TypeAdapter<T1> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\")\n      @Override public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\n        final Class<? super T2> requestedType = typeToken.getRawType();\n        if (!clazz.isAssignableFrom(requestedType)) {\n          return null;\n        }\n        return (TypeAdapter<T2>) new TypeAdapter<T1>() {\n          @Override public void write(JsonWriter out, T1 value) throws IOException {\n            typeAdapter.write(out, value);\n          }\n\n          @Override public T1 read(JsonReader in) throws IOException {\n            T1 result = typeAdapter.read(in);\n            if (result != null && !requestedType.isInstance(result)) {\n              throw new JsonSyntaxException(\"Expected a \" + requestedType.getName()\n                  + \" but was \" + result.getClass().getName());\n            }\n            return result;\n          }\n        };\n      }\n      @Override public String toString() {\n        return \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }\n}\n"}, {"class_name": "com.google.gson.stream.JsonWriter", "buggy_version": "/*\n * Copyright (C) 2010 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.gson.stream;\n\nimport java.io.Closeable;\nimport java.io.Flushable;\nimport java.io.IOException;\nimport java.io.Writer;\n\nimport static com.google.gson.stream.JsonScope.DANGLING_NAME;\nimport static com.google.gson.stream.JsonScope.EMPTY_ARRAY;\nimport static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;\nimport static com.google.gson.stream.JsonScope.EMPTY_OBJECT;\nimport static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;\nimport static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;\nimport static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;\n\n/**\n * Writes a JSON (<a href=\"http://www.ietf.org/rfc/rfc7159.txt\">RFC 7159</a>)\n * encoded value to a stream, one token at a time. The stream includes both\n * literal values (strings, numbers, booleans and nulls) as well as the begin\n * and end delimiters of objects and arrays.\n *\n * <h3>Encoding JSON</h3>\n * To encode your data as JSON, create a new {@code JsonWriter}. Each JSON\n * document must contain one top-level array or object. Call methods on the\n * writer as you walk the structure's contents, nesting arrays and objects as\n * necessary:\n * <ul>\n *   <li>To write <strong>arrays</strong>, first call {@link #beginArray()}.\n *       Write each of the array's elements with the appropriate {@link #value}\n *       methods or by nesting other arrays and objects. Finally close the array\n *       using {@link #endArray()}.\n *   <li>To write <strong>objects</strong>, first call {@link #beginObject()}.\n *       Write each of the object's properties by alternating calls to\n *       {@link #name} with the property's value. Write property values with the\n *       appropriate {@link #value} method or by nesting other objects or arrays.\n *       Finally close the object using {@link #endObject()}.\n * </ul>\n *\n * <h3>Example</h3>\n * Suppose we'd like to encode a stream of messages such as the following: <pre> {@code\n * [\n *   {\n *     \"id\": 912345678901,\n *     \"text\": \"How do I stream JSON in Java?\",\n *     \"geo\": null,\n *     \"user\": {\n *       \"name\": \"json_newb\",\n *       \"followers_count\": 41\n *      }\n *   },\n *   {\n *     \"id\": 912345678902,\n *     \"text\": \"@json_newb just use JsonWriter!\",\n *     \"geo\": [50.454722, -104.606667],\n *     \"user\": {\n *       \"name\": \"jesse\",\n *       \"followers_count\": 2\n *     }\n *   }\n * ]}</pre>\n * This code encodes the above structure: <pre>   {@code\n *   public void writeJsonStream(OutputStream out, List<Message> messages) throws IOException {\n *     JsonWriter writer = new JsonWriter(new OutputStreamWriter(out, \"UTF-8\"));\n *     writer.setIndent(\"    \");\n *     writeMessagesArray(writer, messages);\n *     writer.close();\n *   }\n *\n *   public void writeMessagesArray(JsonWriter writer, List<Message> messages) throws IOException {\n *     writer.beginArray();\n *     for (Message message : messages) {\n *       writeMessage(writer, message);\n *     }\n *     writer.endArray();\n *   }\n *\n *   public void writeMessage(JsonWriter writer, Message message) throws IOException {\n *     writer.beginObject();\n *     writer.name(\"id\").value(message.getId());\n *     writer.name(\"text\").value(message.getText());\n *     if (message.getGeo() != null) {\n *       writer.name(\"geo\");\n *       writeDoublesArray(writer, message.getGeo());\n *     } else {\n *       writer.name(\"geo\").nullValue();\n *     }\n *     writer.name(\"user\");\n *     writeUser(writer, message.getUser());\n *     writer.endObject();\n *   }\n *\n *   public void writeUser(JsonWriter writer, User user) throws IOException {\n *     writer.beginObject();\n *     writer.name(\"name\").value(user.getName());\n *     writer.name(\"followers_count\").value(user.getFollowersCount());\n *     writer.endObject();\n *   }\n *\n *   public void writeDoublesArray(JsonWriter writer, List<Double> doubles) throws IOException {\n *     writer.beginArray();\n *     for (Double value : doubles) {\n *       writer.value(value);\n *     }\n *     writer.endArray();\n *   }}</pre>\n *\n * <p>Each {@code JsonWriter} may be used to write a single JSON stream.\n * Instances of this class are not thread safe. Calls that would result in a\n * malformed JSON string will fail with an {@link IllegalStateException}.\n *\n * @author Jesse Wilson\n * @since 1.6\n */\npublic class JsonWriter implements Closeable, Flushable {\n\n  /*\n   * From RFC 7159, \"All Unicode characters may be placed within the\n   * quotation marks except for the characters that must be escaped:\n   * quotation mark, reverse solidus, and the control characters\n   * (U+0000 through U+001F).\"\n   *\n   * We also escape '\\u2028' and '\\u2029', which JavaScript interprets as\n   * newline characters. This prevents eval() from failing with a syntax\n   * error. http://code.google.com/p/google-gson/issues/detail?id=341\n   */\n  private static final String[] REPLACEMENT_CHARS;\n  private static final String[] HTML_SAFE_REPLACEMENT_CHARS;\n  static {\n    REPLACEMENT_CHARS = new String[128];\n    for (int i = 0; i <= 0x1f; i++) {\n      REPLACEMENT_CHARS[i] = String.format(\"\\\\u%04x\", (int) i);\n    }\n    REPLACEMENT_CHARS['\"'] = \"\\\\\\\"\";\n    REPLACEMENT_CHARS['\\\\'] = \"\\\\\\\\\";\n    REPLACEMENT_CHARS['\\t'] = \"\\\\t\";\n    REPLACEMENT_CHARS['\\b'] = \"\\\\b\";\n    REPLACEMENT_CHARS['\\n'] = \"\\\\n\";\n    REPLACEMENT_CHARS['\\r'] = \"\\\\r\";\n    REPLACEMENT_CHARS['\\f'] = \"\\\\f\";\n    HTML_SAFE_REPLACEMENT_CHARS = REPLACEMENT_CHARS.clone();\n    HTML_SAFE_REPLACEMENT_CHARS['<'] = \"\\\\u003c\";\n    HTML_SAFE_REPLACEMENT_CHARS['>'] = \"\\\\u003e\";\n    HTML_SAFE_REPLACEMENT_CHARS['&'] = \"\\\\u0026\";\n    HTML_SAFE_REPLACEMENT_CHARS['='] = \"\\\\u003d\";\n    HTML_SAFE_REPLACEMENT_CHARS['\\''] = \"\\\\u0027\";\n  }\n\n  /** The output data, containing at most one top-level array or object. */\n  private final Writer out;\n\n  private int[] stack = new int[32];\n  private int stackSize = 0;\n  {\n    push(EMPTY_DOCUMENT);\n  }\n\n  /**\n   * A string containing a full set of spaces for a single level of\n   * indentation, or null for no pretty printing.\n   */\n  private String indent;\n\n  /**\n   * The name/value separator; either \":\" or \": \".\n   */\n  private String separator = \":\";\n\n  private boolean lenient;\n\n  private boolean htmlSafe;\n\n  private String deferredName;\n\n  private boolean serializeNulls = true;\n\n  /**\n   * Creates a new instance that writes a JSON-encoded stream to {@code out}.\n   * For best performance, ensure {@link Writer} is buffered; wrapping in\n   * {@link java.io.BufferedWriter BufferedWriter} if necessary.\n   */\n  public JsonWriter(Writer out) {\n    if (out == null) {\n      throw new NullPointerException(\"out == null\");\n    }\n    this.out = out;\n  }\n\n  /**\n   * Sets the indentation string to be repeated for each level of indentation\n   * in the encoded document. If {@code indent.isEmpty()} the encoded document\n   * will be compact. Otherwise the encoded document will be more\n   * human-readable.\n   *\n   * @param indent a string containing only whitespace.\n   */\n  public final void setIndent(String indent) {\n    if (indent.length() == 0) {\n      this.indent = null;\n      this.separator = \":\";\n    } else {\n      this.indent = indent;\n      this.separator = \": \";\n    }\n  }\n\n  /**\n   * Configure this writer to relax its syntax rules. By default, this writer\n   * only emits well-formed JSON as specified by <a\n   * href=\"http://www.ietf.org/rfc/rfc7159.txt\">RFC 7159</a>. Setting the writer\n   * to lenient permits the following:\n   * <ul>\n   *   <li>Top-level values of any type. With strict writing, the top-level\n   *       value must be an object or an array.\n   *   <li>Numbers may be {@link Double#isNaN() NaNs} or {@link\n   *       Double#isInfinite() infinities}.\n   * </ul>\n   */\n  public final void setLenient(boolean lenient) {\n    this.lenient = lenient;\n  }\n\n  /**\n   * Returns true if this writer has relaxed syntax rules.\n   */\n  public boolean isLenient() {\n    return lenient;\n  }\n\n  /**\n   * Configure this writer to emit JSON that's safe for direct inclusion in HTML\n   * and XML documents. This escapes the HTML characters {@code <}, {@code >},\n   * {@code &} and {@code =} before writing them to the stream. Without this\n   * setting, your XML/HTML encoder should replace these characters with the\n   * corresponding escape sequences.\n   */\n  public final void setHtmlSafe(boolean htmlSafe) {\n    this.htmlSafe = htmlSafe;\n  }\n\n  /**\n   * Returns true if this writer writes JSON that's safe for inclusion in HTML\n   * and XML documents.\n   */\n  public final boolean isHtmlSafe() {\n    return htmlSafe;\n  }\n\n  /**\n   * Sets whether object members are serialized when their value is null.\n   * This has no impact on array elements. The default is true.\n   */\n  public final void setSerializeNulls(boolean serializeNulls) {\n    this.serializeNulls = serializeNulls;\n  }\n\n  /**\n   * Returns true if object members are serialized when their value is null.\n   * This has no impact on array elements. The default is true.\n   */\n  public final boolean getSerializeNulls() {\n    return serializeNulls;\n  }\n\n  /**\n   * Begins encoding a new array. Each call to this method must be paired with\n   * a call to {@link #endArray}.\n   *\n   * @return this writer.\n   */\n  public JsonWriter beginArray() throws IOException {\n    writeDeferredName();\n    return open(EMPTY_ARRAY, \"[\");\n  }\n\n  /**\n   * Ends encoding the current array.\n   *\n   * @return this writer.\n   */\n  public JsonWriter endArray() throws IOException {\n    return close(EMPTY_ARRAY, NONEMPTY_ARRAY, \"]\");\n  }\n\n  /**\n   * Begins encoding a new object. Each call to this method must be paired\n   * with a call to {@link #endObject}.\n   *\n   * @return this writer.\n   */\n  public JsonWriter beginObject() throws IOException {\n    writeDeferredName();\n    return open(EMPTY_OBJECT, \"{\");\n  }\n\n  /**\n   * Ends encoding the current object.\n   *\n   * @return this writer.\n   */\n  public JsonWriter endObject() throws IOException {\n    return close(EMPTY_OBJECT, NONEMPTY_OBJECT, \"}\");\n  }\n\n  /**\n   * Enters a new scope by appending any necessary whitespace and the given\n   * bracket.\n   */\n  private JsonWriter open(int empty, String openBracket) throws IOException {\n    beforeValue();\n    push(empty);\n    out.write(openBracket);\n    return this;\n  }\n\n  /**\n   * Closes the current scope by appending any necessary whitespace and the\n   * given bracket.\n   */\n  private JsonWriter close(int empty, int nonempty, String closeBracket)\n      throws IOException {\n    int context = peek();\n    if (context != nonempty && context != empty) {\n      throw new IllegalStateException(\"Nesting problem.\");\n    }\n    if (deferredName != null) {\n      throw new IllegalStateException(\"Dangling name: \" + deferredName);\n    }\n\n    stackSize--;\n    if (context == nonempty) {\n      newline();\n    }\n    out.write(closeBracket);\n    return this;\n  }\n\n  private void push(int newTop) {\n    if (stackSize == stack.length) {\n      int[] newStack = new int[stackSize * 2];\n      System.arraycopy(stack, 0, newStack, 0, stackSize);\n      stack = newStack;\n    }\n    stack[stackSize++] = newTop;\n  }\n\n  /**\n   * Returns the value on the top of the stack.\n   */\n  private int peek() {\n    if (stackSize == 0) {\n      throw new IllegalStateException(\"JsonWriter is closed.\");\n    }\n    return stack[stackSize - 1];\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(int topOfStack) {\n    stack[stackSize - 1] = topOfStack;\n  }\n\n  /**\n   * Encodes the property name.\n   *\n   * @param name the name of the forthcoming value. May not be null.\n   * @return this writer.\n   */\n  public JsonWriter name(String name) throws IOException {\n    if (name == null) {\n      throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) {\n      throw new IllegalStateException();\n    }\n    if (stackSize == 0) {\n      throw new IllegalStateException(\"JsonWriter is closed.\");\n    }\n    deferredName = name;\n    return this;\n  }\n\n  private void writeDeferredName() throws IOException {\n    if (deferredName != null) {\n      beforeName();\n      string(deferredName);\n      deferredName = null;\n    }\n  }\n\n  /**\n   * Encodes {@code value}.\n   *\n   * @param value the literal string value, or null to encode a null literal.\n   * @return this writer.\n   */\n  public JsonWriter value(String value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n    writeDeferredName();\n    beforeValue();\n    string(value);\n    return this;\n  }\n\n  /**\n   * Writes {@code value} directly to the writer without quoting or\n   * escaping.\n   *\n   * @param value the literal string value, or null to encode a null literal.\n   * @return this writer.\n   */\n  public JsonWriter jsonValue(String value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n    writeDeferredName();\n    beforeValue();\n    out.append(value);\n    return this;\n  }\n\n  /**\n   * Encodes {@code null}.\n   *\n   * @return this writer.\n   */\n  public JsonWriter nullValue() throws IOException {\n    if (deferredName != null) {\n      if (serializeNulls) {\n        writeDeferredName();\n      } else {\n        deferredName = null;\n        return this; // skip the name and the value\n      }\n    }\n    beforeValue();\n    out.write(\"null\");\n    return this;\n  }\n\n  /**\n   * Encodes {@code value}.\n   *\n   * @return this writer.\n   */\n  public JsonWriter value(boolean value) throws IOException {\n    writeDeferredName();\n    beforeValue();\n    out.write(value ? \"true\" : \"false\");\n    return this;\n  }\n\n  /**\n   * Encodes {@code value}.\n   *\n   * @return this writer.\n   */\n\n  /**\n   * Encodes {@code value}.\n   *\n   * @param value a finite value. May not be {@link Double#isNaN() NaNs} or\n   *     {@link Double#isInfinite() infinities}.\n   * @return this writer.\n   */\n  public JsonWriter value(double value) throws IOException {\n    if (Double.isNaN(value) || Double.isInfinite(value)) {\n      throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n    }\n    writeDeferredName();\n    beforeValue();\n    out.append(Double.toString(value));\n    return this;\n  }\n\n  /**\n   * Encodes {@code value}.\n   *\n   * @return this writer.\n   */\n  public JsonWriter value(long value) throws IOException {\n    writeDeferredName();\n    beforeValue();\n    out.write(Long.toString(value));\n    return this;\n  }\n\n  /**\n   * Encodes {@code value}.\n   *\n   * @param value a finite value. May not be {@link Double#isNaN() NaNs} or\n   *     {@link Double#isInfinite() infinities}.\n   * @return this writer.\n   */\n  public JsonWriter value(Number value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n\n    writeDeferredName();\n    String string = value.toString();\n    if (!lenient\n        && (string.equals(\"-Infinity\") || string.equals(\"Infinity\") || string.equals(\"NaN\"))) {\n      throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n    }\n    beforeValue();\n    out.append(string);\n    return this;\n  }\n\n  /**\n   * Ensures all buffered data is written to the underlying {@link Writer}\n   * and flushes that writer.\n   */\n  public void flush() throws IOException {\n    if (stackSize == 0) {\n      throw new IllegalStateException(\"JsonWriter is closed.\");\n    }\n    out.flush();\n  }\n\n  /**\n   * Flushes and closes this writer and the underlying {@link Writer}.\n   *\n   * @throws IOException if the JSON document is incomplete.\n   */\n  public void close() throws IOException {\n    out.close();\n\n    int size = stackSize;\n    if (size > 1 || size == 1 && stack[size - 1] != NONEMPTY_DOCUMENT) {\n      throw new IOException(\"Incomplete document\");\n    }\n    stackSize = 0;\n  }\n\n  private void string(String value) throws IOException {\n    String[] replacements = htmlSafe ? HTML_SAFE_REPLACEMENT_CHARS : REPLACEMENT_CHARS;\n    out.write(\"\\\"\");\n    int last = 0;\n    int length = value.length();\n    for (int i = 0; i < length; i++) {\n      char c = value.charAt(i);\n      String replacement;\n      if (c < 128) {\n        replacement = replacements[c];\n        if (replacement == null) {\n          continue;\n        }\n      } else if (c == '\\u2028') {\n        replacement = \"\\\\u2028\";\n      } else if (c == '\\u2029') {\n        replacement = \"\\\\u2029\";\n      } else {\n        continue;\n      }\n      if (last < i) {\n        out.write(value, last, i - last);\n      }\n      out.write(replacement);\n      last = i + 1;\n    }\n    if (last < length) {\n      out.write(value, last, length - last);\n    }\n    out.write(\"\\\"\");\n  }\n\n  private void newline() throws IOException {\n    if (indent == null) {\n      return;\n    }\n\n    out.write(\"\\n\");\n    for (int i = 1, size = stackSize; i < size; i++) {\n      out.write(indent);\n    }\n  }\n\n  /**\n   * Inserts any necessary separators and whitespace before a name. Also\n   * adjusts the stack to expect the name's value.\n   */\n  private void beforeName() throws IOException {\n    int context = peek();\n    if (context == NONEMPTY_OBJECT) { // first in object\n      out.write(',');\n    } else if (context != EMPTY_OBJECT) { // not in an object!\n      throw new IllegalStateException(\"Nesting problem.\");\n    }\n    newline();\n    replaceTop(DANGLING_NAME);\n  }\n\n  /**\n   * Inserts any necessary separators and whitespace before a literal value,\n   * inline array, or inline object. Also adjusts the stack to expect either a\n   * closing bracket or another element.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private void beforeValue() throws IOException {\n    switch (peek()) {\n    case NONEMPTY_DOCUMENT:\n      if (!lenient) {\n        throw new IllegalStateException(\n            \"JSON must have only one top-level value.\");\n      }\n      // fall-through\n    case EMPTY_DOCUMENT: // first in document\n      replaceTop(NONEMPTY_DOCUMENT);\n      break;\n\n    case EMPTY_ARRAY: // first in array\n      replaceTop(NONEMPTY_ARRAY);\n      newline();\n      break;\n\n    case NONEMPTY_ARRAY: // another in array\n      out.append(',');\n      newline();\n      break;\n\n    case DANGLING_NAME: // value for name\n      out.append(separator);\n      replaceTop(NONEMPTY_OBJECT);\n      break;\n\n    default:\n      throw new IllegalStateException(\"Nesting problem.\");\n    }\n  }\n}\n", "fixed_version": "/*\n * Copyright (C) 2010 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.gson.stream;\n\nimport java.io.Closeable;\nimport java.io.Flushable;\nimport java.io.IOException;\nimport java.io.Writer;\n\nimport static com.google.gson.stream.JsonScope.DANGLING_NAME;\nimport static com.google.gson.stream.JsonScope.EMPTY_ARRAY;\nimport static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;\nimport static com.google.gson.stream.JsonScope.EMPTY_OBJECT;\nimport static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;\nimport static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;\nimport static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;\n\n/**\n * Writes a JSON (<a href=\"http://www.ietf.org/rfc/rfc7159.txt\">RFC 7159</a>)\n * encoded value to a stream, one token at a time. The stream includes both\n * literal values (strings, numbers, booleans and nulls) as well as the begin\n * and end delimiters of objects and arrays.\n *\n * <h3>Encoding JSON</h3>\n * To encode your data as JSON, create a new {@code JsonWriter}. Each JSON\n * document must contain one top-level array or object. Call methods on the\n * writer as you walk the structure's contents, nesting arrays and objects as\n * necessary:\n * <ul>\n *   <li>To write <strong>arrays</strong>, first call {@link #beginArray()}.\n *       Write each of the array's elements with the appropriate {@link #value}\n *       methods or by nesting other arrays and objects. Finally close the array\n *       using {@link #endArray()}.\n *   <li>To write <strong>objects</strong>, first call {@link #beginObject()}.\n *       Write each of the object's properties by alternating calls to\n *       {@link #name} with the property's value. Write property values with the\n *       appropriate {@link #value} method or by nesting other objects or arrays.\n *       Finally close the object using {@link #endObject()}.\n * </ul>\n *\n * <h3>Example</h3>\n * Suppose we'd like to encode a stream of messages such as the following: <pre> {@code\n * [\n *   {\n *     \"id\": 912345678901,\n *     \"text\": \"How do I stream JSON in Java?\",\n *     \"geo\": null,\n *     \"user\": {\n *       \"name\": \"json_newb\",\n *       \"followers_count\": 41\n *      }\n *   },\n *   {\n *     \"id\": 912345678902,\n *     \"text\": \"@json_newb just use JsonWriter!\",\n *     \"geo\": [50.454722, -104.606667],\n *     \"user\": {\n *       \"name\": \"jesse\",\n *       \"followers_count\": 2\n *     }\n *   }\n * ]}</pre>\n * This code encodes the above structure: <pre>   {@code\n *   public void writeJsonStream(OutputStream out, List<Message> messages) throws IOException {\n *     JsonWriter writer = new JsonWriter(new OutputStreamWriter(out, \"UTF-8\"));\n *     writer.setIndent(\"    \");\n *     writeMessagesArray(writer, messages);\n *     writer.close();\n *   }\n *\n *   public void writeMessagesArray(JsonWriter writer, List<Message> messages) throws IOException {\n *     writer.beginArray();\n *     for (Message message : messages) {\n *       writeMessage(writer, message);\n *     }\n *     writer.endArray();\n *   }\n *\n *   public void writeMessage(JsonWriter writer, Message message) throws IOException {\n *     writer.beginObject();\n *     writer.name(\"id\").value(message.getId());\n *     writer.name(\"text\").value(message.getText());\n *     if (message.getGeo() != null) {\n *       writer.name(\"geo\");\n *       writeDoublesArray(writer, message.getGeo());\n *     } else {\n *       writer.name(\"geo\").nullValue();\n *     }\n *     writer.name(\"user\");\n *     writeUser(writer, message.getUser());\n *     writer.endObject();\n *   }\n *\n *   public void writeUser(JsonWriter writer, User user) throws IOException {\n *     writer.beginObject();\n *     writer.name(\"name\").value(user.getName());\n *     writer.name(\"followers_count\").value(user.getFollowersCount());\n *     writer.endObject();\n *   }\n *\n *   public void writeDoublesArray(JsonWriter writer, List<Double> doubles) throws IOException {\n *     writer.beginArray();\n *     for (Double value : doubles) {\n *       writer.value(value);\n *     }\n *     writer.endArray();\n *   }}</pre>\n *\n * <p>Each {@code JsonWriter} may be used to write a single JSON stream.\n * Instances of this class are not thread safe. Calls that would result in a\n * malformed JSON string will fail with an {@link IllegalStateException}.\n *\n * @author Jesse Wilson\n * @since 1.6\n */\npublic class JsonWriter implements Closeable, Flushable {\n\n  /*\n   * From RFC 7159, \"All Unicode characters may be placed within the\n   * quotation marks except for the characters that must be escaped:\n   * quotation mark, reverse solidus, and the control characters\n   * (U+0000 through U+001F).\"\n   *\n   * We also escape '\\u2028' and '\\u2029', which JavaScript interprets as\n   * newline characters. This prevents eval() from failing with a syntax\n   * error. http://code.google.com/p/google-gson/issues/detail?id=341\n   */\n  private static final String[] REPLACEMENT_CHARS;\n  private static final String[] HTML_SAFE_REPLACEMENT_CHARS;\n  static {\n    REPLACEMENT_CHARS = new String[128];\n    for (int i = 0; i <= 0x1f; i++) {\n      REPLACEMENT_CHARS[i] = String.format(\"\\\\u%04x\", (int) i);\n    }\n    REPLACEMENT_CHARS['\"'] = \"\\\\\\\"\";\n    REPLACEMENT_CHARS['\\\\'] = \"\\\\\\\\\";\n    REPLACEMENT_CHARS['\\t'] = \"\\\\t\";\n    REPLACEMENT_CHARS['\\b'] = \"\\\\b\";\n    REPLACEMENT_CHARS['\\n'] = \"\\\\n\";\n    REPLACEMENT_CHARS['\\r'] = \"\\\\r\";\n    REPLACEMENT_CHARS['\\f'] = \"\\\\f\";\n    HTML_SAFE_REPLACEMENT_CHARS = REPLACEMENT_CHARS.clone();\n    HTML_SAFE_REPLACEMENT_CHARS['<'] = \"\\\\u003c\";\n    HTML_SAFE_REPLACEMENT_CHARS['>'] = \"\\\\u003e\";\n    HTML_SAFE_REPLACEMENT_CHARS['&'] = \"\\\\u0026\";\n    HTML_SAFE_REPLACEMENT_CHARS['='] = \"\\\\u003d\";\n    HTML_SAFE_REPLACEMENT_CHARS['\\''] = \"\\\\u0027\";\n  }\n\n  /** The output data, containing at most one top-level array or object. */\n  private final Writer out;\n\n  private int[] stack = new int[32];\n  private int stackSize = 0;\n  {\n    push(EMPTY_DOCUMENT);\n  }\n\n  /**\n   * A string containing a full set of spaces for a single level of\n   * indentation, or null for no pretty printing.\n   */\n  private String indent;\n\n  /**\n   * The name/value separator; either \":\" or \": \".\n   */\n  private String separator = \":\";\n\n  private boolean lenient;\n\n  private boolean htmlSafe;\n\n  private String deferredName;\n\n  private boolean serializeNulls = true;\n\n  /**\n   * Creates a new instance that writes a JSON-encoded stream to {@code out}.\n   * For best performance, ensure {@link Writer} is buffered; wrapping in\n   * {@link java.io.BufferedWriter BufferedWriter} if necessary.\n   */\n  public JsonWriter(Writer out) {\n    if (out == null) {\n      throw new NullPointerException(\"out == null\");\n    }\n    this.out = out;\n  }\n\n  /**\n   * Sets the indentation string to be repeated for each level of indentation\n   * in the encoded document. If {@code indent.isEmpty()} the encoded document\n   * will be compact. Otherwise the encoded document will be more\n   * human-readable.\n   *\n   * @param indent a string containing only whitespace.\n   */\n  public final void setIndent(String indent) {\n    if (indent.length() == 0) {\n      this.indent = null;\n      this.separator = \":\";\n    } else {\n      this.indent = indent;\n      this.separator = \": \";\n    }\n  }\n\n  /**\n   * Configure this writer to relax its syntax rules. By default, this writer\n   * only emits well-formed JSON as specified by <a\n   * href=\"http://www.ietf.org/rfc/rfc7159.txt\">RFC 7159</a>. Setting the writer\n   * to lenient permits the following:\n   * <ul>\n   *   <li>Top-level values of any type. With strict writing, the top-level\n   *       value must be an object or an array.\n   *   <li>Numbers may be {@link Double#isNaN() NaNs} or {@link\n   *       Double#isInfinite() infinities}.\n   * </ul>\n   */\n  public final void setLenient(boolean lenient) {\n    this.lenient = lenient;\n  }\n\n  /**\n   * Returns true if this writer has relaxed syntax rules.\n   */\n  public boolean isLenient() {\n    return lenient;\n  }\n\n  /**\n   * Configure this writer to emit JSON that's safe for direct inclusion in HTML\n   * and XML documents. This escapes the HTML characters {@code <}, {@code >},\n   * {@code &} and {@code =} before writing them to the stream. Without this\n   * setting, your XML/HTML encoder should replace these characters with the\n   * corresponding escape sequences.\n   */\n  public final void setHtmlSafe(boolean htmlSafe) {\n    this.htmlSafe = htmlSafe;\n  }\n\n  /**\n   * Returns true if this writer writes JSON that's safe for inclusion in HTML\n   * and XML documents.\n   */\n  public final boolean isHtmlSafe() {\n    return htmlSafe;\n  }\n\n  /**\n   * Sets whether object members are serialized when their value is null.\n   * This has no impact on array elements. The default is true.\n   */\n  public final void setSerializeNulls(boolean serializeNulls) {\n    this.serializeNulls = serializeNulls;\n  }\n\n  /**\n   * Returns true if object members are serialized when their value is null.\n   * This has no impact on array elements. The default is true.\n   */\n  public final boolean getSerializeNulls() {\n    return serializeNulls;\n  }\n\n  /**\n   * Begins encoding a new array. Each call to this method must be paired with\n   * a call to {@link #endArray}.\n   *\n   * @return this writer.\n   */\n  public JsonWriter beginArray() throws IOException {\n    writeDeferredName();\n    return open(EMPTY_ARRAY, \"[\");\n  }\n\n  /**\n   * Ends encoding the current array.\n   *\n   * @return this writer.\n   */\n  public JsonWriter endArray() throws IOException {\n    return close(EMPTY_ARRAY, NONEMPTY_ARRAY, \"]\");\n  }\n\n  /**\n   * Begins encoding a new object. Each call to this method must be paired\n   * with a call to {@link #endObject}.\n   *\n   * @return this writer.\n   */\n  public JsonWriter beginObject() throws IOException {\n    writeDeferredName();\n    return open(EMPTY_OBJECT, \"{\");\n  }\n\n  /**\n   * Ends encoding the current object.\n   *\n   * @return this writer.\n   */\n  public JsonWriter endObject() throws IOException {\n    return close(EMPTY_OBJECT, NONEMPTY_OBJECT, \"}\");\n  }\n\n  /**\n   * Enters a new scope by appending any necessary whitespace and the given\n   * bracket.\n   */\n  private JsonWriter open(int empty, String openBracket) throws IOException {\n    beforeValue();\n    push(empty);\n    out.write(openBracket);\n    return this;\n  }\n\n  /**\n   * Closes the current scope by appending any necessary whitespace and the\n   * given bracket.\n   */\n  private JsonWriter close(int empty, int nonempty, String closeBracket)\n      throws IOException {\n    int context = peek();\n    if (context != nonempty && context != empty) {\n      throw new IllegalStateException(\"Nesting problem.\");\n    }\n    if (deferredName != null) {\n      throw new IllegalStateException(\"Dangling name: \" + deferredName);\n    }\n\n    stackSize--;\n    if (context == nonempty) {\n      newline();\n    }\n    out.write(closeBracket);\n    return this;\n  }\n\n  private void push(int newTop) {\n    if (stackSize == stack.length) {\n      int[] newStack = new int[stackSize * 2];\n      System.arraycopy(stack, 0, newStack, 0, stackSize);\n      stack = newStack;\n    }\n    stack[stackSize++] = newTop;\n  }\n\n  /**\n   * Returns the value on the top of the stack.\n   */\n  private int peek() {\n    if (stackSize == 0) {\n      throw new IllegalStateException(\"JsonWriter is closed.\");\n    }\n    return stack[stackSize - 1];\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(int topOfStack) {\n    stack[stackSize - 1] = topOfStack;\n  }\n\n  /**\n   * Encodes the property name.\n   *\n   * @param name the name of the forthcoming value. May not be null.\n   * @return this writer.\n   */\n  public JsonWriter name(String name) throws IOException {\n    if (name == null) {\n      throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) {\n      throw new IllegalStateException();\n    }\n    if (stackSize == 0) {\n      throw new IllegalStateException(\"JsonWriter is closed.\");\n    }\n    deferredName = name;\n    return this;\n  }\n\n  private void writeDeferredName() throws IOException {\n    if (deferredName != null) {\n      beforeName();\n      string(deferredName);\n      deferredName = null;\n    }\n  }\n\n  /**\n   * Encodes {@code value}.\n   *\n   * @param value the literal string value, or null to encode a null literal.\n   * @return this writer.\n   */\n  public JsonWriter value(String value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n    writeDeferredName();\n    beforeValue();\n    string(value);\n    return this;\n  }\n\n  /**\n   * Writes {@code value} directly to the writer without quoting or\n   * escaping.\n   *\n   * @param value the literal string value, or null to encode a null literal.\n   * @return this writer.\n   */\n  public JsonWriter jsonValue(String value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n    writeDeferredName();\n    beforeValue();\n    out.append(value);\n    return this;\n  }\n\n  /**\n   * Encodes {@code null}.\n   *\n   * @return this writer.\n   */\n  public JsonWriter nullValue() throws IOException {\n    if (deferredName != null) {\n      if (serializeNulls) {\n        writeDeferredName();\n      } else {\n        deferredName = null;\n        return this; // skip the name and the value\n      }\n    }\n    beforeValue();\n    out.write(\"null\");\n    return this;\n  }\n\n  /**\n   * Encodes {@code value}.\n   *\n   * @return this writer.\n   */\n  public JsonWriter value(boolean value) throws IOException {\n    writeDeferredName();\n    beforeValue();\n    out.write(value ? \"true\" : \"false\");\n    return this;\n  }\n\n  /**\n   * Encodes {@code value}.\n   *\n   * @return this writer.\n   */\n  public JsonWriter value(Boolean value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n    writeDeferredName();\n    beforeValue();\n    out.write(value ? \"true\" : \"false\");\n    return this;\n  }\n\n  /**\n   * Encodes {@code value}.\n   *\n   * @param value a finite value. May not be {@link Double#isNaN() NaNs} or\n   *     {@link Double#isInfinite() infinities}.\n   * @return this writer.\n   */\n  public JsonWriter value(double value) throws IOException {\n    if (Double.isNaN(value) || Double.isInfinite(value)) {\n      throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n    }\n    writeDeferredName();\n    beforeValue();\n    out.append(Double.toString(value));\n    return this;\n  }\n\n  /**\n   * Encodes {@code value}.\n   *\n   * @return this writer.\n   */\n  public JsonWriter value(long value) throws IOException {\n    writeDeferredName();\n    beforeValue();\n    out.write(Long.toString(value));\n    return this;\n  }\n\n  /**\n   * Encodes {@code value}.\n   *\n   * @param value a finite value. May not be {@link Double#isNaN() NaNs} or\n   *     {@link Double#isInfinite() infinities}.\n   * @return this writer.\n   */\n  public JsonWriter value(Number value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n\n    writeDeferredName();\n    String string = value.toString();\n    if (!lenient\n        && (string.equals(\"-Infinity\") || string.equals(\"Infinity\") || string.equals(\"NaN\"))) {\n      throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n    }\n    beforeValue();\n    out.append(string);\n    return this;\n  }\n\n  /**\n   * Ensures all buffered data is written to the underlying {@link Writer}\n   * and flushes that writer.\n   */\n  public void flush() throws IOException {\n    if (stackSize == 0) {\n      throw new IllegalStateException(\"JsonWriter is closed.\");\n    }\n    out.flush();\n  }\n\n  /**\n   * Flushes and closes this writer and the underlying {@link Writer}.\n   *\n   * @throws IOException if the JSON document is incomplete.\n   */\n  public void close() throws IOException {\n    out.close();\n\n    int size = stackSize;\n    if (size > 1 || size == 1 && stack[size - 1] != NONEMPTY_DOCUMENT) {\n      throw new IOException(\"Incomplete document\");\n    }\n    stackSize = 0;\n  }\n\n  private void string(String value) throws IOException {\n    String[] replacements = htmlSafe ? HTML_SAFE_REPLACEMENT_CHARS : REPLACEMENT_CHARS;\n    out.write(\"\\\"\");\n    int last = 0;\n    int length = value.length();\n    for (int i = 0; i < length; i++) {\n      char c = value.charAt(i);\n      String replacement;\n      if (c < 128) {\n        replacement = replacements[c];\n        if (replacement == null) {\n          continue;\n        }\n      } else if (c == '\\u2028') {\n        replacement = \"\\\\u2028\";\n      } else if (c == '\\u2029') {\n        replacement = \"\\\\u2029\";\n      } else {\n        continue;\n      }\n      if (last < i) {\n        out.write(value, last, i - last);\n      }\n      out.write(replacement);\n      last = i + 1;\n    }\n    if (last < length) {\n      out.write(value, last, length - last);\n    }\n    out.write(\"\\\"\");\n  }\n\n  private void newline() throws IOException {\n    if (indent == null) {\n      return;\n    }\n\n    out.write(\"\\n\");\n    for (int i = 1, size = stackSize; i < size; i++) {\n      out.write(indent);\n    }\n  }\n\n  /**\n   * Inserts any necessary separators and whitespace before a name. Also\n   * adjusts the stack to expect the name's value.\n   */\n  private void beforeName() throws IOException {\n    int context = peek();\n    if (context == NONEMPTY_OBJECT) { // first in object\n      out.write(',');\n    } else if (context != EMPTY_OBJECT) { // not in an object!\n      throw new IllegalStateException(\"Nesting problem.\");\n    }\n    newline();\n    replaceTop(DANGLING_NAME);\n  }\n\n  /**\n   * Inserts any necessary separators and whitespace before a literal value,\n   * inline array, or inline object. Also adjusts the stack to expect either a\n   * closing bracket or another element.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private void beforeValue() throws IOException {\n    switch (peek()) {\n    case NONEMPTY_DOCUMENT:\n      if (!lenient) {\n        throw new IllegalStateException(\n            \"JSON must have only one top-level value.\");\n      }\n      // fall-through\n    case EMPTY_DOCUMENT: // first in document\n      replaceTop(NONEMPTY_DOCUMENT);\n      break;\n\n    case EMPTY_ARRAY: // first in array\n      replaceTop(NONEMPTY_ARRAY);\n      newline();\n      break;\n\n    case NONEMPTY_ARRAY: // another in array\n      out.append(',');\n      newline();\n      break;\n\n    case DANGLING_NAME: // value for name\n      out.append(separator);\n      replaceTop(NONEMPTY_OBJECT);\n      break;\n\n    default:\n      throw new IllegalStateException(\"Nesting problem.\");\n    }\n  }\n}\n"}]}
{"project": "Gson", "bug_id": 10, "classes_modified": [{"class_name": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory", "buggy_version": "/*\n * Copyright (C) 2011 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.gson.internal.bind;\n\nimport com.google.gson.FieldNamingStrategy;\nimport com.google.gson.Gson;\nimport com.google.gson.JsonSyntaxException;\nimport com.google.gson.TypeAdapter;\nimport com.google.gson.TypeAdapterFactory;\nimport com.google.gson.annotations.JsonAdapter;\nimport com.google.gson.annotations.SerializedName;\nimport com.google.gson.internal.$Gson$Types;\nimport com.google.gson.internal.ConstructorConstructor;\nimport com.google.gson.internal.Excluder;\nimport com.google.gson.internal.ObjectConstructor;\nimport com.google.gson.internal.Primitives;\nimport com.google.gson.reflect.TypeToken;\nimport com.google.gson.stream.JsonReader;\nimport com.google.gson.stream.JsonToken;\nimport com.google.gson.stream.JsonWriter;\n\nimport java.io.IOException;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Type;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport static com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory.getTypeAdapter;\n\n/**\n * Type adapter that reflects over the fields and methods of a class.\n */\npublic final class ReflectiveTypeAdapterFactory implements TypeAdapterFactory {\n  private final ConstructorConstructor constructorConstructor;\n  private final FieldNamingStrategy fieldNamingPolicy;\n  private final Excluder excluder;\n\n  public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor,\n      FieldNamingStrategy fieldNamingPolicy, Excluder excluder) {\n    this.constructorConstructor = constructorConstructor;\n    this.fieldNamingPolicy = fieldNamingPolicy;\n    this.excluder = excluder;\n  }\n\n  public boolean excludeField(Field f, boolean serialize) {\n    return excludeField(f, serialize, excluder);\n  }\n\n  static boolean excludeField(Field f, boolean serialize, Excluder excluder) {\n    return !excluder.excludeClass(f.getType(), serialize) && !excluder.excludeField(f, serialize);\n  }\n\n  /** first element holds the default name */\n  private List<String> getFieldNames(Field f) {\n    SerializedName annotation = f.getAnnotation(SerializedName.class);\n    if (annotation == null) {\n      String name = fieldNamingPolicy.translateName(f);\n      return Collections.singletonList(name);\n    }\n\n    String serializedName = annotation.value();\n    String[] alternates = annotation.alternate();\n    if (alternates.length == 0) {\n      return Collections.singletonList(serializedName);\n    }\n\n    List<String> fieldNames = new ArrayList<String>(alternates.length + 1);\n    fieldNames.add(serializedName);\n    for (String alternate : alternates) {\n      fieldNames.add(alternate);\n    }\n    return fieldNames;\n  }\n\n  @Override public <T> TypeAdapter<T> create(Gson gson, final TypeToken<T> type) {\n    Class<? super T> raw = type.getRawType();\n\n    if (!Object.class.isAssignableFrom(raw)) {\n      return null; // it's a primitive!\n    }\n\n    ObjectConstructor<T> constructor = constructorConstructor.get(type);\n    return new Adapter<T>(constructor, getBoundFields(gson, type, raw));\n  }\n\n  private ReflectiveTypeAdapterFactory.BoundField createBoundField(\n      final Gson context, final Field field, final String name,\n      final TypeToken<?> fieldType, boolean serialize, boolean deserialize) {\n    final boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());\n    // special casing primitives here saves ~5% on Android...\n    JsonAdapter annotation = field.getAnnotation(JsonAdapter.class);\n    TypeAdapter<?> mapped = null;\n    if (annotation != null) {\n      mapped = getTypeAdapter(constructorConstructor, context, fieldType, annotation);\n    }\n    final boolean jsonAdapterPresent = mapped != null;\n    if (mapped == null) mapped = context.getAdapter(fieldType);\n\n    final TypeAdapter<?> typeAdapter = mapped;\n    return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n      @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // the type adapter and field type always agree\n      @Override void write(JsonWriter writer, Object value)\n          throws IOException, IllegalAccessException {\n        Object fieldValue = field.get(value);\n        TypeAdapter t =\n          new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n        t.write(writer, fieldValue);\n      }\n      @Override void read(JsonReader reader, Object value)\n          throws IOException, IllegalAccessException {\n        Object fieldValue = typeAdapter.read(reader);\n        if (fieldValue != null || !isPrimitive) {\n          field.set(value, fieldValue);\n        }\n      }\n      @Override public boolean writeField(Object value) throws IOException, IllegalAccessException {\n        if (!serialized) return false;\n        Object fieldValue = field.get(value);\n        return fieldValue != value; // avoid recursion for example for Throwable.cause\n      }\n    };\n  }\n\n  private Map<String, BoundField> getBoundFields(Gson context, TypeToken<?> type, Class<?> raw) {\n    Map<String, BoundField> result = new LinkedHashMap<String, BoundField>();\n    if (raw.isInterface()) {\n      return result;\n    }\n\n    Type declaredType = type.getType();\n    while (raw != Object.class) {\n      Field[] fields = raw.getDeclaredFields();\n      for (Field field : fields) {\n        boolean serialize = excludeField(field, true);\n        boolean deserialize = excludeField(field, false);\n        if (!serialize && !deserialize) {\n          continue;\n        }\n        field.setAccessible(true);\n        Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\n        List<String> fieldNames = getFieldNames(field);\n        BoundField previous = null;\n        for (int i = 0; i < fieldNames.size(); ++i) {\n          String name = fieldNames.get(i);\n          if (i != 0) serialize = false; // only serialize the default name\n          BoundField boundField = createBoundField(context, field, name,\n              TypeToken.get(fieldType), serialize, deserialize);\n          BoundField replaced = result.put(name, boundField);\n          if (previous == null) previous = replaced;\n        }\n        if (previous != null) {\n          throw new IllegalArgumentException(declaredType\n              + \" declares multiple JSON fields named \" + previous.name);\n        }\n      }\n      type = TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\n      raw = type.getRawType();\n    }\n    return result;\n  }\n\n  static abstract class BoundField {\n    final String name;\n    final boolean serialized;\n    final boolean deserialized;\n\n    protected BoundField(String name, boolean serialized, boolean deserialized) {\n      this.name = name;\n      this.serialized = serialized;\n      this.deserialized = deserialized;\n    }\n    abstract boolean writeField(Object value) throws IOException, IllegalAccessException;\n    abstract void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException;\n    abstract void read(JsonReader reader, Object value) throws IOException, IllegalAccessException;\n  }\n\n  public static final class Adapter<T> extends TypeAdapter<T> {\n    private final ObjectConstructor<T> constructor;\n    private final Map<String, BoundField> boundFields;\n\n    Adapter(ObjectConstructor<T> constructor, Map<String, BoundField> boundFields) {\n      this.constructor = constructor;\n      this.boundFields = boundFields;\n    }\n\n    @Override public T read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n\n      T instance = constructor.construct();\n\n      try {\n        in.beginObject();\n        while (in.hasNext()) {\n          String name = in.nextName();\n          BoundField field = boundFields.get(name);\n          if (field == null || !field.deserialized) {\n            in.skipValue();\n          } else {\n            field.read(in, instance);\n          }\n        }\n      } catch (IllegalStateException e) {\n        throw new JsonSyntaxException(e);\n      } catch (IllegalAccessException e) {\n        throw new AssertionError(e);\n      }\n      in.endObject();\n      return instance;\n    }\n\n    @Override public void write(JsonWriter out, T value) throws IOException {\n      if (value == null) {\n        out.nullValue();\n        return;\n      }\n\n      out.beginObject();\n      try {\n        for (BoundField boundField : boundFields.values()) {\n          if (boundField.writeField(value)) {\n            out.name(boundField.name);\n            boundField.write(out, value);\n          }\n        }\n      } catch (IllegalAccessException e) {\n        throw new AssertionError(e);\n      }\n      out.endObject();\n    }\n  }\n}\n", "fixed_version": "/*\n * Copyright (C) 2011 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.gson.internal.bind;\n\nimport com.google.gson.FieldNamingStrategy;\nimport com.google.gson.Gson;\nimport com.google.gson.JsonSyntaxException;\nimport com.google.gson.TypeAdapter;\nimport com.google.gson.TypeAdapterFactory;\nimport com.google.gson.annotations.JsonAdapter;\nimport com.google.gson.annotations.SerializedName;\nimport com.google.gson.internal.$Gson$Types;\nimport com.google.gson.internal.ConstructorConstructor;\nimport com.google.gson.internal.Excluder;\nimport com.google.gson.internal.ObjectConstructor;\nimport com.google.gson.internal.Primitives;\nimport com.google.gson.reflect.TypeToken;\nimport com.google.gson.stream.JsonReader;\nimport com.google.gson.stream.JsonToken;\nimport com.google.gson.stream.JsonWriter;\n\nimport java.io.IOException;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Type;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport static com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory.getTypeAdapter;\n\n/**\n * Type adapter that reflects over the fields and methods of a class.\n */\npublic final class ReflectiveTypeAdapterFactory implements TypeAdapterFactory {\n  private final ConstructorConstructor constructorConstructor;\n  private final FieldNamingStrategy fieldNamingPolicy;\n  private final Excluder excluder;\n\n  public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor,\n      FieldNamingStrategy fieldNamingPolicy, Excluder excluder) {\n    this.constructorConstructor = constructorConstructor;\n    this.fieldNamingPolicy = fieldNamingPolicy;\n    this.excluder = excluder;\n  }\n\n  public boolean excludeField(Field f, boolean serialize) {\n    return excludeField(f, serialize, excluder);\n  }\n\n  static boolean excludeField(Field f, boolean serialize, Excluder excluder) {\n    return !excluder.excludeClass(f.getType(), serialize) && !excluder.excludeField(f, serialize);\n  }\n\n  /** first element holds the default name */\n  private List<String> getFieldNames(Field f) {\n    SerializedName annotation = f.getAnnotation(SerializedName.class);\n    if (annotation == null) {\n      String name = fieldNamingPolicy.translateName(f);\n      return Collections.singletonList(name);\n    }\n\n    String serializedName = annotation.value();\n    String[] alternates = annotation.alternate();\n    if (alternates.length == 0) {\n      return Collections.singletonList(serializedName);\n    }\n\n    List<String> fieldNames = new ArrayList<String>(alternates.length + 1);\n    fieldNames.add(serializedName);\n    for (String alternate : alternates) {\n      fieldNames.add(alternate);\n    }\n    return fieldNames;\n  }\n\n  @Override public <T> TypeAdapter<T> create(Gson gson, final TypeToken<T> type) {\n    Class<? super T> raw = type.getRawType();\n\n    if (!Object.class.isAssignableFrom(raw)) {\n      return null; // it's a primitive!\n    }\n\n    ObjectConstructor<T> constructor = constructorConstructor.get(type);\n    return new Adapter<T>(constructor, getBoundFields(gson, type, raw));\n  }\n\n  private ReflectiveTypeAdapterFactory.BoundField createBoundField(\n      final Gson context, final Field field, final String name,\n      final TypeToken<?> fieldType, boolean serialize, boolean deserialize) {\n    final boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());\n    // special casing primitives here saves ~5% on Android...\n    JsonAdapter annotation = field.getAnnotation(JsonAdapter.class);\n    TypeAdapter<?> mapped = null;\n    if (annotation != null) {\n      mapped = getTypeAdapter(constructorConstructor, context, fieldType, annotation);\n    }\n    final boolean jsonAdapterPresent = mapped != null;\n    if (mapped == null) mapped = context.getAdapter(fieldType);\n\n    final TypeAdapter<?> typeAdapter = mapped;\n    return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n      @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // the type adapter and field type always agree\n      @Override void write(JsonWriter writer, Object value)\n          throws IOException, IllegalAccessException {\n        Object fieldValue = field.get(value);\n        TypeAdapter t = jsonAdapterPresent ? typeAdapter\n            : new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n        t.write(writer, fieldValue);\n      }\n      @Override void read(JsonReader reader, Object value)\n          throws IOException, IllegalAccessException {\n        Object fieldValue = typeAdapter.read(reader);\n        if (fieldValue != null || !isPrimitive) {\n          field.set(value, fieldValue);\n        }\n      }\n      @Override public boolean writeField(Object value) throws IOException, IllegalAccessException {\n        if (!serialized) return false;\n        Object fieldValue = field.get(value);\n        return fieldValue != value; // avoid recursion for example for Throwable.cause\n      }\n    };\n  }\n\n  private Map<String, BoundField> getBoundFields(Gson context, TypeToken<?> type, Class<?> raw) {\n    Map<String, BoundField> result = new LinkedHashMap<String, BoundField>();\n    if (raw.isInterface()) {\n      return result;\n    }\n\n    Type declaredType = type.getType();\n    while (raw != Object.class) {\n      Field[] fields = raw.getDeclaredFields();\n      for (Field field : fields) {\n        boolean serialize = excludeField(field, true);\n        boolean deserialize = excludeField(field, false);\n        if (!serialize && !deserialize) {\n          continue;\n        }\n        field.setAccessible(true);\n        Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\n        List<String> fieldNames = getFieldNames(field);\n        BoundField previous = null;\n        for (int i = 0; i < fieldNames.size(); ++i) {\n          String name = fieldNames.get(i);\n          if (i != 0) serialize = false; // only serialize the default name\n          BoundField boundField = createBoundField(context, field, name,\n              TypeToken.get(fieldType), serialize, deserialize);\n          BoundField replaced = result.put(name, boundField);\n          if (previous == null) previous = replaced;\n        }\n        if (previous != null) {\n          throw new IllegalArgumentException(declaredType\n              + \" declares multiple JSON fields named \" + previous.name);\n        }\n      }\n      type = TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\n      raw = type.getRawType();\n    }\n    return result;\n  }\n\n  static abstract class BoundField {\n    final String name;\n    final boolean serialized;\n    final boolean deserialized;\n\n    protected BoundField(String name, boolean serialized, boolean deserialized) {\n      this.name = name;\n      this.serialized = serialized;\n      this.deserialized = deserialized;\n    }\n    abstract boolean writeField(Object value) throws IOException, IllegalAccessException;\n    abstract void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException;\n    abstract void read(JsonReader reader, Object value) throws IOException, IllegalAccessException;\n  }\n\n  public static final class Adapter<T> extends TypeAdapter<T> {\n    private final ObjectConstructor<T> constructor;\n    private final Map<String, BoundField> boundFields;\n\n    Adapter(ObjectConstructor<T> constructor, Map<String, BoundField> boundFields) {\n      this.constructor = constructor;\n      this.boundFields = boundFields;\n    }\n\n    @Override public T read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n\n      T instance = constructor.construct();\n\n      try {\n        in.beginObject();\n        while (in.hasNext()) {\n          String name = in.nextName();\n          BoundField field = boundFields.get(name);\n          if (field == null || !field.deserialized) {\n            in.skipValue();\n          } else {\n            field.read(in, instance);\n          }\n        }\n      } catch (IllegalStateException e) {\n        throw new JsonSyntaxException(e);\n      } catch (IllegalAccessException e) {\n        throw new AssertionError(e);\n      }\n      in.endObject();\n      return instance;\n    }\n\n    @Override public void write(JsonWriter out, T value) throws IOException {\n      if (value == null) {\n        out.nullValue();\n        return;\n      }\n\n      out.beginObject();\n      try {\n        for (BoundField boundField : boundFields.values()) {\n          if (boundField.writeField(value)) {\n            out.name(boundField.name);\n            boundField.write(out, value);\n          }\n        }\n      } catch (IllegalAccessException e) {\n        throw new AssertionError(e);\n      }\n      out.endObject();\n    }\n  }\n}\n"}]}
{"project": "Gson", "bug_id": 11, "classes_modified": [{"class_name": "com.google.gson.internal.bind.TypeAdapters", "buggy_version": "/*\n * Copyright (C) 2011 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.gson.internal.bind;\n\nimport java.io.IOException;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.net.InetAddress;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.sql.Timestamp;\nimport java.util.ArrayList;\nimport java.util.BitSet;\nimport java.util.Calendar;\nimport java.util.Currency;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.StringTokenizer;\nimport java.util.UUID;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicIntegerArray;\n\nimport com.google.gson.Gson;\nimport com.google.gson.JsonArray;\nimport com.google.gson.JsonElement;\nimport com.google.gson.JsonIOException;\nimport com.google.gson.JsonNull;\nimport com.google.gson.JsonObject;\nimport com.google.gson.JsonPrimitive;\nimport com.google.gson.JsonSyntaxException;\nimport com.google.gson.TypeAdapter;\nimport com.google.gson.TypeAdapterFactory;\nimport com.google.gson.annotations.SerializedName;\nimport com.google.gson.internal.LazilyParsedNumber;\nimport com.google.gson.reflect.TypeToken;\nimport com.google.gson.stream.JsonReader;\nimport com.google.gson.stream.JsonToken;\nimport com.google.gson.stream.JsonWriter;\n\n/**\n * Type adapters for basic types.\n */\npublic final class TypeAdapters {\n  private TypeAdapters() {\n    throw new UnsupportedOperationException();\n  }\n\n  @SuppressWarnings(\"rawtypes\")\n  public static final TypeAdapter<Class> CLASS = new TypeAdapter<Class>() {\n    @Override\n    public void write(JsonWriter out, Class value) throws IOException {\n      if (value == null) {\n        out.nullValue();\n      } else {\n        throw new UnsupportedOperationException(\"Attempted to serialize java.lang.Class: \"\n            + value.getName() + \". Forgot to register a type adapter?\");\n      }\n    }\n    @Override\n    public Class read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      } else {\n        throw new UnsupportedOperationException(\n            \"Attempted to deserialize a java.lang.Class. Forgot to register a type adapter?\");\n      }\n    }\n  };\n  public static final TypeAdapterFactory CLASS_FACTORY = newFactory(Class.class, CLASS);\n\n  public static final TypeAdapter<BitSet> BIT_SET = new TypeAdapter<BitSet>() {\n    @Override public BitSet read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n\n      BitSet bitset = new BitSet();\n      in.beginArray();\n      int i = 0;\n      JsonToken tokenType = in.peek();\n      while (tokenType != JsonToken.END_ARRAY) {\n        boolean set;\n        switch (tokenType) {\n        case NUMBER:\n          set = in.nextInt() != 0;\n          break;\n        case BOOLEAN:\n          set = in.nextBoolean();\n          break;\n        case STRING:\n          String stringValue = in.nextString();\n          try {\n            set = Integer.parseInt(stringValue) != 0;\n          } catch (NumberFormatException e) {\n            throw new JsonSyntaxException(\n                \"Error: Expecting: bitset number value (1, 0), Found: \" + stringValue);\n          }\n          break;\n        default:\n          throw new JsonSyntaxException(\"Invalid bitset value type: \" + tokenType);\n        }\n        if (set) {\n          bitset.set(i);\n        }\n        ++i;\n        tokenType = in.peek();\n      }\n      in.endArray();\n      return bitset;\n    }\n\n    @Override public void write(JsonWriter out, BitSet src) throws IOException {\n      if (src == null) {\n        out.nullValue();\n        return;\n      }\n\n      out.beginArray();\n      for (int i = 0; i < src.length(); i++) {\n        int value = (src.get(i)) ? 1 : 0;\n        out.value(value);\n      }\n      out.endArray();\n    }\n  };\n\n  public static final TypeAdapterFactory BIT_SET_FACTORY = newFactory(BitSet.class, BIT_SET);\n\n  public static final TypeAdapter<Boolean> BOOLEAN = new TypeAdapter<Boolean>() {\n    @Override\n    public Boolean read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      } else if (in.peek() == JsonToken.STRING) {\n        // support strings for compatibility with GSON 1.7\n        return Boolean.parseBoolean(in.nextString());\n      }\n      return in.nextBoolean();\n    }\n    @Override\n    public void write(JsonWriter out, Boolean value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  /**\n   * Writes a boolean as a string. Useful for map keys, where booleans aren't\n   * otherwise permitted.\n   */\n  public static final TypeAdapter<Boolean> BOOLEAN_AS_STRING = new TypeAdapter<Boolean>() {\n    @Override public Boolean read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return Boolean.valueOf(in.nextString());\n    }\n\n    @Override public void write(JsonWriter out, Boolean value) throws IOException {\n      out.value(value == null ? \"null\" : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory BOOLEAN_FACTORY\n      = newFactory(boolean.class, Boolean.class, BOOLEAN);\n\n  public static final TypeAdapter<Number> BYTE = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        int intValue = in.nextInt();\n        return (byte) intValue;\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapterFactory BYTE_FACTORY\n      = newFactory(byte.class, Byte.class, BYTE);\n\n  public static final TypeAdapter<Number> SHORT = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return (short) in.nextInt();\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapterFactory SHORT_FACTORY\n      = newFactory(short.class, Short.class, SHORT);\n\n  public static final TypeAdapter<Number> INTEGER = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return in.nextInt();\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n  public static final TypeAdapterFactory INTEGER_FACTORY\n      = newFactory(int.class, Integer.class, INTEGER);\n\n  public static final TypeAdapter<AtomicInteger> ATOMIC_INTEGER = new TypeAdapter<AtomicInteger>() {\n    @Override public AtomicInteger read(JsonReader in) throws IOException {\n      try {\n        return new AtomicInteger(in.nextInt());\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override public void write(JsonWriter out, AtomicInteger value) throws IOException {\n      out.value(value.get());\n    }\n  }.nullSafe();\n  public static final TypeAdapterFactory ATOMIC_INTEGER_FACTORY =\n      newFactory(AtomicInteger.class, TypeAdapters.ATOMIC_INTEGER);\n\n  public static final TypeAdapter<AtomicBoolean> ATOMIC_BOOLEAN = new TypeAdapter<AtomicBoolean>() {\n    @Override public AtomicBoolean read(JsonReader in) throws IOException {\n      return new AtomicBoolean(in.nextBoolean());\n    }\n    @Override public void write(JsonWriter out, AtomicBoolean value) throws IOException {\n      out.value(value.get());\n    }\n  }.nullSafe();\n  public static final TypeAdapterFactory ATOMIC_BOOLEAN_FACTORY =\n      newFactory(AtomicBoolean.class, TypeAdapters.ATOMIC_BOOLEAN);\n\n  public static final TypeAdapter<AtomicIntegerArray> ATOMIC_INTEGER_ARRAY = new TypeAdapter<AtomicIntegerArray>() {\n    @Override public AtomicIntegerArray read(JsonReader in) throws IOException {\n        List<Integer> list = new ArrayList<Integer>();\n        in.beginArray();\n        while (in.hasNext()) {\n          try {\n            int integer = in.nextInt();\n            list.add(integer);\n          } catch (NumberFormatException e) {\n            throw new JsonSyntaxException(e);\n          }\n        }\n        in.endArray();\n        int length = list.size();\n        AtomicIntegerArray array = new AtomicIntegerArray(length);\n        for (int i = 0; i < length; ++i) {\n          array.set(i, list.get(i));\n        }\n        return array;\n    }\n    @Override public void write(JsonWriter out, AtomicIntegerArray value) throws IOException {\n      out.beginArray();\n      for (int i = 0, length = value.length(); i < length; i++) {\n        out.value(value.get(i));\n      }\n      out.endArray();\n    }\n  }.nullSafe();\n  public static final TypeAdapterFactory ATOMIC_INTEGER_ARRAY_FACTORY =\n      newFactory(AtomicIntegerArray.class, TypeAdapters.ATOMIC_INTEGER_ARRAY);\n\n  public static final TypeAdapter<Number> LONG = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return in.nextLong();\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapter<Number> FLOAT = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return (float) in.nextDouble();\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapter<Number> DOUBLE = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return in.nextDouble();\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapter<Number> NUMBER = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      JsonToken jsonToken = in.peek();\n      switch (jsonToken) {\n      case NULL:\n        in.nextNull();\n        return null;\n      case NUMBER:\n        return new LazilyParsedNumber(in.nextString());\n      default:\n        throw new JsonSyntaxException(\"Expecting number, got: \" + jsonToken);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapterFactory NUMBER_FACTORY = newFactory(Number.class, NUMBER);\n\n  public static final TypeAdapter<Character> CHARACTER = new TypeAdapter<Character>() {\n    @Override\n    public Character read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      String str = in.nextString();\n      if (str.length() != 1) {\n        throw new JsonSyntaxException(\"Expecting character, got: \" + str);\n      }\n      return str.charAt(0);\n    }\n    @Override\n    public void write(JsonWriter out, Character value) throws IOException {\n      out.value(value == null ? null : String.valueOf(value));\n    }\n  };\n\n  public static final TypeAdapterFactory CHARACTER_FACTORY\n      = newFactory(char.class, Character.class, CHARACTER);\n\n  public static final TypeAdapter<String> STRING = new TypeAdapter<String>() {\n    @Override\n    public String read(JsonReader in) throws IOException {\n      JsonToken peek = in.peek();\n      if (peek == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      /* coerce booleans to strings for backwards compatibility */\n      if (peek == JsonToken.BOOLEAN) {\n        return Boolean.toString(in.nextBoolean());\n      }\n      return in.nextString();\n    }\n    @Override\n    public void write(JsonWriter out, String value) throws IOException {\n      out.value(value);\n    }\n  };\n  \n  public static final TypeAdapter<BigDecimal> BIG_DECIMAL = new TypeAdapter<BigDecimal>() {\n    @Override public BigDecimal read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return new BigDecimal(in.nextString());\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n\n    @Override public void write(JsonWriter out, BigDecimal value) throws IOException {\n      out.value(value);\n    }\n  };\n  \n  public static final TypeAdapter<BigInteger> BIG_INTEGER = new TypeAdapter<BigInteger>() {\n    @Override public BigInteger read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return new BigInteger(in.nextString());\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n\n    @Override public void write(JsonWriter out, BigInteger value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapterFactory STRING_FACTORY = newFactory(String.class, STRING);\n\n  public static final TypeAdapter<StringBuilder> STRING_BUILDER = new TypeAdapter<StringBuilder>() {\n    @Override\n    public StringBuilder read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return new StringBuilder(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, StringBuilder value) throws IOException {\n      out.value(value == null ? null : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory STRING_BUILDER_FACTORY =\n    newFactory(StringBuilder.class, STRING_BUILDER);\n\n  public static final TypeAdapter<StringBuffer> STRING_BUFFER = new TypeAdapter<StringBuffer>() {\n    @Override\n    public StringBuffer read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return new StringBuffer(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, StringBuffer value) throws IOException {\n      out.value(value == null ? null : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory STRING_BUFFER_FACTORY =\n    newFactory(StringBuffer.class, STRING_BUFFER);\n\n  public static final TypeAdapter<URL> URL = new TypeAdapter<URL>() {\n    @Override\n    public URL read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      String nextString = in.nextString();\n      return \"null\".equals(nextString) ? null : new URL(nextString);\n    }\n    @Override\n    public void write(JsonWriter out, URL value) throws IOException {\n      out.value(value == null ? null : value.toExternalForm());\n    }\n  };\n\n  public static final TypeAdapterFactory URL_FACTORY = newFactory(URL.class, URL);\n\n  public static final TypeAdapter<URI> URI = new TypeAdapter<URI>() {\n    @Override\n    public URI read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        String nextString = in.nextString();\n        return \"null\".equals(nextString) ? null : new URI(nextString);\n      } catch (URISyntaxException e) {\n        throw new JsonIOException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, URI value) throws IOException {\n      out.value(value == null ? null : value.toASCIIString());\n    }\n  };\n\n  public static final TypeAdapterFactory URI_FACTORY = newFactory(URI.class, URI);\n\n  public static final TypeAdapter<InetAddress> INET_ADDRESS = new TypeAdapter<InetAddress>() {\n    @Override\n    public InetAddress read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      // regrettably, this should have included both the host name and the host address\n      return InetAddress.getByName(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, InetAddress value) throws IOException {\n      out.value(value == null ? null : value.getHostAddress());\n    }\n  };\n\n  public static final TypeAdapterFactory INET_ADDRESS_FACTORY =\n    newTypeHierarchyFactory(InetAddress.class, INET_ADDRESS);\n\n  public static final TypeAdapter<UUID> UUID = new TypeAdapter<UUID>() {\n    @Override\n    public UUID read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return java.util.UUID.fromString(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, UUID value) throws IOException {\n      out.value(value == null ? null : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory UUID_FACTORY = newFactory(UUID.class, UUID);\n\n  public static final TypeAdapter<Currency> CURRENCY = new TypeAdapter<Currency>() {\n    @Override\n    public Currency read(JsonReader in) throws IOException {\n      return Currency.getInstance(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, Currency value) throws IOException {\n      out.value(value.getCurrencyCode());\n    }\n  }.nullSafe();\n  public static final TypeAdapterFactory CURRENCY_FACTORY = newFactory(Currency.class, CURRENCY);\n\n  public static final TypeAdapterFactory TIMESTAMP_FACTORY = new TypeAdapterFactory() {\n    @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n    @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n      if (typeToken.getRawType() != Timestamp.class) {\n        return null;\n      }\n\n      final TypeAdapter<Date> dateTypeAdapter = gson.getAdapter(Date.class);\n      return (TypeAdapter<T>) new TypeAdapter<Timestamp>() {\n        @Override public Timestamp read(JsonReader in) throws IOException {\n          Date date = dateTypeAdapter.read(in);\n          return date != null ? new Timestamp(date.getTime()) : null;\n        }\n\n        @Override public void write(JsonWriter out, Timestamp value) throws IOException {\n          dateTypeAdapter.write(out, value);\n        }\n      };\n    }\n  };\n\n  public static final TypeAdapter<Calendar> CALENDAR = new TypeAdapter<Calendar>() {\n    private static final String YEAR = \"year\";\n    private static final String MONTH = \"month\";\n    private static final String DAY_OF_MONTH = \"dayOfMonth\";\n    private static final String HOUR_OF_DAY = \"hourOfDay\";\n    private static final String MINUTE = \"minute\";\n    private static final String SECOND = \"second\";\n\n    @Override\n    public Calendar read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return  null;\n      }\n      in.beginObject();\n      int year = 0;\n      int month = 0;\n      int dayOfMonth = 0;\n      int hourOfDay = 0;\n      int minute = 0;\n      int second = 0;\n      while (in.peek() != JsonToken.END_OBJECT) {\n        String name = in.nextName();\n        int value = in.nextInt();\n        if (YEAR.equals(name)) {\n          year = value;\n        } else if (MONTH.equals(name)) {\n          month = value;\n        } else if (DAY_OF_MONTH.equals(name)) {\n          dayOfMonth = value;\n        } else if (HOUR_OF_DAY.equals(name)) {\n          hourOfDay = value;\n        } else if (MINUTE.equals(name)) {\n          minute = value;\n        } else if (SECOND.equals(name)) {\n          second = value;\n        }\n      }\n      in.endObject();\n      return new GregorianCalendar(year, month, dayOfMonth, hourOfDay, minute, second);\n    }\n\n    @Override\n    public void write(JsonWriter out, Calendar value) throws IOException {\n      if (value == null) {\n        out.nullValue();\n        return;\n      }\n      out.beginObject();\n      out.name(YEAR);\n      out.value(value.get(Calendar.YEAR));\n      out.name(MONTH);\n      out.value(value.get(Calendar.MONTH));\n      out.name(DAY_OF_MONTH);\n      out.value(value.get(Calendar.DAY_OF_MONTH));\n      out.name(HOUR_OF_DAY);\n      out.value(value.get(Calendar.HOUR_OF_DAY));\n      out.name(MINUTE);\n      out.value(value.get(Calendar.MINUTE));\n      out.name(SECOND);\n      out.value(value.get(Calendar.SECOND));\n      out.endObject();\n    }\n  };\n\n  public static final TypeAdapterFactory CALENDAR_FACTORY =\n    newFactoryForMultipleTypes(Calendar.class, GregorianCalendar.class, CALENDAR);\n\n  public static final TypeAdapter<Locale> LOCALE = new TypeAdapter<Locale>() {\n    @Override\n    public Locale read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      String locale = in.nextString();\n      StringTokenizer tokenizer = new StringTokenizer(locale, \"_\");\n      String language = null;\n      String country = null;\n      String variant = null;\n      if (tokenizer.hasMoreElements()) {\n        language = tokenizer.nextToken();\n      }\n      if (tokenizer.hasMoreElements()) {\n        country = tokenizer.nextToken();\n      }\n      if (tokenizer.hasMoreElements()) {\n        variant = tokenizer.nextToken();\n      }\n      if (country == null && variant == null) {\n        return new Locale(language);\n      } else if (variant == null) {\n        return new Locale(language, country);\n      } else {\n        return new Locale(language, country, variant);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Locale value) throws IOException {\n      out.value(value == null ? null : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory LOCALE_FACTORY = newFactory(Locale.class, LOCALE);\n\n  public static final TypeAdapter<JsonElement> JSON_ELEMENT = new TypeAdapter<JsonElement>() {\n    @Override public JsonElement read(JsonReader in) throws IOException {\n      switch (in.peek()) {\n      case STRING:\n        return new JsonPrimitive(in.nextString());\n      case NUMBER:\n        String number = in.nextString();\n        return new JsonPrimitive(new LazilyParsedNumber(number));\n      case BOOLEAN:\n        return new JsonPrimitive(in.nextBoolean());\n      case NULL:\n        in.nextNull();\n        return JsonNull.INSTANCE;\n      case BEGIN_ARRAY:\n        JsonArray array = new JsonArray();\n        in.beginArray();\n        while (in.hasNext()) {\n          array.add(read(in));\n        }\n        in.endArray();\n        return array;\n      case BEGIN_OBJECT:\n        JsonObject object = new JsonObject();\n        in.beginObject();\n        while (in.hasNext()) {\n          object.add(in.nextName(), read(in));\n        }\n        in.endObject();\n        return object;\n      case END_DOCUMENT:\n      case NAME:\n      case END_OBJECT:\n      case END_ARRAY:\n      default:\n        throw new IllegalArgumentException();\n      }\n    }\n\n    @Override public void write(JsonWriter out, JsonElement value) throws IOException {\n      if (value == null || value.isJsonNull()) {\n        out.nullValue();\n      } else if (value.isJsonPrimitive()) {\n        JsonPrimitive primitive = value.getAsJsonPrimitive();\n        if (primitive.isNumber()) {\n          out.value(primitive.getAsNumber());\n        } else if (primitive.isBoolean()) {\n          out.value(primitive.getAsBoolean());\n        } else {\n          out.value(primitive.getAsString());\n        }\n\n      } else if (value.isJsonArray()) {\n        out.beginArray();\n        for (JsonElement e : value.getAsJsonArray()) {\n          write(out, e);\n        }\n        out.endArray();\n\n      } else if (value.isJsonObject()) {\n        out.beginObject();\n        for (Map.Entry<String, JsonElement> e : value.getAsJsonObject().entrySet()) {\n          out.name(e.getKey());\n          write(out, e.getValue());\n        }\n        out.endObject();\n\n      } else {\n        throw new IllegalArgumentException(\"Couldn't write \" + value.getClass());\n      }\n    }\n  };\n\n  public static final TypeAdapterFactory JSON_ELEMENT_FACTORY\n      = newTypeHierarchyFactory(JsonElement.class, JSON_ELEMENT);\n\n  private static final class EnumTypeAdapter<T extends Enum<T>> extends TypeAdapter<T> {\n    private final Map<String, T> nameToConstant = new HashMap<String, T>();\n    private final Map<T, String> constantToName = new HashMap<T, String>();\n\n    public EnumTypeAdapter(Class<T> classOfT) {\n      try {\n        for (T constant : classOfT.getEnumConstants()) {\n          String name = constant.name();\n          SerializedName annotation = classOfT.getField(name).getAnnotation(SerializedName.class);\n          if (annotation != null) {\n            name = annotation.value();\n            for (String alternate : annotation.alternate()) {\n              nameToConstant.put(alternate, constant);\n            }\n          }\n          nameToConstant.put(name, constant);\n          constantToName.put(constant, name);\n        }\n      } catch (NoSuchFieldException e) {\n        throw new AssertionError(e);\n      }\n    }\n    @Override public T read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return nameToConstant.get(in.nextString());\n    }\n\n    @Override public void write(JsonWriter out, T value) throws IOException {\n      out.value(value == null ? null : constantToName.get(value));\n    }\n  }\n\n  public static final TypeAdapterFactory ENUM_FACTORY = new TypeAdapterFactory() {\n    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n    @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n      Class<? super T> rawType = typeToken.getRawType();\n      if (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) {\n        return null;\n      }\n      if (!rawType.isEnum()) {\n        rawType = rawType.getSuperclass(); // handle anonymous subclasses\n      }\n      return (TypeAdapter<T>) new EnumTypeAdapter(rawType);\n    }\n  };\n\n  public static <TT> TypeAdapterFactory newFactory(\n      final TypeToken<TT> type, final TypeAdapter<TT> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n        return typeToken.equals(type) ? (TypeAdapter<T>) typeAdapter : null;\n      }\n    };\n  }\n\n  public static <TT> TypeAdapterFactory newFactory(\n      final Class<TT> type, final TypeAdapter<TT> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n        return typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n      }\n      @Override public String toString() {\n        return \"Factory[type=\" + type.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }\n\n  public static <TT> TypeAdapterFactory newFactory(\n      final Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n        Class<? super T> rawType = typeToken.getRawType();\n        return (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n      }\n      @Override public String toString() {\n        return \"Factory[type=\" + boxed.getName()\n            + \"+\" + unboxed.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }\n\n  public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\n      final Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n        Class<? super T> rawType = typeToken.getRawType();\n        return (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n      }\n      @Override public String toString() {\n        return \"Factory[type=\" + base.getName()\n            + \"+\" + sub.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }\n\n  /**\n   * Returns a factory for all subtypes of {@code typeAdapter}. We do a runtime check to confirm\n   * that the deserialized type matches the type requested.\n   */\n  public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\n      final Class<T1> clazz, final TypeAdapter<T1> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\")\n      @Override public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\n        final Class<? super T2> requestedType = typeToken.getRawType();\n        if (!clazz.isAssignableFrom(requestedType)) {\n          return null;\n        }\n        return (TypeAdapter<T2>) new TypeAdapter<T1>() {\n          @Override public void write(JsonWriter out, T1 value) throws IOException {\n            typeAdapter.write(out, value);\n          }\n\n          @Override public T1 read(JsonReader in) throws IOException {\n            T1 result = typeAdapter.read(in);\n            if (result != null && !requestedType.isInstance(result)) {\n              throw new JsonSyntaxException(\"Expected a \" + requestedType.getName()\n                  + \" but was \" + result.getClass().getName());\n            }\n            return result;\n          }\n        };\n      }\n      @Override public String toString() {\n        return \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }\n}\n", "fixed_version": "/*\n * Copyright (C) 2011 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.gson.internal.bind;\n\nimport java.io.IOException;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.net.InetAddress;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.sql.Timestamp;\nimport java.util.ArrayList;\nimport java.util.BitSet;\nimport java.util.Calendar;\nimport java.util.Currency;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.StringTokenizer;\nimport java.util.UUID;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicIntegerArray;\n\nimport com.google.gson.Gson;\nimport com.google.gson.JsonArray;\nimport com.google.gson.JsonElement;\nimport com.google.gson.JsonIOException;\nimport com.google.gson.JsonNull;\nimport com.google.gson.JsonObject;\nimport com.google.gson.JsonPrimitive;\nimport com.google.gson.JsonSyntaxException;\nimport com.google.gson.TypeAdapter;\nimport com.google.gson.TypeAdapterFactory;\nimport com.google.gson.annotations.SerializedName;\nimport com.google.gson.internal.LazilyParsedNumber;\nimport com.google.gson.reflect.TypeToken;\nimport com.google.gson.stream.JsonReader;\nimport com.google.gson.stream.JsonToken;\nimport com.google.gson.stream.JsonWriter;\n\n/**\n * Type adapters for basic types.\n */\npublic final class TypeAdapters {\n  private TypeAdapters() {\n    throw new UnsupportedOperationException();\n  }\n\n  @SuppressWarnings(\"rawtypes\")\n  public static final TypeAdapter<Class> CLASS = new TypeAdapter<Class>() {\n    @Override\n    public void write(JsonWriter out, Class value) throws IOException {\n      if (value == null) {\n        out.nullValue();\n      } else {\n        throw new UnsupportedOperationException(\"Attempted to serialize java.lang.Class: \"\n            + value.getName() + \". Forgot to register a type adapter?\");\n      }\n    }\n    @Override\n    public Class read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      } else {\n        throw new UnsupportedOperationException(\n            \"Attempted to deserialize a java.lang.Class. Forgot to register a type adapter?\");\n      }\n    }\n  };\n  public static final TypeAdapterFactory CLASS_FACTORY = newFactory(Class.class, CLASS);\n\n  public static final TypeAdapter<BitSet> BIT_SET = new TypeAdapter<BitSet>() {\n    @Override public BitSet read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n\n      BitSet bitset = new BitSet();\n      in.beginArray();\n      int i = 0;\n      JsonToken tokenType = in.peek();\n      while (tokenType != JsonToken.END_ARRAY) {\n        boolean set;\n        switch (tokenType) {\n        case NUMBER:\n          set = in.nextInt() != 0;\n          break;\n        case BOOLEAN:\n          set = in.nextBoolean();\n          break;\n        case STRING:\n          String stringValue = in.nextString();\n          try {\n            set = Integer.parseInt(stringValue) != 0;\n          } catch (NumberFormatException e) {\n            throw new JsonSyntaxException(\n                \"Error: Expecting: bitset number value (1, 0), Found: \" + stringValue);\n          }\n          break;\n        default:\n          throw new JsonSyntaxException(\"Invalid bitset value type: \" + tokenType);\n        }\n        if (set) {\n          bitset.set(i);\n        }\n        ++i;\n        tokenType = in.peek();\n      }\n      in.endArray();\n      return bitset;\n    }\n\n    @Override public void write(JsonWriter out, BitSet src) throws IOException {\n      if (src == null) {\n        out.nullValue();\n        return;\n      }\n\n      out.beginArray();\n      for (int i = 0; i < src.length(); i++) {\n        int value = (src.get(i)) ? 1 : 0;\n        out.value(value);\n      }\n      out.endArray();\n    }\n  };\n\n  public static final TypeAdapterFactory BIT_SET_FACTORY = newFactory(BitSet.class, BIT_SET);\n\n  public static final TypeAdapter<Boolean> BOOLEAN = new TypeAdapter<Boolean>() {\n    @Override\n    public Boolean read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      } else if (in.peek() == JsonToken.STRING) {\n        // support strings for compatibility with GSON 1.7\n        return Boolean.parseBoolean(in.nextString());\n      }\n      return in.nextBoolean();\n    }\n    @Override\n    public void write(JsonWriter out, Boolean value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  /**\n   * Writes a boolean as a string. Useful for map keys, where booleans aren't\n   * otherwise permitted.\n   */\n  public static final TypeAdapter<Boolean> BOOLEAN_AS_STRING = new TypeAdapter<Boolean>() {\n    @Override public Boolean read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return Boolean.valueOf(in.nextString());\n    }\n\n    @Override public void write(JsonWriter out, Boolean value) throws IOException {\n      out.value(value == null ? \"null\" : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory BOOLEAN_FACTORY\n      = newFactory(boolean.class, Boolean.class, BOOLEAN);\n\n  public static final TypeAdapter<Number> BYTE = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        int intValue = in.nextInt();\n        return (byte) intValue;\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapterFactory BYTE_FACTORY\n      = newFactory(byte.class, Byte.class, BYTE);\n\n  public static final TypeAdapter<Number> SHORT = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return (short) in.nextInt();\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapterFactory SHORT_FACTORY\n      = newFactory(short.class, Short.class, SHORT);\n\n  public static final TypeAdapter<Number> INTEGER = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return in.nextInt();\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n  public static final TypeAdapterFactory INTEGER_FACTORY\n      = newFactory(int.class, Integer.class, INTEGER);\n\n  public static final TypeAdapter<AtomicInteger> ATOMIC_INTEGER = new TypeAdapter<AtomicInteger>() {\n    @Override public AtomicInteger read(JsonReader in) throws IOException {\n      try {\n        return new AtomicInteger(in.nextInt());\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override public void write(JsonWriter out, AtomicInteger value) throws IOException {\n      out.value(value.get());\n    }\n  }.nullSafe();\n  public static final TypeAdapterFactory ATOMIC_INTEGER_FACTORY =\n      newFactory(AtomicInteger.class, TypeAdapters.ATOMIC_INTEGER);\n\n  public static final TypeAdapter<AtomicBoolean> ATOMIC_BOOLEAN = new TypeAdapter<AtomicBoolean>() {\n    @Override public AtomicBoolean read(JsonReader in) throws IOException {\n      return new AtomicBoolean(in.nextBoolean());\n    }\n    @Override public void write(JsonWriter out, AtomicBoolean value) throws IOException {\n      out.value(value.get());\n    }\n  }.nullSafe();\n  public static final TypeAdapterFactory ATOMIC_BOOLEAN_FACTORY =\n      newFactory(AtomicBoolean.class, TypeAdapters.ATOMIC_BOOLEAN);\n\n  public static final TypeAdapter<AtomicIntegerArray> ATOMIC_INTEGER_ARRAY = new TypeAdapter<AtomicIntegerArray>() {\n    @Override public AtomicIntegerArray read(JsonReader in) throws IOException {\n        List<Integer> list = new ArrayList<Integer>();\n        in.beginArray();\n        while (in.hasNext()) {\n          try {\n            int integer = in.nextInt();\n            list.add(integer);\n          } catch (NumberFormatException e) {\n            throw new JsonSyntaxException(e);\n          }\n        }\n        in.endArray();\n        int length = list.size();\n        AtomicIntegerArray array = new AtomicIntegerArray(length);\n        for (int i = 0; i < length; ++i) {\n          array.set(i, list.get(i));\n        }\n        return array;\n    }\n    @Override public void write(JsonWriter out, AtomicIntegerArray value) throws IOException {\n      out.beginArray();\n      for (int i = 0, length = value.length(); i < length; i++) {\n        out.value(value.get(i));\n      }\n      out.endArray();\n    }\n  }.nullSafe();\n  public static final TypeAdapterFactory ATOMIC_INTEGER_ARRAY_FACTORY =\n      newFactory(AtomicIntegerArray.class, TypeAdapters.ATOMIC_INTEGER_ARRAY);\n\n  public static final TypeAdapter<Number> LONG = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return in.nextLong();\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapter<Number> FLOAT = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return (float) in.nextDouble();\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapter<Number> DOUBLE = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return in.nextDouble();\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapter<Number> NUMBER = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      JsonToken jsonToken = in.peek();\n      switch (jsonToken) {\n      case NULL:\n        in.nextNull();\n        return null;\n      case NUMBER:\n      case STRING:\n        return new LazilyParsedNumber(in.nextString());\n      default:\n        throw new JsonSyntaxException(\"Expecting number, got: \" + jsonToken);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapterFactory NUMBER_FACTORY = newFactory(Number.class, NUMBER);\n\n  public static final TypeAdapter<Character> CHARACTER = new TypeAdapter<Character>() {\n    @Override\n    public Character read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      String str = in.nextString();\n      if (str.length() != 1) {\n        throw new JsonSyntaxException(\"Expecting character, got: \" + str);\n      }\n      return str.charAt(0);\n    }\n    @Override\n    public void write(JsonWriter out, Character value) throws IOException {\n      out.value(value == null ? null : String.valueOf(value));\n    }\n  };\n\n  public static final TypeAdapterFactory CHARACTER_FACTORY\n      = newFactory(char.class, Character.class, CHARACTER);\n\n  public static final TypeAdapter<String> STRING = new TypeAdapter<String>() {\n    @Override\n    public String read(JsonReader in) throws IOException {\n      JsonToken peek = in.peek();\n      if (peek == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      /* coerce booleans to strings for backwards compatibility */\n      if (peek == JsonToken.BOOLEAN) {\n        return Boolean.toString(in.nextBoolean());\n      }\n      return in.nextString();\n    }\n    @Override\n    public void write(JsonWriter out, String value) throws IOException {\n      out.value(value);\n    }\n  };\n  \n  public static final TypeAdapter<BigDecimal> BIG_DECIMAL = new TypeAdapter<BigDecimal>() {\n    @Override public BigDecimal read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return new BigDecimal(in.nextString());\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n\n    @Override public void write(JsonWriter out, BigDecimal value) throws IOException {\n      out.value(value);\n    }\n  };\n  \n  public static final TypeAdapter<BigInteger> BIG_INTEGER = new TypeAdapter<BigInteger>() {\n    @Override public BigInteger read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        return new BigInteger(in.nextString());\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n\n    @Override public void write(JsonWriter out, BigInteger value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapterFactory STRING_FACTORY = newFactory(String.class, STRING);\n\n  public static final TypeAdapter<StringBuilder> STRING_BUILDER = new TypeAdapter<StringBuilder>() {\n    @Override\n    public StringBuilder read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return new StringBuilder(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, StringBuilder value) throws IOException {\n      out.value(value == null ? null : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory STRING_BUILDER_FACTORY =\n    newFactory(StringBuilder.class, STRING_BUILDER);\n\n  public static final TypeAdapter<StringBuffer> STRING_BUFFER = new TypeAdapter<StringBuffer>() {\n    @Override\n    public StringBuffer read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return new StringBuffer(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, StringBuffer value) throws IOException {\n      out.value(value == null ? null : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory STRING_BUFFER_FACTORY =\n    newFactory(StringBuffer.class, STRING_BUFFER);\n\n  public static final TypeAdapter<URL> URL = new TypeAdapter<URL>() {\n    @Override\n    public URL read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      String nextString = in.nextString();\n      return \"null\".equals(nextString) ? null : new URL(nextString);\n    }\n    @Override\n    public void write(JsonWriter out, URL value) throws IOException {\n      out.value(value == null ? null : value.toExternalForm());\n    }\n  };\n\n  public static final TypeAdapterFactory URL_FACTORY = newFactory(URL.class, URL);\n\n  public static final TypeAdapter<URI> URI = new TypeAdapter<URI>() {\n    @Override\n    public URI read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      try {\n        String nextString = in.nextString();\n        return \"null\".equals(nextString) ? null : new URI(nextString);\n      } catch (URISyntaxException e) {\n        throw new JsonIOException(e);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, URI value) throws IOException {\n      out.value(value == null ? null : value.toASCIIString());\n    }\n  };\n\n  public static final TypeAdapterFactory URI_FACTORY = newFactory(URI.class, URI);\n\n  public static final TypeAdapter<InetAddress> INET_ADDRESS = new TypeAdapter<InetAddress>() {\n    @Override\n    public InetAddress read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      // regrettably, this should have included both the host name and the host address\n      return InetAddress.getByName(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, InetAddress value) throws IOException {\n      out.value(value == null ? null : value.getHostAddress());\n    }\n  };\n\n  public static final TypeAdapterFactory INET_ADDRESS_FACTORY =\n    newTypeHierarchyFactory(InetAddress.class, INET_ADDRESS);\n\n  public static final TypeAdapter<UUID> UUID = new TypeAdapter<UUID>() {\n    @Override\n    public UUID read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return java.util.UUID.fromString(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, UUID value) throws IOException {\n      out.value(value == null ? null : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory UUID_FACTORY = newFactory(UUID.class, UUID);\n\n  public static final TypeAdapter<Currency> CURRENCY = new TypeAdapter<Currency>() {\n    @Override\n    public Currency read(JsonReader in) throws IOException {\n      return Currency.getInstance(in.nextString());\n    }\n    @Override\n    public void write(JsonWriter out, Currency value) throws IOException {\n      out.value(value.getCurrencyCode());\n    }\n  }.nullSafe();\n  public static final TypeAdapterFactory CURRENCY_FACTORY = newFactory(Currency.class, CURRENCY);\n\n  public static final TypeAdapterFactory TIMESTAMP_FACTORY = new TypeAdapterFactory() {\n    @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n    @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n      if (typeToken.getRawType() != Timestamp.class) {\n        return null;\n      }\n\n      final TypeAdapter<Date> dateTypeAdapter = gson.getAdapter(Date.class);\n      return (TypeAdapter<T>) new TypeAdapter<Timestamp>() {\n        @Override public Timestamp read(JsonReader in) throws IOException {\n          Date date = dateTypeAdapter.read(in);\n          return date != null ? new Timestamp(date.getTime()) : null;\n        }\n\n        @Override public void write(JsonWriter out, Timestamp value) throws IOException {\n          dateTypeAdapter.write(out, value);\n        }\n      };\n    }\n  };\n\n  public static final TypeAdapter<Calendar> CALENDAR = new TypeAdapter<Calendar>() {\n    private static final String YEAR = \"year\";\n    private static final String MONTH = \"month\";\n    private static final String DAY_OF_MONTH = \"dayOfMonth\";\n    private static final String HOUR_OF_DAY = \"hourOfDay\";\n    private static final String MINUTE = \"minute\";\n    private static final String SECOND = \"second\";\n\n    @Override\n    public Calendar read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return  null;\n      }\n      in.beginObject();\n      int year = 0;\n      int month = 0;\n      int dayOfMonth = 0;\n      int hourOfDay = 0;\n      int minute = 0;\n      int second = 0;\n      while (in.peek() != JsonToken.END_OBJECT) {\n        String name = in.nextName();\n        int value = in.nextInt();\n        if (YEAR.equals(name)) {\n          year = value;\n        } else if (MONTH.equals(name)) {\n          month = value;\n        } else if (DAY_OF_MONTH.equals(name)) {\n          dayOfMonth = value;\n        } else if (HOUR_OF_DAY.equals(name)) {\n          hourOfDay = value;\n        } else if (MINUTE.equals(name)) {\n          minute = value;\n        } else if (SECOND.equals(name)) {\n          second = value;\n        }\n      }\n      in.endObject();\n      return new GregorianCalendar(year, month, dayOfMonth, hourOfDay, minute, second);\n    }\n\n    @Override\n    public void write(JsonWriter out, Calendar value) throws IOException {\n      if (value == null) {\n        out.nullValue();\n        return;\n      }\n      out.beginObject();\n      out.name(YEAR);\n      out.value(value.get(Calendar.YEAR));\n      out.name(MONTH);\n      out.value(value.get(Calendar.MONTH));\n      out.name(DAY_OF_MONTH);\n      out.value(value.get(Calendar.DAY_OF_MONTH));\n      out.name(HOUR_OF_DAY);\n      out.value(value.get(Calendar.HOUR_OF_DAY));\n      out.name(MINUTE);\n      out.value(value.get(Calendar.MINUTE));\n      out.name(SECOND);\n      out.value(value.get(Calendar.SECOND));\n      out.endObject();\n    }\n  };\n\n  public static final TypeAdapterFactory CALENDAR_FACTORY =\n    newFactoryForMultipleTypes(Calendar.class, GregorianCalendar.class, CALENDAR);\n\n  public static final TypeAdapter<Locale> LOCALE = new TypeAdapter<Locale>() {\n    @Override\n    public Locale read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      String locale = in.nextString();\n      StringTokenizer tokenizer = new StringTokenizer(locale, \"_\");\n      String language = null;\n      String country = null;\n      String variant = null;\n      if (tokenizer.hasMoreElements()) {\n        language = tokenizer.nextToken();\n      }\n      if (tokenizer.hasMoreElements()) {\n        country = tokenizer.nextToken();\n      }\n      if (tokenizer.hasMoreElements()) {\n        variant = tokenizer.nextToken();\n      }\n      if (country == null && variant == null) {\n        return new Locale(language);\n      } else if (variant == null) {\n        return new Locale(language, country);\n      } else {\n        return new Locale(language, country, variant);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Locale value) throws IOException {\n      out.value(value == null ? null : value.toString());\n    }\n  };\n\n  public static final TypeAdapterFactory LOCALE_FACTORY = newFactory(Locale.class, LOCALE);\n\n  public static final TypeAdapter<JsonElement> JSON_ELEMENT = new TypeAdapter<JsonElement>() {\n    @Override public JsonElement read(JsonReader in) throws IOException {\n      switch (in.peek()) {\n      case STRING:\n        return new JsonPrimitive(in.nextString());\n      case NUMBER:\n        String number = in.nextString();\n        return new JsonPrimitive(new LazilyParsedNumber(number));\n      case BOOLEAN:\n        return new JsonPrimitive(in.nextBoolean());\n      case NULL:\n        in.nextNull();\n        return JsonNull.INSTANCE;\n      case BEGIN_ARRAY:\n        JsonArray array = new JsonArray();\n        in.beginArray();\n        while (in.hasNext()) {\n          array.add(read(in));\n        }\n        in.endArray();\n        return array;\n      case BEGIN_OBJECT:\n        JsonObject object = new JsonObject();\n        in.beginObject();\n        while (in.hasNext()) {\n          object.add(in.nextName(), read(in));\n        }\n        in.endObject();\n        return object;\n      case END_DOCUMENT:\n      case NAME:\n      case END_OBJECT:\n      case END_ARRAY:\n      default:\n        throw new IllegalArgumentException();\n      }\n    }\n\n    @Override public void write(JsonWriter out, JsonElement value) throws IOException {\n      if (value == null || value.isJsonNull()) {\n        out.nullValue();\n      } else if (value.isJsonPrimitive()) {\n        JsonPrimitive primitive = value.getAsJsonPrimitive();\n        if (primitive.isNumber()) {\n          out.value(primitive.getAsNumber());\n        } else if (primitive.isBoolean()) {\n          out.value(primitive.getAsBoolean());\n        } else {\n          out.value(primitive.getAsString());\n        }\n\n      } else if (value.isJsonArray()) {\n        out.beginArray();\n        for (JsonElement e : value.getAsJsonArray()) {\n          write(out, e);\n        }\n        out.endArray();\n\n      } else if (value.isJsonObject()) {\n        out.beginObject();\n        for (Map.Entry<String, JsonElement> e : value.getAsJsonObject().entrySet()) {\n          out.name(e.getKey());\n          write(out, e.getValue());\n        }\n        out.endObject();\n\n      } else {\n        throw new IllegalArgumentException(\"Couldn't write \" + value.getClass());\n      }\n    }\n  };\n\n  public static final TypeAdapterFactory JSON_ELEMENT_FACTORY\n      = newTypeHierarchyFactory(JsonElement.class, JSON_ELEMENT);\n\n  private static final class EnumTypeAdapter<T extends Enum<T>> extends TypeAdapter<T> {\n    private final Map<String, T> nameToConstant = new HashMap<String, T>();\n    private final Map<T, String> constantToName = new HashMap<T, String>();\n\n    public EnumTypeAdapter(Class<T> classOfT) {\n      try {\n        for (T constant : classOfT.getEnumConstants()) {\n          String name = constant.name();\n          SerializedName annotation = classOfT.getField(name).getAnnotation(SerializedName.class);\n          if (annotation != null) {\n            name = annotation.value();\n            for (String alternate : annotation.alternate()) {\n              nameToConstant.put(alternate, constant);\n            }\n          }\n          nameToConstant.put(name, constant);\n          constantToName.put(constant, name);\n        }\n      } catch (NoSuchFieldException e) {\n        throw new AssertionError(e);\n      }\n    }\n    @Override public T read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return nameToConstant.get(in.nextString());\n    }\n\n    @Override public void write(JsonWriter out, T value) throws IOException {\n      out.value(value == null ? null : constantToName.get(value));\n    }\n  }\n\n  public static final TypeAdapterFactory ENUM_FACTORY = new TypeAdapterFactory() {\n    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n    @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n      Class<? super T> rawType = typeToken.getRawType();\n      if (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) {\n        return null;\n      }\n      if (!rawType.isEnum()) {\n        rawType = rawType.getSuperclass(); // handle anonymous subclasses\n      }\n      return (TypeAdapter<T>) new EnumTypeAdapter(rawType);\n    }\n  };\n\n  public static <TT> TypeAdapterFactory newFactory(\n      final TypeToken<TT> type, final TypeAdapter<TT> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n        return typeToken.equals(type) ? (TypeAdapter<T>) typeAdapter : null;\n      }\n    };\n  }\n\n  public static <TT> TypeAdapterFactory newFactory(\n      final Class<TT> type, final TypeAdapter<TT> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n        return typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n      }\n      @Override public String toString() {\n        return \"Factory[type=\" + type.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }\n\n  public static <TT> TypeAdapterFactory newFactory(\n      final Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n        Class<? super T> rawType = typeToken.getRawType();\n        return (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n      }\n      @Override public String toString() {\n        return \"Factory[type=\" + boxed.getName()\n            + \"+\" + unboxed.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }\n\n  public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\n      final Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n      @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n        Class<? super T> rawType = typeToken.getRawType();\n        return (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n      }\n      @Override public String toString() {\n        return \"Factory[type=\" + base.getName()\n            + \"+\" + sub.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }\n\n  /**\n   * Returns a factory for all subtypes of {@code typeAdapter}. We do a runtime check to confirm\n   * that the deserialized type matches the type requested.\n   */\n  public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\n      final Class<T1> clazz, final TypeAdapter<T1> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\")\n      @Override public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\n        final Class<? super T2> requestedType = typeToken.getRawType();\n        if (!clazz.isAssignableFrom(requestedType)) {\n          return null;\n        }\n        return (TypeAdapter<T2>) new TypeAdapter<T1>() {\n          @Override public void write(JsonWriter out, T1 value) throws IOException {\n            typeAdapter.write(out, value);\n          }\n\n          @Override public T1 read(JsonReader in) throws IOException {\n            T1 result = typeAdapter.read(in);\n            if (result != null && !requestedType.isInstance(result)) {\n              throw new JsonSyntaxException(\"Expected a \" + requestedType.getName()\n                  + \" but was \" + result.getClass().getName());\n            }\n            return result;\n          }\n        };\n      }\n      @Override public String toString() {\n        return \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }\n}\n"}]}
{"project": "Gson", "bug_id": 12, "classes_modified": [{"class_name": "com.google.gson.internal.bind.JsonTreeReader", "buggy_version": "/*\n * Copyright (C) 2011 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.gson.internal.bind;\n\nimport com.google.gson.JsonArray;\nimport com.google.gson.JsonElement;\nimport com.google.gson.JsonNull;\nimport com.google.gson.JsonObject;\nimport com.google.gson.JsonPrimitive;\nimport com.google.gson.stream.JsonReader;\nimport com.google.gson.stream.JsonToken;\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.util.Iterator;\nimport java.util.Map;\n\n/**\n * This reader walks the elements of a JsonElement as if it was coming from a\n * character stream.\n *\n * @author Jesse Wilson\n */\npublic final class JsonTreeReader extends JsonReader {\n  private static final Reader UNREADABLE_READER = new Reader() {\n    @Override public int read(char[] buffer, int offset, int count) throws IOException {\n      throw new AssertionError();\n    }\n    @Override public void close() throws IOException {\n      throw new AssertionError();\n    }\n  };\n  private static final Object SENTINEL_CLOSED = new Object();\n\n  /*\n   * The nesting stack. Using a manual array rather than an ArrayList saves 20%.\n   */\n  private Object[] stack = new Object[32];\n  private int stackSize = 0;\n\n  /*\n   * The path members. It corresponds directly to stack: At indices where the\n   * stack contains an object (EMPTY_OBJECT, DANGLING_NAME or NONEMPTY_OBJECT),\n   * pathNames contains the name at this scope. Where it contains an array\n   * (EMPTY_ARRAY, NONEMPTY_ARRAY) pathIndices contains the current index in\n   * that array. Otherwise the value is undefined, and we take advantage of that\n   * by incrementing pathIndices when doing so isn't useful.\n   */\n  private String[] pathNames = new String[32];\n  private int[] pathIndices = new int[32];\n\n  public JsonTreeReader(JsonElement element) {\n    super(UNREADABLE_READER);\n    push(element);\n  }\n\n  @Override public void beginArray() throws IOException {\n    expect(JsonToken.BEGIN_ARRAY);\n    JsonArray array = (JsonArray) peekStack();\n    push(array.iterator());\n    pathIndices[stackSize - 1] = 0;\n  }\n\n  @Override public void endArray() throws IOException {\n    expect(JsonToken.END_ARRAY);\n    popStack(); // empty iterator\n    popStack(); // array\n    if (stackSize > 0) {\n      pathIndices[stackSize - 1]++;\n    }\n  }\n\n  @Override public void beginObject() throws IOException {\n    expect(JsonToken.BEGIN_OBJECT);\n    JsonObject object = (JsonObject) peekStack();\n    push(object.entrySet().iterator());\n  }\n\n  @Override public void endObject() throws IOException {\n    expect(JsonToken.END_OBJECT);\n    popStack(); // empty iterator\n    popStack(); // object\n    if (stackSize > 0) {\n      pathIndices[stackSize - 1]++;\n    }\n  }\n\n  @Override public boolean hasNext() throws IOException {\n    JsonToken token = peek();\n    return token != JsonToken.END_OBJECT && token != JsonToken.END_ARRAY;\n  }\n\n  @Override public JsonToken peek() throws IOException {\n    if (stackSize == 0) {\n      return JsonToken.END_DOCUMENT;\n    }\n\n    Object o = peekStack();\n    if (o instanceof Iterator) {\n      boolean isObject = stack[stackSize - 2] instanceof JsonObject;\n      Iterator<?> iterator = (Iterator<?>) o;\n      if (iterator.hasNext()) {\n        if (isObject) {\n          return JsonToken.NAME;\n        } else {\n          push(iterator.next());\n          return peek();\n        }\n      } else {\n        return isObject ? JsonToken.END_OBJECT : JsonToken.END_ARRAY;\n      }\n    } else if (o instanceof JsonObject) {\n      return JsonToken.BEGIN_OBJECT;\n    } else if (o instanceof JsonArray) {\n      return JsonToken.BEGIN_ARRAY;\n    } else if (o instanceof JsonPrimitive) {\n      JsonPrimitive primitive = (JsonPrimitive) o;\n      if (primitive.isString()) {\n        return JsonToken.STRING;\n      } else if (primitive.isBoolean()) {\n        return JsonToken.BOOLEAN;\n      } else if (primitive.isNumber()) {\n        return JsonToken.NUMBER;\n      } else {\n        throw new AssertionError();\n      }\n    } else if (o instanceof JsonNull) {\n      return JsonToken.NULL;\n    } else if (o == SENTINEL_CLOSED) {\n      throw new IllegalStateException(\"JsonReader is closed\");\n    } else {\n      throw new AssertionError();\n    }\n  }\n\n  private Object peekStack() {\n    return stack[stackSize - 1];\n  }\n\n  private Object popStack() {\n    Object result = stack[--stackSize];\n    stack[stackSize] = null;\n    return result;\n  }\n\n  private void expect(JsonToken expected) throws IOException {\n    if (peek() != expected) {\n      throw new IllegalStateException(\n          \"Expected \" + expected + \" but was \" + peek() + locationString());\n    }\n  }\n\n  @Override public String nextName() throws IOException {\n    expect(JsonToken.NAME);\n    Iterator<?> i = (Iterator<?>) peekStack();\n    Map.Entry<?, ?> entry = (Map.Entry<?, ?>) i.next();\n    String result = (String) entry.getKey();\n    pathNames[stackSize - 1] = result;\n    push(entry.getValue());\n    return result;\n  }\n\n  @Override public String nextString() throws IOException {\n    JsonToken token = peek();\n    if (token != JsonToken.STRING && token != JsonToken.NUMBER) {\n      throw new IllegalStateException(\n          \"Expected \" + JsonToken.STRING + \" but was \" + token + locationString());\n    }\n    String result = ((JsonPrimitive) popStack()).getAsString();\n    if (stackSize > 0) {\n      pathIndices[stackSize - 1]++;\n    }\n    return result;\n  }\n\n  @Override public boolean nextBoolean() throws IOException {\n    expect(JsonToken.BOOLEAN);\n    boolean result = ((JsonPrimitive) popStack()).getAsBoolean();\n    if (stackSize > 0) {\n      pathIndices[stackSize - 1]++;\n    }\n    return result;\n  }\n\n  @Override public void nextNull() throws IOException {\n    expect(JsonToken.NULL);\n    popStack();\n    if (stackSize > 0) {\n      pathIndices[stackSize - 1]++;\n    }\n  }\n\n  @Override public double nextDouble() throws IOException {\n    JsonToken token = peek();\n    if (token != JsonToken.NUMBER && token != JsonToken.STRING) {\n      throw new IllegalStateException(\n          \"Expected \" + JsonToken.NUMBER + \" but was \" + token + locationString());\n    }\n    double result = ((JsonPrimitive) peekStack()).getAsDouble();\n    if (!isLenient() && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + result);\n    }\n    popStack();\n    if (stackSize > 0) {\n      pathIndices[stackSize - 1]++;\n    }\n    return result;\n  }\n\n  @Override public long nextLong() throws IOException {\n    JsonToken token = peek();\n    if (token != JsonToken.NUMBER && token != JsonToken.STRING) {\n      throw new IllegalStateException(\n          \"Expected \" + JsonToken.NUMBER + \" but was \" + token + locationString());\n    }\n    long result = ((JsonPrimitive) peekStack()).getAsLong();\n    popStack();\n    if (stackSize > 0) {\n      pathIndices[stackSize - 1]++;\n    }\n    return result;\n  }\n\n  @Override public int nextInt() throws IOException {\n    JsonToken token = peek();\n    if (token != JsonToken.NUMBER && token != JsonToken.STRING) {\n      throw new IllegalStateException(\n          \"Expected \" + JsonToken.NUMBER + \" but was \" + token + locationString());\n    }\n    int result = ((JsonPrimitive) peekStack()).getAsInt();\n    popStack();\n    if (stackSize > 0) {\n      pathIndices[stackSize - 1]++;\n    }\n    return result;\n  }\n\n  @Override public void close() throws IOException {\n    stack = new Object[] { SENTINEL_CLOSED };\n    stackSize = 1;\n  }\n\n  @Override public void skipValue() throws IOException {\n    if (peek() == JsonToken.NAME) {\n      nextName();\n      pathNames[stackSize - 2] = \"null\";\n    } else {\n      popStack();\n        pathNames[stackSize - 1] = \"null\";\n    }\n      pathIndices[stackSize - 1]++;\n  }\n\n  @Override public String toString() {\n    return getClass().getSimpleName();\n  }\n\n  public void promoteNameToValue() throws IOException {\n    expect(JsonToken.NAME);\n    Iterator<?> i = (Iterator<?>) peekStack();\n    Map.Entry<?, ?> entry = (Map.Entry<?, ?>) i.next();\n    push(entry.getValue());\n    push(new JsonPrimitive((String) entry.getKey()));\n  }\n\n  private void push(Object newTop) {\n    if (stackSize == stack.length) {\n      Object[] newStack = new Object[stackSize * 2];\n      int[] newPathIndices = new int[stackSize * 2];\n      String[] newPathNames = new String[stackSize * 2];\n      System.arraycopy(stack, 0, newStack, 0, stackSize);\n      System.arraycopy(pathIndices, 0, newPathIndices, 0, stackSize);\n      System.arraycopy(pathNames, 0, newPathNames, 0, stackSize);\n      stack = newStack;\n      pathIndices = newPathIndices;\n      pathNames = newPathNames;\n    }\n    stack[stackSize++] = newTop;\n  }\n\n  @Override public String getPath() {\n    StringBuilder result = new StringBuilder().append('$');\n    for (int i = 0; i < stackSize; i++) {\n      if (stack[i] instanceof JsonArray) {\n        if (stack[++i] instanceof Iterator) {\n          result.append('[').append(pathIndices[i]).append(']');\n        }\n      } else if (stack[i] instanceof JsonObject) {\n        if (stack[++i] instanceof Iterator) {\n          result.append('.');\n          if (pathNames[i] != null) {\n            result.append(pathNames[i]);\n          }\n        }\n      }\n    }\n    return result.toString();\n  }\n\n  private String locationString() {\n    return \" at path \" + getPath();\n  }\n}\n", "fixed_version": "/*\n * Copyright (C) 2011 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.gson.internal.bind;\n\nimport com.google.gson.JsonArray;\nimport com.google.gson.JsonElement;\nimport com.google.gson.JsonNull;\nimport com.google.gson.JsonObject;\nimport com.google.gson.JsonPrimitive;\nimport com.google.gson.stream.JsonReader;\nimport com.google.gson.stream.JsonToken;\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.util.Iterator;\nimport java.util.Map;\n\n/**\n * This reader walks the elements of a JsonElement as if it was coming from a\n * character stream.\n *\n * @author Jesse Wilson\n */\npublic final class JsonTreeReader extends JsonReader {\n  private static final Reader UNREADABLE_READER = new Reader() {\n    @Override public int read(char[] buffer, int offset, int count) throws IOException {\n      throw new AssertionError();\n    }\n    @Override public void close() throws IOException {\n      throw new AssertionError();\n    }\n  };\n  private static final Object SENTINEL_CLOSED = new Object();\n\n  /*\n   * The nesting stack. Using a manual array rather than an ArrayList saves 20%.\n   */\n  private Object[] stack = new Object[32];\n  private int stackSize = 0;\n\n  /*\n   * The path members. It corresponds directly to stack: At indices where the\n   * stack contains an object (EMPTY_OBJECT, DANGLING_NAME or NONEMPTY_OBJECT),\n   * pathNames contains the name at this scope. Where it contains an array\n   * (EMPTY_ARRAY, NONEMPTY_ARRAY) pathIndices contains the current index in\n   * that array. Otherwise the value is undefined, and we take advantage of that\n   * by incrementing pathIndices when doing so isn't useful.\n   */\n  private String[] pathNames = new String[32];\n  private int[] pathIndices = new int[32];\n\n  public JsonTreeReader(JsonElement element) {\n    super(UNREADABLE_READER);\n    push(element);\n  }\n\n  @Override public void beginArray() throws IOException {\n    expect(JsonToken.BEGIN_ARRAY);\n    JsonArray array = (JsonArray) peekStack();\n    push(array.iterator());\n    pathIndices[stackSize - 1] = 0;\n  }\n\n  @Override public void endArray() throws IOException {\n    expect(JsonToken.END_ARRAY);\n    popStack(); // empty iterator\n    popStack(); // array\n    if (stackSize > 0) {\n      pathIndices[stackSize - 1]++;\n    }\n  }\n\n  @Override public void beginObject() throws IOException {\n    expect(JsonToken.BEGIN_OBJECT);\n    JsonObject object = (JsonObject) peekStack();\n    push(object.entrySet().iterator());\n  }\n\n  @Override public void endObject() throws IOException {\n    expect(JsonToken.END_OBJECT);\n    popStack(); // empty iterator\n    popStack(); // object\n    if (stackSize > 0) {\n      pathIndices[stackSize - 1]++;\n    }\n  }\n\n  @Override public boolean hasNext() throws IOException {\n    JsonToken token = peek();\n    return token != JsonToken.END_OBJECT && token != JsonToken.END_ARRAY;\n  }\n\n  @Override public JsonToken peek() throws IOException {\n    if (stackSize == 0) {\n      return JsonToken.END_DOCUMENT;\n    }\n\n    Object o = peekStack();\n    if (o instanceof Iterator) {\n      boolean isObject = stack[stackSize - 2] instanceof JsonObject;\n      Iterator<?> iterator = (Iterator<?>) o;\n      if (iterator.hasNext()) {\n        if (isObject) {\n          return JsonToken.NAME;\n        } else {\n          push(iterator.next());\n          return peek();\n        }\n      } else {\n        return isObject ? JsonToken.END_OBJECT : JsonToken.END_ARRAY;\n      }\n    } else if (o instanceof JsonObject) {\n      return JsonToken.BEGIN_OBJECT;\n    } else if (o instanceof JsonArray) {\n      return JsonToken.BEGIN_ARRAY;\n    } else if (o instanceof JsonPrimitive) {\n      JsonPrimitive primitive = (JsonPrimitive) o;\n      if (primitive.isString()) {\n        return JsonToken.STRING;\n      } else if (primitive.isBoolean()) {\n        return JsonToken.BOOLEAN;\n      } else if (primitive.isNumber()) {\n        return JsonToken.NUMBER;\n      } else {\n        throw new AssertionError();\n      }\n    } else if (o instanceof JsonNull) {\n      return JsonToken.NULL;\n    } else if (o == SENTINEL_CLOSED) {\n      throw new IllegalStateException(\"JsonReader is closed\");\n    } else {\n      throw new AssertionError();\n    }\n  }\n\n  private Object peekStack() {\n    return stack[stackSize - 1];\n  }\n\n  private Object popStack() {\n    Object result = stack[--stackSize];\n    stack[stackSize] = null;\n    return result;\n  }\n\n  private void expect(JsonToken expected) throws IOException {\n    if (peek() != expected) {\n      throw new IllegalStateException(\n          \"Expected \" + expected + \" but was \" + peek() + locationString());\n    }\n  }\n\n  @Override public String nextName() throws IOException {\n    expect(JsonToken.NAME);\n    Iterator<?> i = (Iterator<?>) peekStack();\n    Map.Entry<?, ?> entry = (Map.Entry<?, ?>) i.next();\n    String result = (String) entry.getKey();\n    pathNames[stackSize - 1] = result;\n    push(entry.getValue());\n    return result;\n  }\n\n  @Override public String nextString() throws IOException {\n    JsonToken token = peek();\n    if (token != JsonToken.STRING && token != JsonToken.NUMBER) {\n      throw new IllegalStateException(\n          \"Expected \" + JsonToken.STRING + \" but was \" + token + locationString());\n    }\n    String result = ((JsonPrimitive) popStack()).getAsString();\n    if (stackSize > 0) {\n      pathIndices[stackSize - 1]++;\n    }\n    return result;\n  }\n\n  @Override public boolean nextBoolean() throws IOException {\n    expect(JsonToken.BOOLEAN);\n    boolean result = ((JsonPrimitive) popStack()).getAsBoolean();\n    if (stackSize > 0) {\n      pathIndices[stackSize - 1]++;\n    }\n    return result;\n  }\n\n  @Override public void nextNull() throws IOException {\n    expect(JsonToken.NULL);\n    popStack();\n    if (stackSize > 0) {\n      pathIndices[stackSize - 1]++;\n    }\n  }\n\n  @Override public double nextDouble() throws IOException {\n    JsonToken token = peek();\n    if (token != JsonToken.NUMBER && token != JsonToken.STRING) {\n      throw new IllegalStateException(\n          \"Expected \" + JsonToken.NUMBER + \" but was \" + token + locationString());\n    }\n    double result = ((JsonPrimitive) peekStack()).getAsDouble();\n    if (!isLenient() && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + result);\n    }\n    popStack();\n    if (stackSize > 0) {\n      pathIndices[stackSize - 1]++;\n    }\n    return result;\n  }\n\n  @Override public long nextLong() throws IOException {\n    JsonToken token = peek();\n    if (token != JsonToken.NUMBER && token != JsonToken.STRING) {\n      throw new IllegalStateException(\n          \"Expected \" + JsonToken.NUMBER + \" but was \" + token + locationString());\n    }\n    long result = ((JsonPrimitive) peekStack()).getAsLong();\n    popStack();\n    if (stackSize > 0) {\n      pathIndices[stackSize - 1]++;\n    }\n    return result;\n  }\n\n  @Override public int nextInt() throws IOException {\n    JsonToken token = peek();\n    if (token != JsonToken.NUMBER && token != JsonToken.STRING) {\n      throw new IllegalStateException(\n          \"Expected \" + JsonToken.NUMBER + \" but was \" + token + locationString());\n    }\n    int result = ((JsonPrimitive) peekStack()).getAsInt();\n    popStack();\n    if (stackSize > 0) {\n      pathIndices[stackSize - 1]++;\n    }\n    return result;\n  }\n\n  @Override public void close() throws IOException {\n    stack = new Object[] { SENTINEL_CLOSED };\n    stackSize = 1;\n  }\n\n  @Override public void skipValue() throws IOException {\n    if (peek() == JsonToken.NAME) {\n      nextName();\n      pathNames[stackSize - 2] = \"null\";\n    } else {\n      popStack();\n      if (stackSize > 0) {\n        pathNames[stackSize - 1] = \"null\";\n      }\n    }\n    if (stackSize > 0) {\n      pathIndices[stackSize - 1]++;\n    }\n  }\n\n  @Override public String toString() {\n    return getClass().getSimpleName();\n  }\n\n  public void promoteNameToValue() throws IOException {\n    expect(JsonToken.NAME);\n    Iterator<?> i = (Iterator<?>) peekStack();\n    Map.Entry<?, ?> entry = (Map.Entry<?, ?>) i.next();\n    push(entry.getValue());\n    push(new JsonPrimitive((String) entry.getKey()));\n  }\n\n  private void push(Object newTop) {\n    if (stackSize == stack.length) {\n      Object[] newStack = new Object[stackSize * 2];\n      int[] newPathIndices = new int[stackSize * 2];\n      String[] newPathNames = new String[stackSize * 2];\n      System.arraycopy(stack, 0, newStack, 0, stackSize);\n      System.arraycopy(pathIndices, 0, newPathIndices, 0, stackSize);\n      System.arraycopy(pathNames, 0, newPathNames, 0, stackSize);\n      stack = newStack;\n      pathIndices = newPathIndices;\n      pathNames = newPathNames;\n    }\n    stack[stackSize++] = newTop;\n  }\n\n  @Override public String getPath() {\n    StringBuilder result = new StringBuilder().append('$');\n    for (int i = 0; i < stackSize; i++) {\n      if (stack[i] instanceof JsonArray) {\n        if (stack[++i] instanceof Iterator) {\n          result.append('[').append(pathIndices[i]).append(']');\n        }\n      } else if (stack[i] instanceof JsonObject) {\n        if (stack[++i] instanceof Iterator) {\n          result.append('.');\n          if (pathNames[i] != null) {\n            result.append(pathNames[i]);\n          }\n        }\n      }\n    }\n    return result.toString();\n  }\n\n  private String locationString() {\n    return \" at path \" + getPath();\n  }\n}\n"}]}
{"project": "Gson", "bug_id": 13, "classes_modified": [{"class_name": "com.google.gson.stream.JsonReader", "buggy_version": "/*\n * Copyright (C) 2010 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.gson.stream;\n\nimport com.google.gson.internal.JsonReaderInternalAccess;\nimport com.google.gson.internal.bind.JsonTreeReader;\nimport java.io.Closeable;\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.io.Reader;\n\n/**\n * Reads a JSON (<a href=\"http://www.ietf.org/rfc/rfc7159.txt\">RFC 7159</a>)\n * encoded value as a stream of tokens. This stream includes both literal\n * values (strings, numbers, booleans, and nulls) as well as the begin and\n * end delimiters of objects and arrays. The tokens are traversed in\n * depth-first order, the same order that they appear in the JSON document.\n * Within JSON objects, name/value pairs are represented by a single token.\n *\n * <h3>Parsing JSON</h3>\n * To create a recursive descent parser for your own JSON streams, first create\n * an entry point method that creates a {@code JsonReader}.\n *\n * <p>Next, create handler methods for each structure in your JSON text. You'll\n * need a method for each object type and for each array type.\n * <ul>\n *   <li>Within <strong>array handling</strong> methods, first call {@link\n *       #beginArray} to consume the array's opening bracket. Then create a\n *       while loop that accumulates values, terminating when {@link #hasNext}\n *       is false. Finally, read the array's closing bracket by calling {@link\n *       #endArray}.\n *   <li>Within <strong>object handling</strong> methods, first call {@link\n *       #beginObject} to consume the object's opening brace. Then create a\n *       while loop that assigns values to local variables based on their name.\n *       This loop should terminate when {@link #hasNext} is false. Finally,\n *       read the object's closing brace by calling {@link #endObject}.\n * </ul>\n * <p>When a nested object or array is encountered, delegate to the\n * corresponding handler method.\n *\n * <p>When an unknown name is encountered, strict parsers should fail with an\n * exception. Lenient parsers should call {@link #skipValue()} to recursively\n * skip the value's nested tokens, which may otherwise conflict.\n *\n * <p>If a value may be null, you should first check using {@link #peek()}.\n * Null literals can be consumed using either {@link #nextNull()} or {@link\n * #skipValue()}.\n *\n * <h3>Example</h3>\n * Suppose we'd like to parse a stream of messages such as the following: <pre> {@code\n * [\n *   {\n *     \"id\": 912345678901,\n *     \"text\": \"How do I read a JSON stream in Java?\",\n *     \"geo\": null,\n *     \"user\": {\n *       \"name\": \"json_newb\",\n *       \"followers_count\": 41\n *      }\n *   },\n *   {\n *     \"id\": 912345678902,\n *     \"text\": \"@json_newb just use JsonReader!\",\n *     \"geo\": [50.454722, -104.606667],\n *     \"user\": {\n *       \"name\": \"jesse\",\n *       \"followers_count\": 2\n *     }\n *   }\n * ]}</pre>\n * This code implements the parser for the above structure: <pre>   {@code\n *\n *   public List<Message> readJsonStream(InputStream in) throws IOException {\n *     JsonReader reader = new JsonReader(new InputStreamReader(in, \"UTF-8\"));\n *     try {\n *       return readMessagesArray(reader);\n *     } finally {\n *       reader.close();\n *     }\n *   }\n *\n *   public List<Message> readMessagesArray(JsonReader reader) throws IOException {\n *     List<Message> messages = new ArrayList<Message>();\n *\n *     reader.beginArray();\n *     while (reader.hasNext()) {\n *       messages.add(readMessage(reader));\n *     }\n *     reader.endArray();\n *     return messages;\n *   }\n *\n *   public Message readMessage(JsonReader reader) throws IOException {\n *     long id = -1;\n *     String text = null;\n *     User user = null;\n *     List<Double> geo = null;\n *\n *     reader.beginObject();\n *     while (reader.hasNext()) {\n *       String name = reader.nextName();\n *       if (name.equals(\"id\")) {\n *         id = reader.nextLong();\n *       } else if (name.equals(\"text\")) {\n *         text = reader.nextString();\n *       } else if (name.equals(\"geo\") && reader.peek() != JsonToken.NULL) {\n *         geo = readDoublesArray(reader);\n *       } else if (name.equals(\"user\")) {\n *         user = readUser(reader);\n *       } else {\n *         reader.skipValue();\n *       }\n *     }\n *     reader.endObject();\n *     return new Message(id, text, user, geo);\n *   }\n *\n *   public List<Double> readDoublesArray(JsonReader reader) throws IOException {\n *     List<Double> doubles = new ArrayList<Double>();\n *\n *     reader.beginArray();\n *     while (reader.hasNext()) {\n *       doubles.add(reader.nextDouble());\n *     }\n *     reader.endArray();\n *     return doubles;\n *   }\n *\n *   public User readUser(JsonReader reader) throws IOException {\n *     String username = null;\n *     int followersCount = -1;\n *\n *     reader.beginObject();\n *     while (reader.hasNext()) {\n *       String name = reader.nextName();\n *       if (name.equals(\"name\")) {\n *         username = reader.nextString();\n *       } else if (name.equals(\"followers_count\")) {\n *         followersCount = reader.nextInt();\n *       } else {\n *         reader.skipValue();\n *       }\n *     }\n *     reader.endObject();\n *     return new User(username, followersCount);\n *   }}</pre>\n *\n * <h3>Number Handling</h3>\n * This reader permits numeric values to be read as strings and string values to\n * be read as numbers. For example, both elements of the JSON array {@code\n * [1, \"1\"]} may be read using either {@link #nextInt} or {@link #nextString}.\n * This behavior is intended to prevent lossy numeric conversions: double is\n * JavaScript's only numeric type and very large values like {@code\n * 9007199254740993} cannot be represented exactly on that platform. To minimize\n * precision loss, extremely large values should be written and read as strings\n * in JSON.\n *\n * <a name=\"nonexecuteprefix\"/><h3>Non-Execute Prefix</h3>\n * Web servers that serve private data using JSON may be vulnerable to <a\n * href=\"http://en.wikipedia.org/wiki/JSON#Cross-site_request_forgery\">Cross-site\n * request forgery</a> attacks. In such an attack, a malicious site gains access\n * to a private JSON file by executing it with an HTML {@code <script>} tag.\n *\n * <p>Prefixing JSON files with <code>\")]}'\\n\"</code> makes them non-executable\n * by {@code <script>} tags, disarming the attack. Since the prefix is malformed\n * JSON, strict parsing fails when it is encountered. This class permits the\n * non-execute prefix when {@link #setLenient(boolean) lenient parsing} is\n * enabled.\n *\n * <p>Each {@code JsonReader} may be used to read a single JSON stream. Instances\n * of this class are not thread safe.\n *\n * @author Jesse Wilson\n * @since 1.6\n */\npublic class JsonReader implements Closeable {\n  /** The only non-execute prefix this parser permits */\n  private static final char[] NON_EXECUTE_PREFIX = \")]}'\\n\".toCharArray();\n  private static final long MIN_INCOMPLETE_INTEGER = Long.MIN_VALUE / 10;\n\n  private static final int PEEKED_NONE = 0;\n  private static final int PEEKED_BEGIN_OBJECT = 1;\n  private static final int PEEKED_END_OBJECT = 2;\n  private static final int PEEKED_BEGIN_ARRAY = 3;\n  private static final int PEEKED_END_ARRAY = 4;\n  private static final int PEEKED_TRUE = 5;\n  private static final int PEEKED_FALSE = 6;\n  private static final int PEEKED_NULL = 7;\n  private static final int PEEKED_SINGLE_QUOTED = 8;\n  private static final int PEEKED_DOUBLE_QUOTED = 9;\n  private static final int PEEKED_UNQUOTED = 10;\n  /** When this is returned, the string value is stored in peekedString. */\n  private static final int PEEKED_BUFFERED = 11;\n  private static final int PEEKED_SINGLE_QUOTED_NAME = 12;\n  private static final int PEEKED_DOUBLE_QUOTED_NAME = 13;\n  private static final int PEEKED_UNQUOTED_NAME = 14;\n  /** When this is returned, the integer value is stored in peekedLong. */\n  private static final int PEEKED_LONG = 15;\n  private static final int PEEKED_NUMBER = 16;\n  private static final int PEEKED_EOF = 17;\n\n  /* State machine when parsing numbers */\n  private static final int NUMBER_CHAR_NONE = 0;\n  private static final int NUMBER_CHAR_SIGN = 1;\n  private static final int NUMBER_CHAR_DIGIT = 2;\n  private static final int NUMBER_CHAR_DECIMAL = 3;\n  private static final int NUMBER_CHAR_FRACTION_DIGIT = 4;\n  private static final int NUMBER_CHAR_EXP_E = 5;\n  private static final int NUMBER_CHAR_EXP_SIGN = 6;\n  private static final int NUMBER_CHAR_EXP_DIGIT = 7;\n\n  /** The input JSON. */\n  private final Reader in;\n\n  /** True to accept non-spec compliant JSON */\n  private boolean lenient = false;\n\n  /**\n   * Use a manual buffer to easily read and unread upcoming characters, and\n   * also so we can create strings without an intermediate StringBuilder.\n   * We decode literals directly out of this buffer, so it must be at least as\n   * long as the longest token that can be reported as a number.\n   */\n  private final char[] buffer = new char[1024];\n  private int pos = 0;\n  private int limit = 0;\n\n  private int lineNumber = 0;\n  private int lineStart = 0;\n\n  int peeked = PEEKED_NONE;\n\n  /**\n   * A peeked value that was composed entirely of digits with an optional\n   * leading dash. Positive values may not have a leading 0.\n   */\n  private long peekedLong;\n\n  /**\n   * The number of characters in a peeked number literal. Increment 'pos' by\n   * this after reading a number.\n   */\n  private int peekedNumberLength;\n\n  /**\n   * A peeked string that should be parsed on the next double, long or string.\n   * This is populated before a numeric value is parsed and used if that parsing\n   * fails.\n   */\n  private String peekedString;\n\n  /*\n   * The nesting stack. Using a manual array rather than an ArrayList saves 20%.\n   */\n  private int[] stack = new int[32];\n  private int stackSize = 0;\n  {\n    stack[stackSize++] = JsonScope.EMPTY_DOCUMENT;\n  }\n\n  /*\n   * The path members. It corresponds directly to stack: At indices where the\n   * stack contains an object (EMPTY_OBJECT, DANGLING_NAME or NONEMPTY_OBJECT),\n   * pathNames contains the name at this scope. Where it contains an array\n   * (EMPTY_ARRAY, NONEMPTY_ARRAY) pathIndices contains the current index in\n   * that array. Otherwise the value is undefined, and we take advantage of that\n   * by incrementing pathIndices when doing so isn't useful.\n   */\n  private String[] pathNames = new String[32];\n  private int[] pathIndices = new int[32];\n\n  /**\n   * Creates a new instance that reads a JSON-encoded stream from {@code in}.\n   */\n  public JsonReader(Reader in) {\n    if (in == null) {\n      throw new NullPointerException(\"in == null\");\n    }\n    this.in = in;\n  }\n\n  /**\n   * Configure this parser to be liberal in what it accepts. By default,\n   * this parser is strict and only accepts JSON as specified by <a\n   * href=\"http://www.ietf.org/rfc/rfc4627.txt\">RFC 4627</a>. Setting the\n   * parser to lenient causes it to ignore the following syntax errors:\n   *\n   * <ul>\n   *   <li>Streams that start with the <a href=\"#nonexecuteprefix\">non-execute\n   *       prefix</a>, <code>\")]}'\\n\"</code>.\n   *   <li>Streams that include multiple top-level values. With strict parsing,\n   *       each stream must contain exactly one top-level value.\n   *   <li>Top-level values of any type. With strict parsing, the top-level\n   *       value must be an object or an array.\n   *   <li>Numbers may be {@link Double#isNaN() NaNs} or {@link\n   *       Double#isInfinite() infinities}.\n   *   <li>End of line comments starting with {@code //} or {@code #} and\n   *       ending with a newline character.\n   *   <li>C-style comments starting with {@code /*} and ending with\n   *       {@code *}{@code /}. Such comments may not be nested.\n   *   <li>Names that are unquoted or {@code 'single quoted'}.\n   *   <li>Strings that are unquoted or {@code 'single quoted'}.\n   *   <li>Array elements separated by {@code ;} instead of {@code ,}.\n   *   <li>Unnecessary array separators. These are interpreted as if null\n   *       was the omitted value.\n   *   <li>Names and values separated by {@code =} or {@code =>} instead of\n   *       {@code :}.\n   *   <li>Name/value pairs separated by {@code ;} instead of {@code ,}.\n   * </ul>\n   */\n  public final void setLenient(boolean lenient) {\n    this.lenient = lenient;\n  }\n\n  /**\n   * Returns true if this parser is liberal in what it accepts.\n   */\n  public final boolean isLenient() {\n    return lenient;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is the\n   * beginning of a new array.\n   */\n  public void beginArray() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_BEGIN_ARRAY) {\n      push(JsonScope.EMPTY_ARRAY);\n      pathIndices[stackSize - 1] = 0;\n      peeked = PEEKED_NONE;\n    } else {\n      throw new IllegalStateException(\"Expected BEGIN_ARRAY but was \" + peek() + locationString());\n    }\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is the\n   * end of the current array.\n   */\n  public void endArray() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_END_ARRAY) {\n      stackSize--;\n      pathIndices[stackSize - 1]++;\n      peeked = PEEKED_NONE;\n    } else {\n      throw new IllegalStateException(\"Expected END_ARRAY but was \" + peek() + locationString());\n    }\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is the\n   * beginning of a new object.\n   */\n  public void beginObject() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_BEGIN_OBJECT) {\n      push(JsonScope.EMPTY_OBJECT);\n      peeked = PEEKED_NONE;\n    } else {\n      throw new IllegalStateException(\"Expected BEGIN_OBJECT but was \" + peek() + locationString());\n    }\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is the\n   * end of the current object.\n   */\n  public void endObject() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_END_OBJECT) {\n      stackSize--;\n      pathNames[stackSize] = null; // Free the last path name so that it can be garbage collected!\n      pathIndices[stackSize - 1]++;\n      peeked = PEEKED_NONE;\n    } else {\n      throw new IllegalStateException(\"Expected END_OBJECT but was \" + peek() + locationString());\n    }\n  }\n\n  /**\n   * Returns true if the current array or object has another element.\n   */\n  public boolean hasNext() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    return p != PEEKED_END_OBJECT && p != PEEKED_END_ARRAY;\n  }\n\n  /**\n   * Returns the type of the next token without consuming it.\n   */\n  public JsonToken peek() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    switch (p) {\n    case PEEKED_BEGIN_OBJECT:\n      return JsonToken.BEGIN_OBJECT;\n    case PEEKED_END_OBJECT:\n      return JsonToken.END_OBJECT;\n    case PEEKED_BEGIN_ARRAY:\n      return JsonToken.BEGIN_ARRAY;\n    case PEEKED_END_ARRAY:\n      return JsonToken.END_ARRAY;\n    case PEEKED_SINGLE_QUOTED_NAME:\n    case PEEKED_DOUBLE_QUOTED_NAME:\n    case PEEKED_UNQUOTED_NAME:\n      return JsonToken.NAME;\n    case PEEKED_TRUE:\n    case PEEKED_FALSE:\n      return JsonToken.BOOLEAN;\n    case PEEKED_NULL:\n      return JsonToken.NULL;\n    case PEEKED_SINGLE_QUOTED:\n    case PEEKED_DOUBLE_QUOTED:\n    case PEEKED_UNQUOTED:\n    case PEEKED_BUFFERED:\n      return JsonToken.STRING;\n    case PEEKED_LONG:\n    case PEEKED_NUMBER:\n      return JsonToken.NUMBER;\n    case PEEKED_EOF:\n      return JsonToken.END_DOCUMENT;\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  int doPeek() throws IOException {\n    int peekStack = stack[stackSize - 1];\n    if (peekStack == JsonScope.EMPTY_ARRAY) {\n      stack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY;\n    } else if (peekStack == JsonScope.NONEMPTY_ARRAY) {\n      // Look for a comma before the next element.\n      int c = nextNonWhitespace(true);\n      switch (c) {\n      case ']':\n        return peeked = PEEKED_END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    } else if (peekStack == JsonScope.EMPTY_OBJECT || peekStack == JsonScope.NONEMPTY_OBJECT) {\n      stack[stackSize - 1] = JsonScope.DANGLING_NAME;\n      // Look for a comma before the next element.\n      if (peekStack == JsonScope.NONEMPTY_OBJECT) {\n        int c = nextNonWhitespace(true);\n        switch (c) {\n        case '}':\n          return peeked = PEEKED_END_OBJECT;\n        case ';':\n          checkLenient(); // fall-through\n        case ',':\n          break;\n        default:\n          throw syntaxError(\"Unterminated object\");\n        }\n      }\n      int c = nextNonWhitespace(true);\n      switch (c) {\n      case '\"':\n        return peeked = PEEKED_DOUBLE_QUOTED_NAME;\n      case '\\'':\n        checkLenient();\n        return peeked = PEEKED_SINGLE_QUOTED_NAME;\n      case '}':\n        if (peekStack != JsonScope.NONEMPTY_OBJECT) {\n          return peeked = PEEKED_END_OBJECT;\n        } else {\n          throw syntaxError(\"Expected name\");\n        }\n      default:\n        checkLenient();\n        pos--; // Don't consume the first character in an unquoted string.\n        if (isLiteral((char) c)) {\n          return peeked = PEEKED_UNQUOTED_NAME;\n        } else {\n          throw syntaxError(\"Expected name\");\n        }\n      }\n    } else if (peekStack == JsonScope.DANGLING_NAME) {\n      stack[stackSize - 1] = JsonScope.NONEMPTY_OBJECT;\n      // Look for a colon before the value.\n      int c = nextNonWhitespace(true);\n      switch (c) {\n      case ':':\n        break;\n      case '=':\n        checkLenient();\n        if ((pos < limit || fillBuffer(1)) && buffer[pos] == '>') {\n          pos++;\n        }\n        break;\n      default:\n        throw syntaxError(\"Expected ':'\");\n      }\n    } else if (peekStack == JsonScope.EMPTY_DOCUMENT) {\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      stack[stackSize - 1] = JsonScope.NONEMPTY_DOCUMENT;\n    } else if (peekStack == JsonScope.NONEMPTY_DOCUMENT) {\n      int c = nextNonWhitespace(false);\n      if (c == -1) {\n        return peeked = PEEKED_EOF;\n      } else {\n        checkLenient();\n        pos--;\n      }\n    } else if (peekStack == JsonScope.CLOSED) {\n      throw new IllegalStateException(\"JsonReader is closed\");\n    }\n\n    int c = nextNonWhitespace(true);\n    switch (c) {\n    case ']':\n      if (peekStack == JsonScope.EMPTY_ARRAY) {\n        return peeked = PEEKED_END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      // In lenient mode, a 0-length literal in an array means 'null'.\n      if (peekStack == JsonScope.EMPTY_ARRAY || peekStack == JsonScope.NONEMPTY_ARRAY) {\n        checkLenient();\n        pos--;\n        return peeked = PEEKED_NULL;\n      } else {\n        throw syntaxError(\"Unexpected value\");\n      }\n    case '\\'':\n      checkLenient();\n      return peeked = PEEKED_SINGLE_QUOTED;\n    case '\"':\n      return peeked = PEEKED_DOUBLE_QUOTED;\n    case '[':\n      return peeked = PEEKED_BEGIN_ARRAY;\n    case '{':\n      return peeked = PEEKED_BEGIN_OBJECT;\n    default:\n      pos--; // Don't consume the first character in a literal value.\n    }\n\n    int result = peekKeyword();\n    if (result != PEEKED_NONE) {\n      return result;\n    }\n\n    result = peekNumber();\n    if (result != PEEKED_NONE) {\n      return result;\n    }\n\n    if (!isLiteral(buffer[pos])) {\n      throw syntaxError(\"Expected value\");\n    }\n\n    checkLenient();\n    return peeked = PEEKED_UNQUOTED;\n  }\n\n  private int peekKeyword() throws IOException {\n    // Figure out which keyword we're matching against by its first character.\n    char c = buffer[pos];\n    String keyword;\n    String keywordUpper;\n    int peeking;\n    if (c == 't' || c == 'T') {\n      keyword = \"true\";\n      keywordUpper = \"TRUE\";\n      peeking = PEEKED_TRUE;\n    } else if (c == 'f' || c == 'F') {\n      keyword = \"false\";\n      keywordUpper = \"FALSE\";\n      peeking = PEEKED_FALSE;\n    } else if (c == 'n' || c == 'N') {\n      keyword = \"null\";\n      keywordUpper = \"NULL\";\n      peeking = PEEKED_NULL;\n    } else {\n      return PEEKED_NONE;\n    }\n\n    // Confirm that chars [1..length) match the keyword.\n    int length = keyword.length();\n    for (int i = 1; i < length; i++) {\n      if (pos + i >= limit && !fillBuffer(i + 1)) {\n        return PEEKED_NONE;\n      }\n      c = buffer[pos + i];\n      if (c != keyword.charAt(i) && c != keywordUpper.charAt(i)) {\n        return PEEKED_NONE;\n      }\n    }\n\n    if ((pos + length < limit || fillBuffer(length + 1))\n        && isLiteral(buffer[pos + length])) {\n      return PEEKED_NONE; // Don't match trues, falsey or nullsoft!\n    }\n\n    // We've found the keyword followed either by EOF or by a non-literal character.\n    pos += length;\n    return peeked = peeking;\n  }\n\n  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }\n\n  private boolean isLiteral(char c) throws IOException {\n    switch (c) {\n    case '/':\n    case '\\\\':\n    case ';':\n    case '#':\n    case '=':\n      checkLenient(); // fall-through\n    case '{':\n    case '}':\n    case '[':\n    case ']':\n    case ':':\n    case ',':\n    case ' ':\n    case '\\t':\n    case '\\f':\n    case '\\r':\n    case '\\n':\n      return false;\n    default:\n      return true;\n    }\n  }\n\n  /**\n   * Returns the next token, a {@link com.google.gson.stream.JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws java.io.IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      result = nextQuotedValue('\"');\n    } else {\n      throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathNames[stackSize - 1] = result;\n    return result;\n  }\n\n  /**\n   * Returns the {@link com.google.gson.stream.JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n      result = nextQuotedValue('\"');\n    } else if (p == PEEKED_BUFFERED) {\n      result = peekedString;\n      peekedString = null;\n    } else if (p == PEEKED_LONG) {\n      result = Long.toString(peekedLong);\n    } else if (p == PEEKED_NUMBER) {\n      result = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }\n\n  /**\n   * Returns the {@link com.google.gson.stream.JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    }\n    throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_NULL) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n    } else {\n      throw new IllegalStateException(\"Expected null but was \" + peek() + locationString());\n    }\n  }\n\n  /**\n   * Returns the {@link com.google.gson.stream.JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double using {@link Double#parseDouble(String)}.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    if (p == PEEKED_LONG) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return (double) peekedLong;\n    }\n\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    } else if (p == PEEKED_UNQUOTED) {\n      peekedString = nextUnquotedValue();\n    } else if (p != PEEKED_BUFFERED) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double result = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new MalformedJsonException(\n          \"JSON forbids NaN and infinities: \" + result + locationString());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }\n\n  /**\n   * Returns the {@link com.google.gson.stream.JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    if (p == PEEKED_LONG) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return peekedLong;\n    }\n\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n      if (p == PEEKED_UNQUOTED) {\n        peekedString = nextUnquotedValue();\n      } else {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      }\n      try {\n        long result = Long.parseLong(peekedString);\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n      } catch (NumberFormatException ignored) {\n        // Fall back to parse as a double below.\n      }\n    } else {\n      throw new IllegalStateException(\"Expected a long but was \" + peek() + locationString());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    long result = (long) asDouble;\n    if (result != asDouble) { // Make sure no precision was lost casting to 'long'.\n      throw new NumberFormatException(\"Expected a long but was \" + peekedString + locationString());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }\n\n  /**\n   * Returns the string up to but not including {@code quote}, unescaping any\n   * character escape sequences encountered along the way. The opening quote\n   * should have already been read. This consumes the closing quote, but does\n   * not include it in the returned string.\n   *\n   * @param quote either ' or \".\n   * @throws NumberFormatException if any unicode escape sequences are\n   *     malformed.\n   */\n  private String nextQuotedValue(char quote) throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    StringBuilder builder = null;\n    while (true) {\n      int p = pos;\n      int l = limit;\n      /* the index of the first character not yet appended to the builder. */\n      int start = p;\n      while (p < l) {\n        int c = buffer[p++];\n\n        if (c == quote) {\n          pos = p;\n          int len = p - start - 1;\n          if (builder == null) {\n            return new String(buffer, start, len);\n          } else {\n            builder.append(buffer, start, len);\n            return builder.toString();\n          }\n        } else if (c == '\\\\') {\n          pos = p;\n          int len = p - start - 1;\n          if (builder == null) {\n            int estimatedLength = (len + 1) * 2;\n            builder = new StringBuilder(Math.max(estimatedLength, 16));\n          }\n          builder.append(buffer, start, len);\n          builder.append(readEscapeCharacter());\n          p = pos;\n          l = limit;\n          start = p;\n        } else if (c == '\\n') {\n          lineNumber++;\n          lineStart = p;\n        }\n      }\n\n      if (builder == null) {\n        int estimatedLength = (p - start) * 2;\n        builder = new StringBuilder(Math.max(estimatedLength, 16));\n      }\n      builder.append(buffer, start, p - start);\n      pos = p;\n      if (!fillBuffer(1)) {\n        throw syntaxError(\"Unterminated string\");\n      }\n    }\n  }\n\n  /**\n   * Returns an unquoted value as a string.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private String nextUnquotedValue() throws IOException {\n    StringBuilder builder = null;\n    int i = 0;\n\n    findNonLiteralCharacter:\n    while (true) {\n      for (; pos + i < limit; i++) {\n        switch (buffer[pos + i]) {\n        case '/':\n        case '\\\\':\n        case ';':\n        case '#':\n        case '=':\n          checkLenient(); // fall-through\n        case '{':\n        case '}':\n        case '[':\n        case ']':\n        case ':':\n        case ',':\n        case ' ':\n        case '\\t':\n        case '\\f':\n        case '\\r':\n        case '\\n':\n          break findNonLiteralCharacter;\n        }\n      }\n\n      // Attempt to load the entire literal into the buffer at once.\n      if (i < buffer.length) {\n        if (fillBuffer(i + 1)) {\n          continue;\n        } else {\n          break;\n        }\n      }\n\n      // use a StringBuilder when the value is too long. This is too long to be a number!\n      if (builder == null) {\n        builder = new StringBuilder();\n      }\n      builder.append(buffer, pos, i);\n      pos += i;\n      i = 0;\n      if (!fillBuffer(1)) {\n        break;\n      }\n    }\n\n    String result;\n    if (builder == null) {\n      result = new String(buffer, pos, i);\n    } else {\n      builder.append(buffer, pos, i);\n      result = builder.toString();\n    }\n    pos += i;\n    return result;\n  }\n\n  private void skipQuotedValue(char quote) throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    do {\n      int p = pos;\n      int l = limit;\n      /* the index of the first character not yet appended to the builder. */\n      while (p < l) {\n        int c = buffer[p++];\n        if (c == quote) {\n          pos = p;\n          return;\n        } else if (c == '\\\\') {\n          pos = p;\n          readEscapeCharacter();\n          p = pos;\n          l = limit;\n        } else if (c == '\\n') {\n          lineNumber++;\n          lineStart = p;\n        }\n      }\n      pos = p;\n    } while (fillBuffer(1));\n    throw syntaxError(\"Unterminated string\");\n  }\n\n  private void skipUnquotedValue() throws IOException {\n    do {\n      int i = 0;\n      for (; pos + i < limit; i++) {\n        switch (buffer[pos + i]) {\n        case '/':\n        case '\\\\':\n        case ';':\n        case '#':\n        case '=':\n          checkLenient(); // fall-through\n        case '{':\n        case '}':\n        case '[':\n        case ']':\n        case ':':\n        case ',':\n        case ' ':\n        case '\\t':\n        case '\\f':\n        case '\\r':\n        case '\\n':\n          pos += i;\n          return;\n        }\n      }\n      pos += i;\n    } while (fillBuffer(1));\n  }\n\n  /**\n   * Returns the {@link com.google.gson.stream.JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    int result;\n    if (p == PEEKED_LONG) {\n      result = (int) peekedLong;\n      if (peekedLong != result) { // Make sure no precision was lost casting to 'int'.\n        throw new NumberFormatException(\"Expected an int but was \" + peekedLong + locationString());\n      }\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    }\n\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n      if (p == PEEKED_UNQUOTED) {\n        peekedString = nextUnquotedValue();\n      } else {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      }\n      try {\n        result = Integer.parseInt(peekedString);\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n      } catch (NumberFormatException ignored) {\n        // Fall back to parse as a double below.\n      }\n    } else {\n      throw new IllegalStateException(\"Expected an int but was \" + peek() + locationString());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    result = (int) asDouble;\n    if (result != asDouble) { // Make sure no precision was lost casting to 'int'.\n      throw new NumberFormatException(\"Expected an int but was \" + peekedString + locationString());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link java.io.Reader}.\n   */\n  public void close() throws IOException {\n    peeked = PEEKED_NONE;\n    stack[0] = JsonScope.CLOSED;\n    stackSize = 1;\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    int count = 0;\n    do {\n      int p = peeked;\n      if (p == PEEKED_NONE) {\n        p = doPeek();\n      }\n\n      if (p == PEEKED_BEGIN_ARRAY) {\n        push(JsonScope.EMPTY_ARRAY);\n        count++;\n      } else if (p == PEEKED_BEGIN_OBJECT) {\n        push(JsonScope.EMPTY_OBJECT);\n        count++;\n      } else if (p == PEEKED_END_ARRAY) {\n        stackSize--;\n        count--;\n      } else if (p == PEEKED_END_OBJECT) {\n        stackSize--;\n        count--;\n      } else if (p == PEEKED_UNQUOTED_NAME || p == PEEKED_UNQUOTED) {\n        skipUnquotedValue();\n      } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_SINGLE_QUOTED_NAME) {\n        skipQuotedValue('\\'');\n      } else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_DOUBLE_QUOTED_NAME) {\n        skipQuotedValue('\"');\n      } else if (p == PEEKED_NUMBER) {\n        pos += peekedNumberLength;\n      }\n      peeked = PEEKED_NONE;\n    } while (count != 0);\n\n    pathIndices[stackSize - 1]++;\n    pathNames[stackSize - 1] = \"null\";\n  }\n\n  private void push(int newTop) {\n    if (stackSize == stack.length) {\n      int[] newStack = new int[stackSize * 2];\n      int[] newPathIndices = new int[stackSize * 2];\n      String[] newPathNames = new String[stackSize * 2];\n      System.arraycopy(stack, 0, newStack, 0, stackSize);\n      System.arraycopy(pathIndices, 0, newPathIndices, 0, stackSize);\n      System.arraycopy(pathNames, 0, newPathNames, 0, stackSize);\n      stack = newStack;\n      pathIndices = newPathIndices;\n      pathNames = newPathNames;\n    }\n    stack[stackSize++] = newTop;\n  }\n\n  /**\n   * Returns true once {@code limit - pos >= minimum}. If the data is\n   * exhausted before that many characters are available, this returns\n   * false.\n   */\n  private boolean fillBuffer(int minimum) throws IOException {\n    char[] buffer = this.buffer;\n    lineStart -= pos;\n    if (limit != pos) {\n      limit -= pos;\n      System.arraycopy(buffer, pos, buffer, 0, limit);\n    } else {\n      limit = 0;\n    }\n\n    pos = 0;\n    int total;\n    while ((total = in.read(buffer, limit, buffer.length - limit)) != -1) {\n      limit += total;\n\n      // if this is the first read, consume an optional byte order mark (BOM) if it exists\n      if (lineNumber == 0 && lineStart == 0 && limit > 0 && buffer[0] == '\\ufeff') {\n        pos++;\n        lineStart++;\n        minimum++;\n      }\n\n      if (limit >= minimum) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Returns the next character in the stream that is neither whitespace nor a\n   * part of a comment. When this returns, the returned character is always at\n   * {@code buffer[pos-1]}; this means the caller can always push back the\n   * returned character by decrementing {@code pos}.\n   */\n  private int nextNonWhitespace(boolean throwOnEof) throws IOException {\n    /*\n     * This code uses ugly local variables 'p' and 'l' representing the 'pos'\n     * and 'limit' fields respectively. Using locals rather than fields saves\n     * a few field reads for each whitespace character in a pretty-printed\n     * document, resulting in a 5% speedup. We need to flush 'p' to its field\n     * before any (potentially indirect) call to fillBuffer() and reread both\n     * 'p' and 'l' after any (potentially indirect) call to the same method.\n     */\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n    while (true) {\n      if (p == l) {\n        pos = p;\n        if (!fillBuffer(1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      int c = buffer[p++];\n      if (c == '\\n') {\n        lineNumber++;\n        lineStart = p;\n        continue;\n      } else if (c == ' ' || c == '\\r' || c == '\\t') {\n        continue;\n      }\n\n      if (c == '/') {\n        pos = p;\n        if (p == l) {\n          pos--; // push back '/' so it's still in the buffer when this method returns\n          boolean charsLoaded = fillBuffer(2);\n          pos++; // consume the '/' again\n          if (!charsLoaded) {\n            return c;\n          }\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;\n          if (!skipTo(\"*/\")) {\n            throw syntaxError(\"Unterminated comment\");\n          }\n          p = pos + 2;\n          l = limit;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          p = pos;\n          l = limit;\n          continue;\n\n        default:\n          return c;\n        }\n      } else if (c == '#') {\n        pos = p;\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        p = pos;\n        l = limit;\n      } else {\n        pos = p;\n        return c;\n      }\n    }\n    if (throwOnEof) {\n      throw new EOFException(\"End of input\" + locationString());\n    } else {\n      return -1;\n    }\n  }\n\n  private void checkLenient() throws IOException {\n    if (!lenient) {\n      throw syntaxError(\"Use JsonReader.setLenient(true) to accept malformed JSON\");\n    }\n  }\n\n  /**\n   * Advances the position until after the next newline character. If the line\n   * is terminated by \"\\r\\n\", the '\\n' must be consumed as whitespace by the\n   * caller.\n   */\n  private void skipToEndOfLine() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      char c = buffer[pos++];\n      if (c == '\\n') {\n        lineNumber++;\n        lineStart = pos;\n        break;\n      } else if (c == '\\r') {\n        break;\n      }\n    }\n  }\n\n  /**\n   * @param toFind a string to search for. Must not contain a newline.\n   */\n  private boolean skipTo(String toFind) throws IOException {\n    outer:\n    for (; pos + toFind.length() <= limit || fillBuffer(toFind.length()); pos++) {\n      if (buffer[pos] == '\\n') {\n        lineNumber++;\n        lineStart = pos + 1;\n        continue;\n      }\n      for (int c = 0; c < toFind.length(); c++) {\n        if (buffer[pos + c] != toFind.charAt(c)) {\n          continue outer;\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n\n  @Override public String toString() {\n    return getClass().getSimpleName() + locationString();\n  }\n\n  private String locationString() {\n    int line = lineNumber + 1;\n    int column = pos - lineStart + 1;\n    return \" at line \" + line + \" column \" + column + \" path \" + getPath();\n  }\n\n  /**\n   * Returns a <a href=\"http://goessner.net/articles/JsonPath/\">JsonPath</a> to\n   * the current location in the JSON value.\n   */\n  public String getPath() {\n    StringBuilder result = new StringBuilder().append('$');\n    for (int i = 0, size = stackSize; i < size; i++) {\n      switch (stack[i]) {\n        case JsonScope.EMPTY_ARRAY:\n        case JsonScope.NONEMPTY_ARRAY:\n          result.append('[').append(pathIndices[i]).append(']');\n          break;\n\n        case JsonScope.EMPTY_OBJECT:\n        case JsonScope.DANGLING_NAME:\n        case JsonScope.NONEMPTY_OBJECT:\n          result.append('.');\n          if (pathNames[i] != null) {\n            result.append(pathNames[i]);\n          }\n          break;\n\n        case JsonScope.NONEMPTY_DOCUMENT:\n        case JsonScope.EMPTY_DOCUMENT:\n        case JsonScope.CLOSED:\n          break;\n      }\n    }\n    return result.toString();\n  }\n\n  /**\n   * Unescapes the character identified by the character or characters that\n   * immediately follow a backslash. The backslash '\\' should have already\n   * been read. This supports both unicode escapes \"u000A\" and two-character\n   * escapes \"\\n\".\n   *\n   * @throws NumberFormatException if any unicode escape sequences are\n   *     malformed.\n   */\n  private char readEscapeCharacter() throws IOException {\n    if (pos == limit && !fillBuffer(1)) {\n      throw syntaxError(\"Unterminated escape sequence\");\n    }\n\n    char escaped = buffer[pos++];\n    switch (escaped) {\n    case 'u':\n      if (pos + 4 > limit && !fillBuffer(4)) {\n        throw syntaxError(\"Unterminated escape sequence\");\n      }\n      // Equivalent to Integer.parseInt(stringPool.get(buffer, pos, 4), 16);\n      char result = 0;\n      for (int i = pos, end = i + 4; i < end; i++) {\n        char c = buffer[i];\n        result <<= 4;\n        if (c >= '0' && c <= '9') {\n          result += (c - '0');\n        } else if (c >= 'a' && c <= 'f') {\n          result += (c - 'a' + 10);\n        } else if (c >= 'A' && c <= 'F') {\n          result += (c - 'A' + 10);\n        } else {\n          throw new NumberFormatException(\"\\\\u\" + new String(buffer, pos, 4));\n        }\n      }\n      pos += 4;\n      return result;\n\n    case 't':\n      return '\\t';\n\n    case 'b':\n      return '\\b';\n\n    case 'n':\n      return '\\n';\n\n    case 'r':\n      return '\\r';\n\n    case 'f':\n      return '\\f';\n\n    case '\\n':\n      lineNumber++;\n      lineStart = pos;\n      // fall-through\n\n    case '\\'':\n    case '\"':\n    case '\\\\':\n    case '/':\t\n    \treturn escaped;\n    default:\n    \t// throw error when none of the above cases are matched\n    \tthrow syntaxError(\"Invalid escape sequence\");\n    }\n  }\n\n  /**\n   * Throws a new IO exception with the given message and a context snippet\n   * with this reader's content.\n   */\n  private IOException syntaxError(String message) throws IOException {\n    throw new MalformedJsonException(message + locationString());\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace(true);\n    pos--;\n\n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n\n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n\n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  static {\n    JsonReaderInternalAccess.INSTANCE = new JsonReaderInternalAccess() {\n      @Override public void promoteNameToValue(JsonReader reader) throws IOException {\n        if (reader instanceof JsonTreeReader) {\n          ((JsonTreeReader)reader).promoteNameToValue();\n          return;\n        }\n        int p = reader.peeked;\n        if (p == PEEKED_NONE) {\n          p = reader.doPeek();\n        }\n        if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n          reader.peeked = PEEKED_DOUBLE_QUOTED;\n        } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n          reader.peeked = PEEKED_SINGLE_QUOTED;\n        } else if (p == PEEKED_UNQUOTED_NAME) {\n          reader.peeked = PEEKED_UNQUOTED;\n        } else {\n          throw new IllegalStateException(\n              \"Expected a name but was \" + reader.peek() + reader.locationString());\n        }\n      }\n    };\n  }\n}\n", "fixed_version": "/*\n * Copyright (C) 2010 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.gson.stream;\n\nimport com.google.gson.internal.JsonReaderInternalAccess;\nimport com.google.gson.internal.bind.JsonTreeReader;\nimport java.io.Closeable;\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.io.Reader;\n\n/**\n * Reads a JSON (<a href=\"http://www.ietf.org/rfc/rfc7159.txt\">RFC 7159</a>)\n * encoded value as a stream of tokens. This stream includes both literal\n * values (strings, numbers, booleans, and nulls) as well as the begin and\n * end delimiters of objects and arrays. The tokens are traversed in\n * depth-first order, the same order that they appear in the JSON document.\n * Within JSON objects, name/value pairs are represented by a single token.\n *\n * <h3>Parsing JSON</h3>\n * To create a recursive descent parser for your own JSON streams, first create\n * an entry point method that creates a {@code JsonReader}.\n *\n * <p>Next, create handler methods for each structure in your JSON text. You'll\n * need a method for each object type and for each array type.\n * <ul>\n *   <li>Within <strong>array handling</strong> methods, first call {@link\n *       #beginArray} to consume the array's opening bracket. Then create a\n *       while loop that accumulates values, terminating when {@link #hasNext}\n *       is false. Finally, read the array's closing bracket by calling {@link\n *       #endArray}.\n *   <li>Within <strong>object handling</strong> methods, first call {@link\n *       #beginObject} to consume the object's opening brace. Then create a\n *       while loop that assigns values to local variables based on their name.\n *       This loop should terminate when {@link #hasNext} is false. Finally,\n *       read the object's closing brace by calling {@link #endObject}.\n * </ul>\n * <p>When a nested object or array is encountered, delegate to the\n * corresponding handler method.\n *\n * <p>When an unknown name is encountered, strict parsers should fail with an\n * exception. Lenient parsers should call {@link #skipValue()} to recursively\n * skip the value's nested tokens, which may otherwise conflict.\n *\n * <p>If a value may be null, you should first check using {@link #peek()}.\n * Null literals can be consumed using either {@link #nextNull()} or {@link\n * #skipValue()}.\n *\n * <h3>Example</h3>\n * Suppose we'd like to parse a stream of messages such as the following: <pre> {@code\n * [\n *   {\n *     \"id\": 912345678901,\n *     \"text\": \"How do I read a JSON stream in Java?\",\n *     \"geo\": null,\n *     \"user\": {\n *       \"name\": \"json_newb\",\n *       \"followers_count\": 41\n *      }\n *   },\n *   {\n *     \"id\": 912345678902,\n *     \"text\": \"@json_newb just use JsonReader!\",\n *     \"geo\": [50.454722, -104.606667],\n *     \"user\": {\n *       \"name\": \"jesse\",\n *       \"followers_count\": 2\n *     }\n *   }\n * ]}</pre>\n * This code implements the parser for the above structure: <pre>   {@code\n *\n *   public List<Message> readJsonStream(InputStream in) throws IOException {\n *     JsonReader reader = new JsonReader(new InputStreamReader(in, \"UTF-8\"));\n *     try {\n *       return readMessagesArray(reader);\n *     } finally {\n *       reader.close();\n *     }\n *   }\n *\n *   public List<Message> readMessagesArray(JsonReader reader) throws IOException {\n *     List<Message> messages = new ArrayList<Message>();\n *\n *     reader.beginArray();\n *     while (reader.hasNext()) {\n *       messages.add(readMessage(reader));\n *     }\n *     reader.endArray();\n *     return messages;\n *   }\n *\n *   public Message readMessage(JsonReader reader) throws IOException {\n *     long id = -1;\n *     String text = null;\n *     User user = null;\n *     List<Double> geo = null;\n *\n *     reader.beginObject();\n *     while (reader.hasNext()) {\n *       String name = reader.nextName();\n *       if (name.equals(\"id\")) {\n *         id = reader.nextLong();\n *       } else if (name.equals(\"text\")) {\n *         text = reader.nextString();\n *       } else if (name.equals(\"geo\") && reader.peek() != JsonToken.NULL) {\n *         geo = readDoublesArray(reader);\n *       } else if (name.equals(\"user\")) {\n *         user = readUser(reader);\n *       } else {\n *         reader.skipValue();\n *       }\n *     }\n *     reader.endObject();\n *     return new Message(id, text, user, geo);\n *   }\n *\n *   public List<Double> readDoublesArray(JsonReader reader) throws IOException {\n *     List<Double> doubles = new ArrayList<Double>();\n *\n *     reader.beginArray();\n *     while (reader.hasNext()) {\n *       doubles.add(reader.nextDouble());\n *     }\n *     reader.endArray();\n *     return doubles;\n *   }\n *\n *   public User readUser(JsonReader reader) throws IOException {\n *     String username = null;\n *     int followersCount = -1;\n *\n *     reader.beginObject();\n *     while (reader.hasNext()) {\n *       String name = reader.nextName();\n *       if (name.equals(\"name\")) {\n *         username = reader.nextString();\n *       } else if (name.equals(\"followers_count\")) {\n *         followersCount = reader.nextInt();\n *       } else {\n *         reader.skipValue();\n *       }\n *     }\n *     reader.endObject();\n *     return new User(username, followersCount);\n *   }}</pre>\n *\n * <h3>Number Handling</h3>\n * This reader permits numeric values to be read as strings and string values to\n * be read as numbers. For example, both elements of the JSON array {@code\n * [1, \"1\"]} may be read using either {@link #nextInt} or {@link #nextString}.\n * This behavior is intended to prevent lossy numeric conversions: double is\n * JavaScript's only numeric type and very large values like {@code\n * 9007199254740993} cannot be represented exactly on that platform. To minimize\n * precision loss, extremely large values should be written and read as strings\n * in JSON.\n *\n * <a name=\"nonexecuteprefix\"/><h3>Non-Execute Prefix</h3>\n * Web servers that serve private data using JSON may be vulnerable to <a\n * href=\"http://en.wikipedia.org/wiki/JSON#Cross-site_request_forgery\">Cross-site\n * request forgery</a> attacks. In such an attack, a malicious site gains access\n * to a private JSON file by executing it with an HTML {@code <script>} tag.\n *\n * <p>Prefixing JSON files with <code>\")]}'\\n\"</code> makes them non-executable\n * by {@code <script>} tags, disarming the attack. Since the prefix is malformed\n * JSON, strict parsing fails when it is encountered. This class permits the\n * non-execute prefix when {@link #setLenient(boolean) lenient parsing} is\n * enabled.\n *\n * <p>Each {@code JsonReader} may be used to read a single JSON stream. Instances\n * of this class are not thread safe.\n *\n * @author Jesse Wilson\n * @since 1.6\n */\npublic class JsonReader implements Closeable {\n  /** The only non-execute prefix this parser permits */\n  private static final char[] NON_EXECUTE_PREFIX = \")]}'\\n\".toCharArray();\n  private static final long MIN_INCOMPLETE_INTEGER = Long.MIN_VALUE / 10;\n\n  private static final int PEEKED_NONE = 0;\n  private static final int PEEKED_BEGIN_OBJECT = 1;\n  private static final int PEEKED_END_OBJECT = 2;\n  private static final int PEEKED_BEGIN_ARRAY = 3;\n  private static final int PEEKED_END_ARRAY = 4;\n  private static final int PEEKED_TRUE = 5;\n  private static final int PEEKED_FALSE = 6;\n  private static final int PEEKED_NULL = 7;\n  private static final int PEEKED_SINGLE_QUOTED = 8;\n  private static final int PEEKED_DOUBLE_QUOTED = 9;\n  private static final int PEEKED_UNQUOTED = 10;\n  /** When this is returned, the string value is stored in peekedString. */\n  private static final int PEEKED_BUFFERED = 11;\n  private static final int PEEKED_SINGLE_QUOTED_NAME = 12;\n  private static final int PEEKED_DOUBLE_QUOTED_NAME = 13;\n  private static final int PEEKED_UNQUOTED_NAME = 14;\n  /** When this is returned, the integer value is stored in peekedLong. */\n  private static final int PEEKED_LONG = 15;\n  private static final int PEEKED_NUMBER = 16;\n  private static final int PEEKED_EOF = 17;\n\n  /* State machine when parsing numbers */\n  private static final int NUMBER_CHAR_NONE = 0;\n  private static final int NUMBER_CHAR_SIGN = 1;\n  private static final int NUMBER_CHAR_DIGIT = 2;\n  private static final int NUMBER_CHAR_DECIMAL = 3;\n  private static final int NUMBER_CHAR_FRACTION_DIGIT = 4;\n  private static final int NUMBER_CHAR_EXP_E = 5;\n  private static final int NUMBER_CHAR_EXP_SIGN = 6;\n  private static final int NUMBER_CHAR_EXP_DIGIT = 7;\n\n  /** The input JSON. */\n  private final Reader in;\n\n  /** True to accept non-spec compliant JSON */\n  private boolean lenient = false;\n\n  /**\n   * Use a manual buffer to easily read and unread upcoming characters, and\n   * also so we can create strings without an intermediate StringBuilder.\n   * We decode literals directly out of this buffer, so it must be at least as\n   * long as the longest token that can be reported as a number.\n   */\n  private final char[] buffer = new char[1024];\n  private int pos = 0;\n  private int limit = 0;\n\n  private int lineNumber = 0;\n  private int lineStart = 0;\n\n  int peeked = PEEKED_NONE;\n\n  /**\n   * A peeked value that was composed entirely of digits with an optional\n   * leading dash. Positive values may not have a leading 0.\n   */\n  private long peekedLong;\n\n  /**\n   * The number of characters in a peeked number literal. Increment 'pos' by\n   * this after reading a number.\n   */\n  private int peekedNumberLength;\n\n  /**\n   * A peeked string that should be parsed on the next double, long or string.\n   * This is populated before a numeric value is parsed and used if that parsing\n   * fails.\n   */\n  private String peekedString;\n\n  /*\n   * The nesting stack. Using a manual array rather than an ArrayList saves 20%.\n   */\n  private int[] stack = new int[32];\n  private int stackSize = 0;\n  {\n    stack[stackSize++] = JsonScope.EMPTY_DOCUMENT;\n  }\n\n  /*\n   * The path members. It corresponds directly to stack: At indices where the\n   * stack contains an object (EMPTY_OBJECT, DANGLING_NAME or NONEMPTY_OBJECT),\n   * pathNames contains the name at this scope. Where it contains an array\n   * (EMPTY_ARRAY, NONEMPTY_ARRAY) pathIndices contains the current index in\n   * that array. Otherwise the value is undefined, and we take advantage of that\n   * by incrementing pathIndices when doing so isn't useful.\n   */\n  private String[] pathNames = new String[32];\n  private int[] pathIndices = new int[32];\n\n  /**\n   * Creates a new instance that reads a JSON-encoded stream from {@code in}.\n   */\n  public JsonReader(Reader in) {\n    if (in == null) {\n      throw new NullPointerException(\"in == null\");\n    }\n    this.in = in;\n  }\n\n  /**\n   * Configure this parser to be liberal in what it accepts. By default,\n   * this parser is strict and only accepts JSON as specified by <a\n   * href=\"http://www.ietf.org/rfc/rfc4627.txt\">RFC 4627</a>. Setting the\n   * parser to lenient causes it to ignore the following syntax errors:\n   *\n   * <ul>\n   *   <li>Streams that start with the <a href=\"#nonexecuteprefix\">non-execute\n   *       prefix</a>, <code>\")]}'\\n\"</code>.\n   *   <li>Streams that include multiple top-level values. With strict parsing,\n   *       each stream must contain exactly one top-level value.\n   *   <li>Top-level values of any type. With strict parsing, the top-level\n   *       value must be an object or an array.\n   *   <li>Numbers may be {@link Double#isNaN() NaNs} or {@link\n   *       Double#isInfinite() infinities}.\n   *   <li>End of line comments starting with {@code //} or {@code #} and\n   *       ending with a newline character.\n   *   <li>C-style comments starting with {@code /*} and ending with\n   *       {@code *}{@code /}. Such comments may not be nested.\n   *   <li>Names that are unquoted or {@code 'single quoted'}.\n   *   <li>Strings that are unquoted or {@code 'single quoted'}.\n   *   <li>Array elements separated by {@code ;} instead of {@code ,}.\n   *   <li>Unnecessary array separators. These are interpreted as if null\n   *       was the omitted value.\n   *   <li>Names and values separated by {@code =} or {@code =>} instead of\n   *       {@code :}.\n   *   <li>Name/value pairs separated by {@code ;} instead of {@code ,}.\n   * </ul>\n   */\n  public final void setLenient(boolean lenient) {\n    this.lenient = lenient;\n  }\n\n  /**\n   * Returns true if this parser is liberal in what it accepts.\n   */\n  public final boolean isLenient() {\n    return lenient;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is the\n   * beginning of a new array.\n   */\n  public void beginArray() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_BEGIN_ARRAY) {\n      push(JsonScope.EMPTY_ARRAY);\n      pathIndices[stackSize - 1] = 0;\n      peeked = PEEKED_NONE;\n    } else {\n      throw new IllegalStateException(\"Expected BEGIN_ARRAY but was \" + peek() + locationString());\n    }\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is the\n   * end of the current array.\n   */\n  public void endArray() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_END_ARRAY) {\n      stackSize--;\n      pathIndices[stackSize - 1]++;\n      peeked = PEEKED_NONE;\n    } else {\n      throw new IllegalStateException(\"Expected END_ARRAY but was \" + peek() + locationString());\n    }\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is the\n   * beginning of a new object.\n   */\n  public void beginObject() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_BEGIN_OBJECT) {\n      push(JsonScope.EMPTY_OBJECT);\n      peeked = PEEKED_NONE;\n    } else {\n      throw new IllegalStateException(\"Expected BEGIN_OBJECT but was \" + peek() + locationString());\n    }\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is the\n   * end of the current object.\n   */\n  public void endObject() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_END_OBJECT) {\n      stackSize--;\n      pathNames[stackSize] = null; // Free the last path name so that it can be garbage collected!\n      pathIndices[stackSize - 1]++;\n      peeked = PEEKED_NONE;\n    } else {\n      throw new IllegalStateException(\"Expected END_OBJECT but was \" + peek() + locationString());\n    }\n  }\n\n  /**\n   * Returns true if the current array or object has another element.\n   */\n  public boolean hasNext() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    return p != PEEKED_END_OBJECT && p != PEEKED_END_ARRAY;\n  }\n\n  /**\n   * Returns the type of the next token without consuming it.\n   */\n  public JsonToken peek() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    switch (p) {\n    case PEEKED_BEGIN_OBJECT:\n      return JsonToken.BEGIN_OBJECT;\n    case PEEKED_END_OBJECT:\n      return JsonToken.END_OBJECT;\n    case PEEKED_BEGIN_ARRAY:\n      return JsonToken.BEGIN_ARRAY;\n    case PEEKED_END_ARRAY:\n      return JsonToken.END_ARRAY;\n    case PEEKED_SINGLE_QUOTED_NAME:\n    case PEEKED_DOUBLE_QUOTED_NAME:\n    case PEEKED_UNQUOTED_NAME:\n      return JsonToken.NAME;\n    case PEEKED_TRUE:\n    case PEEKED_FALSE:\n      return JsonToken.BOOLEAN;\n    case PEEKED_NULL:\n      return JsonToken.NULL;\n    case PEEKED_SINGLE_QUOTED:\n    case PEEKED_DOUBLE_QUOTED:\n    case PEEKED_UNQUOTED:\n    case PEEKED_BUFFERED:\n      return JsonToken.STRING;\n    case PEEKED_LONG:\n    case PEEKED_NUMBER:\n      return JsonToken.NUMBER;\n    case PEEKED_EOF:\n      return JsonToken.END_DOCUMENT;\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  int doPeek() throws IOException {\n    int peekStack = stack[stackSize - 1];\n    if (peekStack == JsonScope.EMPTY_ARRAY) {\n      stack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY;\n    } else if (peekStack == JsonScope.NONEMPTY_ARRAY) {\n      // Look for a comma before the next element.\n      int c = nextNonWhitespace(true);\n      switch (c) {\n      case ']':\n        return peeked = PEEKED_END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    } else if (peekStack == JsonScope.EMPTY_OBJECT || peekStack == JsonScope.NONEMPTY_OBJECT) {\n      stack[stackSize - 1] = JsonScope.DANGLING_NAME;\n      // Look for a comma before the next element.\n      if (peekStack == JsonScope.NONEMPTY_OBJECT) {\n        int c = nextNonWhitespace(true);\n        switch (c) {\n        case '}':\n          return peeked = PEEKED_END_OBJECT;\n        case ';':\n          checkLenient(); // fall-through\n        case ',':\n          break;\n        default:\n          throw syntaxError(\"Unterminated object\");\n        }\n      }\n      int c = nextNonWhitespace(true);\n      switch (c) {\n      case '\"':\n        return peeked = PEEKED_DOUBLE_QUOTED_NAME;\n      case '\\'':\n        checkLenient();\n        return peeked = PEEKED_SINGLE_QUOTED_NAME;\n      case '}':\n        if (peekStack != JsonScope.NONEMPTY_OBJECT) {\n          return peeked = PEEKED_END_OBJECT;\n        } else {\n          throw syntaxError(\"Expected name\");\n        }\n      default:\n        checkLenient();\n        pos--; // Don't consume the first character in an unquoted string.\n        if (isLiteral((char) c)) {\n          return peeked = PEEKED_UNQUOTED_NAME;\n        } else {\n          throw syntaxError(\"Expected name\");\n        }\n      }\n    } else if (peekStack == JsonScope.DANGLING_NAME) {\n      stack[stackSize - 1] = JsonScope.NONEMPTY_OBJECT;\n      // Look for a colon before the value.\n      int c = nextNonWhitespace(true);\n      switch (c) {\n      case ':':\n        break;\n      case '=':\n        checkLenient();\n        if ((pos < limit || fillBuffer(1)) && buffer[pos] == '>') {\n          pos++;\n        }\n        break;\n      default:\n        throw syntaxError(\"Expected ':'\");\n      }\n    } else if (peekStack == JsonScope.EMPTY_DOCUMENT) {\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      stack[stackSize - 1] = JsonScope.NONEMPTY_DOCUMENT;\n    } else if (peekStack == JsonScope.NONEMPTY_DOCUMENT) {\n      int c = nextNonWhitespace(false);\n      if (c == -1) {\n        return peeked = PEEKED_EOF;\n      } else {\n        checkLenient();\n        pos--;\n      }\n    } else if (peekStack == JsonScope.CLOSED) {\n      throw new IllegalStateException(\"JsonReader is closed\");\n    }\n\n    int c = nextNonWhitespace(true);\n    switch (c) {\n    case ']':\n      if (peekStack == JsonScope.EMPTY_ARRAY) {\n        return peeked = PEEKED_END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      // In lenient mode, a 0-length literal in an array means 'null'.\n      if (peekStack == JsonScope.EMPTY_ARRAY || peekStack == JsonScope.NONEMPTY_ARRAY) {\n        checkLenient();\n        pos--;\n        return peeked = PEEKED_NULL;\n      } else {\n        throw syntaxError(\"Unexpected value\");\n      }\n    case '\\'':\n      checkLenient();\n      return peeked = PEEKED_SINGLE_QUOTED;\n    case '\"':\n      return peeked = PEEKED_DOUBLE_QUOTED;\n    case '[':\n      return peeked = PEEKED_BEGIN_ARRAY;\n    case '{':\n      return peeked = PEEKED_BEGIN_OBJECT;\n    default:\n      pos--; // Don't consume the first character in a literal value.\n    }\n\n    int result = peekKeyword();\n    if (result != PEEKED_NONE) {\n      return result;\n    }\n\n    result = peekNumber();\n    if (result != PEEKED_NONE) {\n      return result;\n    }\n\n    if (!isLiteral(buffer[pos])) {\n      throw syntaxError(\"Expected value\");\n    }\n\n    checkLenient();\n    return peeked = PEEKED_UNQUOTED;\n  }\n\n  private int peekKeyword() throws IOException {\n    // Figure out which keyword we're matching against by its first character.\n    char c = buffer[pos];\n    String keyword;\n    String keywordUpper;\n    int peeking;\n    if (c == 't' || c == 'T') {\n      keyword = \"true\";\n      keywordUpper = \"TRUE\";\n      peeking = PEEKED_TRUE;\n    } else if (c == 'f' || c == 'F') {\n      keyword = \"false\";\n      keywordUpper = \"FALSE\";\n      peeking = PEEKED_FALSE;\n    } else if (c == 'n' || c == 'N') {\n      keyword = \"null\";\n      keywordUpper = \"NULL\";\n      peeking = PEEKED_NULL;\n    } else {\n      return PEEKED_NONE;\n    }\n\n    // Confirm that chars [1..length) match the keyword.\n    int length = keyword.length();\n    for (int i = 1; i < length; i++) {\n      if (pos + i >= limit && !fillBuffer(i + 1)) {\n        return PEEKED_NONE;\n      }\n      c = buffer[pos + i];\n      if (c != keyword.charAt(i) && c != keywordUpper.charAt(i)) {\n        return PEEKED_NONE;\n      }\n    }\n\n    if ((pos + length < limit || fillBuffer(length + 1))\n        && isLiteral(buffer[pos + length])) {\n      return PEEKED_NONE; // Don't match trues, falsey or nullsoft!\n    }\n\n    // We've found the keyword followed either by EOF or by a non-literal character.\n    pos += length;\n    return peeked = peeking;\n  }\n\n  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative) && (value!=0 || false==negative)) {\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }\n\n  private boolean isLiteral(char c) throws IOException {\n    switch (c) {\n    case '/':\n    case '\\\\':\n    case ';':\n    case '#':\n    case '=':\n      checkLenient(); // fall-through\n    case '{':\n    case '}':\n    case '[':\n    case ']':\n    case ':':\n    case ',':\n    case ' ':\n    case '\\t':\n    case '\\f':\n    case '\\r':\n    case '\\n':\n      return false;\n    default:\n      return true;\n    }\n  }\n\n  /**\n   * Returns the next token, a {@link com.google.gson.stream.JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws java.io.IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      result = nextQuotedValue('\"');\n    } else {\n      throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathNames[stackSize - 1] = result;\n    return result;\n  }\n\n  /**\n   * Returns the {@link com.google.gson.stream.JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n      result = nextQuotedValue('\"');\n    } else if (p == PEEKED_BUFFERED) {\n      result = peekedString;\n      peekedString = null;\n    } else if (p == PEEKED_LONG) {\n      result = Long.toString(peekedLong);\n    } else if (p == PEEKED_NUMBER) {\n      result = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }\n\n  /**\n   * Returns the {@link com.google.gson.stream.JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    }\n    throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_NULL) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n    } else {\n      throw new IllegalStateException(\"Expected null but was \" + peek() + locationString());\n    }\n  }\n\n  /**\n   * Returns the {@link com.google.gson.stream.JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double using {@link Double#parseDouble(String)}.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    if (p == PEEKED_LONG) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return (double) peekedLong;\n    }\n\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    } else if (p == PEEKED_UNQUOTED) {\n      peekedString = nextUnquotedValue();\n    } else if (p != PEEKED_BUFFERED) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double result = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new MalformedJsonException(\n          \"JSON forbids NaN and infinities: \" + result + locationString());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }\n\n  /**\n   * Returns the {@link com.google.gson.stream.JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    if (p == PEEKED_LONG) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return peekedLong;\n    }\n\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n      if (p == PEEKED_UNQUOTED) {\n        peekedString = nextUnquotedValue();\n      } else {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      }\n      try {\n        long result = Long.parseLong(peekedString);\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n      } catch (NumberFormatException ignored) {\n        // Fall back to parse as a double below.\n      }\n    } else {\n      throw new IllegalStateException(\"Expected a long but was \" + peek() + locationString());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    long result = (long) asDouble;\n    if (result != asDouble) { // Make sure no precision was lost casting to 'long'.\n      throw new NumberFormatException(\"Expected a long but was \" + peekedString + locationString());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }\n\n  /**\n   * Returns the string up to but not including {@code quote}, unescaping any\n   * character escape sequences encountered along the way. The opening quote\n   * should have already been read. This consumes the closing quote, but does\n   * not include it in the returned string.\n   *\n   * @param quote either ' or \".\n   * @throws NumberFormatException if any unicode escape sequences are\n   *     malformed.\n   */\n  private String nextQuotedValue(char quote) throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    StringBuilder builder = null;\n    while (true) {\n      int p = pos;\n      int l = limit;\n      /* the index of the first character not yet appended to the builder. */\n      int start = p;\n      while (p < l) {\n        int c = buffer[p++];\n\n        if (c == quote) {\n          pos = p;\n          int len = p - start - 1;\n          if (builder == null) {\n            return new String(buffer, start, len);\n          } else {\n            builder.append(buffer, start, len);\n            return builder.toString();\n          }\n        } else if (c == '\\\\') {\n          pos = p;\n          int len = p - start - 1;\n          if (builder == null) {\n            int estimatedLength = (len + 1) * 2;\n            builder = new StringBuilder(Math.max(estimatedLength, 16));\n          }\n          builder.append(buffer, start, len);\n          builder.append(readEscapeCharacter());\n          p = pos;\n          l = limit;\n          start = p;\n        } else if (c == '\\n') {\n          lineNumber++;\n          lineStart = p;\n        }\n      }\n\n      if (builder == null) {\n        int estimatedLength = (p - start) * 2;\n        builder = new StringBuilder(Math.max(estimatedLength, 16));\n      }\n      builder.append(buffer, start, p - start);\n      pos = p;\n      if (!fillBuffer(1)) {\n        throw syntaxError(\"Unterminated string\");\n      }\n    }\n  }\n\n  /**\n   * Returns an unquoted value as a string.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private String nextUnquotedValue() throws IOException {\n    StringBuilder builder = null;\n    int i = 0;\n\n    findNonLiteralCharacter:\n    while (true) {\n      for (; pos + i < limit; i++) {\n        switch (buffer[pos + i]) {\n        case '/':\n        case '\\\\':\n        case ';':\n        case '#':\n        case '=':\n          checkLenient(); // fall-through\n        case '{':\n        case '}':\n        case '[':\n        case ']':\n        case ':':\n        case ',':\n        case ' ':\n        case '\\t':\n        case '\\f':\n        case '\\r':\n        case '\\n':\n          break findNonLiteralCharacter;\n        }\n      }\n\n      // Attempt to load the entire literal into the buffer at once.\n      if (i < buffer.length) {\n        if (fillBuffer(i + 1)) {\n          continue;\n        } else {\n          break;\n        }\n      }\n\n      // use a StringBuilder when the value is too long. This is too long to be a number!\n      if (builder == null) {\n        builder = new StringBuilder();\n      }\n      builder.append(buffer, pos, i);\n      pos += i;\n      i = 0;\n      if (!fillBuffer(1)) {\n        break;\n      }\n    }\n\n    String result;\n    if (builder == null) {\n      result = new String(buffer, pos, i);\n    } else {\n      builder.append(buffer, pos, i);\n      result = builder.toString();\n    }\n    pos += i;\n    return result;\n  }\n\n  private void skipQuotedValue(char quote) throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    do {\n      int p = pos;\n      int l = limit;\n      /* the index of the first character not yet appended to the builder. */\n      while (p < l) {\n        int c = buffer[p++];\n        if (c == quote) {\n          pos = p;\n          return;\n        } else if (c == '\\\\') {\n          pos = p;\n          readEscapeCharacter();\n          p = pos;\n          l = limit;\n        } else if (c == '\\n') {\n          lineNumber++;\n          lineStart = p;\n        }\n      }\n      pos = p;\n    } while (fillBuffer(1));\n    throw syntaxError(\"Unterminated string\");\n  }\n\n  private void skipUnquotedValue() throws IOException {\n    do {\n      int i = 0;\n      for (; pos + i < limit; i++) {\n        switch (buffer[pos + i]) {\n        case '/':\n        case '\\\\':\n        case ';':\n        case '#':\n        case '=':\n          checkLenient(); // fall-through\n        case '{':\n        case '}':\n        case '[':\n        case ']':\n        case ':':\n        case ',':\n        case ' ':\n        case '\\t':\n        case '\\f':\n        case '\\r':\n        case '\\n':\n          pos += i;\n          return;\n        }\n      }\n      pos += i;\n    } while (fillBuffer(1));\n  }\n\n  /**\n   * Returns the {@link com.google.gson.stream.JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    int result;\n    if (p == PEEKED_LONG) {\n      result = (int) peekedLong;\n      if (peekedLong != result) { // Make sure no precision was lost casting to 'int'.\n        throw new NumberFormatException(\"Expected an int but was \" + peekedLong + locationString());\n      }\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    }\n\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n      if (p == PEEKED_UNQUOTED) {\n        peekedString = nextUnquotedValue();\n      } else {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      }\n      try {\n        result = Integer.parseInt(peekedString);\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n      } catch (NumberFormatException ignored) {\n        // Fall back to parse as a double below.\n      }\n    } else {\n      throw new IllegalStateException(\"Expected an int but was \" + peek() + locationString());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    result = (int) asDouble;\n    if (result != asDouble) { // Make sure no precision was lost casting to 'int'.\n      throw new NumberFormatException(\"Expected an int but was \" + peekedString + locationString());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link java.io.Reader}.\n   */\n  public void close() throws IOException {\n    peeked = PEEKED_NONE;\n    stack[0] = JsonScope.CLOSED;\n    stackSize = 1;\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    int count = 0;\n    do {\n      int p = peeked;\n      if (p == PEEKED_NONE) {\n        p = doPeek();\n      }\n\n      if (p == PEEKED_BEGIN_ARRAY) {\n        push(JsonScope.EMPTY_ARRAY);\n        count++;\n      } else if (p == PEEKED_BEGIN_OBJECT) {\n        push(JsonScope.EMPTY_OBJECT);\n        count++;\n      } else if (p == PEEKED_END_ARRAY) {\n        stackSize--;\n        count--;\n      } else if (p == PEEKED_END_OBJECT) {\n        stackSize--;\n        count--;\n      } else if (p == PEEKED_UNQUOTED_NAME || p == PEEKED_UNQUOTED) {\n        skipUnquotedValue();\n      } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_SINGLE_QUOTED_NAME) {\n        skipQuotedValue('\\'');\n      } else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_DOUBLE_QUOTED_NAME) {\n        skipQuotedValue('\"');\n      } else if (p == PEEKED_NUMBER) {\n        pos += peekedNumberLength;\n      }\n      peeked = PEEKED_NONE;\n    } while (count != 0);\n\n    pathIndices[stackSize - 1]++;\n    pathNames[stackSize - 1] = \"null\";\n  }\n\n  private void push(int newTop) {\n    if (stackSize == stack.length) {\n      int[] newStack = new int[stackSize * 2];\n      int[] newPathIndices = new int[stackSize * 2];\n      String[] newPathNames = new String[stackSize * 2];\n      System.arraycopy(stack, 0, newStack, 0, stackSize);\n      System.arraycopy(pathIndices, 0, newPathIndices, 0, stackSize);\n      System.arraycopy(pathNames, 0, newPathNames, 0, stackSize);\n      stack = newStack;\n      pathIndices = newPathIndices;\n      pathNames = newPathNames;\n    }\n    stack[stackSize++] = newTop;\n  }\n\n  /**\n   * Returns true once {@code limit - pos >= minimum}. If the data is\n   * exhausted before that many characters are available, this returns\n   * false.\n   */\n  private boolean fillBuffer(int minimum) throws IOException {\n    char[] buffer = this.buffer;\n    lineStart -= pos;\n    if (limit != pos) {\n      limit -= pos;\n      System.arraycopy(buffer, pos, buffer, 0, limit);\n    } else {\n      limit = 0;\n    }\n\n    pos = 0;\n    int total;\n    while ((total = in.read(buffer, limit, buffer.length - limit)) != -1) {\n      limit += total;\n\n      // if this is the first read, consume an optional byte order mark (BOM) if it exists\n      if (lineNumber == 0 && lineStart == 0 && limit > 0 && buffer[0] == '\\ufeff') {\n        pos++;\n        lineStart++;\n        minimum++;\n      }\n\n      if (limit >= minimum) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Returns the next character in the stream that is neither whitespace nor a\n   * part of a comment. When this returns, the returned character is always at\n   * {@code buffer[pos-1]}; this means the caller can always push back the\n   * returned character by decrementing {@code pos}.\n   */\n  private int nextNonWhitespace(boolean throwOnEof) throws IOException {\n    /*\n     * This code uses ugly local variables 'p' and 'l' representing the 'pos'\n     * and 'limit' fields respectively. Using locals rather than fields saves\n     * a few field reads for each whitespace character in a pretty-printed\n     * document, resulting in a 5% speedup. We need to flush 'p' to its field\n     * before any (potentially indirect) call to fillBuffer() and reread both\n     * 'p' and 'l' after any (potentially indirect) call to the same method.\n     */\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n    while (true) {\n      if (p == l) {\n        pos = p;\n        if (!fillBuffer(1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      int c = buffer[p++];\n      if (c == '\\n') {\n        lineNumber++;\n        lineStart = p;\n        continue;\n      } else if (c == ' ' || c == '\\r' || c == '\\t') {\n        continue;\n      }\n\n      if (c == '/') {\n        pos = p;\n        if (p == l) {\n          pos--; // push back '/' so it's still in the buffer when this method returns\n          boolean charsLoaded = fillBuffer(2);\n          pos++; // consume the '/' again\n          if (!charsLoaded) {\n            return c;\n          }\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;\n          if (!skipTo(\"*/\")) {\n            throw syntaxError(\"Unterminated comment\");\n          }\n          p = pos + 2;\n          l = limit;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          p = pos;\n          l = limit;\n          continue;\n\n        default:\n          return c;\n        }\n      } else if (c == '#') {\n        pos = p;\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        p = pos;\n        l = limit;\n      } else {\n        pos = p;\n        return c;\n      }\n    }\n    if (throwOnEof) {\n      throw new EOFException(\"End of input\" + locationString());\n    } else {\n      return -1;\n    }\n  }\n\n  private void checkLenient() throws IOException {\n    if (!lenient) {\n      throw syntaxError(\"Use JsonReader.setLenient(true) to accept malformed JSON\");\n    }\n  }\n\n  /**\n   * Advances the position until after the next newline character. If the line\n   * is terminated by \"\\r\\n\", the '\\n' must be consumed as whitespace by the\n   * caller.\n   */\n  private void skipToEndOfLine() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      char c = buffer[pos++];\n      if (c == '\\n') {\n        lineNumber++;\n        lineStart = pos;\n        break;\n      } else if (c == '\\r') {\n        break;\n      }\n    }\n  }\n\n  /**\n   * @param toFind a string to search for. Must not contain a newline.\n   */\n  private boolean skipTo(String toFind) throws IOException {\n    outer:\n    for (; pos + toFind.length() <= limit || fillBuffer(toFind.length()); pos++) {\n      if (buffer[pos] == '\\n') {\n        lineNumber++;\n        lineStart = pos + 1;\n        continue;\n      }\n      for (int c = 0; c < toFind.length(); c++) {\n        if (buffer[pos + c] != toFind.charAt(c)) {\n          continue outer;\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n\n  @Override public String toString() {\n    return getClass().getSimpleName() + locationString();\n  }\n\n  private String locationString() {\n    int line = lineNumber + 1;\n    int column = pos - lineStart + 1;\n    return \" at line \" + line + \" column \" + column + \" path \" + getPath();\n  }\n\n  /**\n   * Returns a <a href=\"http://goessner.net/articles/JsonPath/\">JsonPath</a> to\n   * the current location in the JSON value.\n   */\n  public String getPath() {\n    StringBuilder result = new StringBuilder().append('$');\n    for (int i = 0, size = stackSize; i < size; i++) {\n      switch (stack[i]) {\n        case JsonScope.EMPTY_ARRAY:\n        case JsonScope.NONEMPTY_ARRAY:\n          result.append('[').append(pathIndices[i]).append(']');\n          break;\n\n        case JsonScope.EMPTY_OBJECT:\n        case JsonScope.DANGLING_NAME:\n        case JsonScope.NONEMPTY_OBJECT:\n          result.append('.');\n          if (pathNames[i] != null) {\n            result.append(pathNames[i]);\n          }\n          break;\n\n        case JsonScope.NONEMPTY_DOCUMENT:\n        case JsonScope.EMPTY_DOCUMENT:\n        case JsonScope.CLOSED:\n          break;\n      }\n    }\n    return result.toString();\n  }\n\n  /**\n   * Unescapes the character identified by the character or characters that\n   * immediately follow a backslash. The backslash '\\' should have already\n   * been read. This supports both unicode escapes \"u000A\" and two-character\n   * escapes \"\\n\".\n   *\n   * @throws NumberFormatException if any unicode escape sequences are\n   *     malformed.\n   */\n  private char readEscapeCharacter() throws IOException {\n    if (pos == limit && !fillBuffer(1)) {\n      throw syntaxError(\"Unterminated escape sequence\");\n    }\n\n    char escaped = buffer[pos++];\n    switch (escaped) {\n    case 'u':\n      if (pos + 4 > limit && !fillBuffer(4)) {\n        throw syntaxError(\"Unterminated escape sequence\");\n      }\n      // Equivalent to Integer.parseInt(stringPool.get(buffer, pos, 4), 16);\n      char result = 0;\n      for (int i = pos, end = i + 4; i < end; i++) {\n        char c = buffer[i];\n        result <<= 4;\n        if (c >= '0' && c <= '9') {\n          result += (c - '0');\n        } else if (c >= 'a' && c <= 'f') {\n          result += (c - 'a' + 10);\n        } else if (c >= 'A' && c <= 'F') {\n          result += (c - 'A' + 10);\n        } else {\n          throw new NumberFormatException(\"\\\\u\" + new String(buffer, pos, 4));\n        }\n      }\n      pos += 4;\n      return result;\n\n    case 't':\n      return '\\t';\n\n    case 'b':\n      return '\\b';\n\n    case 'n':\n      return '\\n';\n\n    case 'r':\n      return '\\r';\n\n    case 'f':\n      return '\\f';\n\n    case '\\n':\n      lineNumber++;\n      lineStart = pos;\n      // fall-through\n\n    case '\\'':\n    case '\"':\n    case '\\\\':\n    case '/':\t\n    \treturn escaped;\n    default:\n    \t// throw error when none of the above cases are matched\n    \tthrow syntaxError(\"Invalid escape sequence\");\n    }\n  }\n\n  /**\n   * Throws a new IO exception with the given message and a context snippet\n   * with this reader's content.\n   */\n  private IOException syntaxError(String message) throws IOException {\n    throw new MalformedJsonException(message + locationString());\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace(true);\n    pos--;\n\n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n\n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n\n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  static {\n    JsonReaderInternalAccess.INSTANCE = new JsonReaderInternalAccess() {\n      @Override public void promoteNameToValue(JsonReader reader) throws IOException {\n        if (reader instanceof JsonTreeReader) {\n          ((JsonTreeReader)reader).promoteNameToValue();\n          return;\n        }\n        int p = reader.peeked;\n        if (p == PEEKED_NONE) {\n          p = reader.doPeek();\n        }\n        if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n          reader.peeked = PEEKED_DOUBLE_QUOTED;\n        } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n          reader.peeked = PEEKED_SINGLE_QUOTED;\n        } else if (p == PEEKED_UNQUOTED_NAME) {\n          reader.peeked = PEEKED_UNQUOTED;\n        } else {\n          throw new IllegalStateException(\n              \"Expected a name but was \" + reader.peek() + reader.locationString());\n        }\n      }\n    };\n  }\n}\n"}]}
{"project": "Gson", "bug_id": 14, "classes_modified": [{"class_name": "com.google.gson.internal.$Gson$Types", "buggy_version": "/**\n * Copyright (C) 2008 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.gson.internal;\n\nimport java.io.Serializable;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.GenericArrayType;\nimport java.lang.reflect.GenericDeclaration;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.TypeVariable;\nimport java.lang.reflect.WildcardType;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Properties;\n\nimport static com.google.gson.internal.$Gson$Preconditions.checkArgument;\nimport static com.google.gson.internal.$Gson$Preconditions.checkNotNull;\n\n/**\n * Static methods for working with types.\n *\n * @author Bob Lee\n * @author Jesse Wilson\n */\npublic final class $Gson$Types {\n  static final Type[] EMPTY_TYPE_ARRAY = new Type[] {};\n\n  private $Gson$Types() {\n    throw new UnsupportedOperationException();\n  }\n\n  /**\n   * Returns a new parameterized type, applying {@code typeArguments} to\n   * {@code rawType} and enclosed by {@code ownerType}.\n   *\n   * @return a {@link java.io.Serializable serializable} parameterized type.\n   */\n  public static ParameterizedType newParameterizedTypeWithOwner(\n      Type ownerType, Type rawType, Type... typeArguments) {\n    return new ParameterizedTypeImpl(ownerType, rawType, typeArguments);\n  }\n\n  /**\n   * Returns an array type whose elements are all instances of\n   * {@code componentType}.\n   *\n   * @return a {@link java.io.Serializable serializable} generic array type.\n   */\n  public static GenericArrayType arrayOf(Type componentType) {\n    return new GenericArrayTypeImpl(componentType);\n  }\n\n  /**\n   * Returns a type that represents an unknown type that extends {@code bound}.\n   * For example, if {@code bound} is {@code CharSequence.class}, this returns\n   * {@code ? extends CharSequence}. If {@code bound} is {@code Object.class},\n   * this returns {@code ?}, which is shorthand for {@code ? extends Object}.\n   */\n  public static WildcardType subtypeOf(Type bound) {\n    Type[] upperBounds;\n      upperBounds = new Type[] { bound };\n    return new WildcardTypeImpl(upperBounds, EMPTY_TYPE_ARRAY);\n  }\n\n  /**\n   * Returns a type that represents an unknown supertype of {@code bound}. For\n   * example, if {@code bound} is {@code String.class}, this returns {@code ?\n   * super String}.\n   */\n  public static WildcardType supertypeOf(Type bound) {\n    Type[] lowerBounds;\n      lowerBounds = new Type[] { bound };\n    return new WildcardTypeImpl(new Type[] { Object.class }, lowerBounds);\n  }\n\n  /**\n   * Returns a type that is functionally equal but not necessarily equal\n   * according to {@link Object#equals(Object) Object.equals()}. The returned\n   * type is {@link java.io.Serializable}.\n   */\n  public static Type canonicalize(Type type) {\n    if (type instanceof Class) {\n      Class<?> c = (Class<?>) type;\n      return c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c;\n\n    } else if (type instanceof ParameterizedType) {\n      ParameterizedType p = (ParameterizedType) type;\n      return new ParameterizedTypeImpl(p.getOwnerType(),\n          p.getRawType(), p.getActualTypeArguments());\n\n    } else if (type instanceof GenericArrayType) {\n      GenericArrayType g = (GenericArrayType) type;\n      return new GenericArrayTypeImpl(g.getGenericComponentType());\n\n    } else if (type instanceof WildcardType) {\n      WildcardType w = (WildcardType) type;\n      return new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds());\n\n    } else {\n      // type is either serializable as-is or unsupported\n      return type;\n    }\n  }\n\n  public static Class<?> getRawType(Type type) {\n    if (type instanceof Class<?>) {\n      // type is a normal class.\n      return (Class<?>) type;\n\n    } else if (type instanceof ParameterizedType) {\n      ParameterizedType parameterizedType = (ParameterizedType) type;\n\n      // I'm not exactly sure why getRawType() returns Type instead of Class.\n      // Neal isn't either but suspects some pathological case related\n      // to nested classes exists.\n      Type rawType = parameterizedType.getRawType();\n      checkArgument(rawType instanceof Class);\n      return (Class<?>) rawType;\n\n    } else if (type instanceof GenericArrayType) {\n      Type componentType = ((GenericArrayType)type).getGenericComponentType();\n      return Array.newInstance(getRawType(componentType), 0).getClass();\n\n    } else if (type instanceof TypeVariable) {\n      // we could use the variable's bounds, but that won't work if there are multiple.\n      // having a raw type that's more general than necessary is okay\n      return Object.class;\n\n    } else if (type instanceof WildcardType) {\n      return getRawType(((WildcardType) type).getUpperBounds()[0]);\n\n    } else {\n      String className = type == null ? \"null\" : type.getClass().getName();\n      throw new IllegalArgumentException(\"Expected a Class, ParameterizedType, or \"\n          + \"GenericArrayType, but <\" + type + \"> is of type \" + className);\n    }\n  }\n\n  static boolean equal(Object a, Object b) {\n    return a == b || (a != null && a.equals(b));\n  }\n\n  /**\n   * Returns true if {@code a} and {@code b} are equal.\n   */\n  public static boolean equals(Type a, Type b) {\n    if (a == b) {\n      // also handles (a == null && b == null)\n      return true;\n\n    } else if (a instanceof Class) {\n      // Class already specifies equals().\n      return a.equals(b);\n\n    } else if (a instanceof ParameterizedType) {\n      if (!(b instanceof ParameterizedType)) {\n        return false;\n      }\n\n      // TODO: save a .clone() call\n      ParameterizedType pa = (ParameterizedType) a;\n      ParameterizedType pb = (ParameterizedType) b;\n      return equal(pa.getOwnerType(), pb.getOwnerType())\n          && pa.getRawType().equals(pb.getRawType())\n          && Arrays.equals(pa.getActualTypeArguments(), pb.getActualTypeArguments());\n\n    } else if (a instanceof GenericArrayType) {\n      if (!(b instanceof GenericArrayType)) {\n        return false;\n      }\n\n      GenericArrayType ga = (GenericArrayType) a;\n      GenericArrayType gb = (GenericArrayType) b;\n      return equals(ga.getGenericComponentType(), gb.getGenericComponentType());\n\n    } else if (a instanceof WildcardType) {\n      if (!(b instanceof WildcardType)) {\n        return false;\n      }\n\n      WildcardType wa = (WildcardType) a;\n      WildcardType wb = (WildcardType) b;\n      return Arrays.equals(wa.getUpperBounds(), wb.getUpperBounds())\n          && Arrays.equals(wa.getLowerBounds(), wb.getLowerBounds());\n\n    } else if (a instanceof TypeVariable) {\n      if (!(b instanceof TypeVariable)) {\n        return false;\n      }\n      TypeVariable<?> va = (TypeVariable<?>) a;\n      TypeVariable<?> vb = (TypeVariable<?>) b;\n      return va.getGenericDeclaration() == vb.getGenericDeclaration()\n          && va.getName().equals(vb.getName());\n\n    } else {\n      // This isn't a type we support. Could be a generic array type, wildcard type, etc.\n      return false;\n    }\n  }\n\n  static int hashCodeOrZero(Object o) {\n    return o != null ? o.hashCode() : 0;\n  }\n\n  public static String typeToString(Type type) {\n    return type instanceof Class ? ((Class<?>) type).getName() : type.toString();\n  }\n\n  /**\n   * Returns the generic supertype for {@code supertype}. For example, given a class {@code\n   * IntegerSet}, the result for when supertype is {@code Set.class} is {@code Set<Integer>} and the\n   * result when the supertype is {@code Collection.class} is {@code Collection<Integer>}.\n   */\n  static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResolve) {\n    if (toResolve == rawType) {\n      return context;\n    }\n\n    // we skip searching through interfaces if unknown is an interface\n    if (toResolve.isInterface()) {\n      Class<?>[] interfaces = rawType.getInterfaces();\n      for (int i = 0, length = interfaces.length; i < length; i++) {\n        if (interfaces[i] == toResolve) {\n          return rawType.getGenericInterfaces()[i];\n        } else if (toResolve.isAssignableFrom(interfaces[i])) {\n          return getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], toResolve);\n        }\n      }\n    }\n\n    // check our supertypes\n    if (!rawType.isInterface()) {\n      while (rawType != Object.class) {\n        Class<?> rawSupertype = rawType.getSuperclass();\n        if (rawSupertype == toResolve) {\n          return rawType.getGenericSuperclass();\n        } else if (toResolve.isAssignableFrom(rawSupertype)) {\n          return getGenericSupertype(rawType.getGenericSuperclass(), rawSupertype, toResolve);\n        }\n        rawType = rawSupertype;\n      }\n    }\n\n    // we can't resolve this further\n    return toResolve;\n  }\n\n  /**\n   * Returns the generic form of {@code supertype}. For example, if this is {@code\n   * ArrayList<String>}, this returns {@code Iterable<String>} given the input {@code\n   * Iterable.class}.\n   *\n   * @param supertype a superclass of, or interface implemented by, this.\n   */\n  static Type getSupertype(Type context, Class<?> contextRawType, Class<?> supertype) {\n    checkArgument(supertype.isAssignableFrom(contextRawType));\n    return resolve(context, contextRawType,\n        $Gson$Types.getGenericSupertype(context, contextRawType, supertype));\n  }\n\n  /**\n   * Returns the component type of this array type.\n   * @throws ClassCastException if this type is not an array.\n   */\n  public static Type getArrayComponentType(Type array) {\n    return array instanceof GenericArrayType\n        ? ((GenericArrayType) array).getGenericComponentType()\n        : ((Class<?>) array).getComponentType();\n  }\n\n  /**\n   * Returns the element type of this collection type.\n   * @throws IllegalArgumentException if this type is not a collection.\n   */\n  public static Type getCollectionElementType(Type context, Class<?> contextRawType) {\n    Type collectionType = getSupertype(context, contextRawType, Collection.class);\n\n    if (collectionType instanceof WildcardType) {\n      collectionType = ((WildcardType)collectionType).getUpperBounds()[0];\n    }\n    if (collectionType instanceof ParameterizedType) {\n      return ((ParameterizedType) collectionType).getActualTypeArguments()[0];\n    }\n    return Object.class;\n  }\n\n  /**\n   * Returns a two element array containing this map's key and value types in\n   * positions 0 and 1 respectively.\n   */\n  public static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType) {\n    /*\n     * Work around a problem with the declaration of java.util.Properties. That\n     * class should extend Hashtable<String, String>, but it's declared to\n     * extend Hashtable<Object, Object>.\n     */\n    if (context == Properties.class) {\n      return new Type[] { String.class, String.class }; // TODO: test subclasses of Properties!\n    }\n\n    Type mapType = getSupertype(context, contextRawType, Map.class);\n    // TODO: strip wildcards?\n    if (mapType instanceof ParameterizedType) {\n      ParameterizedType mapParameterizedType = (ParameterizedType) mapType;\n      return mapParameterizedType.getActualTypeArguments();\n    }\n    return new Type[] { Object.class, Object.class };\n  }\n\n  public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {\n    // this implementation is made a little more complicated in an attempt to avoid object-creation\n    while (true) {\n      if (toResolve instanceof TypeVariable) {\n        TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;\n        toResolve = resolveTypeVariable(context, contextRawType, typeVariable);\n        if (toResolve == typeVariable) {\n          return toResolve;\n        }\n\n      } else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {\n        Class<?> original = (Class<?>) toResolve;\n        Type componentType = original.getComponentType();\n        Type newComponentType = resolve(context, contextRawType, componentType);\n        return componentType == newComponentType\n            ? original\n            : arrayOf(newComponentType);\n\n      } else if (toResolve instanceof GenericArrayType) {\n        GenericArrayType original = (GenericArrayType) toResolve;\n        Type componentType = original.getGenericComponentType();\n        Type newComponentType = resolve(context, contextRawType, componentType);\n        return componentType == newComponentType\n            ? original\n            : arrayOf(newComponentType);\n\n      } else if (toResolve instanceof ParameterizedType) {\n        ParameterizedType original = (ParameterizedType) toResolve;\n        Type ownerType = original.getOwnerType();\n        Type newOwnerType = resolve(context, contextRawType, ownerType);\n        boolean changed = newOwnerType != ownerType;\n\n        Type[] args = original.getActualTypeArguments();\n        for (int t = 0, length = args.length; t < length; t++) {\n          Type resolvedTypeArgument = resolve(context, contextRawType, args[t]);\n          if (resolvedTypeArgument != args[t]) {\n            if (!changed) {\n              args = args.clone();\n              changed = true;\n            }\n            args[t] = resolvedTypeArgument;\n          }\n        }\n\n        return changed\n            ? newParameterizedTypeWithOwner(newOwnerType, original.getRawType(), args)\n            : original;\n\n      } else if (toResolve instanceof WildcardType) {\n        WildcardType original = (WildcardType) toResolve;\n        Type[] originalLowerBound = original.getLowerBounds();\n        Type[] originalUpperBound = original.getUpperBounds();\n\n        if (originalLowerBound.length == 1) {\n          Type lowerBound = resolve(context, contextRawType, originalLowerBound[0]);\n          if (lowerBound != originalLowerBound[0]) {\n            return supertypeOf(lowerBound);\n          }\n        } else if (originalUpperBound.length == 1) {\n          Type upperBound = resolve(context, contextRawType, originalUpperBound[0]);\n          if (upperBound != originalUpperBound[0]) {\n            return subtypeOf(upperBound);\n          }\n        }\n        return original;\n\n      } else {\n        return toResolve;\n      }\n    }\n  }\n\n  static Type resolveTypeVariable(Type context, Class<?> contextRawType, TypeVariable<?> unknown) {\n    Class<?> declaredByRaw = declaringClassOf(unknown);\n\n    // we can't reduce this further\n    if (declaredByRaw == null) {\n      return unknown;\n    }\n\n    Type declaredBy = getGenericSupertype(context, contextRawType, declaredByRaw);\n    if (declaredBy instanceof ParameterizedType) {\n      int index = indexOf(declaredByRaw.getTypeParameters(), unknown);\n      return ((ParameterizedType) declaredBy).getActualTypeArguments()[index];\n    }\n\n    return unknown;\n  }\n\n  private static int indexOf(Object[] array, Object toFind) {\n    for (int i = 0, length = array.length; i < length; i++) {\n      if (toFind.equals(array[i])) {\n        return i;\n      }\n    }\n    throw new NoSuchElementException();\n  }\n\n  /**\n   * Returns the declaring class of {@code typeVariable}, or {@code null} if it was not declared by\n   * a class.\n   */\n  private static Class<?> declaringClassOf(TypeVariable<?> typeVariable) {\n    GenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();\n    return genericDeclaration instanceof Class\n        ? (Class<?>) genericDeclaration\n        : null;\n  }\n\n  static void checkNotPrimitive(Type type) {\n    checkArgument(!(type instanceof Class<?>) || !((Class<?>) type).isPrimitive());\n  }\n\n  private static final class ParameterizedTypeImpl implements ParameterizedType, Serializable {\n    private final Type ownerType;\n    private final Type rawType;\n    private final Type[] typeArguments;\n\n    public ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments) {\n      // require an owner type if the raw type needs it\n      if (rawType instanceof Class<?>) {\n        Class<?> rawTypeAsClass = (Class<?>) rawType;\n        boolean isStaticOrTopLevelClass = Modifier.isStatic(rawTypeAsClass.getModifiers())\n            || rawTypeAsClass.getEnclosingClass() == null;\n        checkArgument(ownerType != null || isStaticOrTopLevelClass);\n      }\n\n      this.ownerType = ownerType == null ? null : canonicalize(ownerType);\n      this.rawType = canonicalize(rawType);\n      this.typeArguments = typeArguments.clone();\n      for (int t = 0, length = this.typeArguments.length; t < length; t++) {\n        checkNotNull(this.typeArguments[t]);\n        checkNotPrimitive(this.typeArguments[t]);\n        this.typeArguments[t] = canonicalize(this.typeArguments[t]);\n      }\n    }\n\n    public Type[] getActualTypeArguments() {\n      return typeArguments.clone();\n    }\n\n    public Type getRawType() {\n      return rawType;\n    }\n\n    public Type getOwnerType() {\n      return ownerType;\n    }\n\n    @Override public boolean equals(Object other) {\n      return other instanceof ParameterizedType\n          && $Gson$Types.equals(this, (ParameterizedType) other);\n    }\n\n    @Override public int hashCode() {\n      return Arrays.hashCode(typeArguments)\n          ^ rawType.hashCode()\n          ^ hashCodeOrZero(ownerType);\n    }\n\n    @Override public String toString() {\n      int length = typeArguments.length;\n      if (length == 0) {\n        return typeToString(rawType);\n      }\n\n      StringBuilder stringBuilder = new StringBuilder(30 * (length + 1));\n      stringBuilder.append(typeToString(rawType)).append(\"<\").append(typeToString(typeArguments[0]));\n      for (int i = 1; i < length; i++) {\n        stringBuilder.append(\", \").append(typeToString(typeArguments[i]));\n      }\n      return stringBuilder.append(\">\").toString();\n    }\n\n    private static final long serialVersionUID = 0;\n  }\n\n  private static final class GenericArrayTypeImpl implements GenericArrayType, Serializable {\n    private final Type componentType;\n\n    public GenericArrayTypeImpl(Type componentType) {\n      this.componentType = canonicalize(componentType);\n    }\n\n    public Type getGenericComponentType() {\n      return componentType;\n    }\n\n    @Override public boolean equals(Object o) {\n      return o instanceof GenericArrayType\n          && $Gson$Types.equals(this, (GenericArrayType) o);\n    }\n\n    @Override public int hashCode() {\n      return componentType.hashCode();\n    }\n\n    @Override public String toString() {\n      return typeToString(componentType) + \"[]\";\n    }\n\n    private static final long serialVersionUID = 0;\n  }\n\n  /**\n   * The WildcardType interface supports multiple upper bounds and multiple\n   * lower bounds. We only support what the Java 6 language needs - at most one\n   * bound. If a lower bound is set, the upper bound must be Object.class.\n   */\n  private static final class WildcardTypeImpl implements WildcardType, Serializable {\n    private final Type upperBound;\n    private final Type lowerBound;\n\n    public WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {\n      checkArgument(lowerBounds.length <= 1);\n      checkArgument(upperBounds.length == 1);\n\n      if (lowerBounds.length == 1) {\n        checkNotNull(lowerBounds[0]);\n        checkNotPrimitive(lowerBounds[0]);\n        checkArgument(upperBounds[0] == Object.class);\n        this.lowerBound = canonicalize(lowerBounds[0]);\n        this.upperBound = Object.class;\n\n      } else {\n        checkNotNull(upperBounds[0]);\n        checkNotPrimitive(upperBounds[0]);\n        this.lowerBound = null;\n        this.upperBound = canonicalize(upperBounds[0]);\n      }\n    }\n\n    public Type[] getUpperBounds() {\n      return new Type[] { upperBound };\n    }\n\n    public Type[] getLowerBounds() {\n      return lowerBound != null ? new Type[] { lowerBound } : EMPTY_TYPE_ARRAY;\n    }\n\n    @Override public boolean equals(Object other) {\n      return other instanceof WildcardType\n          && $Gson$Types.equals(this, (WildcardType) other);\n    }\n\n    @Override public int hashCode() {\n      // this equals Arrays.hashCode(getLowerBounds()) ^ Arrays.hashCode(getUpperBounds());\n      return (lowerBound != null ? 31 + lowerBound.hashCode() : 1)\n          ^ (31 + upperBound.hashCode());\n    }\n\n    @Override public String toString() {\n      if (lowerBound != null) {\n        return \"? super \" + typeToString(lowerBound);\n      } else if (upperBound == Object.class) {\n        return \"?\";\n      } else {\n        return \"? extends \" + typeToString(upperBound);\n      }\n    }\n\n    private static final long serialVersionUID = 0;\n  }\n}\n", "fixed_version": "/**\n * Copyright (C) 2008 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.gson.internal;\n\nimport java.io.Serializable;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.GenericArrayType;\nimport java.lang.reflect.GenericDeclaration;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.TypeVariable;\nimport java.lang.reflect.WildcardType;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Properties;\n\nimport static com.google.gson.internal.$Gson$Preconditions.checkArgument;\nimport static com.google.gson.internal.$Gson$Preconditions.checkNotNull;\n\n/**\n * Static methods for working with types.\n *\n * @author Bob Lee\n * @author Jesse Wilson\n */\npublic final class $Gson$Types {\n  static final Type[] EMPTY_TYPE_ARRAY = new Type[] {};\n\n  private $Gson$Types() {\n    throw new UnsupportedOperationException();\n  }\n\n  /**\n   * Returns a new parameterized type, applying {@code typeArguments} to\n   * {@code rawType} and enclosed by {@code ownerType}.\n   *\n   * @return a {@link java.io.Serializable serializable} parameterized type.\n   */\n  public static ParameterizedType newParameterizedTypeWithOwner(\n      Type ownerType, Type rawType, Type... typeArguments) {\n    return new ParameterizedTypeImpl(ownerType, rawType, typeArguments);\n  }\n\n  /**\n   * Returns an array type whose elements are all instances of\n   * {@code componentType}.\n   *\n   * @return a {@link java.io.Serializable serializable} generic array type.\n   */\n  public static GenericArrayType arrayOf(Type componentType) {\n    return new GenericArrayTypeImpl(componentType);\n  }\n\n  /**\n   * Returns a type that represents an unknown type that extends {@code bound}.\n   * For example, if {@code bound} is {@code CharSequence.class}, this returns\n   * {@code ? extends CharSequence}. If {@code bound} is {@code Object.class},\n   * this returns {@code ?}, which is shorthand for {@code ? extends Object}.\n   */\n  public static WildcardType subtypeOf(Type bound) {\n    Type[] upperBounds;\n    if (bound instanceof WildcardType) {\n      upperBounds = ((WildcardType) bound).getUpperBounds();\n    } else {\n      upperBounds = new Type[] { bound };\n    }\n    return new WildcardTypeImpl(upperBounds, EMPTY_TYPE_ARRAY);\n  }\n\n  /**\n   * Returns a type that represents an unknown supertype of {@code bound}. For\n   * example, if {@code bound} is {@code String.class}, this returns {@code ?\n   * super String}.\n   */\n  public static WildcardType supertypeOf(Type bound) {\n    Type[] lowerBounds;\n    if (bound instanceof WildcardType) {\n      lowerBounds = ((WildcardType) bound).getLowerBounds();\n    } else {\n      lowerBounds = new Type[] { bound };\n    }\n    return new WildcardTypeImpl(new Type[] { Object.class }, lowerBounds);\n  }\n\n  /**\n   * Returns a type that is functionally equal but not necessarily equal\n   * according to {@link Object#equals(Object) Object.equals()}. The returned\n   * type is {@link java.io.Serializable}.\n   */\n  public static Type canonicalize(Type type) {\n    if (type instanceof Class) {\n      Class<?> c = (Class<?>) type;\n      return c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c;\n\n    } else if (type instanceof ParameterizedType) {\n      ParameterizedType p = (ParameterizedType) type;\n      return new ParameterizedTypeImpl(p.getOwnerType(),\n          p.getRawType(), p.getActualTypeArguments());\n\n    } else if (type instanceof GenericArrayType) {\n      GenericArrayType g = (GenericArrayType) type;\n      return new GenericArrayTypeImpl(g.getGenericComponentType());\n\n    } else if (type instanceof WildcardType) {\n      WildcardType w = (WildcardType) type;\n      return new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds());\n\n    } else {\n      // type is either serializable as-is or unsupported\n      return type;\n    }\n  }\n\n  public static Class<?> getRawType(Type type) {\n    if (type instanceof Class<?>) {\n      // type is a normal class.\n      return (Class<?>) type;\n\n    } else if (type instanceof ParameterizedType) {\n      ParameterizedType parameterizedType = (ParameterizedType) type;\n\n      // I'm not exactly sure why getRawType() returns Type instead of Class.\n      // Neal isn't either but suspects some pathological case related\n      // to nested classes exists.\n      Type rawType = parameterizedType.getRawType();\n      checkArgument(rawType instanceof Class);\n      return (Class<?>) rawType;\n\n    } else if (type instanceof GenericArrayType) {\n      Type componentType = ((GenericArrayType)type).getGenericComponentType();\n      return Array.newInstance(getRawType(componentType), 0).getClass();\n\n    } else if (type instanceof TypeVariable) {\n      // we could use the variable's bounds, but that won't work if there are multiple.\n      // having a raw type that's more general than necessary is okay\n      return Object.class;\n\n    } else if (type instanceof WildcardType) {\n      return getRawType(((WildcardType) type).getUpperBounds()[0]);\n\n    } else {\n      String className = type == null ? \"null\" : type.getClass().getName();\n      throw new IllegalArgumentException(\"Expected a Class, ParameterizedType, or \"\n          + \"GenericArrayType, but <\" + type + \"> is of type \" + className);\n    }\n  }\n\n  static boolean equal(Object a, Object b) {\n    return a == b || (a != null && a.equals(b));\n  }\n\n  /**\n   * Returns true if {@code a} and {@code b} are equal.\n   */\n  public static boolean equals(Type a, Type b) {\n    if (a == b) {\n      // also handles (a == null && b == null)\n      return true;\n\n    } else if (a instanceof Class) {\n      // Class already specifies equals().\n      return a.equals(b);\n\n    } else if (a instanceof ParameterizedType) {\n      if (!(b instanceof ParameterizedType)) {\n        return false;\n      }\n\n      // TODO: save a .clone() call\n      ParameterizedType pa = (ParameterizedType) a;\n      ParameterizedType pb = (ParameterizedType) b;\n      return equal(pa.getOwnerType(), pb.getOwnerType())\n          && pa.getRawType().equals(pb.getRawType())\n          && Arrays.equals(pa.getActualTypeArguments(), pb.getActualTypeArguments());\n\n    } else if (a instanceof GenericArrayType) {\n      if (!(b instanceof GenericArrayType)) {\n        return false;\n      }\n\n      GenericArrayType ga = (GenericArrayType) a;\n      GenericArrayType gb = (GenericArrayType) b;\n      return equals(ga.getGenericComponentType(), gb.getGenericComponentType());\n\n    } else if (a instanceof WildcardType) {\n      if (!(b instanceof WildcardType)) {\n        return false;\n      }\n\n      WildcardType wa = (WildcardType) a;\n      WildcardType wb = (WildcardType) b;\n      return Arrays.equals(wa.getUpperBounds(), wb.getUpperBounds())\n          && Arrays.equals(wa.getLowerBounds(), wb.getLowerBounds());\n\n    } else if (a instanceof TypeVariable) {\n      if (!(b instanceof TypeVariable)) {\n        return false;\n      }\n      TypeVariable<?> va = (TypeVariable<?>) a;\n      TypeVariable<?> vb = (TypeVariable<?>) b;\n      return va.getGenericDeclaration() == vb.getGenericDeclaration()\n          && va.getName().equals(vb.getName());\n\n    } else {\n      // This isn't a type we support. Could be a generic array type, wildcard type, etc.\n      return false;\n    }\n  }\n\n  static int hashCodeOrZero(Object o) {\n    return o != null ? o.hashCode() : 0;\n  }\n\n  public static String typeToString(Type type) {\n    return type instanceof Class ? ((Class<?>) type).getName() : type.toString();\n  }\n\n  /**\n   * Returns the generic supertype for {@code supertype}. For example, given a class {@code\n   * IntegerSet}, the result for when supertype is {@code Set.class} is {@code Set<Integer>} and the\n   * result when the supertype is {@code Collection.class} is {@code Collection<Integer>}.\n   */\n  static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResolve) {\n    if (toResolve == rawType) {\n      return context;\n    }\n\n    // we skip searching through interfaces if unknown is an interface\n    if (toResolve.isInterface()) {\n      Class<?>[] interfaces = rawType.getInterfaces();\n      for (int i = 0, length = interfaces.length; i < length; i++) {\n        if (interfaces[i] == toResolve) {\n          return rawType.getGenericInterfaces()[i];\n        } else if (toResolve.isAssignableFrom(interfaces[i])) {\n          return getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], toResolve);\n        }\n      }\n    }\n\n    // check our supertypes\n    if (!rawType.isInterface()) {\n      while (rawType != Object.class) {\n        Class<?> rawSupertype = rawType.getSuperclass();\n        if (rawSupertype == toResolve) {\n          return rawType.getGenericSuperclass();\n        } else if (toResolve.isAssignableFrom(rawSupertype)) {\n          return getGenericSupertype(rawType.getGenericSuperclass(), rawSupertype, toResolve);\n        }\n        rawType = rawSupertype;\n      }\n    }\n\n    // we can't resolve this further\n    return toResolve;\n  }\n\n  /**\n   * Returns the generic form of {@code supertype}. For example, if this is {@code\n   * ArrayList<String>}, this returns {@code Iterable<String>} given the input {@code\n   * Iterable.class}.\n   *\n   * @param supertype a superclass of, or interface implemented by, this.\n   */\n  static Type getSupertype(Type context, Class<?> contextRawType, Class<?> supertype) {\n    checkArgument(supertype.isAssignableFrom(contextRawType));\n    return resolve(context, contextRawType,\n        $Gson$Types.getGenericSupertype(context, contextRawType, supertype));\n  }\n\n  /**\n   * Returns the component type of this array type.\n   * @throws ClassCastException if this type is not an array.\n   */\n  public static Type getArrayComponentType(Type array) {\n    return array instanceof GenericArrayType\n        ? ((GenericArrayType) array).getGenericComponentType()\n        : ((Class<?>) array).getComponentType();\n  }\n\n  /**\n   * Returns the element type of this collection type.\n   * @throws IllegalArgumentException if this type is not a collection.\n   */\n  public static Type getCollectionElementType(Type context, Class<?> contextRawType) {\n    Type collectionType = getSupertype(context, contextRawType, Collection.class);\n\n    if (collectionType instanceof WildcardType) {\n      collectionType = ((WildcardType)collectionType).getUpperBounds()[0];\n    }\n    if (collectionType instanceof ParameterizedType) {\n      return ((ParameterizedType) collectionType).getActualTypeArguments()[0];\n    }\n    return Object.class;\n  }\n\n  /**\n   * Returns a two element array containing this map's key and value types in\n   * positions 0 and 1 respectively.\n   */\n  public static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType) {\n    /*\n     * Work around a problem with the declaration of java.util.Properties. That\n     * class should extend Hashtable<String, String>, but it's declared to\n     * extend Hashtable<Object, Object>.\n     */\n    if (context == Properties.class) {\n      return new Type[] { String.class, String.class }; // TODO: test subclasses of Properties!\n    }\n\n    Type mapType = getSupertype(context, contextRawType, Map.class);\n    // TODO: strip wildcards?\n    if (mapType instanceof ParameterizedType) {\n      ParameterizedType mapParameterizedType = (ParameterizedType) mapType;\n      return mapParameterizedType.getActualTypeArguments();\n    }\n    return new Type[] { Object.class, Object.class };\n  }\n\n  public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {\n    // this implementation is made a little more complicated in an attempt to avoid object-creation\n    while (true) {\n      if (toResolve instanceof TypeVariable) {\n        TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;\n        toResolve = resolveTypeVariable(context, contextRawType, typeVariable);\n        if (toResolve == typeVariable) {\n          return toResolve;\n        }\n\n      } else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {\n        Class<?> original = (Class<?>) toResolve;\n        Type componentType = original.getComponentType();\n        Type newComponentType = resolve(context, contextRawType, componentType);\n        return componentType == newComponentType\n            ? original\n            : arrayOf(newComponentType);\n\n      } else if (toResolve instanceof GenericArrayType) {\n        GenericArrayType original = (GenericArrayType) toResolve;\n        Type componentType = original.getGenericComponentType();\n        Type newComponentType = resolve(context, contextRawType, componentType);\n        return componentType == newComponentType\n            ? original\n            : arrayOf(newComponentType);\n\n      } else if (toResolve instanceof ParameterizedType) {\n        ParameterizedType original = (ParameterizedType) toResolve;\n        Type ownerType = original.getOwnerType();\n        Type newOwnerType = resolve(context, contextRawType, ownerType);\n        boolean changed = newOwnerType != ownerType;\n\n        Type[] args = original.getActualTypeArguments();\n        for (int t = 0, length = args.length; t < length; t++) {\n          Type resolvedTypeArgument = resolve(context, contextRawType, args[t]);\n          if (resolvedTypeArgument != args[t]) {\n            if (!changed) {\n              args = args.clone();\n              changed = true;\n            }\n            args[t] = resolvedTypeArgument;\n          }\n        }\n\n        return changed\n            ? newParameterizedTypeWithOwner(newOwnerType, original.getRawType(), args)\n            : original;\n\n      } else if (toResolve instanceof WildcardType) {\n        WildcardType original = (WildcardType) toResolve;\n        Type[] originalLowerBound = original.getLowerBounds();\n        Type[] originalUpperBound = original.getUpperBounds();\n\n        if (originalLowerBound.length == 1) {\n          Type lowerBound = resolve(context, contextRawType, originalLowerBound[0]);\n          if (lowerBound != originalLowerBound[0]) {\n            return supertypeOf(lowerBound);\n          }\n        } else if (originalUpperBound.length == 1) {\n          Type upperBound = resolve(context, contextRawType, originalUpperBound[0]);\n          if (upperBound != originalUpperBound[0]) {\n            return subtypeOf(upperBound);\n          }\n        }\n        return original;\n\n      } else {\n        return toResolve;\n      }\n    }\n  }\n\n  static Type resolveTypeVariable(Type context, Class<?> contextRawType, TypeVariable<?> unknown) {\n    Class<?> declaredByRaw = declaringClassOf(unknown);\n\n    // we can't reduce this further\n    if (declaredByRaw == null) {\n      return unknown;\n    }\n\n    Type declaredBy = getGenericSupertype(context, contextRawType, declaredByRaw);\n    if (declaredBy instanceof ParameterizedType) {\n      int index = indexOf(declaredByRaw.getTypeParameters(), unknown);\n      return ((ParameterizedType) declaredBy).getActualTypeArguments()[index];\n    }\n\n    return unknown;\n  }\n\n  private static int indexOf(Object[] array, Object toFind) {\n    for (int i = 0, length = array.length; i < length; i++) {\n      if (toFind.equals(array[i])) {\n        return i;\n      }\n    }\n    throw new NoSuchElementException();\n  }\n\n  /**\n   * Returns the declaring class of {@code typeVariable}, or {@code null} if it was not declared by\n   * a class.\n   */\n  private static Class<?> declaringClassOf(TypeVariable<?> typeVariable) {\n    GenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();\n    return genericDeclaration instanceof Class\n        ? (Class<?>) genericDeclaration\n        : null;\n  }\n\n  static void checkNotPrimitive(Type type) {\n    checkArgument(!(type instanceof Class<?>) || !((Class<?>) type).isPrimitive());\n  }\n\n  private static final class ParameterizedTypeImpl implements ParameterizedType, Serializable {\n    private final Type ownerType;\n    private final Type rawType;\n    private final Type[] typeArguments;\n\n    public ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments) {\n      // require an owner type if the raw type needs it\n      if (rawType instanceof Class<?>) {\n        Class<?> rawTypeAsClass = (Class<?>) rawType;\n        boolean isStaticOrTopLevelClass = Modifier.isStatic(rawTypeAsClass.getModifiers())\n            || rawTypeAsClass.getEnclosingClass() == null;\n        checkArgument(ownerType != null || isStaticOrTopLevelClass);\n      }\n\n      this.ownerType = ownerType == null ? null : canonicalize(ownerType);\n      this.rawType = canonicalize(rawType);\n      this.typeArguments = typeArguments.clone();\n      for (int t = 0, length = this.typeArguments.length; t < length; t++) {\n        checkNotNull(this.typeArguments[t]);\n        checkNotPrimitive(this.typeArguments[t]);\n        this.typeArguments[t] = canonicalize(this.typeArguments[t]);\n      }\n    }\n\n    public Type[] getActualTypeArguments() {\n      return typeArguments.clone();\n    }\n\n    public Type getRawType() {\n      return rawType;\n    }\n\n    public Type getOwnerType() {\n      return ownerType;\n    }\n\n    @Override public boolean equals(Object other) {\n      return other instanceof ParameterizedType\n          && $Gson$Types.equals(this, (ParameterizedType) other);\n    }\n\n    @Override public int hashCode() {\n      return Arrays.hashCode(typeArguments)\n          ^ rawType.hashCode()\n          ^ hashCodeOrZero(ownerType);\n    }\n\n    @Override public String toString() {\n      int length = typeArguments.length;\n      if (length == 0) {\n        return typeToString(rawType);\n      }\n\n      StringBuilder stringBuilder = new StringBuilder(30 * (length + 1));\n      stringBuilder.append(typeToString(rawType)).append(\"<\").append(typeToString(typeArguments[0]));\n      for (int i = 1; i < length; i++) {\n        stringBuilder.append(\", \").append(typeToString(typeArguments[i]));\n      }\n      return stringBuilder.append(\">\").toString();\n    }\n\n    private static final long serialVersionUID = 0;\n  }\n\n  private static final class GenericArrayTypeImpl implements GenericArrayType, Serializable {\n    private final Type componentType;\n\n    public GenericArrayTypeImpl(Type componentType) {\n      this.componentType = canonicalize(componentType);\n    }\n\n    public Type getGenericComponentType() {\n      return componentType;\n    }\n\n    @Override public boolean equals(Object o) {\n      return o instanceof GenericArrayType\n          && $Gson$Types.equals(this, (GenericArrayType) o);\n    }\n\n    @Override public int hashCode() {\n      return componentType.hashCode();\n    }\n\n    @Override public String toString() {\n      return typeToString(componentType) + \"[]\";\n    }\n\n    private static final long serialVersionUID = 0;\n  }\n\n  /**\n   * The WildcardType interface supports multiple upper bounds and multiple\n   * lower bounds. We only support what the Java 6 language needs - at most one\n   * bound. If a lower bound is set, the upper bound must be Object.class.\n   */\n  private static final class WildcardTypeImpl implements WildcardType, Serializable {\n    private final Type upperBound;\n    private final Type lowerBound;\n\n    public WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {\n      checkArgument(lowerBounds.length <= 1);\n      checkArgument(upperBounds.length == 1);\n\n      if (lowerBounds.length == 1) {\n        checkNotNull(lowerBounds[0]);\n        checkNotPrimitive(lowerBounds[0]);\n        checkArgument(upperBounds[0] == Object.class);\n        this.lowerBound = canonicalize(lowerBounds[0]);\n        this.upperBound = Object.class;\n\n      } else {\n        checkNotNull(upperBounds[0]);\n        checkNotPrimitive(upperBounds[0]);\n        this.lowerBound = null;\n        this.upperBound = canonicalize(upperBounds[0]);\n      }\n    }\n\n    public Type[] getUpperBounds() {\n      return new Type[] { upperBound };\n    }\n\n    public Type[] getLowerBounds() {\n      return lowerBound != null ? new Type[] { lowerBound } : EMPTY_TYPE_ARRAY;\n    }\n\n    @Override public boolean equals(Object other) {\n      return other instanceof WildcardType\n          && $Gson$Types.equals(this, (WildcardType) other);\n    }\n\n    @Override public int hashCode() {\n      // this equals Arrays.hashCode(getLowerBounds()) ^ Arrays.hashCode(getUpperBounds());\n      return (lowerBound != null ? 31 + lowerBound.hashCode() : 1)\n          ^ (31 + upperBound.hashCode());\n    }\n\n    @Override public String toString() {\n      if (lowerBound != null) {\n        return \"? super \" + typeToString(lowerBound);\n      } else if (upperBound == Object.class) {\n        return \"?\";\n      } else {\n        return \"? extends \" + typeToString(upperBound);\n      }\n    }\n\n    private static final long serialVersionUID = 0;\n  }\n}\n"}]}
{"project": "Gson", "bug_id": 15, "classes_modified": [{"class_name": "com.google.gson.stream.JsonWriter", "buggy_version": "/*\n * Copyright (C) 2010 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.gson.stream;\n\nimport java.io.Closeable;\nimport java.io.Flushable;\nimport java.io.IOException;\nimport java.io.Writer;\n\nimport static com.google.gson.stream.JsonScope.DANGLING_NAME;\nimport static com.google.gson.stream.JsonScope.EMPTY_ARRAY;\nimport static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;\nimport static com.google.gson.stream.JsonScope.EMPTY_OBJECT;\nimport static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;\nimport static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;\nimport static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;\n\n/**\n * Writes a JSON (<a href=\"http://www.ietf.org/rfc/rfc7159.txt\">RFC 7159</a>)\n * encoded value to a stream, one token at a time. The stream includes both\n * literal values (strings, numbers, booleans and nulls) as well as the begin\n * and end delimiters of objects and arrays.\n *\n * <h3>Encoding JSON</h3>\n * To encode your data as JSON, create a new {@code JsonWriter}. Each JSON\n * document must contain one top-level array or object. Call methods on the\n * writer as you walk the structure's contents, nesting arrays and objects as\n * necessary:\n * <ul>\n *   <li>To write <strong>arrays</strong>, first call {@link #beginArray()}.\n *       Write each of the array's elements with the appropriate {@link #value}\n *       methods or by nesting other arrays and objects. Finally close the array\n *       using {@link #endArray()}.\n *   <li>To write <strong>objects</strong>, first call {@link #beginObject()}.\n *       Write each of the object's properties by alternating calls to\n *       {@link #name} with the property's value. Write property values with the\n *       appropriate {@link #value} method or by nesting other objects or arrays.\n *       Finally close the object using {@link #endObject()}.\n * </ul>\n *\n * <h3>Example</h3>\n * Suppose we'd like to encode a stream of messages such as the following: <pre> {@code\n * [\n *   {\n *     \"id\": 912345678901,\n *     \"text\": \"How do I stream JSON in Java?\",\n *     \"geo\": null,\n *     \"user\": {\n *       \"name\": \"json_newb\",\n *       \"followers_count\": 41\n *      }\n *   },\n *   {\n *     \"id\": 912345678902,\n *     \"text\": \"@json_newb just use JsonWriter!\",\n *     \"geo\": [50.454722, -104.606667],\n *     \"user\": {\n *       \"name\": \"jesse\",\n *       \"followers_count\": 2\n *     }\n *   }\n * ]}</pre>\n * This code encodes the above structure: <pre>   {@code\n *   public void writeJsonStream(OutputStream out, List<Message> messages) throws IOException {\n *     JsonWriter writer = new JsonWriter(new OutputStreamWriter(out, \"UTF-8\"));\n *     writer.setIndent(\"    \");\n *     writeMessagesArray(writer, messages);\n *     writer.close();\n *   }\n *\n *   public void writeMessagesArray(JsonWriter writer, List<Message> messages) throws IOException {\n *     writer.beginArray();\n *     for (Message message : messages) {\n *       writeMessage(writer, message);\n *     }\n *     writer.endArray();\n *   }\n *\n *   public void writeMessage(JsonWriter writer, Message message) throws IOException {\n *     writer.beginObject();\n *     writer.name(\"id\").value(message.getId());\n *     writer.name(\"text\").value(message.getText());\n *     if (message.getGeo() != null) {\n *       writer.name(\"geo\");\n *       writeDoublesArray(writer, message.getGeo());\n *     } else {\n *       writer.name(\"geo\").nullValue();\n *     }\n *     writer.name(\"user\");\n *     writeUser(writer, message.getUser());\n *     writer.endObject();\n *   }\n *\n *   public void writeUser(JsonWriter writer, User user) throws IOException {\n *     writer.beginObject();\n *     writer.name(\"name\").value(user.getName());\n *     writer.name(\"followers_count\").value(user.getFollowersCount());\n *     writer.endObject();\n *   }\n *\n *   public void writeDoublesArray(JsonWriter writer, List<Double> doubles) throws IOException {\n *     writer.beginArray();\n *     for (Double value : doubles) {\n *       writer.value(value);\n *     }\n *     writer.endArray();\n *   }}</pre>\n *\n * <p>Each {@code JsonWriter} may be used to write a single JSON stream.\n * Instances of this class are not thread safe. Calls that would result in a\n * malformed JSON string will fail with an {@link IllegalStateException}.\n *\n * @author Jesse Wilson\n * @since 1.6\n */\npublic class JsonWriter implements Closeable, Flushable {\n\n  /*\n   * From RFC 7159, \"All Unicode characters may be placed within the\n   * quotation marks except for the characters that must be escaped:\n   * quotation mark, reverse solidus, and the control characters\n   * (U+0000 through U+001F).\"\n   *\n   * We also escape '\\u2028' and '\\u2029', which JavaScript interprets as\n   * newline characters. This prevents eval() from failing with a syntax\n   * error. http://code.google.com/p/google-gson/issues/detail?id=341\n   */\n  private static final String[] REPLACEMENT_CHARS;\n  private static final String[] HTML_SAFE_REPLACEMENT_CHARS;\n  static {\n    REPLACEMENT_CHARS = new String[128];\n    for (int i = 0; i <= 0x1f; i++) {\n      REPLACEMENT_CHARS[i] = String.format(\"\\\\u%04x\", (int) i);\n    }\n    REPLACEMENT_CHARS['\"'] = \"\\\\\\\"\";\n    REPLACEMENT_CHARS['\\\\'] = \"\\\\\\\\\";\n    REPLACEMENT_CHARS['\\t'] = \"\\\\t\";\n    REPLACEMENT_CHARS['\\b'] = \"\\\\b\";\n    REPLACEMENT_CHARS['\\n'] = \"\\\\n\";\n    REPLACEMENT_CHARS['\\r'] = \"\\\\r\";\n    REPLACEMENT_CHARS['\\f'] = \"\\\\f\";\n    HTML_SAFE_REPLACEMENT_CHARS = REPLACEMENT_CHARS.clone();\n    HTML_SAFE_REPLACEMENT_CHARS['<'] = \"\\\\u003c\";\n    HTML_SAFE_REPLACEMENT_CHARS['>'] = \"\\\\u003e\";\n    HTML_SAFE_REPLACEMENT_CHARS['&'] = \"\\\\u0026\";\n    HTML_SAFE_REPLACEMENT_CHARS['='] = \"\\\\u003d\";\n    HTML_SAFE_REPLACEMENT_CHARS['\\''] = \"\\\\u0027\";\n  }\n\n  /** The output data, containing at most one top-level array or object. */\n  private final Writer out;\n\n  private int[] stack = new int[32];\n  private int stackSize = 0;\n  {\n    push(EMPTY_DOCUMENT);\n  }\n\n  /**\n   * A string containing a full set of spaces for a single level of\n   * indentation, or null for no pretty printing.\n   */\n  private String indent;\n\n  /**\n   * The name/value separator; either \":\" or \": \".\n   */\n  private String separator = \":\";\n\n  private boolean lenient;\n\n  private boolean htmlSafe;\n\n  private String deferredName;\n\n  private boolean serializeNulls = true;\n\n  /**\n   * Creates a new instance that writes a JSON-encoded stream to {@code out}.\n   * For best performance, ensure {@link Writer} is buffered; wrapping in\n   * {@link java.io.BufferedWriter BufferedWriter} if necessary.\n   */\n  public JsonWriter(Writer out) {\n    if (out == null) {\n      throw new NullPointerException(\"out == null\");\n    }\n    this.out = out;\n  }\n\n  /**\n   * Sets the indentation string to be repeated for each level of indentation\n   * in the encoded document. If {@code indent.isEmpty()} the encoded document\n   * will be compact. Otherwise the encoded document will be more\n   * human-readable.\n   *\n   * @param indent a string containing only whitespace.\n   */\n  public final void setIndent(String indent) {\n    if (indent.length() == 0) {\n      this.indent = null;\n      this.separator = \":\";\n    } else {\n      this.indent = indent;\n      this.separator = \": \";\n    }\n  }\n\n  /**\n   * Configure this writer to relax its syntax rules. By default, this writer\n   * only emits well-formed JSON as specified by <a\n   * href=\"http://www.ietf.org/rfc/rfc7159.txt\">RFC 7159</a>. Setting the writer\n   * to lenient permits the following:\n   * <ul>\n   *   <li>Top-level values of any type. With strict writing, the top-level\n   *       value must be an object or an array.\n   *   <li>Numbers may be {@link Double#isNaN() NaNs} or {@link\n   *       Double#isInfinite() infinities}.\n   * </ul>\n   */\n  public final void setLenient(boolean lenient) {\n    this.lenient = lenient;\n  }\n\n  /**\n   * Returns true if this writer has relaxed syntax rules.\n   */\n  public boolean isLenient() {\n    return lenient;\n  }\n\n  /**\n   * Configure this writer to emit JSON that's safe for direct inclusion in HTML\n   * and XML documents. This escapes the HTML characters {@code <}, {@code >},\n   * {@code &} and {@code =} before writing them to the stream. Without this\n   * setting, your XML/HTML encoder should replace these characters with the\n   * corresponding escape sequences.\n   */\n  public final void setHtmlSafe(boolean htmlSafe) {\n    this.htmlSafe = htmlSafe;\n  }\n\n  /**\n   * Returns true if this writer writes JSON that's safe for inclusion in HTML\n   * and XML documents.\n   */\n  public final boolean isHtmlSafe() {\n    return htmlSafe;\n  }\n\n  /**\n   * Sets whether object members are serialized when their value is null.\n   * This has no impact on array elements. The default is true.\n   */\n  public final void setSerializeNulls(boolean serializeNulls) {\n    this.serializeNulls = serializeNulls;\n  }\n\n  /**\n   * Returns true if object members are serialized when their value is null.\n   * This has no impact on array elements. The default is true.\n   */\n  public final boolean getSerializeNulls() {\n    return serializeNulls;\n  }\n\n  /**\n   * Begins encoding a new array. Each call to this method must be paired with\n   * a call to {@link #endArray}.\n   *\n   * @return this writer.\n   */\n  public JsonWriter beginArray() throws IOException {\n    writeDeferredName();\n    return open(EMPTY_ARRAY, \"[\");\n  }\n\n  /**\n   * Ends encoding the current array.\n   *\n   * @return this writer.\n   */\n  public JsonWriter endArray() throws IOException {\n    return close(EMPTY_ARRAY, NONEMPTY_ARRAY, \"]\");\n  }\n\n  /**\n   * Begins encoding a new object. Each call to this method must be paired\n   * with a call to {@link #endObject}.\n   *\n   * @return this writer.\n   */\n  public JsonWriter beginObject() throws IOException {\n    writeDeferredName();\n    return open(EMPTY_OBJECT, \"{\");\n  }\n\n  /**\n   * Ends encoding the current object.\n   *\n   * @return this writer.\n   */\n  public JsonWriter endObject() throws IOException {\n    return close(EMPTY_OBJECT, NONEMPTY_OBJECT, \"}\");\n  }\n\n  /**\n   * Enters a new scope by appending any necessary whitespace and the given\n   * bracket.\n   */\n  private JsonWriter open(int empty, String openBracket) throws IOException {\n    beforeValue();\n    push(empty);\n    out.write(openBracket);\n    return this;\n  }\n\n  /**\n   * Closes the current scope by appending any necessary whitespace and the\n   * given bracket.\n   */\n  private JsonWriter close(int empty, int nonempty, String closeBracket)\n      throws IOException {\n    int context = peek();\n    if (context != nonempty && context != empty) {\n      throw new IllegalStateException(\"Nesting problem.\");\n    }\n    if (deferredName != null) {\n      throw new IllegalStateException(\"Dangling name: \" + deferredName);\n    }\n\n    stackSize--;\n    if (context == nonempty) {\n      newline();\n    }\n    out.write(closeBracket);\n    return this;\n  }\n\n  private void push(int newTop) {\n    if (stackSize == stack.length) {\n      int[] newStack = new int[stackSize * 2];\n      System.arraycopy(stack, 0, newStack, 0, stackSize);\n      stack = newStack;\n    }\n    stack[stackSize++] = newTop;\n  }\n\n  /**\n   * Returns the value on the top of the stack.\n   */\n  private int peek() {\n    if (stackSize == 0) {\n      throw new IllegalStateException(\"JsonWriter is closed.\");\n    }\n    return stack[stackSize - 1];\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(int topOfStack) {\n    stack[stackSize - 1] = topOfStack;\n  }\n\n  /**\n   * Encodes the property name.\n   *\n   * @param name the name of the forthcoming value. May not be null.\n   * @return this writer.\n   */\n  public JsonWriter name(String name) throws IOException {\n    if (name == null) {\n      throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) {\n      throw new IllegalStateException();\n    }\n    if (stackSize == 0) {\n      throw new IllegalStateException(\"JsonWriter is closed.\");\n    }\n    deferredName = name;\n    return this;\n  }\n\n  private void writeDeferredName() throws IOException {\n    if (deferredName != null) {\n      beforeName();\n      string(deferredName);\n      deferredName = null;\n    }\n  }\n\n  /**\n   * Encodes {@code value}.\n   *\n   * @param value the literal string value, or null to encode a null literal.\n   * @return this writer.\n   */\n  public JsonWriter value(String value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n    writeDeferredName();\n    beforeValue();\n    string(value);\n    return this;\n  }\n\n  /**\n   * Writes {@code value} directly to the writer without quoting or\n   * escaping.\n   *\n   * @param value the literal string value, or null to encode a null literal.\n   * @return this writer.\n   */\n  public JsonWriter jsonValue(String value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n    writeDeferredName();\n    beforeValue();\n    out.append(value);\n    return this;\n  }\n\n  /**\n   * Encodes {@code null}.\n   *\n   * @return this writer.\n   */\n  public JsonWriter nullValue() throws IOException {\n    if (deferredName != null) {\n      if (serializeNulls) {\n        writeDeferredName();\n      } else {\n        deferredName = null;\n        return this; // skip the name and the value\n      }\n    }\n    beforeValue();\n    out.write(\"null\");\n    return this;\n  }\n\n  /**\n   * Encodes {@code value}.\n   *\n   * @return this writer.\n   */\n  public JsonWriter value(boolean value) throws IOException {\n    writeDeferredName();\n    beforeValue();\n    out.write(value ? \"true\" : \"false\");\n    return this;\n  }\n\n  /**\n   * Encodes {@code value}.\n   *\n   * @return this writer.\n   */\n  public JsonWriter value(Boolean value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n    writeDeferredName();\n    beforeValue();\n    out.write(value ? \"true\" : \"false\");\n    return this;\n  }\n\n  /**\n   * Encodes {@code value}.\n   *\n   * @param value a finite value. May not be {@link Double#isNaN() NaNs} or\n   *     {@link Double#isInfinite() infinities}.\n   * @return this writer.\n   */\n  public JsonWriter value(double value) throws IOException {\n    writeDeferredName();\n    if (Double.isNaN(value) || Double.isInfinite(value)) {\n      throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n    }\n    beforeValue();\n    out.append(Double.toString(value));\n    return this;\n  }\n\n  /**\n   * Encodes {@code value}.\n   *\n   * @return this writer.\n   */\n  public JsonWriter value(long value) throws IOException {\n    writeDeferredName();\n    beforeValue();\n    out.write(Long.toString(value));\n    return this;\n  }\n\n  /**\n   * Encodes {@code value}.\n   *\n   * @param value a finite value. May not be {@link Double#isNaN() NaNs} or\n   *     {@link Double#isInfinite() infinities}.\n   * @return this writer.\n   */\n  public JsonWriter value(Number value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n\n    writeDeferredName();\n    String string = value.toString();\n    if (!lenient\n        && (string.equals(\"-Infinity\") || string.equals(\"Infinity\") || string.equals(\"NaN\"))) {\n      throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n    }\n    beforeValue();\n    out.append(string);\n    return this;\n  }\n\n  /**\n   * Ensures all buffered data is written to the underlying {@link Writer}\n   * and flushes that writer.\n   */\n  public void flush() throws IOException {\n    if (stackSize == 0) {\n      throw new IllegalStateException(\"JsonWriter is closed.\");\n    }\n    out.flush();\n  }\n\n  /**\n   * Flushes and closes this writer and the underlying {@link Writer}.\n   *\n   * @throws IOException if the JSON document is incomplete.\n   */\n  public void close() throws IOException {\n    out.close();\n\n    int size = stackSize;\n    if (size > 1 || size == 1 && stack[size - 1] != NONEMPTY_DOCUMENT) {\n      throw new IOException(\"Incomplete document\");\n    }\n    stackSize = 0;\n  }\n\n  private void string(String value) throws IOException {\n    String[] replacements = htmlSafe ? HTML_SAFE_REPLACEMENT_CHARS : REPLACEMENT_CHARS;\n    out.write(\"\\\"\");\n    int last = 0;\n    int length = value.length();\n    for (int i = 0; i < length; i++) {\n      char c = value.charAt(i);\n      String replacement;\n      if (c < 128) {\n        replacement = replacements[c];\n        if (replacement == null) {\n          continue;\n        }\n      } else if (c == '\\u2028') {\n        replacement = \"\\\\u2028\";\n      } else if (c == '\\u2029') {\n        replacement = \"\\\\u2029\";\n      } else {\n        continue;\n      }\n      if (last < i) {\n        out.write(value, last, i - last);\n      }\n      out.write(replacement);\n      last = i + 1;\n    }\n    if (last < length) {\n      out.write(value, last, length - last);\n    }\n    out.write(\"\\\"\");\n  }\n\n  private void newline() throws IOException {\n    if (indent == null) {\n      return;\n    }\n\n    out.write(\"\\n\");\n    for (int i = 1, size = stackSize; i < size; i++) {\n      out.write(indent);\n    }\n  }\n\n  /**\n   * Inserts any necessary separators and whitespace before a name. Also\n   * adjusts the stack to expect the name's value.\n   */\n  private void beforeName() throws IOException {\n    int context = peek();\n    if (context == NONEMPTY_OBJECT) { // first in object\n      out.write(',');\n    } else if (context != EMPTY_OBJECT) { // not in an object!\n      throw new IllegalStateException(\"Nesting problem.\");\n    }\n    newline();\n    replaceTop(DANGLING_NAME);\n  }\n\n  /**\n   * Inserts any necessary separators and whitespace before a literal value,\n   * inline array, or inline object. Also adjusts the stack to expect either a\n   * closing bracket or another element.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private void beforeValue() throws IOException {\n    switch (peek()) {\n    case NONEMPTY_DOCUMENT:\n      if (!lenient) {\n        throw new IllegalStateException(\n            \"JSON must have only one top-level value.\");\n      }\n      // fall-through\n    case EMPTY_DOCUMENT: // first in document\n      replaceTop(NONEMPTY_DOCUMENT);\n      break;\n\n    case EMPTY_ARRAY: // first in array\n      replaceTop(NONEMPTY_ARRAY);\n      newline();\n      break;\n\n    case NONEMPTY_ARRAY: // another in array\n      out.append(',');\n      newline();\n      break;\n\n    case DANGLING_NAME: // value for name\n      out.append(separator);\n      replaceTop(NONEMPTY_OBJECT);\n      break;\n\n    default:\n      throw new IllegalStateException(\"Nesting problem.\");\n    }\n  }\n}\n", "fixed_version": "/*\n * Copyright (C) 2010 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.gson.stream;\n\nimport java.io.Closeable;\nimport java.io.Flushable;\nimport java.io.IOException;\nimport java.io.Writer;\n\nimport static com.google.gson.stream.JsonScope.DANGLING_NAME;\nimport static com.google.gson.stream.JsonScope.EMPTY_ARRAY;\nimport static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;\nimport static com.google.gson.stream.JsonScope.EMPTY_OBJECT;\nimport static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;\nimport static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;\nimport static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;\n\n/**\n * Writes a JSON (<a href=\"http://www.ietf.org/rfc/rfc7159.txt\">RFC 7159</a>)\n * encoded value to a stream, one token at a time. The stream includes both\n * literal values (strings, numbers, booleans and nulls) as well as the begin\n * and end delimiters of objects and arrays.\n *\n * <h3>Encoding JSON</h3>\n * To encode your data as JSON, create a new {@code JsonWriter}. Each JSON\n * document must contain one top-level array or object. Call methods on the\n * writer as you walk the structure's contents, nesting arrays and objects as\n * necessary:\n * <ul>\n *   <li>To write <strong>arrays</strong>, first call {@link #beginArray()}.\n *       Write each of the array's elements with the appropriate {@link #value}\n *       methods or by nesting other arrays and objects. Finally close the array\n *       using {@link #endArray()}.\n *   <li>To write <strong>objects</strong>, first call {@link #beginObject()}.\n *       Write each of the object's properties by alternating calls to\n *       {@link #name} with the property's value. Write property values with the\n *       appropriate {@link #value} method or by nesting other objects or arrays.\n *       Finally close the object using {@link #endObject()}.\n * </ul>\n *\n * <h3>Example</h3>\n * Suppose we'd like to encode a stream of messages such as the following: <pre> {@code\n * [\n *   {\n *     \"id\": 912345678901,\n *     \"text\": \"How do I stream JSON in Java?\",\n *     \"geo\": null,\n *     \"user\": {\n *       \"name\": \"json_newb\",\n *       \"followers_count\": 41\n *      }\n *   },\n *   {\n *     \"id\": 912345678902,\n *     \"text\": \"@json_newb just use JsonWriter!\",\n *     \"geo\": [50.454722, -104.606667],\n *     \"user\": {\n *       \"name\": \"jesse\",\n *       \"followers_count\": 2\n *     }\n *   }\n * ]}</pre>\n * This code encodes the above structure: <pre>   {@code\n *   public void writeJsonStream(OutputStream out, List<Message> messages) throws IOException {\n *     JsonWriter writer = new JsonWriter(new OutputStreamWriter(out, \"UTF-8\"));\n *     writer.setIndent(\"    \");\n *     writeMessagesArray(writer, messages);\n *     writer.close();\n *   }\n *\n *   public void writeMessagesArray(JsonWriter writer, List<Message> messages) throws IOException {\n *     writer.beginArray();\n *     for (Message message : messages) {\n *       writeMessage(writer, message);\n *     }\n *     writer.endArray();\n *   }\n *\n *   public void writeMessage(JsonWriter writer, Message message) throws IOException {\n *     writer.beginObject();\n *     writer.name(\"id\").value(message.getId());\n *     writer.name(\"text\").value(message.getText());\n *     if (message.getGeo() != null) {\n *       writer.name(\"geo\");\n *       writeDoublesArray(writer, message.getGeo());\n *     } else {\n *       writer.name(\"geo\").nullValue();\n *     }\n *     writer.name(\"user\");\n *     writeUser(writer, message.getUser());\n *     writer.endObject();\n *   }\n *\n *   public void writeUser(JsonWriter writer, User user) throws IOException {\n *     writer.beginObject();\n *     writer.name(\"name\").value(user.getName());\n *     writer.name(\"followers_count\").value(user.getFollowersCount());\n *     writer.endObject();\n *   }\n *\n *   public void writeDoublesArray(JsonWriter writer, List<Double> doubles) throws IOException {\n *     writer.beginArray();\n *     for (Double value : doubles) {\n *       writer.value(value);\n *     }\n *     writer.endArray();\n *   }}</pre>\n *\n * <p>Each {@code JsonWriter} may be used to write a single JSON stream.\n * Instances of this class are not thread safe. Calls that would result in a\n * malformed JSON string will fail with an {@link IllegalStateException}.\n *\n * @author Jesse Wilson\n * @since 1.6\n */\npublic class JsonWriter implements Closeable, Flushable {\n\n  /*\n   * From RFC 7159, \"All Unicode characters may be placed within the\n   * quotation marks except for the characters that must be escaped:\n   * quotation mark, reverse solidus, and the control characters\n   * (U+0000 through U+001F).\"\n   *\n   * We also escape '\\u2028' and '\\u2029', which JavaScript interprets as\n   * newline characters. This prevents eval() from failing with a syntax\n   * error. http://code.google.com/p/google-gson/issues/detail?id=341\n   */\n  private static final String[] REPLACEMENT_CHARS;\n  private static final String[] HTML_SAFE_REPLACEMENT_CHARS;\n  static {\n    REPLACEMENT_CHARS = new String[128];\n    for (int i = 0; i <= 0x1f; i++) {\n      REPLACEMENT_CHARS[i] = String.format(\"\\\\u%04x\", (int) i);\n    }\n    REPLACEMENT_CHARS['\"'] = \"\\\\\\\"\";\n    REPLACEMENT_CHARS['\\\\'] = \"\\\\\\\\\";\n    REPLACEMENT_CHARS['\\t'] = \"\\\\t\";\n    REPLACEMENT_CHARS['\\b'] = \"\\\\b\";\n    REPLACEMENT_CHARS['\\n'] = \"\\\\n\";\n    REPLACEMENT_CHARS['\\r'] = \"\\\\r\";\n    REPLACEMENT_CHARS['\\f'] = \"\\\\f\";\n    HTML_SAFE_REPLACEMENT_CHARS = REPLACEMENT_CHARS.clone();\n    HTML_SAFE_REPLACEMENT_CHARS['<'] = \"\\\\u003c\";\n    HTML_SAFE_REPLACEMENT_CHARS['>'] = \"\\\\u003e\";\n    HTML_SAFE_REPLACEMENT_CHARS['&'] = \"\\\\u0026\";\n    HTML_SAFE_REPLACEMENT_CHARS['='] = \"\\\\u003d\";\n    HTML_SAFE_REPLACEMENT_CHARS['\\''] = \"\\\\u0027\";\n  }\n\n  /** The output data, containing at most one top-level array or object. */\n  private final Writer out;\n\n  private int[] stack = new int[32];\n  private int stackSize = 0;\n  {\n    push(EMPTY_DOCUMENT);\n  }\n\n  /**\n   * A string containing a full set of spaces for a single level of\n   * indentation, or null for no pretty printing.\n   */\n  private String indent;\n\n  /**\n   * The name/value separator; either \":\" or \": \".\n   */\n  private String separator = \":\";\n\n  private boolean lenient;\n\n  private boolean htmlSafe;\n\n  private String deferredName;\n\n  private boolean serializeNulls = true;\n\n  /**\n   * Creates a new instance that writes a JSON-encoded stream to {@code out}.\n   * For best performance, ensure {@link Writer} is buffered; wrapping in\n   * {@link java.io.BufferedWriter BufferedWriter} if necessary.\n   */\n  public JsonWriter(Writer out) {\n    if (out == null) {\n      throw new NullPointerException(\"out == null\");\n    }\n    this.out = out;\n  }\n\n  /**\n   * Sets the indentation string to be repeated for each level of indentation\n   * in the encoded document. If {@code indent.isEmpty()} the encoded document\n   * will be compact. Otherwise the encoded document will be more\n   * human-readable.\n   *\n   * @param indent a string containing only whitespace.\n   */\n  public final void setIndent(String indent) {\n    if (indent.length() == 0) {\n      this.indent = null;\n      this.separator = \":\";\n    } else {\n      this.indent = indent;\n      this.separator = \": \";\n    }\n  }\n\n  /**\n   * Configure this writer to relax its syntax rules. By default, this writer\n   * only emits well-formed JSON as specified by <a\n   * href=\"http://www.ietf.org/rfc/rfc7159.txt\">RFC 7159</a>. Setting the writer\n   * to lenient permits the following:\n   * <ul>\n   *   <li>Top-level values of any type. With strict writing, the top-level\n   *       value must be an object or an array.\n   *   <li>Numbers may be {@link Double#isNaN() NaNs} or {@link\n   *       Double#isInfinite() infinities}.\n   * </ul>\n   */\n  public final void setLenient(boolean lenient) {\n    this.lenient = lenient;\n  }\n\n  /**\n   * Returns true if this writer has relaxed syntax rules.\n   */\n  public boolean isLenient() {\n    return lenient;\n  }\n\n  /**\n   * Configure this writer to emit JSON that's safe for direct inclusion in HTML\n   * and XML documents. This escapes the HTML characters {@code <}, {@code >},\n   * {@code &} and {@code =} before writing them to the stream. Without this\n   * setting, your XML/HTML encoder should replace these characters with the\n   * corresponding escape sequences.\n   */\n  public final void setHtmlSafe(boolean htmlSafe) {\n    this.htmlSafe = htmlSafe;\n  }\n\n  /**\n   * Returns true if this writer writes JSON that's safe for inclusion in HTML\n   * and XML documents.\n   */\n  public final boolean isHtmlSafe() {\n    return htmlSafe;\n  }\n\n  /**\n   * Sets whether object members are serialized when their value is null.\n   * This has no impact on array elements. The default is true.\n   */\n  public final void setSerializeNulls(boolean serializeNulls) {\n    this.serializeNulls = serializeNulls;\n  }\n\n  /**\n   * Returns true if object members are serialized when their value is null.\n   * This has no impact on array elements. The default is true.\n   */\n  public final boolean getSerializeNulls() {\n    return serializeNulls;\n  }\n\n  /**\n   * Begins encoding a new array. Each call to this method must be paired with\n   * a call to {@link #endArray}.\n   *\n   * @return this writer.\n   */\n  public JsonWriter beginArray() throws IOException {\n    writeDeferredName();\n    return open(EMPTY_ARRAY, \"[\");\n  }\n\n  /**\n   * Ends encoding the current array.\n   *\n   * @return this writer.\n   */\n  public JsonWriter endArray() throws IOException {\n    return close(EMPTY_ARRAY, NONEMPTY_ARRAY, \"]\");\n  }\n\n  /**\n   * Begins encoding a new object. Each call to this method must be paired\n   * with a call to {@link #endObject}.\n   *\n   * @return this writer.\n   */\n  public JsonWriter beginObject() throws IOException {\n    writeDeferredName();\n    return open(EMPTY_OBJECT, \"{\");\n  }\n\n  /**\n   * Ends encoding the current object.\n   *\n   * @return this writer.\n   */\n  public JsonWriter endObject() throws IOException {\n    return close(EMPTY_OBJECT, NONEMPTY_OBJECT, \"}\");\n  }\n\n  /**\n   * Enters a new scope by appending any necessary whitespace and the given\n   * bracket.\n   */\n  private JsonWriter open(int empty, String openBracket) throws IOException {\n    beforeValue();\n    push(empty);\n    out.write(openBracket);\n    return this;\n  }\n\n  /**\n   * Closes the current scope by appending any necessary whitespace and the\n   * given bracket.\n   */\n  private JsonWriter close(int empty, int nonempty, String closeBracket)\n      throws IOException {\n    int context = peek();\n    if (context != nonempty && context != empty) {\n      throw new IllegalStateException(\"Nesting problem.\");\n    }\n    if (deferredName != null) {\n      throw new IllegalStateException(\"Dangling name: \" + deferredName);\n    }\n\n    stackSize--;\n    if (context == nonempty) {\n      newline();\n    }\n    out.write(closeBracket);\n    return this;\n  }\n\n  private void push(int newTop) {\n    if (stackSize == stack.length) {\n      int[] newStack = new int[stackSize * 2];\n      System.arraycopy(stack, 0, newStack, 0, stackSize);\n      stack = newStack;\n    }\n    stack[stackSize++] = newTop;\n  }\n\n  /**\n   * Returns the value on the top of the stack.\n   */\n  private int peek() {\n    if (stackSize == 0) {\n      throw new IllegalStateException(\"JsonWriter is closed.\");\n    }\n    return stack[stackSize - 1];\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(int topOfStack) {\n    stack[stackSize - 1] = topOfStack;\n  }\n\n  /**\n   * Encodes the property name.\n   *\n   * @param name the name of the forthcoming value. May not be null.\n   * @return this writer.\n   */\n  public JsonWriter name(String name) throws IOException {\n    if (name == null) {\n      throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) {\n      throw new IllegalStateException();\n    }\n    if (stackSize == 0) {\n      throw new IllegalStateException(\"JsonWriter is closed.\");\n    }\n    deferredName = name;\n    return this;\n  }\n\n  private void writeDeferredName() throws IOException {\n    if (deferredName != null) {\n      beforeName();\n      string(deferredName);\n      deferredName = null;\n    }\n  }\n\n  /**\n   * Encodes {@code value}.\n   *\n   * @param value the literal string value, or null to encode a null literal.\n   * @return this writer.\n   */\n  public JsonWriter value(String value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n    writeDeferredName();\n    beforeValue();\n    string(value);\n    return this;\n  }\n\n  /**\n   * Writes {@code value} directly to the writer without quoting or\n   * escaping.\n   *\n   * @param value the literal string value, or null to encode a null literal.\n   * @return this writer.\n   */\n  public JsonWriter jsonValue(String value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n    writeDeferredName();\n    beforeValue();\n    out.append(value);\n    return this;\n  }\n\n  /**\n   * Encodes {@code null}.\n   *\n   * @return this writer.\n   */\n  public JsonWriter nullValue() throws IOException {\n    if (deferredName != null) {\n      if (serializeNulls) {\n        writeDeferredName();\n      } else {\n        deferredName = null;\n        return this; // skip the name and the value\n      }\n    }\n    beforeValue();\n    out.write(\"null\");\n    return this;\n  }\n\n  /**\n   * Encodes {@code value}.\n   *\n   * @return this writer.\n   */\n  public JsonWriter value(boolean value) throws IOException {\n    writeDeferredName();\n    beforeValue();\n    out.write(value ? \"true\" : \"false\");\n    return this;\n  }\n\n  /**\n   * Encodes {@code value}.\n   *\n   * @return this writer.\n   */\n  public JsonWriter value(Boolean value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n    writeDeferredName();\n    beforeValue();\n    out.write(value ? \"true\" : \"false\");\n    return this;\n  }\n\n  /**\n   * Encodes {@code value}.\n   *\n   * @param value a finite value. May not be {@link Double#isNaN() NaNs} or\n   *     {@link Double#isInfinite() infinities}.\n   * @return this writer.\n   */\n  public JsonWriter value(double value) throws IOException {\n    writeDeferredName();\n    if (!lenient && (Double.isNaN(value) || Double.isInfinite(value))) {\n      throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n    }\n    beforeValue();\n    out.append(Double.toString(value));\n    return this;\n  }\n\n  /**\n   * Encodes {@code value}.\n   *\n   * @return this writer.\n   */\n  public JsonWriter value(long value) throws IOException {\n    writeDeferredName();\n    beforeValue();\n    out.write(Long.toString(value));\n    return this;\n  }\n\n  /**\n   * Encodes {@code value}.\n   *\n   * @param value a finite value. May not be {@link Double#isNaN() NaNs} or\n   *     {@link Double#isInfinite() infinities}.\n   * @return this writer.\n   */\n  public JsonWriter value(Number value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n\n    writeDeferredName();\n    String string = value.toString();\n    if (!lenient\n        && (string.equals(\"-Infinity\") || string.equals(\"Infinity\") || string.equals(\"NaN\"))) {\n      throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n    }\n    beforeValue();\n    out.append(string);\n    return this;\n  }\n\n  /**\n   * Ensures all buffered data is written to the underlying {@link Writer}\n   * and flushes that writer.\n   */\n  public void flush() throws IOException {\n    if (stackSize == 0) {\n      throw new IllegalStateException(\"JsonWriter is closed.\");\n    }\n    out.flush();\n  }\n\n  /**\n   * Flushes and closes this writer and the underlying {@link Writer}.\n   *\n   * @throws IOException if the JSON document is incomplete.\n   */\n  public void close() throws IOException {\n    out.close();\n\n    int size = stackSize;\n    if (size > 1 || size == 1 && stack[size - 1] != NONEMPTY_DOCUMENT) {\n      throw new IOException(\"Incomplete document\");\n    }\n    stackSize = 0;\n  }\n\n  private void string(String value) throws IOException {\n    String[] replacements = htmlSafe ? HTML_SAFE_REPLACEMENT_CHARS : REPLACEMENT_CHARS;\n    out.write(\"\\\"\");\n    int last = 0;\n    int length = value.length();\n    for (int i = 0; i < length; i++) {\n      char c = value.charAt(i);\n      String replacement;\n      if (c < 128) {\n        replacement = replacements[c];\n        if (replacement == null) {\n          continue;\n        }\n      } else if (c == '\\u2028') {\n        replacement = \"\\\\u2028\";\n      } else if (c == '\\u2029') {\n        replacement = \"\\\\u2029\";\n      } else {\n        continue;\n      }\n      if (last < i) {\n        out.write(value, last, i - last);\n      }\n      out.write(replacement);\n      last = i + 1;\n    }\n    if (last < length) {\n      out.write(value, last, length - last);\n    }\n    out.write(\"\\\"\");\n  }\n\n  private void newline() throws IOException {\n    if (indent == null) {\n      return;\n    }\n\n    out.write(\"\\n\");\n    for (int i = 1, size = stackSize; i < size; i++) {\n      out.write(indent);\n    }\n  }\n\n  /**\n   * Inserts any necessary separators and whitespace before a name. Also\n   * adjusts the stack to expect the name's value.\n   */\n  private void beforeName() throws IOException {\n    int context = peek();\n    if (context == NONEMPTY_OBJECT) { // first in object\n      out.write(',');\n    } else if (context != EMPTY_OBJECT) { // not in an object!\n      throw new IllegalStateException(\"Nesting problem.\");\n    }\n    newline();\n    replaceTop(DANGLING_NAME);\n  }\n\n  /**\n   * Inserts any necessary separators and whitespace before a literal value,\n   * inline array, or inline object. Also adjusts the stack to expect either a\n   * closing bracket or another element.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private void beforeValue() throws IOException {\n    switch (peek()) {\n    case NONEMPTY_DOCUMENT:\n      if (!lenient) {\n        throw new IllegalStateException(\n            \"JSON must have only one top-level value.\");\n      }\n      // fall-through\n    case EMPTY_DOCUMENT: // first in document\n      replaceTop(NONEMPTY_DOCUMENT);\n      break;\n\n    case EMPTY_ARRAY: // first in array\n      replaceTop(NONEMPTY_ARRAY);\n      newline();\n      break;\n\n    case NONEMPTY_ARRAY: // another in array\n      out.append(',');\n      newline();\n      break;\n\n    case DANGLING_NAME: // value for name\n      out.append(separator);\n      replaceTop(NONEMPTY_OBJECT);\n      break;\n\n    default:\n      throw new IllegalStateException(\"Nesting problem.\");\n    }\n  }\n}\n"}]}
{"project": "Gson", "bug_id": 16, "classes_modified": [{"class_name": "com.google.gson.internal.$Gson$Types", "buggy_version": "/**\n * Copyright (C) 2008 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.gson.internal;\n\nimport java.io.Serializable;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.GenericArrayType;\nimport java.lang.reflect.GenericDeclaration;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.TypeVariable;\nimport java.lang.reflect.WildcardType;\nimport java.util.*;\n\nimport static com.google.gson.internal.$Gson$Preconditions.checkArgument;\nimport static com.google.gson.internal.$Gson$Preconditions.checkNotNull;\n\n/**\n * Static methods for working with types.\n *\n * @author Bob Lee\n * @author Jesse Wilson\n */\npublic final class $Gson$Types {\n  static final Type[] EMPTY_TYPE_ARRAY = new Type[] {};\n\n  private $Gson$Types() {\n    throw new UnsupportedOperationException();\n  }\n\n  /**\n   * Returns a new parameterized type, applying {@code typeArguments} to\n   * {@code rawType} and enclosed by {@code ownerType}.\n   *\n   * @return a {@link java.io.Serializable serializable} parameterized type.\n   */\n  public static ParameterizedType newParameterizedTypeWithOwner(\n      Type ownerType, Type rawType, Type... typeArguments) {\n    return new ParameterizedTypeImpl(ownerType, rawType, typeArguments);\n  }\n\n  /**\n   * Returns an array type whose elements are all instances of\n   * {@code componentType}.\n   *\n   * @return a {@link java.io.Serializable serializable} generic array type.\n   */\n  public static GenericArrayType arrayOf(Type componentType) {\n    return new GenericArrayTypeImpl(componentType);\n  }\n\n  /**\n   * Returns a type that represents an unknown type that extends {@code bound}.\n   * For example, if {@code bound} is {@code CharSequence.class}, this returns\n   * {@code ? extends CharSequence}. If {@code bound} is {@code Object.class},\n   * this returns {@code ?}, which is shorthand for {@code ? extends Object}.\n   */\n  public static WildcardType subtypeOf(Type bound) {\n    Type[] upperBounds;\n    if (bound instanceof WildcardType) {\n      upperBounds = ((WildcardType) bound).getUpperBounds();\n    } else {\n      upperBounds = new Type[] { bound };\n    }\n    return new WildcardTypeImpl(upperBounds, EMPTY_TYPE_ARRAY);\n  }\n\n  /**\n   * Returns a type that represents an unknown supertype of {@code bound}. For\n   * example, if {@code bound} is {@code String.class}, this returns {@code ?\n   * super String}.\n   */\n  public static WildcardType supertypeOf(Type bound) {\n    Type[] lowerBounds;\n    if (bound instanceof WildcardType) {\n      lowerBounds = ((WildcardType) bound).getLowerBounds();\n    } else {\n      lowerBounds = new Type[] { bound };\n    }\n    return new WildcardTypeImpl(new Type[] { Object.class }, lowerBounds);\n  }\n\n  /**\n   * Returns a type that is functionally equal but not necessarily equal\n   * according to {@link Object#equals(Object) Object.equals()}. The returned\n   * type is {@link java.io.Serializable}.\n   */\n  public static Type canonicalize(Type type) {\n    if (type instanceof Class) {\n      Class<?> c = (Class<?>) type;\n      return c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c;\n\n    } else if (type instanceof ParameterizedType) {\n      ParameterizedType p = (ParameterizedType) type;\n      return new ParameterizedTypeImpl(p.getOwnerType(),\n          p.getRawType(), p.getActualTypeArguments());\n\n    } else if (type instanceof GenericArrayType) {\n      GenericArrayType g = (GenericArrayType) type;\n      return new GenericArrayTypeImpl(g.getGenericComponentType());\n\n    } else if (type instanceof WildcardType) {\n      WildcardType w = (WildcardType) type;\n      return new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds());\n\n    } else {\n      // type is either serializable as-is or unsupported\n      return type;\n    }\n  }\n\n  public static Class<?> getRawType(Type type) {\n    if (type instanceof Class<?>) {\n      // type is a normal class.\n      return (Class<?>) type;\n\n    } else if (type instanceof ParameterizedType) {\n      ParameterizedType parameterizedType = (ParameterizedType) type;\n\n      // I'm not exactly sure why getRawType() returns Type instead of Class.\n      // Neal isn't either but suspects some pathological case related\n      // to nested classes exists.\n      Type rawType = parameterizedType.getRawType();\n      checkArgument(rawType instanceof Class);\n      return (Class<?>) rawType;\n\n    } else if (type instanceof GenericArrayType) {\n      Type componentType = ((GenericArrayType)type).getGenericComponentType();\n      return Array.newInstance(getRawType(componentType), 0).getClass();\n\n    } else if (type instanceof TypeVariable) {\n      // we could use the variable's bounds, but that won't work if there are multiple.\n      // having a raw type that's more general than necessary is okay\n      return Object.class;\n\n    } else if (type instanceof WildcardType) {\n      return getRawType(((WildcardType) type).getUpperBounds()[0]);\n\n    } else {\n      String className = type == null ? \"null\" : type.getClass().getName();\n      throw new IllegalArgumentException(\"Expected a Class, ParameterizedType, or \"\n          + \"GenericArrayType, but <\" + type + \"> is of type \" + className);\n    }\n  }\n\n  static boolean equal(Object a, Object b) {\n    return a == b || (a != null && a.equals(b));\n  }\n\n  /**\n   * Returns true if {@code a} and {@code b} are equal.\n   */\n  public static boolean equals(Type a, Type b) {\n    if (a == b) {\n      // also handles (a == null && b == null)\n      return true;\n\n    } else if (a instanceof Class) {\n      // Class already specifies equals().\n      return a.equals(b);\n\n    } else if (a instanceof ParameterizedType) {\n      if (!(b instanceof ParameterizedType)) {\n        return false;\n      }\n\n      // TODO: save a .clone() call\n      ParameterizedType pa = (ParameterizedType) a;\n      ParameterizedType pb = (ParameterizedType) b;\n      return equal(pa.getOwnerType(), pb.getOwnerType())\n          && pa.getRawType().equals(pb.getRawType())\n          && Arrays.equals(pa.getActualTypeArguments(), pb.getActualTypeArguments());\n\n    } else if (a instanceof GenericArrayType) {\n      if (!(b instanceof GenericArrayType)) {\n        return false;\n      }\n\n      GenericArrayType ga = (GenericArrayType) a;\n      GenericArrayType gb = (GenericArrayType) b;\n      return equals(ga.getGenericComponentType(), gb.getGenericComponentType());\n\n    } else if (a instanceof WildcardType) {\n      if (!(b instanceof WildcardType)) {\n        return false;\n      }\n\n      WildcardType wa = (WildcardType) a;\n      WildcardType wb = (WildcardType) b;\n      return Arrays.equals(wa.getUpperBounds(), wb.getUpperBounds())\n          && Arrays.equals(wa.getLowerBounds(), wb.getLowerBounds());\n\n    } else if (a instanceof TypeVariable) {\n      if (!(b instanceof TypeVariable)) {\n        return false;\n      }\n      TypeVariable<?> va = (TypeVariable<?>) a;\n      TypeVariable<?> vb = (TypeVariable<?>) b;\n      return va.getGenericDeclaration() == vb.getGenericDeclaration()\n          && va.getName().equals(vb.getName());\n\n    } else {\n      // This isn't a type we support. Could be a generic array type, wildcard type, etc.\n      return false;\n    }\n  }\n\n  static int hashCodeOrZero(Object o) {\n    return o != null ? o.hashCode() : 0;\n  }\n\n  public static String typeToString(Type type) {\n    return type instanceof Class ? ((Class<?>) type).getName() : type.toString();\n  }\n\n  /**\n   * Returns the generic supertype for {@code supertype}. For example, given a class {@code\n   * IntegerSet}, the result for when supertype is {@code Set.class} is {@code Set<Integer>} and the\n   * result when the supertype is {@code Collection.class} is {@code Collection<Integer>}.\n   */\n  static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResolve) {\n    if (toResolve == rawType) {\n      return context;\n    }\n\n    // we skip searching through interfaces if unknown is an interface\n    if (toResolve.isInterface()) {\n      Class<?>[] interfaces = rawType.getInterfaces();\n      for (int i = 0, length = interfaces.length; i < length; i++) {\n        if (interfaces[i] == toResolve) {\n          return rawType.getGenericInterfaces()[i];\n        } else if (toResolve.isAssignableFrom(interfaces[i])) {\n          return getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], toResolve);\n        }\n      }\n    }\n\n    // check our supertypes\n    if (!rawType.isInterface()) {\n      while (rawType != Object.class) {\n        Class<?> rawSupertype = rawType.getSuperclass();\n        if (rawSupertype == toResolve) {\n          return rawType.getGenericSuperclass();\n        } else if (toResolve.isAssignableFrom(rawSupertype)) {\n          return getGenericSupertype(rawType.getGenericSuperclass(), rawSupertype, toResolve);\n        }\n        rawType = rawSupertype;\n      }\n    }\n\n    // we can't resolve this further\n    return toResolve;\n  }\n\n  /**\n   * Returns the generic form of {@code supertype}. For example, if this is {@code\n   * ArrayList<String>}, this returns {@code Iterable<String>} given the input {@code\n   * Iterable.class}.\n   *\n   * @param supertype a superclass of, or interface implemented by, this.\n   */\n  static Type getSupertype(Type context, Class<?> contextRawType, Class<?> supertype) {\n    checkArgument(supertype.isAssignableFrom(contextRawType));\n    return resolve(context, contextRawType,\n        $Gson$Types.getGenericSupertype(context, contextRawType, supertype));\n  }\n\n  /**\n   * Returns the component type of this array type.\n   * @throws ClassCastException if this type is not an array.\n   */\n  public static Type getArrayComponentType(Type array) {\n    return array instanceof GenericArrayType\n        ? ((GenericArrayType) array).getGenericComponentType()\n        : ((Class<?>) array).getComponentType();\n  }\n\n  /**\n   * Returns the element type of this collection type.\n   * @throws IllegalArgumentException if this type is not a collection.\n   */\n  public static Type getCollectionElementType(Type context, Class<?> contextRawType) {\n    Type collectionType = getSupertype(context, contextRawType, Collection.class);\n\n    if (collectionType instanceof WildcardType) {\n      collectionType = ((WildcardType)collectionType).getUpperBounds()[0];\n    }\n    if (collectionType instanceof ParameterizedType) {\n      return ((ParameterizedType) collectionType).getActualTypeArguments()[0];\n    }\n    return Object.class;\n  }\n\n  /**\n   * Returns a two element array containing this map's key and value types in\n   * positions 0 and 1 respectively.\n   */\n  public static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType) {\n    /*\n     * Work around a problem with the declaration of java.util.Properties. That\n     * class should extend Hashtable<String, String>, but it's declared to\n     * extend Hashtable<Object, Object>.\n     */\n    if (context == Properties.class) {\n      return new Type[] { String.class, String.class }; // TODO: test subclasses of Properties!\n    }\n\n    Type mapType = getSupertype(context, contextRawType, Map.class);\n    // TODO: strip wildcards?\n    if (mapType instanceof ParameterizedType) {\n      ParameterizedType mapParameterizedType = (ParameterizedType) mapType;\n      return mapParameterizedType.getActualTypeArguments();\n    }\n    return new Type[] { Object.class, Object.class };\n  }\n\n  public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {\n    return resolve(context, contextRawType, toResolve, new HashSet<TypeVariable>());\n  }\n\n  private static Type resolve(Type context, Class<?> contextRawType, Type toResolve,\n                              Collection<TypeVariable> visitedTypeVariables) {\n    // this implementation is made a little more complicated in an attempt to avoid object-creation\n    while (true) {\n      if (toResolve instanceof TypeVariable) {\n        TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;\n          // cannot reduce due to infinite recursion\n        toResolve = resolveTypeVariable(context, contextRawType, typeVariable);\n        if (toResolve == typeVariable) {\n          return toResolve;\n        }\n\n      } else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {\n        Class<?> original = (Class<?>) toResolve;\n        Type componentType = original.getComponentType();\n        Type newComponentType = resolve(context, contextRawType, componentType, visitedTypeVariables);\n        return componentType == newComponentType\n            ? original\n            : arrayOf(newComponentType);\n\n      } else if (toResolve instanceof GenericArrayType) {\n        GenericArrayType original = (GenericArrayType) toResolve;\n        Type componentType = original.getGenericComponentType();\n        Type newComponentType = resolve(context, contextRawType, componentType, visitedTypeVariables);\n        return componentType == newComponentType\n            ? original\n            : arrayOf(newComponentType);\n\n      } else if (toResolve instanceof ParameterizedType) {\n        ParameterizedType original = (ParameterizedType) toResolve;\n        Type ownerType = original.getOwnerType();\n        Type newOwnerType = resolve(context, contextRawType, ownerType, visitedTypeVariables);\n        boolean changed = newOwnerType != ownerType;\n\n        Type[] args = original.getActualTypeArguments();\n        for (int t = 0, length = args.length; t < length; t++) {\n          Type resolvedTypeArgument = resolve(context, contextRawType, args[t], visitedTypeVariables);\n          if (resolvedTypeArgument != args[t]) {\n            if (!changed) {\n              args = args.clone();\n              changed = true;\n            }\n            args[t] = resolvedTypeArgument;\n          }\n        }\n\n        return changed\n            ? newParameterizedTypeWithOwner(newOwnerType, original.getRawType(), args)\n            : original;\n\n      } else if (toResolve instanceof WildcardType) {\n        WildcardType original = (WildcardType) toResolve;\n        Type[] originalLowerBound = original.getLowerBounds();\n        Type[] originalUpperBound = original.getUpperBounds();\n\n        if (originalLowerBound.length == 1) {\n          Type lowerBound = resolve(context, contextRawType, originalLowerBound[0], visitedTypeVariables);\n          if (lowerBound != originalLowerBound[0]) {\n            return supertypeOf(lowerBound);\n          }\n        } else if (originalUpperBound.length == 1) {\n          Type upperBound = resolve(context, contextRawType, originalUpperBound[0], visitedTypeVariables);\n          if (upperBound != originalUpperBound[0]) {\n            return subtypeOf(upperBound);\n          }\n        }\n        return original;\n\n      } else {\n        return toResolve;\n      }\n    }\n  }\n\n  static Type resolveTypeVariable(Type context, Class<?> contextRawType, TypeVariable<?> unknown) {\n    Class<?> declaredByRaw = declaringClassOf(unknown);\n\n    // we can't reduce this further\n    if (declaredByRaw == null) {\n      return unknown;\n    }\n\n    Type declaredBy = getGenericSupertype(context, contextRawType, declaredByRaw);\n    if (declaredBy instanceof ParameterizedType) {\n      int index = indexOf(declaredByRaw.getTypeParameters(), unknown);\n      return ((ParameterizedType) declaredBy).getActualTypeArguments()[index];\n    }\n\n    return unknown;\n  }\n\n  private static int indexOf(Object[] array, Object toFind) {\n    for (int i = 0, length = array.length; i < length; i++) {\n      if (toFind.equals(array[i])) {\n        return i;\n      }\n    }\n    throw new NoSuchElementException();\n  }\n\n  /**\n   * Returns the declaring class of {@code typeVariable}, or {@code null} if it was not declared by\n   * a class.\n   */\n  private static Class<?> declaringClassOf(TypeVariable<?> typeVariable) {\n    GenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();\n    return genericDeclaration instanceof Class\n        ? (Class<?>) genericDeclaration\n        : null;\n  }\n\n  static void checkNotPrimitive(Type type) {\n    checkArgument(!(type instanceof Class<?>) || !((Class<?>) type).isPrimitive());\n  }\n\n  private static final class ParameterizedTypeImpl implements ParameterizedType, Serializable {\n    private final Type ownerType;\n    private final Type rawType;\n    private final Type[] typeArguments;\n\n    public ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments) {\n      // require an owner type if the raw type needs it\n      if (rawType instanceof Class<?>) {\n        Class<?> rawTypeAsClass = (Class<?>) rawType;\n        boolean isStaticOrTopLevelClass = Modifier.isStatic(rawTypeAsClass.getModifiers())\n            || rawTypeAsClass.getEnclosingClass() == null;\n        checkArgument(ownerType != null || isStaticOrTopLevelClass);\n      }\n\n      this.ownerType = ownerType == null ? null : canonicalize(ownerType);\n      this.rawType = canonicalize(rawType);\n      this.typeArguments = typeArguments.clone();\n      for (int t = 0, length = this.typeArguments.length; t < length; t++) {\n        checkNotNull(this.typeArguments[t]);\n        checkNotPrimitive(this.typeArguments[t]);\n        this.typeArguments[t] = canonicalize(this.typeArguments[t]);\n      }\n    }\n\n    public Type[] getActualTypeArguments() {\n      return typeArguments.clone();\n    }\n\n    public Type getRawType() {\n      return rawType;\n    }\n\n    public Type getOwnerType() {\n      return ownerType;\n    }\n\n    @Override public boolean equals(Object other) {\n      return other instanceof ParameterizedType\n          && $Gson$Types.equals(this, (ParameterizedType) other);\n    }\n\n    @Override public int hashCode() {\n      return Arrays.hashCode(typeArguments)\n          ^ rawType.hashCode()\n          ^ hashCodeOrZero(ownerType);\n    }\n\n    @Override public String toString() {\n      int length = typeArguments.length;\n      if (length == 0) {\n        return typeToString(rawType);\n      }\n\n      StringBuilder stringBuilder = new StringBuilder(30 * (length + 1));\n      stringBuilder.append(typeToString(rawType)).append(\"<\").append(typeToString(typeArguments[0]));\n      for (int i = 1; i < length; i++) {\n        stringBuilder.append(\", \").append(typeToString(typeArguments[i]));\n      }\n      return stringBuilder.append(\">\").toString();\n    }\n\n    private static final long serialVersionUID = 0;\n  }\n\n  private static final class GenericArrayTypeImpl implements GenericArrayType, Serializable {\n    private final Type componentType;\n\n    public GenericArrayTypeImpl(Type componentType) {\n      this.componentType = canonicalize(componentType);\n    }\n\n    public Type getGenericComponentType() {\n      return componentType;\n    }\n\n    @Override public boolean equals(Object o) {\n      return o instanceof GenericArrayType\n          && $Gson$Types.equals(this, (GenericArrayType) o);\n    }\n\n    @Override public int hashCode() {\n      return componentType.hashCode();\n    }\n\n    @Override public String toString() {\n      return typeToString(componentType) + \"[]\";\n    }\n\n    private static final long serialVersionUID = 0;\n  }\n\n  /**\n   * The WildcardType interface supports multiple upper bounds and multiple\n   * lower bounds. We only support what the Java 6 language needs - at most one\n   * bound. If a lower bound is set, the upper bound must be Object.class.\n   */\n  private static final class WildcardTypeImpl implements WildcardType, Serializable {\n    private final Type upperBound;\n    private final Type lowerBound;\n\n    public WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {\n      checkArgument(lowerBounds.length <= 1);\n      checkArgument(upperBounds.length == 1);\n\n      if (lowerBounds.length == 1) {\n        checkNotNull(lowerBounds[0]);\n        checkNotPrimitive(lowerBounds[0]);\n        checkArgument(upperBounds[0] == Object.class);\n        this.lowerBound = canonicalize(lowerBounds[0]);\n        this.upperBound = Object.class;\n\n      } else {\n        checkNotNull(upperBounds[0]);\n        checkNotPrimitive(upperBounds[0]);\n        this.lowerBound = null;\n        this.upperBound = canonicalize(upperBounds[0]);\n      }\n    }\n\n    public Type[] getUpperBounds() {\n      return new Type[] { upperBound };\n    }\n\n    public Type[] getLowerBounds() {\n      return lowerBound != null ? new Type[] { lowerBound } : EMPTY_TYPE_ARRAY;\n    }\n\n    @Override public boolean equals(Object other) {\n      return other instanceof WildcardType\n          && $Gson$Types.equals(this, (WildcardType) other);\n    }\n\n    @Override public int hashCode() {\n      // this equals Arrays.hashCode(getLowerBounds()) ^ Arrays.hashCode(getUpperBounds());\n      return (lowerBound != null ? 31 + lowerBound.hashCode() : 1)\n          ^ (31 + upperBound.hashCode());\n    }\n\n    @Override public String toString() {\n      if (lowerBound != null) {\n        return \"? super \" + typeToString(lowerBound);\n      } else if (upperBound == Object.class) {\n        return \"?\";\n      } else {\n        return \"? extends \" + typeToString(upperBound);\n      }\n    }\n\n    private static final long serialVersionUID = 0;\n  }\n}\n", "fixed_version": "/**\n * Copyright (C) 2008 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.gson.internal;\n\nimport java.io.Serializable;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.GenericArrayType;\nimport java.lang.reflect.GenericDeclaration;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.TypeVariable;\nimport java.lang.reflect.WildcardType;\nimport java.util.*;\n\nimport static com.google.gson.internal.$Gson$Preconditions.checkArgument;\nimport static com.google.gson.internal.$Gson$Preconditions.checkNotNull;\n\n/**\n * Static methods for working with types.\n *\n * @author Bob Lee\n * @author Jesse Wilson\n */\npublic final class $Gson$Types {\n  static final Type[] EMPTY_TYPE_ARRAY = new Type[] {};\n\n  private $Gson$Types() {\n    throw new UnsupportedOperationException();\n  }\n\n  /**\n   * Returns a new parameterized type, applying {@code typeArguments} to\n   * {@code rawType} and enclosed by {@code ownerType}.\n   *\n   * @return a {@link java.io.Serializable serializable} parameterized type.\n   */\n  public static ParameterizedType newParameterizedTypeWithOwner(\n      Type ownerType, Type rawType, Type... typeArguments) {\n    return new ParameterizedTypeImpl(ownerType, rawType, typeArguments);\n  }\n\n  /**\n   * Returns an array type whose elements are all instances of\n   * {@code componentType}.\n   *\n   * @return a {@link java.io.Serializable serializable} generic array type.\n   */\n  public static GenericArrayType arrayOf(Type componentType) {\n    return new GenericArrayTypeImpl(componentType);\n  }\n\n  /**\n   * Returns a type that represents an unknown type that extends {@code bound}.\n   * For example, if {@code bound} is {@code CharSequence.class}, this returns\n   * {@code ? extends CharSequence}. If {@code bound} is {@code Object.class},\n   * this returns {@code ?}, which is shorthand for {@code ? extends Object}.\n   */\n  public static WildcardType subtypeOf(Type bound) {\n    Type[] upperBounds;\n    if (bound instanceof WildcardType) {\n      upperBounds = ((WildcardType) bound).getUpperBounds();\n    } else {\n      upperBounds = new Type[] { bound };\n    }\n    return new WildcardTypeImpl(upperBounds, EMPTY_TYPE_ARRAY);\n  }\n\n  /**\n   * Returns a type that represents an unknown supertype of {@code bound}. For\n   * example, if {@code bound} is {@code String.class}, this returns {@code ?\n   * super String}.\n   */\n  public static WildcardType supertypeOf(Type bound) {\n    Type[] lowerBounds;\n    if (bound instanceof WildcardType) {\n      lowerBounds = ((WildcardType) bound).getLowerBounds();\n    } else {\n      lowerBounds = new Type[] { bound };\n    }\n    return new WildcardTypeImpl(new Type[] { Object.class }, lowerBounds);\n  }\n\n  /**\n   * Returns a type that is functionally equal but not necessarily equal\n   * according to {@link Object#equals(Object) Object.equals()}. The returned\n   * type is {@link java.io.Serializable}.\n   */\n  public static Type canonicalize(Type type) {\n    if (type instanceof Class) {\n      Class<?> c = (Class<?>) type;\n      return c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c;\n\n    } else if (type instanceof ParameterizedType) {\n      ParameterizedType p = (ParameterizedType) type;\n      return new ParameterizedTypeImpl(p.getOwnerType(),\n          p.getRawType(), p.getActualTypeArguments());\n\n    } else if (type instanceof GenericArrayType) {\n      GenericArrayType g = (GenericArrayType) type;\n      return new GenericArrayTypeImpl(g.getGenericComponentType());\n\n    } else if (type instanceof WildcardType) {\n      WildcardType w = (WildcardType) type;\n      return new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds());\n\n    } else {\n      // type is either serializable as-is or unsupported\n      return type;\n    }\n  }\n\n  public static Class<?> getRawType(Type type) {\n    if (type instanceof Class<?>) {\n      // type is a normal class.\n      return (Class<?>) type;\n\n    } else if (type instanceof ParameterizedType) {\n      ParameterizedType parameterizedType = (ParameterizedType) type;\n\n      // I'm not exactly sure why getRawType() returns Type instead of Class.\n      // Neal isn't either but suspects some pathological case related\n      // to nested classes exists.\n      Type rawType = parameterizedType.getRawType();\n      checkArgument(rawType instanceof Class);\n      return (Class<?>) rawType;\n\n    } else if (type instanceof GenericArrayType) {\n      Type componentType = ((GenericArrayType)type).getGenericComponentType();\n      return Array.newInstance(getRawType(componentType), 0).getClass();\n\n    } else if (type instanceof TypeVariable) {\n      // we could use the variable's bounds, but that won't work if there are multiple.\n      // having a raw type that's more general than necessary is okay\n      return Object.class;\n\n    } else if (type instanceof WildcardType) {\n      return getRawType(((WildcardType) type).getUpperBounds()[0]);\n\n    } else {\n      String className = type == null ? \"null\" : type.getClass().getName();\n      throw new IllegalArgumentException(\"Expected a Class, ParameterizedType, or \"\n          + \"GenericArrayType, but <\" + type + \"> is of type \" + className);\n    }\n  }\n\n  static boolean equal(Object a, Object b) {\n    return a == b || (a != null && a.equals(b));\n  }\n\n  /**\n   * Returns true if {@code a} and {@code b} are equal.\n   */\n  public static boolean equals(Type a, Type b) {\n    if (a == b) {\n      // also handles (a == null && b == null)\n      return true;\n\n    } else if (a instanceof Class) {\n      // Class already specifies equals().\n      return a.equals(b);\n\n    } else if (a instanceof ParameterizedType) {\n      if (!(b instanceof ParameterizedType)) {\n        return false;\n      }\n\n      // TODO: save a .clone() call\n      ParameterizedType pa = (ParameterizedType) a;\n      ParameterizedType pb = (ParameterizedType) b;\n      return equal(pa.getOwnerType(), pb.getOwnerType())\n          && pa.getRawType().equals(pb.getRawType())\n          && Arrays.equals(pa.getActualTypeArguments(), pb.getActualTypeArguments());\n\n    } else if (a instanceof GenericArrayType) {\n      if (!(b instanceof GenericArrayType)) {\n        return false;\n      }\n\n      GenericArrayType ga = (GenericArrayType) a;\n      GenericArrayType gb = (GenericArrayType) b;\n      return equals(ga.getGenericComponentType(), gb.getGenericComponentType());\n\n    } else if (a instanceof WildcardType) {\n      if (!(b instanceof WildcardType)) {\n        return false;\n      }\n\n      WildcardType wa = (WildcardType) a;\n      WildcardType wb = (WildcardType) b;\n      return Arrays.equals(wa.getUpperBounds(), wb.getUpperBounds())\n          && Arrays.equals(wa.getLowerBounds(), wb.getLowerBounds());\n\n    } else if (a instanceof TypeVariable) {\n      if (!(b instanceof TypeVariable)) {\n        return false;\n      }\n      TypeVariable<?> va = (TypeVariable<?>) a;\n      TypeVariable<?> vb = (TypeVariable<?>) b;\n      return va.getGenericDeclaration() == vb.getGenericDeclaration()\n          && va.getName().equals(vb.getName());\n\n    } else {\n      // This isn't a type we support. Could be a generic array type, wildcard type, etc.\n      return false;\n    }\n  }\n\n  static int hashCodeOrZero(Object o) {\n    return o != null ? o.hashCode() : 0;\n  }\n\n  public static String typeToString(Type type) {\n    return type instanceof Class ? ((Class<?>) type).getName() : type.toString();\n  }\n\n  /**\n   * Returns the generic supertype for {@code supertype}. For example, given a class {@code\n   * IntegerSet}, the result for when supertype is {@code Set.class} is {@code Set<Integer>} and the\n   * result when the supertype is {@code Collection.class} is {@code Collection<Integer>}.\n   */\n  static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResolve) {\n    if (toResolve == rawType) {\n      return context;\n    }\n\n    // we skip searching through interfaces if unknown is an interface\n    if (toResolve.isInterface()) {\n      Class<?>[] interfaces = rawType.getInterfaces();\n      for (int i = 0, length = interfaces.length; i < length; i++) {\n        if (interfaces[i] == toResolve) {\n          return rawType.getGenericInterfaces()[i];\n        } else if (toResolve.isAssignableFrom(interfaces[i])) {\n          return getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], toResolve);\n        }\n      }\n    }\n\n    // check our supertypes\n    if (!rawType.isInterface()) {\n      while (rawType != Object.class) {\n        Class<?> rawSupertype = rawType.getSuperclass();\n        if (rawSupertype == toResolve) {\n          return rawType.getGenericSuperclass();\n        } else if (toResolve.isAssignableFrom(rawSupertype)) {\n          return getGenericSupertype(rawType.getGenericSuperclass(), rawSupertype, toResolve);\n        }\n        rawType = rawSupertype;\n      }\n    }\n\n    // we can't resolve this further\n    return toResolve;\n  }\n\n  /**\n   * Returns the generic form of {@code supertype}. For example, if this is {@code\n   * ArrayList<String>}, this returns {@code Iterable<String>} given the input {@code\n   * Iterable.class}.\n   *\n   * @param supertype a superclass of, or interface implemented by, this.\n   */\n  static Type getSupertype(Type context, Class<?> contextRawType, Class<?> supertype) {\n    checkArgument(supertype.isAssignableFrom(contextRawType));\n    return resolve(context, contextRawType,\n        $Gson$Types.getGenericSupertype(context, contextRawType, supertype));\n  }\n\n  /**\n   * Returns the component type of this array type.\n   * @throws ClassCastException if this type is not an array.\n   */\n  public static Type getArrayComponentType(Type array) {\n    return array instanceof GenericArrayType\n        ? ((GenericArrayType) array).getGenericComponentType()\n        : ((Class<?>) array).getComponentType();\n  }\n\n  /**\n   * Returns the element type of this collection type.\n   * @throws IllegalArgumentException if this type is not a collection.\n   */\n  public static Type getCollectionElementType(Type context, Class<?> contextRawType) {\n    Type collectionType = getSupertype(context, contextRawType, Collection.class);\n\n    if (collectionType instanceof WildcardType) {\n      collectionType = ((WildcardType)collectionType).getUpperBounds()[0];\n    }\n    if (collectionType instanceof ParameterizedType) {\n      return ((ParameterizedType) collectionType).getActualTypeArguments()[0];\n    }\n    return Object.class;\n  }\n\n  /**\n   * Returns a two element array containing this map's key and value types in\n   * positions 0 and 1 respectively.\n   */\n  public static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType) {\n    /*\n     * Work around a problem with the declaration of java.util.Properties. That\n     * class should extend Hashtable<String, String>, but it's declared to\n     * extend Hashtable<Object, Object>.\n     */\n    if (context == Properties.class) {\n      return new Type[] { String.class, String.class }; // TODO: test subclasses of Properties!\n    }\n\n    Type mapType = getSupertype(context, contextRawType, Map.class);\n    // TODO: strip wildcards?\n    if (mapType instanceof ParameterizedType) {\n      ParameterizedType mapParameterizedType = (ParameterizedType) mapType;\n      return mapParameterizedType.getActualTypeArguments();\n    }\n    return new Type[] { Object.class, Object.class };\n  }\n\n  public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {\n    return resolve(context, contextRawType, toResolve, new HashSet<TypeVariable>());\n  }\n\n  private static Type resolve(Type context, Class<?> contextRawType, Type toResolve,\n                              Collection<TypeVariable> visitedTypeVariables) {\n    // this implementation is made a little more complicated in an attempt to avoid object-creation\n    while (true) {\n      if (toResolve instanceof TypeVariable) {\n        TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;\n        if (visitedTypeVariables.contains(typeVariable)) {\n          // cannot reduce due to infinite recursion\n          return toResolve;\n        } else {\n          visitedTypeVariables.add(typeVariable);\n        }\n        toResolve = resolveTypeVariable(context, contextRawType, typeVariable);\n        if (toResolve == typeVariable) {\n          return toResolve;\n        }\n\n      } else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {\n        Class<?> original = (Class<?>) toResolve;\n        Type componentType = original.getComponentType();\n        Type newComponentType = resolve(context, contextRawType, componentType, visitedTypeVariables);\n        return componentType == newComponentType\n            ? original\n            : arrayOf(newComponentType);\n\n      } else if (toResolve instanceof GenericArrayType) {\n        GenericArrayType original = (GenericArrayType) toResolve;\n        Type componentType = original.getGenericComponentType();\n        Type newComponentType = resolve(context, contextRawType, componentType, visitedTypeVariables);\n        return componentType == newComponentType\n            ? original\n            : arrayOf(newComponentType);\n\n      } else if (toResolve instanceof ParameterizedType) {\n        ParameterizedType original = (ParameterizedType) toResolve;\n        Type ownerType = original.getOwnerType();\n        Type newOwnerType = resolve(context, contextRawType, ownerType, visitedTypeVariables);\n        boolean changed = newOwnerType != ownerType;\n\n        Type[] args = original.getActualTypeArguments();\n        for (int t = 0, length = args.length; t < length; t++) {\n          Type resolvedTypeArgument = resolve(context, contextRawType, args[t], visitedTypeVariables);\n          if (resolvedTypeArgument != args[t]) {\n            if (!changed) {\n              args = args.clone();\n              changed = true;\n            }\n            args[t] = resolvedTypeArgument;\n          }\n        }\n\n        return changed\n            ? newParameterizedTypeWithOwner(newOwnerType, original.getRawType(), args)\n            : original;\n\n      } else if (toResolve instanceof WildcardType) {\n        WildcardType original = (WildcardType) toResolve;\n        Type[] originalLowerBound = original.getLowerBounds();\n        Type[] originalUpperBound = original.getUpperBounds();\n\n        if (originalLowerBound.length == 1) {\n          Type lowerBound = resolve(context, contextRawType, originalLowerBound[0], visitedTypeVariables);\n          if (lowerBound != originalLowerBound[0]) {\n            return supertypeOf(lowerBound);\n          }\n        } else if (originalUpperBound.length == 1) {\n          Type upperBound = resolve(context, contextRawType, originalUpperBound[0], visitedTypeVariables);\n          if (upperBound != originalUpperBound[0]) {\n            return subtypeOf(upperBound);\n          }\n        }\n        return original;\n\n      } else {\n        return toResolve;\n      }\n    }\n  }\n\n  static Type resolveTypeVariable(Type context, Class<?> contextRawType, TypeVariable<?> unknown) {\n    Class<?> declaredByRaw = declaringClassOf(unknown);\n\n    // we can't reduce this further\n    if (declaredByRaw == null) {\n      return unknown;\n    }\n\n    Type declaredBy = getGenericSupertype(context, contextRawType, declaredByRaw);\n    if (declaredBy instanceof ParameterizedType) {\n      int index = indexOf(declaredByRaw.getTypeParameters(), unknown);\n      return ((ParameterizedType) declaredBy).getActualTypeArguments()[index];\n    }\n\n    return unknown;\n  }\n\n  private static int indexOf(Object[] array, Object toFind) {\n    for (int i = 0, length = array.length; i < length; i++) {\n      if (toFind.equals(array[i])) {\n        return i;\n      }\n    }\n    throw new NoSuchElementException();\n  }\n\n  /**\n   * Returns the declaring class of {@code typeVariable}, or {@code null} if it was not declared by\n   * a class.\n   */\n  private static Class<?> declaringClassOf(TypeVariable<?> typeVariable) {\n    GenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();\n    return genericDeclaration instanceof Class\n        ? (Class<?>) genericDeclaration\n        : null;\n  }\n\n  static void checkNotPrimitive(Type type) {\n    checkArgument(!(type instanceof Class<?>) || !((Class<?>) type).isPrimitive());\n  }\n\n  private static final class ParameterizedTypeImpl implements ParameterizedType, Serializable {\n    private final Type ownerType;\n    private final Type rawType;\n    private final Type[] typeArguments;\n\n    public ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments) {\n      // require an owner type if the raw type needs it\n      if (rawType instanceof Class<?>) {\n        Class<?> rawTypeAsClass = (Class<?>) rawType;\n        boolean isStaticOrTopLevelClass = Modifier.isStatic(rawTypeAsClass.getModifiers())\n            || rawTypeAsClass.getEnclosingClass() == null;\n        checkArgument(ownerType != null || isStaticOrTopLevelClass);\n      }\n\n      this.ownerType = ownerType == null ? null : canonicalize(ownerType);\n      this.rawType = canonicalize(rawType);\n      this.typeArguments = typeArguments.clone();\n      for (int t = 0, length = this.typeArguments.length; t < length; t++) {\n        checkNotNull(this.typeArguments[t]);\n        checkNotPrimitive(this.typeArguments[t]);\n        this.typeArguments[t] = canonicalize(this.typeArguments[t]);\n      }\n    }\n\n    public Type[] getActualTypeArguments() {\n      return typeArguments.clone();\n    }\n\n    public Type getRawType() {\n      return rawType;\n    }\n\n    public Type getOwnerType() {\n      return ownerType;\n    }\n\n    @Override public boolean equals(Object other) {\n      return other instanceof ParameterizedType\n          && $Gson$Types.equals(this, (ParameterizedType) other);\n    }\n\n    @Override public int hashCode() {\n      return Arrays.hashCode(typeArguments)\n          ^ rawType.hashCode()\n          ^ hashCodeOrZero(ownerType);\n    }\n\n    @Override public String toString() {\n      int length = typeArguments.length;\n      if (length == 0) {\n        return typeToString(rawType);\n      }\n\n      StringBuilder stringBuilder = new StringBuilder(30 * (length + 1));\n      stringBuilder.append(typeToString(rawType)).append(\"<\").append(typeToString(typeArguments[0]));\n      for (int i = 1; i < length; i++) {\n        stringBuilder.append(\", \").append(typeToString(typeArguments[i]));\n      }\n      return stringBuilder.append(\">\").toString();\n    }\n\n    private static final long serialVersionUID = 0;\n  }\n\n  private static final class GenericArrayTypeImpl implements GenericArrayType, Serializable {\n    private final Type componentType;\n\n    public GenericArrayTypeImpl(Type componentType) {\n      this.componentType = canonicalize(componentType);\n    }\n\n    public Type getGenericComponentType() {\n      return componentType;\n    }\n\n    @Override public boolean equals(Object o) {\n      return o instanceof GenericArrayType\n          && $Gson$Types.equals(this, (GenericArrayType) o);\n    }\n\n    @Override public int hashCode() {\n      return componentType.hashCode();\n    }\n\n    @Override public String toString() {\n      return typeToString(componentType) + \"[]\";\n    }\n\n    private static final long serialVersionUID = 0;\n  }\n\n  /**\n   * The WildcardType interface supports multiple upper bounds and multiple\n   * lower bounds. We only support what the Java 6 language needs - at most one\n   * bound. If a lower bound is set, the upper bound must be Object.class.\n   */\n  private static final class WildcardTypeImpl implements WildcardType, Serializable {\n    private final Type upperBound;\n    private final Type lowerBound;\n\n    public WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {\n      checkArgument(lowerBounds.length <= 1);\n      checkArgument(upperBounds.length == 1);\n\n      if (lowerBounds.length == 1) {\n        checkNotNull(lowerBounds[0]);\n        checkNotPrimitive(lowerBounds[0]);\n        checkArgument(upperBounds[0] == Object.class);\n        this.lowerBound = canonicalize(lowerBounds[0]);\n        this.upperBound = Object.class;\n\n      } else {\n        checkNotNull(upperBounds[0]);\n        checkNotPrimitive(upperBounds[0]);\n        this.lowerBound = null;\n        this.upperBound = canonicalize(upperBounds[0]);\n      }\n    }\n\n    public Type[] getUpperBounds() {\n      return new Type[] { upperBound };\n    }\n\n    public Type[] getLowerBounds() {\n      return lowerBound != null ? new Type[] { lowerBound } : EMPTY_TYPE_ARRAY;\n    }\n\n    @Override public boolean equals(Object other) {\n      return other instanceof WildcardType\n          && $Gson$Types.equals(this, (WildcardType) other);\n    }\n\n    @Override public int hashCode() {\n      // this equals Arrays.hashCode(getLowerBounds()) ^ Arrays.hashCode(getUpperBounds());\n      return (lowerBound != null ? 31 + lowerBound.hashCode() : 1)\n          ^ (31 + upperBound.hashCode());\n    }\n\n    @Override public String toString() {\n      if (lowerBound != null) {\n        return \"? super \" + typeToString(lowerBound);\n      } else if (upperBound == Object.class) {\n        return \"?\";\n      } else {\n        return \"? extends \" + typeToString(upperBound);\n      }\n    }\n\n    private static final long serialVersionUID = 0;\n  }\n}\n"}]}
{"project": "Gson", "bug_id": 17, "classes_modified": [{"class_name": "com.google.gson.DefaultDateTypeAdapter", "buggy_version": "/*\n * Copyright (C) 2008 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.gson;\n\nimport java.io.IOException;\nimport java.sql.Timestamp;\nimport java.text.DateFormat;\nimport java.text.ParseException;\nimport java.text.ParsePosition;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.Locale;\n\nimport com.google.gson.internal.bind.util.ISO8601Utils;\nimport com.google.gson.stream.JsonReader;\nimport com.google.gson.stream.JsonToken;\nimport com.google.gson.stream.JsonWriter;\n\n/**\n * This type adapter supports three subclasses of date: Date, Timestamp, and\n * java.sql.Date.\n *\n * @author Inderjeet Singh\n * @author Joel Leitch\n */\nfinal class DefaultDateTypeAdapter extends TypeAdapter<Date> {\n\n  private static final String SIMPLE_NAME = \"DefaultDateTypeAdapter\";\n\n  private final Class<? extends Date> dateType;\n  private final DateFormat enUsFormat;\n  private final DateFormat localFormat;\n  \n  DefaultDateTypeAdapter(Class<? extends Date> dateType) {\n    this(dateType,\n        DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT, Locale.US),\n        DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT));\n  }\n\n  DefaultDateTypeAdapter(Class<? extends Date> dateType, String datePattern) {\n    this(dateType, new SimpleDateFormat(datePattern, Locale.US), new SimpleDateFormat(datePattern));\n  }\n\n  DefaultDateTypeAdapter(Class<? extends Date> dateType, int style) {\n    this(dateType, DateFormat.getDateInstance(style, Locale.US), DateFormat.getDateInstance(style));\n  }\n\n  public DefaultDateTypeAdapter(int dateStyle, int timeStyle) {\n    this(Date.class,\n        DateFormat.getDateTimeInstance(dateStyle, timeStyle, Locale.US),\n        DateFormat.getDateTimeInstance(dateStyle, timeStyle));\n  }\n\n  public DefaultDateTypeAdapter(Class<? extends Date> dateType, int dateStyle, int timeStyle) {\n    this(dateType,\n        DateFormat.getDateTimeInstance(dateStyle, timeStyle, Locale.US),\n        DateFormat.getDateTimeInstance(dateStyle, timeStyle));\n  }\n\n  DefaultDateTypeAdapter(final Class<? extends Date> dateType, DateFormat enUsFormat, DateFormat localFormat) {\n    if ( dateType != Date.class && dateType != java.sql.Date.class && dateType != Timestamp.class ) {\n      throw new IllegalArgumentException(\"Date type must be one of \" + Date.class + \", \" + Timestamp.class + \", or \" + java.sql.Date.class + \" but was \" + dateType);\n    }\n    this.dateType = dateType;\n    this.enUsFormat = enUsFormat;\n    this.localFormat = localFormat;\n  }\n\n  // These methods need to be synchronized since JDK DateFormat classes are not thread-safe\n  // See issue 162\n  @Override\n  public void write(JsonWriter out, Date value) throws IOException {\n    if (value == null) {\n      out.nullValue();\n      return;\n    }\n    synchronized (localFormat) {\n      String dateFormatAsString = enUsFormat.format(value);\n      out.value(dateFormatAsString);\n    }\n  }\n\n  @Override\n  public Date read(JsonReader in) throws IOException {\n    if (in.peek() != JsonToken.STRING) {\n      throw new JsonParseException(\"The date should be a string value\");\n    }\n    Date date = deserializeToDate(in.nextString());\n    if (dateType == Date.class) {\n      return date;\n    } else if (dateType == Timestamp.class) {\n      return new Timestamp(date.getTime());\n    } else if (dateType == java.sql.Date.class) {\n      return new java.sql.Date(date.getTime());\n    } else {\n      // This must never happen: dateType is guarded in the primary constructor\n      throw new AssertionError();\n    }\n  }\n\n  private Date deserializeToDate(String s) {\n    synchronized (localFormat) {\n      try {\n        return localFormat.parse(s);\n      } catch (ParseException ignored) {}\n      try {\n        return enUsFormat.parse(s);\n      } catch (ParseException ignored) {}\n      try {\n        return ISO8601Utils.parse(s, new ParsePosition(0));\n      } catch (ParseException e) {\n        throw new JsonSyntaxException(s, e);\n      }\n    }\n  }\n\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(SIMPLE_NAME);\n    sb.append('(').append(localFormat.getClass().getSimpleName()).append(')');\n    return sb.toString();\n  }\n}\n", "fixed_version": "/*\n * Copyright (C) 2008 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.gson;\n\nimport java.io.IOException;\nimport java.sql.Timestamp;\nimport java.text.DateFormat;\nimport java.text.ParseException;\nimport java.text.ParsePosition;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.Locale;\n\nimport com.google.gson.internal.bind.util.ISO8601Utils;\nimport com.google.gson.stream.JsonReader;\nimport com.google.gson.stream.JsonToken;\nimport com.google.gson.stream.JsonWriter;\n\n/**\n * This type adapter supports three subclasses of date: Date, Timestamp, and\n * java.sql.Date.\n *\n * @author Inderjeet Singh\n * @author Joel Leitch\n */\nfinal class DefaultDateTypeAdapter extends TypeAdapter<Date> {\n\n  private static final String SIMPLE_NAME = \"DefaultDateTypeAdapter\";\n\n  private final Class<? extends Date> dateType;\n  private final DateFormat enUsFormat;\n  private final DateFormat localFormat;\n  \n  DefaultDateTypeAdapter(Class<? extends Date> dateType) {\n    this(dateType,\n        DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT, Locale.US),\n        DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT));\n  }\n\n  DefaultDateTypeAdapter(Class<? extends Date> dateType, String datePattern) {\n    this(dateType, new SimpleDateFormat(datePattern, Locale.US), new SimpleDateFormat(datePattern));\n  }\n\n  DefaultDateTypeAdapter(Class<? extends Date> dateType, int style) {\n    this(dateType, DateFormat.getDateInstance(style, Locale.US), DateFormat.getDateInstance(style));\n  }\n\n  public DefaultDateTypeAdapter(int dateStyle, int timeStyle) {\n    this(Date.class,\n        DateFormat.getDateTimeInstance(dateStyle, timeStyle, Locale.US),\n        DateFormat.getDateTimeInstance(dateStyle, timeStyle));\n  }\n\n  public DefaultDateTypeAdapter(Class<? extends Date> dateType, int dateStyle, int timeStyle) {\n    this(dateType,\n        DateFormat.getDateTimeInstance(dateStyle, timeStyle, Locale.US),\n        DateFormat.getDateTimeInstance(dateStyle, timeStyle));\n  }\n\n  DefaultDateTypeAdapter(final Class<? extends Date> dateType, DateFormat enUsFormat, DateFormat localFormat) {\n    if ( dateType != Date.class && dateType != java.sql.Date.class && dateType != Timestamp.class ) {\n      throw new IllegalArgumentException(\"Date type must be one of \" + Date.class + \", \" + Timestamp.class + \", or \" + java.sql.Date.class + \" but was \" + dateType);\n    }\n    this.dateType = dateType;\n    this.enUsFormat = enUsFormat;\n    this.localFormat = localFormat;\n  }\n\n  // These methods need to be synchronized since JDK DateFormat classes are not thread-safe\n  // See issue 162\n  @Override\n  public void write(JsonWriter out, Date value) throws IOException {\n    if (value == null) {\n      out.nullValue();\n      return;\n    }\n    synchronized (localFormat) {\n      String dateFormatAsString = enUsFormat.format(value);\n      out.value(dateFormatAsString);\n    }\n  }\n\n  @Override\n  public Date read(JsonReader in) throws IOException {\n    if (in.peek() == JsonToken.NULL) {\n      in.nextNull();\n      return null;\n    }\n    Date date = deserializeToDate(in.nextString());\n    if (dateType == Date.class) {\n      return date;\n    } else if (dateType == Timestamp.class) {\n      return new Timestamp(date.getTime());\n    } else if (dateType == java.sql.Date.class) {\n      return new java.sql.Date(date.getTime());\n    } else {\n      // This must never happen: dateType is guarded in the primary constructor\n      throw new AssertionError();\n    }\n  }\n\n  private Date deserializeToDate(String s) {\n    synchronized (localFormat) {\n      try {\n        return localFormat.parse(s);\n      } catch (ParseException ignored) {}\n      try {\n        return enUsFormat.parse(s);\n      } catch (ParseException ignored) {}\n      try {\n        return ISO8601Utils.parse(s, new ParsePosition(0));\n      } catch (ParseException e) {\n        throw new JsonSyntaxException(s, e);\n      }\n    }\n  }\n\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(SIMPLE_NAME);\n    sb.append('(').append(localFormat.getClass().getSimpleName()).append(')');\n    return sb.toString();\n  }\n}\n"}]}
{"project": "Gson", "bug_id": 18, "classes_modified": [{"class_name": "com.google.gson.internal.$Gson$Types", "buggy_version": "/**\n * Copyright (C) 2008 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.gson.internal;\n\nimport java.io.Serializable;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.GenericArrayType;\nimport java.lang.reflect.GenericDeclaration;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.TypeVariable;\nimport java.lang.reflect.WildcardType;\nimport java.util.*;\n\nimport static com.google.gson.internal.$Gson$Preconditions.checkArgument;\nimport static com.google.gson.internal.$Gson$Preconditions.checkNotNull;\n\n/**\n * Static methods for working with types.\n *\n * @author Bob Lee\n * @author Jesse Wilson\n */\npublic final class $Gson$Types {\n  static final Type[] EMPTY_TYPE_ARRAY = new Type[] {};\n\n  private $Gson$Types() {\n    throw new UnsupportedOperationException();\n  }\n\n  /**\n   * Returns a new parameterized type, applying {@code typeArguments} to\n   * {@code rawType} and enclosed by {@code ownerType}.\n   *\n   * @return a {@link java.io.Serializable serializable} parameterized type.\n   */\n  public static ParameterizedType newParameterizedTypeWithOwner(\n      Type ownerType, Type rawType, Type... typeArguments) {\n    return new ParameterizedTypeImpl(ownerType, rawType, typeArguments);\n  }\n\n  /**\n   * Returns an array type whose elements are all instances of\n   * {@code componentType}.\n   *\n   * @return a {@link java.io.Serializable serializable} generic array type.\n   */\n  public static GenericArrayType arrayOf(Type componentType) {\n    return new GenericArrayTypeImpl(componentType);\n  }\n\n  /**\n   * Returns a type that represents an unknown type that extends {@code bound}.\n   * For example, if {@code bound} is {@code CharSequence.class}, this returns\n   * {@code ? extends CharSequence}. If {@code bound} is {@code Object.class},\n   * this returns {@code ?}, which is shorthand for {@code ? extends Object}.\n   */\n  public static WildcardType subtypeOf(Type bound) {\n    Type[] upperBounds;\n    if (bound instanceof WildcardType) {\n      upperBounds = ((WildcardType) bound).getUpperBounds();\n    } else {\n      upperBounds = new Type[] { bound };\n    }\n    return new WildcardTypeImpl(upperBounds, EMPTY_TYPE_ARRAY);\n  }\n\n  /**\n   * Returns a type that represents an unknown supertype of {@code bound}. For\n   * example, if {@code bound} is {@code String.class}, this returns {@code ?\n   * super String}.\n   */\n  public static WildcardType supertypeOf(Type bound) {\n    Type[] lowerBounds;\n    if (bound instanceof WildcardType) {\n      lowerBounds = ((WildcardType) bound).getLowerBounds();\n    } else {\n      lowerBounds = new Type[] { bound };\n    }\n    return new WildcardTypeImpl(new Type[] { Object.class }, lowerBounds);\n  }\n\n  /**\n   * Returns a type that is functionally equal but not necessarily equal\n   * according to {@link Object#equals(Object) Object.equals()}. The returned\n   * type is {@link java.io.Serializable}.\n   */\n  public static Type canonicalize(Type type) {\n    if (type instanceof Class) {\n      Class<?> c = (Class<?>) type;\n      return c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c;\n\n    } else if (type instanceof ParameterizedType) {\n      ParameterizedType p = (ParameterizedType) type;\n      return new ParameterizedTypeImpl(p.getOwnerType(),\n          p.getRawType(), p.getActualTypeArguments());\n\n    } else if (type instanceof GenericArrayType) {\n      GenericArrayType g = (GenericArrayType) type;\n      return new GenericArrayTypeImpl(g.getGenericComponentType());\n\n    } else if (type instanceof WildcardType) {\n      WildcardType w = (WildcardType) type;\n      return new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds());\n\n    } else {\n      // type is either serializable as-is or unsupported\n      return type;\n    }\n  }\n\n  public static Class<?> getRawType(Type type) {\n    if (type instanceof Class<?>) {\n      // type is a normal class.\n      return (Class<?>) type;\n\n    } else if (type instanceof ParameterizedType) {\n      ParameterizedType parameterizedType = (ParameterizedType) type;\n\n      // I'm not exactly sure why getRawType() returns Type instead of Class.\n      // Neal isn't either but suspects some pathological case related\n      // to nested classes exists.\n      Type rawType = parameterizedType.getRawType();\n      checkArgument(rawType instanceof Class);\n      return (Class<?>) rawType;\n\n    } else if (type instanceof GenericArrayType) {\n      Type componentType = ((GenericArrayType)type).getGenericComponentType();\n      return Array.newInstance(getRawType(componentType), 0).getClass();\n\n    } else if (type instanceof TypeVariable) {\n      // we could use the variable's bounds, but that won't work if there are multiple.\n      // having a raw type that's more general than necessary is okay\n      return Object.class;\n\n    } else if (type instanceof WildcardType) {\n      return getRawType(((WildcardType) type).getUpperBounds()[0]);\n\n    } else {\n      String className = type == null ? \"null\" : type.getClass().getName();\n      throw new IllegalArgumentException(\"Expected a Class, ParameterizedType, or \"\n          + \"GenericArrayType, but <\" + type + \"> is of type \" + className);\n    }\n  }\n\n  static boolean equal(Object a, Object b) {\n    return a == b || (a != null && a.equals(b));\n  }\n\n  /**\n   * Returns true if {@code a} and {@code b} are equal.\n   */\n  public static boolean equals(Type a, Type b) {\n    if (a == b) {\n      // also handles (a == null && b == null)\n      return true;\n\n    } else if (a instanceof Class) {\n      // Class already specifies equals().\n      return a.equals(b);\n\n    } else if (a instanceof ParameterizedType) {\n      if (!(b instanceof ParameterizedType)) {\n        return false;\n      }\n\n      // TODO: save a .clone() call\n      ParameterizedType pa = (ParameterizedType) a;\n      ParameterizedType pb = (ParameterizedType) b;\n      return equal(pa.getOwnerType(), pb.getOwnerType())\n          && pa.getRawType().equals(pb.getRawType())\n          && Arrays.equals(pa.getActualTypeArguments(), pb.getActualTypeArguments());\n\n    } else if (a instanceof GenericArrayType) {\n      if (!(b instanceof GenericArrayType)) {\n        return false;\n      }\n\n      GenericArrayType ga = (GenericArrayType) a;\n      GenericArrayType gb = (GenericArrayType) b;\n      return equals(ga.getGenericComponentType(), gb.getGenericComponentType());\n\n    } else if (a instanceof WildcardType) {\n      if (!(b instanceof WildcardType)) {\n        return false;\n      }\n\n      WildcardType wa = (WildcardType) a;\n      WildcardType wb = (WildcardType) b;\n      return Arrays.equals(wa.getUpperBounds(), wb.getUpperBounds())\n          && Arrays.equals(wa.getLowerBounds(), wb.getLowerBounds());\n\n    } else if (a instanceof TypeVariable) {\n      if (!(b instanceof TypeVariable)) {\n        return false;\n      }\n      TypeVariable<?> va = (TypeVariable<?>) a;\n      TypeVariable<?> vb = (TypeVariable<?>) b;\n      return va.getGenericDeclaration() == vb.getGenericDeclaration()\n          && va.getName().equals(vb.getName());\n\n    } else {\n      // This isn't a type we support. Could be a generic array type, wildcard type, etc.\n      return false;\n    }\n  }\n\n  static int hashCodeOrZero(Object o) {\n    return o != null ? o.hashCode() : 0;\n  }\n\n  public static String typeToString(Type type) {\n    return type instanceof Class ? ((Class<?>) type).getName() : type.toString();\n  }\n\n  /**\n   * Returns the generic supertype for {@code supertype}. For example, given a class {@code\n   * IntegerSet}, the result for when supertype is {@code Set.class} is {@code Set<Integer>} and the\n   * result when the supertype is {@code Collection.class} is {@code Collection<Integer>}.\n   */\n  static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResolve) {\n    if (toResolve == rawType) {\n      return context;\n    }\n\n    // we skip searching through interfaces if unknown is an interface\n    if (toResolve.isInterface()) {\n      Class<?>[] interfaces = rawType.getInterfaces();\n      for (int i = 0, length = interfaces.length; i < length; i++) {\n        if (interfaces[i] == toResolve) {\n          return rawType.getGenericInterfaces()[i];\n        } else if (toResolve.isAssignableFrom(interfaces[i])) {\n          return getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], toResolve);\n        }\n      }\n    }\n\n    // check our supertypes\n    if (!rawType.isInterface()) {\n      while (rawType != Object.class) {\n        Class<?> rawSupertype = rawType.getSuperclass();\n        if (rawSupertype == toResolve) {\n          return rawType.getGenericSuperclass();\n        } else if (toResolve.isAssignableFrom(rawSupertype)) {\n          return getGenericSupertype(rawType.getGenericSuperclass(), rawSupertype, toResolve);\n        }\n        rawType = rawSupertype;\n      }\n    }\n\n    // we can't resolve this further\n    return toResolve;\n  }\n\n  /**\n   * Returns the generic form of {@code supertype}. For example, if this is {@code\n   * ArrayList<String>}, this returns {@code Iterable<String>} given the input {@code\n   * Iterable.class}.\n   *\n   * @param supertype a superclass of, or interface implemented by, this.\n   */\n  static Type getSupertype(Type context, Class<?> contextRawType, Class<?> supertype) {\n      // wildcards are useless for resolving supertypes. As the upper bound has the same raw type, use it instead\n    checkArgument(supertype.isAssignableFrom(contextRawType));\n    return resolve(context, contextRawType,\n        $Gson$Types.getGenericSupertype(context, contextRawType, supertype));\n  }\n\n  /**\n   * Returns the component type of this array type.\n   * @throws ClassCastException if this type is not an array.\n   */\n  public static Type getArrayComponentType(Type array) {\n    return array instanceof GenericArrayType\n        ? ((GenericArrayType) array).getGenericComponentType()\n        : ((Class<?>) array).getComponentType();\n  }\n\n  /**\n   * Returns the element type of this collection type.\n   * @throws IllegalArgumentException if this type is not a collection.\n   */\n  public static Type getCollectionElementType(Type context, Class<?> contextRawType) {\n    Type collectionType = getSupertype(context, contextRawType, Collection.class);\n\n    if (collectionType instanceof WildcardType) {\n      collectionType = ((WildcardType)collectionType).getUpperBounds()[0];\n    }\n    if (collectionType instanceof ParameterizedType) {\n      return ((ParameterizedType) collectionType).getActualTypeArguments()[0];\n    }\n    return Object.class;\n  }\n\n  /**\n   * Returns a two element array containing this map's key and value types in\n   * positions 0 and 1 respectively.\n   */\n  public static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType) {\n    /*\n     * Work around a problem with the declaration of java.util.Properties. That\n     * class should extend Hashtable<String, String>, but it's declared to\n     * extend Hashtable<Object, Object>.\n     */\n    if (context == Properties.class) {\n      return new Type[] { String.class, String.class }; // TODO: test subclasses of Properties!\n    }\n\n    Type mapType = getSupertype(context, contextRawType, Map.class);\n    // TODO: strip wildcards?\n    if (mapType instanceof ParameterizedType) {\n      ParameterizedType mapParameterizedType = (ParameterizedType) mapType;\n      return mapParameterizedType.getActualTypeArguments();\n    }\n    return new Type[] { Object.class, Object.class };\n  }\n\n  public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {\n    return resolve(context, contextRawType, toResolve, new HashSet<TypeVariable>());\n  }\n\n  private static Type resolve(Type context, Class<?> contextRawType, Type toResolve,\n                              Collection<TypeVariable> visitedTypeVariables) {\n    // this implementation is made a little more complicated in an attempt to avoid object-creation\n    while (true) {\n      if (toResolve instanceof TypeVariable) {\n        TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;\n        if (visitedTypeVariables.contains(typeVariable)) {\n          // cannot reduce due to infinite recursion\n          return toResolve;\n        } else {\n          visitedTypeVariables.add(typeVariable);\n        }\n        toResolve = resolveTypeVariable(context, contextRawType, typeVariable);\n        if (toResolve == typeVariable) {\n          return toResolve;\n        }\n\n      } else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {\n        Class<?> original = (Class<?>) toResolve;\n        Type componentType = original.getComponentType();\n        Type newComponentType = resolve(context, contextRawType, componentType, visitedTypeVariables);\n        return componentType == newComponentType\n            ? original\n            : arrayOf(newComponentType);\n\n      } else if (toResolve instanceof GenericArrayType) {\n        GenericArrayType original = (GenericArrayType) toResolve;\n        Type componentType = original.getGenericComponentType();\n        Type newComponentType = resolve(context, contextRawType, componentType, visitedTypeVariables);\n        return componentType == newComponentType\n            ? original\n            : arrayOf(newComponentType);\n\n      } else if (toResolve instanceof ParameterizedType) {\n        ParameterizedType original = (ParameterizedType) toResolve;\n        Type ownerType = original.getOwnerType();\n        Type newOwnerType = resolve(context, contextRawType, ownerType, visitedTypeVariables);\n        boolean changed = newOwnerType != ownerType;\n\n        Type[] args = original.getActualTypeArguments();\n        for (int t = 0, length = args.length; t < length; t++) {\n          Type resolvedTypeArgument = resolve(context, contextRawType, args[t], visitedTypeVariables);\n          if (resolvedTypeArgument != args[t]) {\n            if (!changed) {\n              args = args.clone();\n              changed = true;\n            }\n            args[t] = resolvedTypeArgument;\n          }\n        }\n\n        return changed\n            ? newParameterizedTypeWithOwner(newOwnerType, original.getRawType(), args)\n            : original;\n\n      } else if (toResolve instanceof WildcardType) {\n        WildcardType original = (WildcardType) toResolve;\n        Type[] originalLowerBound = original.getLowerBounds();\n        Type[] originalUpperBound = original.getUpperBounds();\n\n        if (originalLowerBound.length == 1) {\n          Type lowerBound = resolve(context, contextRawType, originalLowerBound[0], visitedTypeVariables);\n          if (lowerBound != originalLowerBound[0]) {\n            return supertypeOf(lowerBound);\n          }\n        } else if (originalUpperBound.length == 1) {\n          Type upperBound = resolve(context, contextRawType, originalUpperBound[0], visitedTypeVariables);\n          if (upperBound != originalUpperBound[0]) {\n            return subtypeOf(upperBound);\n          }\n        }\n        return original;\n\n      } else {\n        return toResolve;\n      }\n    }\n  }\n\n  static Type resolveTypeVariable(Type context, Class<?> contextRawType, TypeVariable<?> unknown) {\n    Class<?> declaredByRaw = declaringClassOf(unknown);\n\n    // we can't reduce this further\n    if (declaredByRaw == null) {\n      return unknown;\n    }\n\n    Type declaredBy = getGenericSupertype(context, contextRawType, declaredByRaw);\n    if (declaredBy instanceof ParameterizedType) {\n      int index = indexOf(declaredByRaw.getTypeParameters(), unknown);\n      return ((ParameterizedType) declaredBy).getActualTypeArguments()[index];\n    }\n\n    return unknown;\n  }\n\n  private static int indexOf(Object[] array, Object toFind) {\n    for (int i = 0, length = array.length; i < length; i++) {\n      if (toFind.equals(array[i])) {\n        return i;\n      }\n    }\n    throw new NoSuchElementException();\n  }\n\n  /**\n   * Returns the declaring class of {@code typeVariable}, or {@code null} if it was not declared by\n   * a class.\n   */\n  private static Class<?> declaringClassOf(TypeVariable<?> typeVariable) {\n    GenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();\n    return genericDeclaration instanceof Class\n        ? (Class<?>) genericDeclaration\n        : null;\n  }\n\n  static void checkNotPrimitive(Type type) {\n    checkArgument(!(type instanceof Class<?>) || !((Class<?>) type).isPrimitive());\n  }\n\n  private static final class ParameterizedTypeImpl implements ParameterizedType, Serializable {\n    private final Type ownerType;\n    private final Type rawType;\n    private final Type[] typeArguments;\n\n    public ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments) {\n      // require an owner type if the raw type needs it\n      if (rawType instanceof Class<?>) {\n        Class<?> rawTypeAsClass = (Class<?>) rawType;\n        boolean isStaticOrTopLevelClass = Modifier.isStatic(rawTypeAsClass.getModifiers())\n            || rawTypeAsClass.getEnclosingClass() == null;\n        checkArgument(ownerType != null || isStaticOrTopLevelClass);\n      }\n\n      this.ownerType = ownerType == null ? null : canonicalize(ownerType);\n      this.rawType = canonicalize(rawType);\n      this.typeArguments = typeArguments.clone();\n      for (int t = 0, length = this.typeArguments.length; t < length; t++) {\n        checkNotNull(this.typeArguments[t]);\n        checkNotPrimitive(this.typeArguments[t]);\n        this.typeArguments[t] = canonicalize(this.typeArguments[t]);\n      }\n    }\n\n    public Type[] getActualTypeArguments() {\n      return typeArguments.clone();\n    }\n\n    public Type getRawType() {\n      return rawType;\n    }\n\n    public Type getOwnerType() {\n      return ownerType;\n    }\n\n    @Override public boolean equals(Object other) {\n      return other instanceof ParameterizedType\n          && $Gson$Types.equals(this, (ParameterizedType) other);\n    }\n\n    @Override public int hashCode() {\n      return Arrays.hashCode(typeArguments)\n          ^ rawType.hashCode()\n          ^ hashCodeOrZero(ownerType);\n    }\n\n    @Override public String toString() {\n      int length = typeArguments.length;\n      if (length == 0) {\n        return typeToString(rawType);\n      }\n\n      StringBuilder stringBuilder = new StringBuilder(30 * (length + 1));\n      stringBuilder.append(typeToString(rawType)).append(\"<\").append(typeToString(typeArguments[0]));\n      for (int i = 1; i < length; i++) {\n        stringBuilder.append(\", \").append(typeToString(typeArguments[i]));\n      }\n      return stringBuilder.append(\">\").toString();\n    }\n\n    private static final long serialVersionUID = 0;\n  }\n\n  private static final class GenericArrayTypeImpl implements GenericArrayType, Serializable {\n    private final Type componentType;\n\n    public GenericArrayTypeImpl(Type componentType) {\n      this.componentType = canonicalize(componentType);\n    }\n\n    public Type getGenericComponentType() {\n      return componentType;\n    }\n\n    @Override public boolean equals(Object o) {\n      return o instanceof GenericArrayType\n          && $Gson$Types.equals(this, (GenericArrayType) o);\n    }\n\n    @Override public int hashCode() {\n      return componentType.hashCode();\n    }\n\n    @Override public String toString() {\n      return typeToString(componentType) + \"[]\";\n    }\n\n    private static final long serialVersionUID = 0;\n  }\n\n  /**\n   * The WildcardType interface supports multiple upper bounds and multiple\n   * lower bounds. We only support what the Java 6 language needs - at most one\n   * bound. If a lower bound is set, the upper bound must be Object.class.\n   */\n  private static final class WildcardTypeImpl implements WildcardType, Serializable {\n    private final Type upperBound;\n    private final Type lowerBound;\n\n    public WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {\n      checkArgument(lowerBounds.length <= 1);\n      checkArgument(upperBounds.length == 1);\n\n      if (lowerBounds.length == 1) {\n        checkNotNull(lowerBounds[0]);\n        checkNotPrimitive(lowerBounds[0]);\n        checkArgument(upperBounds[0] == Object.class);\n        this.lowerBound = canonicalize(lowerBounds[0]);\n        this.upperBound = Object.class;\n\n      } else {\n        checkNotNull(upperBounds[0]);\n        checkNotPrimitive(upperBounds[0]);\n        this.lowerBound = null;\n        this.upperBound = canonicalize(upperBounds[0]);\n      }\n    }\n\n    public Type[] getUpperBounds() {\n      return new Type[] { upperBound };\n    }\n\n    public Type[] getLowerBounds() {\n      return lowerBound != null ? new Type[] { lowerBound } : EMPTY_TYPE_ARRAY;\n    }\n\n    @Override public boolean equals(Object other) {\n      return other instanceof WildcardType\n          && $Gson$Types.equals(this, (WildcardType) other);\n    }\n\n    @Override public int hashCode() {\n      // this equals Arrays.hashCode(getLowerBounds()) ^ Arrays.hashCode(getUpperBounds());\n      return (lowerBound != null ? 31 + lowerBound.hashCode() : 1)\n          ^ (31 + upperBound.hashCode());\n    }\n\n    @Override public String toString() {\n      if (lowerBound != null) {\n        return \"? super \" + typeToString(lowerBound);\n      } else if (upperBound == Object.class) {\n        return \"?\";\n      } else {\n        return \"? extends \" + typeToString(upperBound);\n      }\n    }\n\n    private static final long serialVersionUID = 0;\n  }\n}\n", "fixed_version": "/**\n * Copyright (C) 2008 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.gson.internal;\n\nimport java.io.Serializable;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.GenericArrayType;\nimport java.lang.reflect.GenericDeclaration;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.TypeVariable;\nimport java.lang.reflect.WildcardType;\nimport java.util.*;\n\nimport static com.google.gson.internal.$Gson$Preconditions.checkArgument;\nimport static com.google.gson.internal.$Gson$Preconditions.checkNotNull;\n\n/**\n * Static methods for working with types.\n *\n * @author Bob Lee\n * @author Jesse Wilson\n */\npublic final class $Gson$Types {\n  static final Type[] EMPTY_TYPE_ARRAY = new Type[] {};\n\n  private $Gson$Types() {\n    throw new UnsupportedOperationException();\n  }\n\n  /**\n   * Returns a new parameterized type, applying {@code typeArguments} to\n   * {@code rawType} and enclosed by {@code ownerType}.\n   *\n   * @return a {@link java.io.Serializable serializable} parameterized type.\n   */\n  public static ParameterizedType newParameterizedTypeWithOwner(\n      Type ownerType, Type rawType, Type... typeArguments) {\n    return new ParameterizedTypeImpl(ownerType, rawType, typeArguments);\n  }\n\n  /**\n   * Returns an array type whose elements are all instances of\n   * {@code componentType}.\n   *\n   * @return a {@link java.io.Serializable serializable} generic array type.\n   */\n  public static GenericArrayType arrayOf(Type componentType) {\n    return new GenericArrayTypeImpl(componentType);\n  }\n\n  /**\n   * Returns a type that represents an unknown type that extends {@code bound}.\n   * For example, if {@code bound} is {@code CharSequence.class}, this returns\n   * {@code ? extends CharSequence}. If {@code bound} is {@code Object.class},\n   * this returns {@code ?}, which is shorthand for {@code ? extends Object}.\n   */\n  public static WildcardType subtypeOf(Type bound) {\n    Type[] upperBounds;\n    if (bound instanceof WildcardType) {\n      upperBounds = ((WildcardType) bound).getUpperBounds();\n    } else {\n      upperBounds = new Type[] { bound };\n    }\n    return new WildcardTypeImpl(upperBounds, EMPTY_TYPE_ARRAY);\n  }\n\n  /**\n   * Returns a type that represents an unknown supertype of {@code bound}. For\n   * example, if {@code bound} is {@code String.class}, this returns {@code ?\n   * super String}.\n   */\n  public static WildcardType supertypeOf(Type bound) {\n    Type[] lowerBounds;\n    if (bound instanceof WildcardType) {\n      lowerBounds = ((WildcardType) bound).getLowerBounds();\n    } else {\n      lowerBounds = new Type[] { bound };\n    }\n    return new WildcardTypeImpl(new Type[] { Object.class }, lowerBounds);\n  }\n\n  /**\n   * Returns a type that is functionally equal but not necessarily equal\n   * according to {@link Object#equals(Object) Object.equals()}. The returned\n   * type is {@link java.io.Serializable}.\n   */\n  public static Type canonicalize(Type type) {\n    if (type instanceof Class) {\n      Class<?> c = (Class<?>) type;\n      return c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c;\n\n    } else if (type instanceof ParameterizedType) {\n      ParameterizedType p = (ParameterizedType) type;\n      return new ParameterizedTypeImpl(p.getOwnerType(),\n          p.getRawType(), p.getActualTypeArguments());\n\n    } else if (type instanceof GenericArrayType) {\n      GenericArrayType g = (GenericArrayType) type;\n      return new GenericArrayTypeImpl(g.getGenericComponentType());\n\n    } else if (type instanceof WildcardType) {\n      WildcardType w = (WildcardType) type;\n      return new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds());\n\n    } else {\n      // type is either serializable as-is or unsupported\n      return type;\n    }\n  }\n\n  public static Class<?> getRawType(Type type) {\n    if (type instanceof Class<?>) {\n      // type is a normal class.\n      return (Class<?>) type;\n\n    } else if (type instanceof ParameterizedType) {\n      ParameterizedType parameterizedType = (ParameterizedType) type;\n\n      // I'm not exactly sure why getRawType() returns Type instead of Class.\n      // Neal isn't either but suspects some pathological case related\n      // to nested classes exists.\n      Type rawType = parameterizedType.getRawType();\n      checkArgument(rawType instanceof Class);\n      return (Class<?>) rawType;\n\n    } else if (type instanceof GenericArrayType) {\n      Type componentType = ((GenericArrayType)type).getGenericComponentType();\n      return Array.newInstance(getRawType(componentType), 0).getClass();\n\n    } else if (type instanceof TypeVariable) {\n      // we could use the variable's bounds, but that won't work if there are multiple.\n      // having a raw type that's more general than necessary is okay\n      return Object.class;\n\n    } else if (type instanceof WildcardType) {\n      return getRawType(((WildcardType) type).getUpperBounds()[0]);\n\n    } else {\n      String className = type == null ? \"null\" : type.getClass().getName();\n      throw new IllegalArgumentException(\"Expected a Class, ParameterizedType, or \"\n          + \"GenericArrayType, but <\" + type + \"> is of type \" + className);\n    }\n  }\n\n  static boolean equal(Object a, Object b) {\n    return a == b || (a != null && a.equals(b));\n  }\n\n  /**\n   * Returns true if {@code a} and {@code b} are equal.\n   */\n  public static boolean equals(Type a, Type b) {\n    if (a == b) {\n      // also handles (a == null && b == null)\n      return true;\n\n    } else if (a instanceof Class) {\n      // Class already specifies equals().\n      return a.equals(b);\n\n    } else if (a instanceof ParameterizedType) {\n      if (!(b instanceof ParameterizedType)) {\n        return false;\n      }\n\n      // TODO: save a .clone() call\n      ParameterizedType pa = (ParameterizedType) a;\n      ParameterizedType pb = (ParameterizedType) b;\n      return equal(pa.getOwnerType(), pb.getOwnerType())\n          && pa.getRawType().equals(pb.getRawType())\n          && Arrays.equals(pa.getActualTypeArguments(), pb.getActualTypeArguments());\n\n    } else if (a instanceof GenericArrayType) {\n      if (!(b instanceof GenericArrayType)) {\n        return false;\n      }\n\n      GenericArrayType ga = (GenericArrayType) a;\n      GenericArrayType gb = (GenericArrayType) b;\n      return equals(ga.getGenericComponentType(), gb.getGenericComponentType());\n\n    } else if (a instanceof WildcardType) {\n      if (!(b instanceof WildcardType)) {\n        return false;\n      }\n\n      WildcardType wa = (WildcardType) a;\n      WildcardType wb = (WildcardType) b;\n      return Arrays.equals(wa.getUpperBounds(), wb.getUpperBounds())\n          && Arrays.equals(wa.getLowerBounds(), wb.getLowerBounds());\n\n    } else if (a instanceof TypeVariable) {\n      if (!(b instanceof TypeVariable)) {\n        return false;\n      }\n      TypeVariable<?> va = (TypeVariable<?>) a;\n      TypeVariable<?> vb = (TypeVariable<?>) b;\n      return va.getGenericDeclaration() == vb.getGenericDeclaration()\n          && va.getName().equals(vb.getName());\n\n    } else {\n      // This isn't a type we support. Could be a generic array type, wildcard type, etc.\n      return false;\n    }\n  }\n\n  static int hashCodeOrZero(Object o) {\n    return o != null ? o.hashCode() : 0;\n  }\n\n  public static String typeToString(Type type) {\n    return type instanceof Class ? ((Class<?>) type).getName() : type.toString();\n  }\n\n  /**\n   * Returns the generic supertype for {@code supertype}. For example, given a class {@code\n   * IntegerSet}, the result for when supertype is {@code Set.class} is {@code Set<Integer>} and the\n   * result when the supertype is {@code Collection.class} is {@code Collection<Integer>}.\n   */\n  static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResolve) {\n    if (toResolve == rawType) {\n      return context;\n    }\n\n    // we skip searching through interfaces if unknown is an interface\n    if (toResolve.isInterface()) {\n      Class<?>[] interfaces = rawType.getInterfaces();\n      for (int i = 0, length = interfaces.length; i < length; i++) {\n        if (interfaces[i] == toResolve) {\n          return rawType.getGenericInterfaces()[i];\n        } else if (toResolve.isAssignableFrom(interfaces[i])) {\n          return getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], toResolve);\n        }\n      }\n    }\n\n    // check our supertypes\n    if (!rawType.isInterface()) {\n      while (rawType != Object.class) {\n        Class<?> rawSupertype = rawType.getSuperclass();\n        if (rawSupertype == toResolve) {\n          return rawType.getGenericSuperclass();\n        } else if (toResolve.isAssignableFrom(rawSupertype)) {\n          return getGenericSupertype(rawType.getGenericSuperclass(), rawSupertype, toResolve);\n        }\n        rawType = rawSupertype;\n      }\n    }\n\n    // we can't resolve this further\n    return toResolve;\n  }\n\n  /**\n   * Returns the generic form of {@code supertype}. For example, if this is {@code\n   * ArrayList<String>}, this returns {@code Iterable<String>} given the input {@code\n   * Iterable.class}.\n   *\n   * @param supertype a superclass of, or interface implemented by, this.\n   */\n  static Type getSupertype(Type context, Class<?> contextRawType, Class<?> supertype) {\n    if (context instanceof WildcardType) {\n      // wildcards are useless for resolving supertypes. As the upper bound has the same raw type, use it instead\n      context = ((WildcardType)context).getUpperBounds()[0];\n    }\n    checkArgument(supertype.isAssignableFrom(contextRawType));\n    return resolve(context, contextRawType,\n        $Gson$Types.getGenericSupertype(context, contextRawType, supertype));\n  }\n\n  /**\n   * Returns the component type of this array type.\n   * @throws ClassCastException if this type is not an array.\n   */\n  public static Type getArrayComponentType(Type array) {\n    return array instanceof GenericArrayType\n        ? ((GenericArrayType) array).getGenericComponentType()\n        : ((Class<?>) array).getComponentType();\n  }\n\n  /**\n   * Returns the element type of this collection type.\n   * @throws IllegalArgumentException if this type is not a collection.\n   */\n  public static Type getCollectionElementType(Type context, Class<?> contextRawType) {\n    Type collectionType = getSupertype(context, contextRawType, Collection.class);\n\n    if (collectionType instanceof WildcardType) {\n      collectionType = ((WildcardType)collectionType).getUpperBounds()[0];\n    }\n    if (collectionType instanceof ParameterizedType) {\n      return ((ParameterizedType) collectionType).getActualTypeArguments()[0];\n    }\n    return Object.class;\n  }\n\n  /**\n   * Returns a two element array containing this map's key and value types in\n   * positions 0 and 1 respectively.\n   */\n  public static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType) {\n    /*\n     * Work around a problem with the declaration of java.util.Properties. That\n     * class should extend Hashtable<String, String>, but it's declared to\n     * extend Hashtable<Object, Object>.\n     */\n    if (context == Properties.class) {\n      return new Type[] { String.class, String.class }; // TODO: test subclasses of Properties!\n    }\n\n    Type mapType = getSupertype(context, contextRawType, Map.class);\n    // TODO: strip wildcards?\n    if (mapType instanceof ParameterizedType) {\n      ParameterizedType mapParameterizedType = (ParameterizedType) mapType;\n      return mapParameterizedType.getActualTypeArguments();\n    }\n    return new Type[] { Object.class, Object.class };\n  }\n\n  public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {\n    return resolve(context, contextRawType, toResolve, new HashSet<TypeVariable>());\n  }\n\n  private static Type resolve(Type context, Class<?> contextRawType, Type toResolve,\n                              Collection<TypeVariable> visitedTypeVariables) {\n    // this implementation is made a little more complicated in an attempt to avoid object-creation\n    while (true) {\n      if (toResolve instanceof TypeVariable) {\n        TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;\n        if (visitedTypeVariables.contains(typeVariable)) {\n          // cannot reduce due to infinite recursion\n          return toResolve;\n        } else {\n          visitedTypeVariables.add(typeVariable);\n        }\n        toResolve = resolveTypeVariable(context, contextRawType, typeVariable);\n        if (toResolve == typeVariable) {\n          return toResolve;\n        }\n\n      } else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {\n        Class<?> original = (Class<?>) toResolve;\n        Type componentType = original.getComponentType();\n        Type newComponentType = resolve(context, contextRawType, componentType, visitedTypeVariables);\n        return componentType == newComponentType\n            ? original\n            : arrayOf(newComponentType);\n\n      } else if (toResolve instanceof GenericArrayType) {\n        GenericArrayType original = (GenericArrayType) toResolve;\n        Type componentType = original.getGenericComponentType();\n        Type newComponentType = resolve(context, contextRawType, componentType, visitedTypeVariables);\n        return componentType == newComponentType\n            ? original\n            : arrayOf(newComponentType);\n\n      } else if (toResolve instanceof ParameterizedType) {\n        ParameterizedType original = (ParameterizedType) toResolve;\n        Type ownerType = original.getOwnerType();\n        Type newOwnerType = resolve(context, contextRawType, ownerType, visitedTypeVariables);\n        boolean changed = newOwnerType != ownerType;\n\n        Type[] args = original.getActualTypeArguments();\n        for (int t = 0, length = args.length; t < length; t++) {\n          Type resolvedTypeArgument = resolve(context, contextRawType, args[t], visitedTypeVariables);\n          if (resolvedTypeArgument != args[t]) {\n            if (!changed) {\n              args = args.clone();\n              changed = true;\n            }\n            args[t] = resolvedTypeArgument;\n          }\n        }\n\n        return changed\n            ? newParameterizedTypeWithOwner(newOwnerType, original.getRawType(), args)\n            : original;\n\n      } else if (toResolve instanceof WildcardType) {\n        WildcardType original = (WildcardType) toResolve;\n        Type[] originalLowerBound = original.getLowerBounds();\n        Type[] originalUpperBound = original.getUpperBounds();\n\n        if (originalLowerBound.length == 1) {\n          Type lowerBound = resolve(context, contextRawType, originalLowerBound[0], visitedTypeVariables);\n          if (lowerBound != originalLowerBound[0]) {\n            return supertypeOf(lowerBound);\n          }\n        } else if (originalUpperBound.length == 1) {\n          Type upperBound = resolve(context, contextRawType, originalUpperBound[0], visitedTypeVariables);\n          if (upperBound != originalUpperBound[0]) {\n            return subtypeOf(upperBound);\n          }\n        }\n        return original;\n\n      } else {\n        return toResolve;\n      }\n    }\n  }\n\n  static Type resolveTypeVariable(Type context, Class<?> contextRawType, TypeVariable<?> unknown) {\n    Class<?> declaredByRaw = declaringClassOf(unknown);\n\n    // we can't reduce this further\n    if (declaredByRaw == null) {\n      return unknown;\n    }\n\n    Type declaredBy = getGenericSupertype(context, contextRawType, declaredByRaw);\n    if (declaredBy instanceof ParameterizedType) {\n      int index = indexOf(declaredByRaw.getTypeParameters(), unknown);\n      return ((ParameterizedType) declaredBy).getActualTypeArguments()[index];\n    }\n\n    return unknown;\n  }\n\n  private static int indexOf(Object[] array, Object toFind) {\n    for (int i = 0, length = array.length; i < length; i++) {\n      if (toFind.equals(array[i])) {\n        return i;\n      }\n    }\n    throw new NoSuchElementException();\n  }\n\n  /**\n   * Returns the declaring class of {@code typeVariable}, or {@code null} if it was not declared by\n   * a class.\n   */\n  private static Class<?> declaringClassOf(TypeVariable<?> typeVariable) {\n    GenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();\n    return genericDeclaration instanceof Class\n        ? (Class<?>) genericDeclaration\n        : null;\n  }\n\n  static void checkNotPrimitive(Type type) {\n    checkArgument(!(type instanceof Class<?>) || !((Class<?>) type).isPrimitive());\n  }\n\n  private static final class ParameterizedTypeImpl implements ParameterizedType, Serializable {\n    private final Type ownerType;\n    private final Type rawType;\n    private final Type[] typeArguments;\n\n    public ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments) {\n      // require an owner type if the raw type needs it\n      if (rawType instanceof Class<?>) {\n        Class<?> rawTypeAsClass = (Class<?>) rawType;\n        boolean isStaticOrTopLevelClass = Modifier.isStatic(rawTypeAsClass.getModifiers())\n            || rawTypeAsClass.getEnclosingClass() == null;\n        checkArgument(ownerType != null || isStaticOrTopLevelClass);\n      }\n\n      this.ownerType = ownerType == null ? null : canonicalize(ownerType);\n      this.rawType = canonicalize(rawType);\n      this.typeArguments = typeArguments.clone();\n      for (int t = 0, length = this.typeArguments.length; t < length; t++) {\n        checkNotNull(this.typeArguments[t]);\n        checkNotPrimitive(this.typeArguments[t]);\n        this.typeArguments[t] = canonicalize(this.typeArguments[t]);\n      }\n    }\n\n    public Type[] getActualTypeArguments() {\n      return typeArguments.clone();\n    }\n\n    public Type getRawType() {\n      return rawType;\n    }\n\n    public Type getOwnerType() {\n      return ownerType;\n    }\n\n    @Override public boolean equals(Object other) {\n      return other instanceof ParameterizedType\n          && $Gson$Types.equals(this, (ParameterizedType) other);\n    }\n\n    @Override public int hashCode() {\n      return Arrays.hashCode(typeArguments)\n          ^ rawType.hashCode()\n          ^ hashCodeOrZero(ownerType);\n    }\n\n    @Override public String toString() {\n      int length = typeArguments.length;\n      if (length == 0) {\n        return typeToString(rawType);\n      }\n\n      StringBuilder stringBuilder = new StringBuilder(30 * (length + 1));\n      stringBuilder.append(typeToString(rawType)).append(\"<\").append(typeToString(typeArguments[0]));\n      for (int i = 1; i < length; i++) {\n        stringBuilder.append(\", \").append(typeToString(typeArguments[i]));\n      }\n      return stringBuilder.append(\">\").toString();\n    }\n\n    private static final long serialVersionUID = 0;\n  }\n\n  private static final class GenericArrayTypeImpl implements GenericArrayType, Serializable {\n    private final Type componentType;\n\n    public GenericArrayTypeImpl(Type componentType) {\n      this.componentType = canonicalize(componentType);\n    }\n\n    public Type getGenericComponentType() {\n      return componentType;\n    }\n\n    @Override public boolean equals(Object o) {\n      return o instanceof GenericArrayType\n          && $Gson$Types.equals(this, (GenericArrayType) o);\n    }\n\n    @Override public int hashCode() {\n      return componentType.hashCode();\n    }\n\n    @Override public String toString() {\n      return typeToString(componentType) + \"[]\";\n    }\n\n    private static final long serialVersionUID = 0;\n  }\n\n  /**\n   * The WildcardType interface supports multiple upper bounds and multiple\n   * lower bounds. We only support what the Java 6 language needs - at most one\n   * bound. If a lower bound is set, the upper bound must be Object.class.\n   */\n  private static final class WildcardTypeImpl implements WildcardType, Serializable {\n    private final Type upperBound;\n    private final Type lowerBound;\n\n    public WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {\n      checkArgument(lowerBounds.length <= 1);\n      checkArgument(upperBounds.length == 1);\n\n      if (lowerBounds.length == 1) {\n        checkNotNull(lowerBounds[0]);\n        checkNotPrimitive(lowerBounds[0]);\n        checkArgument(upperBounds[0] == Object.class);\n        this.lowerBound = canonicalize(lowerBounds[0]);\n        this.upperBound = Object.class;\n\n      } else {\n        checkNotNull(upperBounds[0]);\n        checkNotPrimitive(upperBounds[0]);\n        this.lowerBound = null;\n        this.upperBound = canonicalize(upperBounds[0]);\n      }\n    }\n\n    public Type[] getUpperBounds() {\n      return new Type[] { upperBound };\n    }\n\n    public Type[] getLowerBounds() {\n      return lowerBound != null ? new Type[] { lowerBound } : EMPTY_TYPE_ARRAY;\n    }\n\n    @Override public boolean equals(Object other) {\n      return other instanceof WildcardType\n          && $Gson$Types.equals(this, (WildcardType) other);\n    }\n\n    @Override public int hashCode() {\n      // this equals Arrays.hashCode(getLowerBounds()) ^ Arrays.hashCode(getUpperBounds());\n      return (lowerBound != null ? 31 + lowerBound.hashCode() : 1)\n          ^ (31 + upperBound.hashCode());\n    }\n\n    @Override public String toString() {\n      if (lowerBound != null) {\n        return \"? super \" + typeToString(lowerBound);\n      } else if (upperBound == Object.class) {\n        return \"?\";\n      } else {\n        return \"? extends \" + typeToString(upperBound);\n      }\n    }\n\n    private static final long serialVersionUID = 0;\n  }\n}\n"}]}
